"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-9104bb"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-layer-view_14.entry.js":
/*!***********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-layer-view_14.entry.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_layer_view: () => (/* binding */ ArcgisLayerView$1),
/* harmony export */   arcgis_layer_view_browse_layer: () => (/* binding */ ArcgisLayerViewBrowseLayer),
/* harmony export */   arcgis_layer_view_create: () => (/* binding */ ArcgisLayerViewCreate$1),
/* harmony export */   arcgis_layer_view_definition: () => (/* binding */ ArcgisLayerViewDefinition),
/* harmony export */   arcgis_layer_view_join: () => (/* binding */ ArcgisLayerView),
/* harmony export */   arcgis_layer_view_join_add_selection: () => (/* binding */ ArcgisLayerViewJoinAddSelection),
/* harmony export */   arcgis_layer_view_join_browse_layer: () => (/* binding */ ArcgisLayerViewJoinBrowseLayer),
/* harmony export */   arcgis_layer_view_join_config: () => (/* binding */ ArcgisLayerViewJoinConfig),
/* harmony export */   arcgis_layer_view_join_create: () => (/* binding */ ArcgisLayerViewJoinCreate),
/* harmony export */   arcgis_layer_view_join_target_selection: () => (/* binding */ ArcgisLayerViewJoinTargetSelection),
/* harmony export */   arcgis_layer_view_msg: () => (/* binding */ ArcgisLayerViewCreate),
/* harmony export */   arcgis_layer_view_overview: () => (/* binding */ ArcgisLayerViewOverview),
/* harmony export */   arcgis_layer_view_selection: () => (/* binding */ ArcgisLayerViewSelection),
/* harmony export */   arcgis_layer_view_swap_source: () => (/* binding */ ArcgisLayerViewSwapSource)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale-050b6db9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _portal_660bb43a_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./portal-660bb43a.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-660bb43a.js");
/* harmony import */ var _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./item-properties-10491b2e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-properties-10491b2e.js");
/* harmony import */ var _localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./localStorage-9c4e7a3a.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/localStorage-9c4e7a3a.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/* harmony import */ var _index_05956cab_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./index-05956cab.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */













const CSS$9 = {
    panel: "panel",
    footer: "footer",
    errorContent: "error-content"
};

var flowStatus;
(function (flowStatus) {
    flowStatus[flowStatus["ERROR"] = 0] = "ERROR";
    flowStatus[flowStatus["LOADING"] = 1] = "LOADING";
    flowStatus[flowStatus["SELECTION"] = 2] = "SELECTION";
    flowStatus[flowStatus["OVERVIEW"] = 3] = "OVERVIEW";
    flowStatus[flowStatus["SWAP_SOURCE"] = 4] = "SWAP_SOURCE";
    flowStatus[flowStatus["BROWSE_LAYER"] = 5] = "BROWSE_LAYER";
    flowStatus[flowStatus["DEFINITION"] = 6] = "DEFINITION";
    flowStatus[flowStatus["FILTER"] = 7] = "FILTER";
    flowStatus[flowStatus["CREATE"] = 8] = "CREATE";
})(flowStatus || (flowStatus = {}));
var actions;
(function (actions) {
    actions[actions["CANCEL"] = 0] = "CANCEL";
    actions[actions["CREATE"] = 1] = "CREATE";
})(actions || (actions = {}));
/**
 * Checks if a featureEffect on a layer is empty
 * @param effect - layer.featureEffect
 */
function isEffectEmpty(effect) {
    if (!effect || !effect.filter) {
        return true;
    }
    const checkProps = ["geometry", "distance", "objectIds", "timeExtent", "where"];
    return !checkProps.some((prop) => effect.filter.hasOwnProperty(prop));
}
function createEffect(fl, FeatureEffect, props) {
    const { backgroundTheme } = props;
    let brightness = backgroundTheme === "light" ? 100 : 65;
    fl.featureEffect = new FeatureEffect({
        filter: {},
        excludedEffect: `grayscale(100%) opacity(30%) brightness(${brightness}%)`,
        excludedLabelsVisible: true
    });
}
function sameCoord(val1, val2) {
    return val1 === val2 || Math.round(val1 * 1000000) / 1000000 === Math.round(val2 * 1000000) / 1000000;
}
function sameSR(sp1, sp2) {
    // works for __esri.SpatialReference and JSON objects
    var mercator = [102113, 102100, 3857];
    if (sp1 &&
        sp2 &&
        (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(sp1.wkid) &&
        (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(sp2.wkid) &&
        mercator.indexOf(sp1.wkid) > -1 &&
        mercator.indexOf(sp2.wkid) > -1) {
        return true;
    }
    else if (sp1 &&
        sp2 &&
        (((0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(sp1.wkid) && (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(sp2.wkid) && sp1.wkid == sp2.wkid) ||
            ((0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(sp1.latestWkid) && (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(sp2.wkid) && sp1.latestWkid == sp2.wkid) ||
            ((0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(sp1.wkid) && (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(sp2.latestWkid) && sp1.wkid == sp2.latestWkid) ||
            ((0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(sp1.latestWkid) && (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(sp2.latestWkid) && sp1.latestWkid == sp2.latestWkid))) {
        return true;
    }
    else if (sp1 && sp2 && (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(sp1.wkt) && (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(sp2.wkt) && sp1.wkt === sp2.wkt) {
        return true;
    }
    return false;
}
/**
 *
 * @param props
 * @returns
 */
function getRequiredFieldNames(props, layer) {
    const requiredFieldTypes = [
        "oid",
        "esriFieldTypeOID",
        "global-id",
        "esriFieldTypeGlobalID",
        "geometry",
        "esriFieldTypeGeometry"
    ];
    let totalFields;
    if (layer) {
        totalFields = layer.fields;
    }
    else {
        const { definitionLayerId } = props;
        const adminLayerInfo = getAdminLayerInfo(definitionLayerId, props);
        totalFields = (adminLayerInfo === null || adminLayerInfo === void 0 ? void 0 : adminLayerInfo.fields) || getFL(definitionLayerId, props).fields;
    }
    return totalFields
        .filter((field) => requiredFieldTypes.indexOf(field.type) > -1 || (!field.nullable && !(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(field.defaultValue)))
        .map((field) => field.name);
}

/**
 * Initialize settings of current view
 */
async function initDefinitions(props) {
    var _a, _b, _c;
    const { viewItem, adminServiceInfo, layer } = props;
    const { modules } = props;
    if (!viewItem) {
        // use parent's definitionExpression as default filter
        if (layer.type === "group") {
            (_a = layer.layers) === null || _a === void 0 ? void 0 : _a.forEach((lyr) => {
                if (lyr.definitionExpression) {
                    addViewLayerProps(lyr.layerId, { filter: lyr.definitionExpression }, props);
                    applyLayerFilter(lyr.definitionExpression, lyr.layerId, props);
                    lyr.definitionExpression = null;
                }
            });
            (_b = layer.tables) === null || _b === void 0 ? void 0 : _b.forEach((table) => {
                if (table.definitionExpression) {
                    addViewLayerProps(table.layerId, { filter: table.definitionExpression }, props);
                    applyLayerFilter(table.definitionExpression, table.layerId, props);
                    table.definitionExpression = null;
                }
            });
        }
        else {
            if (layer.definitionExpression) {
                addViewLayerProps(layer.layerId, { filter: layer.definitionExpression }, props);
                applyLayerFilter(layer.definitionExpression, layer.layerId, props);
                layer.definitionExpression = null;
            }
        }
    }
    else {
        if (!adminServiceInfo) {
            // probably not a view yet
            return;
        }
        props.layerIds = [];
        getLayersAndTables(adminServiceInfo).forEach(async (layerInfo) => {
            var _a, _b, _c, _d;
            props.layerIds.push(layerInfo.id);
            const fields = [];
            layerInfo.fields.forEach((field) => {
                if (field.visible !== false) {
                    fields.push(field.name);
                }
            });
            if (fields.length !== layerInfo.fields.length) {
                addViewLayerProps(layerInfo.id, { fields }, props);
            }
            const whereClause = layerInfo.viewDefinitionQuery;
            if (whereClause) {
                addViewLayerProps(layerInfo.id, { filter: whereClause }, props);
                applyLayerFilter(whereClause, layerInfo.id, props);
            }
            const aoiValue = (_d = (_c = (_b = (_a = layerInfo.adminLayerInfo) === null || _a === void 0 ? void 0 : _a.viewLayerDefinition) === null || _b === void 0 ? void 0 : _b.table) === null || _c === void 0 ? void 0 : _c.filter) === null || _d === void 0 ? void 0 : _d.value;
            if (aoiValue) {
                // don't need to check SR of saved AOI, any SR work
                addViewLayerProps(layerInfo.id, {
                    aoi: JSON.parse(JSON.stringify(aoiValue.geometry))
                }, props);
                const geometry = aoiValue.geometry.rings
                    ? modules.Polygon.fromJSON(aoiValue.geometry)
                    : modules.Extent.fromJSON(aoiValue.geometry);
                applyLayerAOI(geometry, layerInfo.id, props);
            }
        });
        // set layer visibility on map and remove definitionExpression
        if (layer.type === "group") {
            layer.layers.forEach((fLayer) => {
                fLayer.visible = props.layerIds.indexOf(fLayer.layerId) > -1;
                fLayer.definitionExpression = null;
            });
            (_c = layer.tables) === null || _c === void 0 ? void 0 : _c.forEach((table) => {
                table.definitionExpression = null;
            });
        }
        else {
            layer.visible = props.layerIds.indexOf(layer.layerId) > -1;
            layer.definitionExpression = null;
        }
    }
}
/**
 * Returns true if the value is defined
 * @param layerId - layer id
 */
function getViewLayerProps(layerId, props) {
    const { viewProps } = props;
    return viewProps === null || viewProps === void 0 ? void 0 : viewProps.find((viewLayerProps) => layerId === viewLayerProps.layerId);
}
/**
 * check if one ViewLayerProp is empty, then delete it
 */
function sanitizeViewProps(props) {
    const { viewProps } = props;
    if (!viewProps) {
        return;
    }
    props.viewProps = viewProps.filter((viewLayerProps) => viewLayerProps.filter || viewLayerProps.aoi || viewLayerProps.fields);
    if (!props.viewProps.length) {
        props.viewProps = undefined;
    }
}
/**
 * add props for one layer
 */
function addViewLayerProps(layerId, addProps, props) {
    var _a;
    let viewLayerProps = getViewLayerProps(layerId, props);
    if (!viewLayerProps) {
        viewLayerProps = { layerId };
    }
    const newProps = Object.assign(Object.assign({}, viewLayerProps), addProps);
    props.viewProps = (_a = props.viewProps) === null || _a === void 0 ? void 0 : _a.filter((viewLayerProp) => viewLayerProp.layerId !== layerId);
    props.viewProps = props.viewProps || [];
    props.viewProps.push(newProps);
}

/**
 * Returns non-view FL
 * @param layerId - layer id
 */
function getFL(layerId, props) {
    const { layer } = props;
    return layer.type === "group"
        ? getLayersAndTables(layer).find((lyr) => lyr.layerId === layerId)
        : layer;
}
/**
 * apply filter to layer as effect
 * @param where - where clause
 * @param layerId - layer id
 */
async function applyLayerFilter(where, layerId, props) {
    const fl = getFL(layerId, props);
    if (fl.isTable) {
        return new Promise((resolve) => {
            resolve();
        });
    }
    const [FeatureEffect] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/layers/support/FeatureEffect"]);
    if (where) {
        let count = 0;
        // wait until the filter component is done
        const intervalHandler = setInterval(() => {
            var _a;
            if (!((_a = fl.featureEffect) === null || _a === void 0 ? void 0 : _a.filter)) {
                createEffect(fl, FeatureEffect, props);
            }
            fl.featureEffect.filter.where = where;
            count++;
            if (count === 3) {
                clearInterval(intervalHandler);
            }
        }, 200);
    }
    else {
        fl.featureEffect.filter.where = null;
        if (isEffectEmpty(fl.featureEffect)) {
            fl.featureEffect = null;
        }
    }
}
/**
 * apply AOI to layer as effect
 * @param graphic - Graphic with geometry
 * @param layerId - layer id
 */
async function applyLayerAOI(geometry, layerId, props) {
    const fl = getFL(layerId, props);
    const [FeatureEffect, Polygon, Extent] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)([
        "esri/layers/support/FeatureEffect",
        "esri/geometry/Polygon",
        "esri/geometry/Extent"
    ]);
    if (geometry) {
        let count = 0;
        // wait until the filter component is done
        const intervalHandler = setInterval(() => {
            var _a;
            if (!((_a = fl.featureEffect) === null || _a === void 0 ? void 0 : _a.filter)) {
                createEffect(fl, FeatureEffect, props);
            }
            const geom = geometry.type === "polygon" ? Polygon.fromJSON(geometry.toJSON()) : Extent.fromJSON(geometry.toJSON());
            fl.featureEffect.filter.geometry = geom;
            count++;
            if (count === 3) {
                clearInterval(intervalHandler);
            }
        }, 200);
    }
    else {
        fl.featureEffect.filter.geometry = null;
        if (isEffectEmpty(fl.featureEffect)) {
            fl.featureEffect = null;
        }
    }
}
/**
 * get name of service from URL
 * @param portalItem - __esri.PortalItem
 * @return service name
 */
function getServiceName(portalItem) {
    var _a;
    const { url } = portalItem;
    if (!url) {
        return "";
    }
    const serverTypes = ["/FeatureServer", "/MapServer"];
    const serverType = (_a = serverTypes.filter((type) => url.toLowerCase().indexOf(type.toLowerCase()) > -1)) === null || _a === void 0 ? void 0 : _a[0];
    let title = "";
    if (serverType) {
        title = url.substring(0, url.indexOf(serverType));
        title = title.substring(title.lastIndexOf("/") + 1, title.length);
    }
    return title;
}
/**
 * get name of service from URL
 * @layer group layer or adminServiceInfo
 * @return Collecction of layers and tables
 */
function getLayersAndTables(layer) {
    var _a, _b, _c;
    if (((_a = layer.layers) === null || _a === void 0 ? void 0 : _a.length) && ((_b = layer.tables) === null || _b === void 0 ? void 0 : _b.length)) {
        return layer.layers.concat(layer.tables);
    }
    else if ((_c = layer.layers) === null || _c === void 0 ? void 0 : _c.length) {
        return layer.layers;
    }
    else {
        return layer.tables;
    }
}

async function canSwap(swapItem, props) {
    var _a, _b, _c, _d, _e;
    const { layerItem, layer, adminServiceInfo, modules, strings } = props;
    const { Layer, PortalItem } = modules;
    props.swapItem = props.swapLayer = undefined;
    if (layerItem.id === swapItem.id) {
        return Promise.resolve("");
    }
    const portalItem = PortalItem.fromJSON(swapItem);
    await portalItem.load();
    const swapLayer = await Layer.fromPortalItem({
        portalItem
    });
    if (layer.type !== swapLayer.type) {
        console.log("layer type does not match,", layer.type, "!=", swapLayer.type);
        return Promise.resolve(strings.msg.swapErrors.layerType);
    }
    if (layer.type === "group") {
        // group layer has no layers or tables at this point
        // loadAll() loads layers, tables (at v4.23) and capabilities
        await swapLayer.loadAll();
    }
    else {
        // "feature"
        await swapLayer.load();
    }
    // if view has editor tracking swap has to have it too (check service)
    // sync
    if (layer.type === "group") {
        // just need to check one sublayer/table
        const hasSync = adminServiceInfo.layers[0].capabilities.indexOf("Sync") > -1;
        const firstSwapLyr = (((_a = swapLayer.layers) === null || _a === void 0 ? void 0 : _a.length) ? swapLayer.layers : swapLayer.tables).getItemAt(0);
        const swapHasSync = firstSwapLyr.sourceJSON.capabilities.indexOf("Sync") > -1;
        if (hasSync !== swapHasSync) {
            console.log("new source layer Sync not matching");
            return Promise.resolve(strings.msg.swapErrors.sync);
        }
    }
    else {
        // "feature"
        const hasSync = adminServiceInfo.capabilities.indexOf("Sync") > -1;
        const swapHasSync = swapLayer.sourceJSON.capabilities.indexOf("Sync") > -1;
        if (hasSync !== swapHasSync) {
            console.log("new source layer Sync not matching");
            return Promise.resolve(strings.msg.swapErrors.sync);
        }
    }
    // same sublayers
    if (layer.type === "group") {
        // group layer has no layers or tables at this point
        // loadAll() loads layers and tables (at v4.23)
        if (((_b = layer.layers) === null || _b === void 0 ? void 0 : _b.length) !== ((_c = swapLayer.layers) === null || _c === void 0 ? void 0 : _c.length) || ((_d = layer.tables) === null || _d === void 0 ? void 0 : _d.length) !== ((_e = swapLayer.tables) === null || _e === void 0 ? void 0 : _e.length)) {
            console.log("layer sublayers count does not match");
            return Promise.resolve(strings.msg.swapErrors.layerCount);
        }
    }
    // Change in sublayers or fields
    if (layer.type === "group") {
        const layersAndTables = getLayersAndTables(layer);
        const swapLayersAndTables = getLayersAndTables(swapLayer);
        for (let i = 0; i < layersAndTables.length; i++) {
            const subLayer = layersAndTables.getItemAt(i);
            const swapSubLayer = swapLayersAndTables.getItemAt(i);
            //console.log("sublayer", i, subLayer, "==", swapSubLayer);
            let check = checkSubLayers(subLayer, swapSubLayer, props);
            if (check) {
                return Promise.resolve(check);
            }
            check = checkFields(subLayer, swapSubLayer, props);
            if (check) {
                return Promise.resolve(check);
            }
        }
    }
    else {
        // "feature"
        let check = checkSubLayers(layer, swapLayer, props);
        if (check) {
            return Promise.resolve(check);
        }
        check = checkFields(layer, swapLayer, props);
        if (check) {
            return Promise.resolve(check);
        }
    }
    props.swapItem = swapItem;
    props.swapLayer = swapLayer;
    return Promise.resolve(null);
}
async function swapSource(props) {
    var _a, _b;
    let { layer, layerIds, modules } = props;
    const { PortalItem } = modules;
    const { view, swapItem, swapLayer } = props;
    const [esriRequest] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/request"]);
    try {
        await emptyView(props, esriRequest);
        const portalItem = PortalItem.fromJSON(swapItem);
        await portalItem.load();
        //const oldLayerItem = props.layerItem;
        //const oldLayer = layer;
        props.layerItem = portalItem;
        props.layer = swapLayer;
        props.swapItem = props.swapLayer = undefined;
        // we want to behave as if we're creating a new view
        // current settings are based off the source item
        const savedViewItem = props.viewItem;
        props.viewItem = undefined;
        props.adminServiceInfo = undefined;
        await getAdminServiceInfo$1(props);
        await initialAddToDefinition(props, { serviceurl: savedViewItem.url }, esriRequest);
        props.viewItem = savedViewItem;
        // now get view info
        props.adminServiceInfo = undefined;
        await getAdminServiceInfo$1(props);
        /* console.log(
          "view adminServiceInfo layers",
          props.adminServiceInfo?.layers?.map((lyr: any) => {
            return {
              id: lyr.id,
              name: lyr.name,
              adminLayerInfo_filter: lyr.adminLayerInfo?.viewLayerDefinition?.table?.filter?.value,
              viewDefinitionQuery: lyr.viewDefinitionQuery,
              fields: lyr.fields.map((field: any) => `${field.name} (${field.visible})`)
            };
          })
        ); */
        // update map
        view.map.remove(layer);
        layer = props.layer;
        if (layer.type === "group") {
            if ((_a = layer.layers) === null || _a === void 0 ? void 0 : _a.length) {
                // has at least one spatial layer
                if (layerIds) {
                    // only make included sublayers visible
                    layer.layers.forEach((subLayer) => {
                        subLayer.visible = layerIds.indexOf(subLayer.layerId) > -1;
                    });
                }
                view.map.add(layer);
            }
            // default popups
            (_b = layer.layers) === null || _b === void 0 ? void 0 : _b.forEach((lyr) => {
                if (!lyr.popupTemplate && lyr.popupEnabled) {
                    lyr.popupTemplate = lyr.createPopupTemplate();
                }
            });
        }
        else {
            if (!layer.isTable) {
                view.map.add(layer);
            }
            // default popup
            layer.popupTemplate = layer.createPopupTemplate();
        }
        // apply correct filter and AOI on map
        getLayersAndTables(props.adminServiceInfo).forEach(async (layerInfo) => {
            var _a, _b, _c, _d;
            const whereClause = layerInfo.viewDefinitionQuery;
            if (whereClause) {
                applyLayerFilter(whereClause, layerInfo.id, props);
            }
            const aoiValue = (_d = (_c = (_b = (_a = layerInfo.adminLayerInfo) === null || _a === void 0 ? void 0 : _a.viewLayerDefinition) === null || _b === void 0 ? void 0 : _b.table) === null || _c === void 0 ? void 0 : _c.filter) === null || _d === void 0 ? void 0 : _d.value;
            if (aoiValue) {
                const geometry = aoiValue.geometry.rings
                    ? modules.Polygon.fromJSON(aoiValue.geometry)
                    : modules.Extent.fromJSON(aoiValue.geometry);
                applyLayerAOI(geometry, layerInfo.id, props);
            }
        });
    }
    catch (e) {
        return new Promise((_, reject) => {
            reject(new Error("swap source failed"));
        });
    }
}
function checkSubLayers(layer, swapLayer, props) {
    const { strings } = props;
    if (layer.geometryType !== swapLayer.geometryType) {
        console.log("layer geometry type does not match");
        return strings.msg.swapErrors.geometryType;
    }
    if (JSON.stringify(layer.spatialReference.toJSON()) !== JSON.stringify(swapLayer.spatialReference.toJSON())) {
        console.log("layer spatial reference does not match");
        return strings.msg.swapErrors.spatialReference;
    }
    return null;
}
function checkFields(layer, swapLayer, props) {
    // all visible fields in current view must be contained in new source
    const { strings } = props;
    const requiredFieldNames = getRequiredFieldNames(props, layer);
    const viewLayerProps = getViewLayerProps(layer.layerId, props);
    let visFields;
    if (viewLayerProps === null || viewLayerProps === void 0 ? void 0 : viewLayerProps.fields) {
        const allFields = viewLayerProps.fields.concat(requiredFieldNames);
        visFields = layer.fields.filter((field) => allFields.indexOf(field.name) > -1);
    }
    else {
        visFields = layer.fields;
    }
    //console.log("checkFields - visFields", visFields.map((f) =>f.name));
    //console.log("swapLayer - fields", swapLayer.fields.map((f) => f.name));
    for (let i = 0; i < visFields.length; i++) {
        const field = visFields[i];
        const swapField = swapLayer.fields.find((swapField) => field.name === swapField.name);
        if (!swapField) {
            //if (["global-id", "oid"].indexOf(field.type) === -1) {
            console.log("layer", layer.layerId, layer.title, ": field", field.name, "missing in new source layer");
            return strings.msg.swapErrors.missingField;
            //} else {
            //  console.log("field", field.name, "missing in new source layer, ignoring");
            //}
        }
        else if (field.type !== swapField.type) {
            console.log("layer", layer.layerId, layer.title, ": field type of", field.name, "different in layers");
            return strings.msg.swapErrors.fieldType;
        }
    }
    return null;
}

/**
 * get a suggested title for the view
 * @param props - LayerViewProps
 */
async function getSuggestedTitle(props) {
    var _a, _b;
    const { layerItem, layer, strings } = props;
    const [esriRequest] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/request"]);
    const relatedUrl = `${layerItem.itemUrl}/relatedItems`;
    const relatedContent = {
        relationshipType: "Service2Service",
        direction: "forward"
    };
    const result = await esriRequest(relatedUrl, {
        query: Object.assign(Object.assign({}, relatedContent), { f: "json", token: layer.portalItem.portal.credential.token }),
        method: "post",
        responseType: "json"
    });
    // check with spaces and underscores
    const viewItems = ((_b = (_a = result === null || result === void 0 ? void 0 : result.data) === null || _a === void 0 ? void 0 : _a.relatedItems) === null || _b === void 0 ? void 0 : _b.filter((item) => item.type === "Feature Service" &&
        (item.title.indexOf(layerItem.title) > -1 ||
            item.title.indexOf(layerItem.title.replace(/ /g, "_")) > -1 ||
            item.title.replace(/ /g, "_").indexOf(layerItem.title) > -1))) || [];
    return `${layerItem.title}${viewItems.length ? ` ${viewItems.length + 1}` : ``} ${strings.createView.view}`;
}
/**
 * Make admin service info request for view layer
 * @param props - LayerViewProps
 */
async function getAdminServiceInfo$1(props, noCache) {
    const { layer, viewItem, adminServiceInfo } = props;
    if (adminServiceInfo) {
        return;
    }
    const serviceUrl = (viewItem === null || viewItem === void 0 ? void 0 : viewItem.url) || layer.portalItem.url;
    let adminUrl = serviceUrl.replace("/rest/services", "/rest/admin/services");
    if (noCache) {
        adminUrl += `${adminUrl.indexOf("?") > -1 ? "&" : "?"}_ts=${new Date().getTime()}`;
    }
    try {
        const [IdentityManager, esriRequest] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/identity/IdentityManager", "esri/request"]);
        await IdentityManager.getCredential(adminUrl);
        const response = await esriRequest(adminUrl, {
            query: { f: "json" }
        });
        props.adminServiceInfo = response.data;
    }
    catch (e) {
        return new Promise((_, reject) => {
            reject(new Error("could not get admin info"));
        });
    }
}
/**
 * Creates layer view
 * @param layerId - layer id
 * @param props - LayerViewProps
 */
function getAdminLayerInfo(layerId, props) {
    var _a, _b;
    const { adminServiceInfo } = props;
    const layer = (_a = adminServiceInfo === null || adminServiceInfo === void 0 ? void 0 : adminServiceInfo.layers) === null || _a === void 0 ? void 0 : _a.find((layer) => layer.id === layerId);
    if (!layer) {
        return (_b = adminServiceInfo === null || adminServiceInfo === void 0 ? void 0 : adminServiceInfo.tables) === null || _b === void 0 ? void 0 : _b.find((table) => table.id === layerId);
    }
    return layer;
}
/**
 * Returns true if the user made recent changes
 * @param props
 * @returns boolean
 */
function hasChanges(props) {
    const { layer, layerIds, adminServiceInfo } = props;
    if (layer.type === "group") {
        const layersAndTables = adminServiceInfo && getLayersAndTables(adminServiceInfo);
        const containsAllLayers = adminServiceInfo &&
            layersAndTables.length === layerIds.length &&
            layersAndTables.every((lyr) => layerIds.indexOf(lyr.id) > -1);
        return (!containsAllLayers ||
            getLayersAndTables(layer)
                .filter((fLayer) => layerIds.indexOf(fLayer.layerId) > -1)
                .some((fLayer) => hasLayerChanges(fLayer.layerId, props)));
    }
    else {
        return hasLayerChanges(layer.layerId, props);
    }
}
/**
 * Returns true if the user made recent changes to the feature layer
 * @param layerId
 * @param props
 * @returns
 */
function hasLayerChanges(layerId, props) {
    var _a, _b, _c, _d;
    const { viewItem } = props;
    const fLayer = getFL(layerId, props);
    const viewLayerProps = getViewLayerProps(layerId, props);
    const adminLayerInfo = getAdminLayerInfo(layerId, props);
    // ignore field.visible prop on parent layers
    const viewFields = viewItem && (adminLayerInfo === null || adminLayerInfo === void 0 ? void 0 : adminLayerInfo.fields)
        ? adminLayerInfo.fields.filter((field) => field.visible)
        : (adminLayerInfo === null || adminLayerInfo === void 0 ? void 0 : adminLayerInfo.fields) || fLayer.fields;
    if (viewLayerProps) {
        if (viewLayerProps.filter !== (adminLayerInfo === null || adminLayerInfo === void 0 ? void 0 : adminLayerInfo.viewDefinitionQuery) ||
            !!(viewLayerProps.fields && viewLayerProps.fields.length !== viewFields.length) ||
            !!(!viewLayerProps.fields && viewFields.length !== fLayer.fields.length) ||
            (!fLayer.isTable && !isSameAOI(viewLayerProps, adminLayerInfo))) {
            /* console.log(
              "hasLayerChanges=true (props) id:",
              layerId,
              "filter:",
              viewLayerProps.filter !== adminLayerInfo?.viewDefinitionQuery,
              //`(${viewLayerProps.filter}|${adminLayerInfo?.viewDefinitionQuery})`,
              "fields-has-props:",
              !!(viewLayerProps.fields && viewLayerProps.fields.length !== viewFields.length),
              "fields-no-props:",
              !!(!viewLayerProps.fields && viewFields.length !== fLayer.fields.length),
              "!sameAOI:",
              !isSameAOI(viewLayerProps, adminLayerInfo)
            ); */
            return true;
        }
    }
    else {
        if ((adminLayerInfo === null || adminLayerInfo === void 0 ? void 0 : adminLayerInfo.viewDefinitionQuery) ||
            viewFields.length < fLayer.fields.length ||
            (!fLayer.isTable && ((_d = (_c = (_b = (_a = adminLayerInfo === null || adminLayerInfo === void 0 ? void 0 : adminLayerInfo.adminLayerInfo) === null || _a === void 0 ? void 0 : _a.viewLayerDefinition) === null || _b === void 0 ? void 0 : _b.table) === null || _c === void 0 ? void 0 : _c.filter) === null || _d === void 0 ? void 0 : _d.value))) {
            return true;
        }
    }
    return false;
}
/**
 * Creates layer view
 * @param props - LayerViewProps
 * @param newItemProps - user input (NewItemProps)
 */
async function createView(props, newItemProps) {
    const [esriRequest] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/request"]);
    try {
        const createServiceResponse = await createService(props, newItemProps, esriRequest);
        //console.log("createServiceResponse", createServiceResponse);
        await initialAddToDefinition(props, createServiceResponse, esriRequest);
        await initialItemUpdate(props, createServiceResponse, newItemProps, esriRequest);
        await moveToFolder(props, createServiceResponse, newItemProps, esriRequest);
        return createServiceResponse.itemId;
    }
    catch (e) {
        return new Promise((_, reject) => {
            if (e.message === "service name already exists") {
                reject(e);
            }
            else {
                reject(new Error("createView failed"));
            }
        });
    }
}
/**
 * Creates layer view
 * @param props - LayerViewProps
 */
async function updateView(props) {
    const { viewItem } = props;
    const [esriRequest] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/request"]);
    try {
        const { addLayerIds, deleteLayerIds } = await updateDefinition(props, viewItem, esriRequest);
        await itemUpdate(props, addLayerIds, deleteLayerIds, esriRequest);
        return new Promise((resolve) => {
            resolve();
        });
    }
    catch (e) {
        return new Promise((_, reject) => {
            reject(new Error("updateView failed"));
        });
    }
}
/**
 * Removes all layers from the view
 * @param props - LayerViewProps
 */
async function emptyView(props, esriRequest) {
    var _a, _b;
    const { layer, viewItem, adminServiceInfo } = props;
    const portalItem = layer.portalItem;
    // delete
    const deleteLayerIds = [];
    (_a = adminServiceInfo === null || adminServiceInfo === void 0 ? void 0 : adminServiceInfo.layers) === null || _a === void 0 ? void 0 : _a.forEach((lyr) => {
        deleteLayerIds.push(lyr.id);
    });
    const deleteTableIds = [];
    (_b = adminServiceInfo === null || adminServiceInfo === void 0 ? void 0 : adminServiceInfo.tables) === null || _b === void 0 ? void 0 : _b.forEach((lyr) => {
        deleteTableIds.push(lyr.id);
    });
    if (deleteLayerIds.length || deleteTableIds.length) {
        const adminUrl = viewItem.url.replace("rest/services", "rest/admin/services");
        const deleteFromDefUrl = `${adminUrl}/deleteFromDefinition`;
        await deleteFromDefinitionRequest(deleteFromDefUrl, {
            layers: deleteLayerIds === null || deleteLayerIds === void 0 ? void 0 : deleteLayerIds.map((id) => {
                return { id };
            }),
            tables: deleteTableIds === null || deleteTableIds === void 0 ? void 0 : deleteTableIds.map((id) => {
                return { id };
            })
        }, portalItem, esriRequest);
    }
    return new Promise((resolve) => {
        resolve();
    });
}
function isSameAOI(viewLayerProps, adminLayerInfo) {
    var _a, _b, _c, _d;
    const adminAOIValue = (_d = (_c = (_b = (_a = adminLayerInfo === null || adminLayerInfo === void 0 ? void 0 : adminLayerInfo.adminLayerInfo) === null || _a === void 0 ? void 0 : _a.viewLayerDefinition) === null || _b === void 0 ? void 0 : _b.table) === null || _c === void 0 ? void 0 : _c.filter) === null || _d === void 0 ? void 0 : _d.value;
    //console.log("isSameAOI admin:", adminAOIValue?.geometry, "prop:", viewLayerProps?.aoi);
    if (!(viewLayerProps === null || viewLayerProps === void 0 ? void 0 : viewLayerProps.aoi) && !adminAOIValue) {
        return true;
    }
    else if (((viewLayerProps === null || viewLayerProps === void 0 ? void 0 : viewLayerProps.aoi) && !adminAOIValue) || (!(viewLayerProps === null || viewLayerProps === void 0 ? void 0 : viewLayerProps.aoi) && adminAOIValue)) {
        return false;
    }
    if ((viewLayerProps.aoi.rings && adminAOIValue.geometryType !== "esriGeometryPolygon") ||
        (viewLayerProps.aoi.xmin && adminAOIValue.geometryType !== "esriGeometryEnvelope")) {
        return false;
    }
    if (viewLayerProps.aoi.xmin) {
        const propsExt = viewLayerProps.aoi;
        const adminExt = adminAOIValue.geometry;
        // compare coords with a margin; service rounds passed in coords
        if (sameCoord(propsExt.xmin, adminExt.xmin) &&
            sameCoord(propsExt.xmax, adminExt.xmax) &&
            sameCoord(propsExt.ymin, adminExt.ymin) &&
            sameCoord(propsExt.ymax, adminExt.ymax)) {
            return true;
        }
        else {
            return false;
        }
    }
    else if (viewLayerProps.aoi.rings) {
        if (viewLayerProps.aoi.rings[0].length !== adminAOIValue.geometry.rings[0].length) {
            return false;
        }
        else {
            const isSame = viewLayerProps.aoi.rings[0].every((pt1) => {
                return adminAOIValue.geometry.rings[0].some((pt2) => {
                    // compare coords with a margin; service rounds passed in coords
                    return sameCoord(pt1[0], pt2[0]) && sameCoord(pt1[1], pt2[1]);
                });
            });
            return isSame;
        }
    }
}
async function createService(props, newItemProps, esriRequest) {
    var _a, _b, _c;
    const { layer, layerIds } = props;
    const portalItem = layer.portalItem;
    const portal = portalItem.portal;
    let fl = getFL(layerIds[0], props);
    const createServiceUrl = `${portal.restUrl}/content/users/${portalItem.owner}/createService`;
    const createParams = {
        name: newItemProps.title.replace(/ /g, "_"),
        isView: true,
        sourceSchemaChangesAllowed: true,
        isUpdatableView: true,
        spatialReference: (_a = fl.sourceJSON.extent) === null || _a === void 0 ? void 0 : _a.spatialReference,
        initialExtent: fl.sourceJSON.extent,
        capabilities: "Query",
        preserveLayerIds: true
    };
    if (portal.isPortal) {
        const dataSourceType = getDataSourceType$1(props);
        if (dataSourceType) {
            createParams.options = { dataSourceType };
        }
    }
    let createServiceContent = {
        createParameters: JSON.stringify(createParams),
        outputType: "featureService",
        tags: ((_b = newItemProps.tags) === null || _b === void 0 ? void 0 : _b.length) ? newItemProps.tags.toString() : undefined,
        snippet: newItemProps.summary,
        categories: (_c = newItemProps.categories) === null || _c === void 0 ? void 0 : _c.join(","),
        isView: true
    };
    try {
        const response = await esriRequest(createServiceUrl, {
            query: Object.assign(Object.assign({}, createServiceContent), { f: "json", token: portal.credential.token }),
            method: "post",
            responseType: "json"
        });
        //console.log("newServiceResponse", response);
        return response.data;
    }
    catch (e) {
        return new Promise((_, reject) => {
            if (e.message.indexOf(" already exists ") > -1) {
                reject(new Error("service name already exists"));
            }
            else {
                reject(new Error("create service failed"));
            }
        });
    }
}
function getDataSourceType$1(props) {
    var _a, _b, _c, _d;
    const { adminServiceInfo } = props;
    const dataSource = ((_b = (_a = adminServiceInfo === null || adminServiceInfo === void 0 ? void 0 : adminServiceInfo.adminServiceInfo) === null || _a === void 0 ? void 0 : _a.database) === null || _b === void 0 ? void 0 : _b.datasource) || {};
    const dataSourceType = ((_c = dataSource === null || dataSource === void 0 ? void 0 : dataSource.name) === null || _c === void 0 ? void 0 : _c.indexOf("/nosqlDatabases")) > -1
        ? "spatiotemporal"
        : ((_d = dataSource === null || dataSource === void 0 ? void 0 : dataSource.name) === null || _d === void 0 ? void 0 : _d.indexOf("/enterpriseDatabases")) > -1
            ? "relational"
            : null;
    return dataSourceType;
}
async function initialAddToDefinition(props, createServiceResponse, esriRequest) {
    /* TODO??
    updatePopupAfterFieldDefinitionChange: function(mapLayer) {
  
      if (!mapLayer.popupInfo || !mapLayer.popupInfo.fieldInfos) {
        return;
      }
  
      var fieldInfos = mapLayer.popupInfo.fieldInfos;
      var newFieldInfos = [];
      var defaultPopupInfo = arcgisonline.map.popup.getDefaultPopupInfo(mapLayer.serviceInfo, mapLayer.layer.isEditable(), mapLayer.layer);
  
      // remove fields that are not available anymore and add new fields
      dojo.forEach(defaultPopupInfo.fieldInfos, function(defInfo) {
        var curFInfo;
        dojo.forEach(fieldInfos, function(fInfo) {
          if (fInfo.fieldName === defInfo.fieldName) {
            curFInfo = fInfo;
          }
        });
        if (!curFInfo) {
          // add new fields to the popup
          newFieldInfos.push(defInfo);
        } else {
          // keep the one we have
          newFieldInfos.push(curFInfo);
        }
      });
      // keep special fields
      var relatedFieldPrefix = "relationships/";
      var expressionPrefix = "expression/";
      var rasterPrefix = "Raster.";
      dojo.forEach(fieldInfos, function(fInfo) {
        if (fInfo.fieldName.startsWith(relatedFieldPrefix) ||
          fInfo.fieldName.startsWith(expressionPrefix) ||
          fInfo.fieldName.startsWith(rasterPrefix)) {
          newFieldInfos.push(fInfo);
        }
      });
      if (dojo.json.stringify(mapLayer.popupInfo.fieldInfos) !== dojo.json.stringify(newFieldInfos)) {
        mapLayer.popupInfo.fieldInfos = newFieldInfos;
        arcgisonline.map.mapUtil.setInfoTemplate(mapLayer.layer, mapLayer.popupInfo);
        mapLayer.popupChanged = true;
  
        if (mapLayer.origItemLayers) {
          // save new popup on layer item
  
          var getItemLayerInfosHandler = function(){
            // mapLayer.origItemLayers contains what's saved on the item currently
  
            var itemData = arcgisonline.map.itemData.itemDataContents[mapLayer.itemId] || {};
  
            var id = parseInt(mapLayer.layer.url.substring(mapLayer.layer.url.lastIndexOf("/") + 1));
            var layerInfo = null;
            for (var i = 0; i < mapLayer.origItemLayers.length; i++) {
              if (mapLayer.origItemLayers[i].id === id) {
                layerInfo = mapLayer.origItemLayers[i];
                break;
              }
            }
  
            if (!layerInfo) {
              //should not happen
              return;
            }
  
            // only update popupInfo
            layerInfo.popupInfo = mapLayer.popupInfo;
  
            var json = {
              layers: mapLayer.origItemLayers
            };
  
            delete itemData.layers;
            json = dojo.mixin(itemData, json);
  
            var request = {
              text: dojo.json.stringify(json)
            };
  
            var user = arcgisonline.sharing.util.getUser();
            var url = esriGeowConfig.restBaseUrl + 'content/users/' + mapLayer.itemCard.owner; // user might be admin and item owner is someone else
            url += (mapLayer.itemCard.ownerFolder) ? ('/' + mapLayer.itemCard.ownerFolder) : '';
            url += '/items/' + mapLayer.itemCard.id + '/update';
            arcgisonline.sharing.util.postJson(request, url, dojo.hitch(this,function() {
              delete mapLayer.popupChanged;
            }));
          };
  
          // get the latest layerInfos from the item in case they got changed by another layer in the map
          arcgisonline.map.itemData.getItemLayerInfos(mapLayer, dojo.hitch(this, getItemLayerInfosHandler), dojo.hitch(this, getItemLayerInfosHandler));
        }
      }
    },
    */
    var _a, _b;
    const { layer, layerIds } = props;
    let layers, tables;
    if (layer.type === "group") {
        layers = (_a = layer.layers) === null || _a === void 0 ? void 0 : _a.filter((lyr) => layerIds.indexOf(lyr.layerId) > -1).map((lyr) => getDefLayerJSON(lyr, props)).toArray().reverse();
        tables = (_b = layer.tables) === null || _b === void 0 ? void 0 : _b.filter((lyr) => layerIds.indexOf(lyr.layerId) > -1).map((lyr) => getDefLayerJSON(lyr, props)).toArray().reverse();
    }
    else {
        if (layer.isTable) {
            tables = [getDefLayerJSON(layer, props)];
        }
        else {
            layers = [getDefLayerJSON(layer, props)];
        }
    }
    try {
        // the response from a createService call returns 'serviceurl'
        const adminUrl = createServiceResponse.serviceurl.replace("rest/services", "rest/admin/services");
        await addToDefinitionRequest$1(`${adminUrl}/addToDefinition`, {
            layers: layers,
            tables: tables
        }, esriRequest, props);
        await updateDefinitions(props, createServiceResponse, esriRequest);
        return new Promise((resolve) => {
            resolve();
        });
    }
    catch (e) {
        return new Promise((_, reject) => {
            reject(new Error("initialAddToDefinition failed"));
        });
    }
}
async function updateDefinitions(props, createServiceResponse, esriRequest) {
    const { layer, layerIds } = props;
    const { portalItem } = layer;
    const { portal } = portalItem;
    const adminUrl = createServiceResponse.serviceurl.replace("rest/services", "rest/admin/services");
    try {
        // now update definitions like filter, fields, and AOI
        // changing fields and AOI not supported with addToDefinition
        if (layer.type === "group") {
            const callInfos = [];
            const lyrs = getLayersAndTables(layer).filter((fLayer) => layerIds.indexOf(fLayer.layerId) > -1);
            // use for loop so await works
            for (let i = 0; i < lyrs.length; i++) {
                const fLayer = lyrs.getItemAt(i);
                if (hasLayerChanges(fLayer.layerId, props)) {
                    const json = await getUpdateLayerJSON(fLayer, props);
                    const updateDefUrl = `${adminUrl}/${fLayer.layerId}/updateDefinition`;
                    callInfos.push({ updateDefUrl, json });
                }
            }
            if (callInfos.length) {
                if (portal.isPortal) {
                    // can't handle simultaneous requests
                    for (const callInfo of callInfos) {
                        await updateDefinitionRequest(callInfo.updateDefUrl, callInfo.json, esriRequest, props);
                    }
                }
                else {
                    const calls = [];
                    callInfos.forEach((callInfo) => {
                        calls.push(updateDefinitionRequest(callInfo.updateDefUrl, callInfo.json, esriRequest, props));
                    });
                    await Promise.all(calls);
                }
            }
        }
        else {
            // not a group layer
            if (hasLayerChanges(layer.layerId, props)) {
                const json = await getUpdateLayerJSON(layer, props);
                const updateDefUrl = `${adminUrl}/${layer.layerId}/updateDefinition`;
                await updateDefinitionRequest(updateDefUrl, json, esriRequest, props);
            }
        }
        return new Promise((resolve) => {
            resolve();
        });
    }
    catch (e) {
        return new Promise((_, reject) => {
            reject(new Error("updateDefinitions failed"));
        });
    }
}
async function updateDefinition(props, viewItem, esriRequest) {
    /*
    TODO??
    if (arcgisonline.sharing.util.isPortal()) {
      // can't send all of those requests out at the same time [#19301]
    */
    var _a, _b, _c, _d;
    const { layer, layerIds, adminServiceInfo } = props;
    const portalItem = layer.portalItem;
    const { portal } = portalItem;
    const deleteLayerIds = [];
    const addLayerIds = [];
    try {
        // the response from an item card call returns 'url'
        const adminUrl = viewItem.url.replace("rest/services", "rest/admin/services");
        if (layer.type === "group") {
            // delete
            (_a = adminServiceInfo === null || adminServiceInfo === void 0 ? void 0 : adminServiceInfo.layers) === null || _a === void 0 ? void 0 : _a.forEach((lyr) => {
                if (layerIds.indexOf(lyr.id) === -1) {
                    deleteLayerIds.push(lyr.id);
                }
            });
            const deleteTableIds = [];
            (_b = adminServiceInfo === null || adminServiceInfo === void 0 ? void 0 : adminServiceInfo.tables) === null || _b === void 0 ? void 0 : _b.forEach((lyr) => {
                if (layerIds.indexOf(lyr.id) === -1) {
                    deleteTableIds.push(lyr.id);
                }
            });
            if (deleteLayerIds.length || deleteTableIds.length) {
                const deleteFromDefUrl = `${adminUrl}/deleteFromDefinition`;
                await deleteFromDefinitionRequest(deleteFromDefUrl, {
                    layers: deleteLayerIds === null || deleteLayerIds === void 0 ? void 0 : deleteLayerIds.map((id) => {
                        return { id };
                    }),
                    tables: deleteTableIds === null || deleteTableIds === void 0 ? void 0 : deleteTableIds.map((id) => {
                        return { id };
                    })
                }, portalItem, esriRequest);
                // do we need to remove relationships from existing view layers
                // pointing to any removed layers?
                let callInfos = [];
                getLayersAndTables(layer)
                    .filter((fLayer) => layerIds.indexOf(fLayer.layerId) > -1)
                    .forEach(async (fLayer) => {
                    var _a, _b;
                    if ((_a = fLayer.relationships) === null || _a === void 0 ? void 0 : _a.length) {
                        // the original layer has relationships
                        const viewLayerInfo = getLayersAndTables(adminServiceInfo).find((layerInfo) => layerInfo.id === fLayer.layerId);
                        if ((_b = viewLayerInfo === null || viewLayerInfo === void 0 ? void 0 : viewLayerInfo.relationships) === null || _b === void 0 ? void 0 : _b.length) {
                            // remove relationships pointing to newly removed layers
                            const relationships = viewLayerInfo.relationships.filter((relationship) => deleteLayerIds.indexOf(relationship.relatedTableId) > -1 ||
                                deleteTableIds.indexOf(relationship.relatedTableId) > -1);
                            if (relationships.length) {
                                // at least one relationship needs to be removed
                                const json = {};
                                json.relationships = relationships;
                                const delFromDefUrl = `${adminUrl}/${fLayer.layerId}/deleteFromDefinition`;
                                callInfos.push({ delFromDefUrl, json });
                            }
                        } // else view layer not yet part of view or already has all relationships
                    }
                });
                if (callInfos.length) {
                    if (portal.isPortal) {
                        // can't handle simultaneous requests
                        for (const callInfo of callInfos) {
                            await deleteFromDefinitionRequest(callInfo.delFromDefUrl, callInfo.json, portalItem, esriRequest);
                        }
                    }
                    else {
                        const calls = [];
                        callInfos.forEach((callInfo) => {
                            calls.push(deleteFromDefinitionRequest(callInfo.delFromDefUrl, callInfo.json, portalItem, esriRequest));
                        });
                        await Promise.all(calls);
                    }
                }
            }
            // add
            layerIds.forEach((id) => {
                if (!getLayersAndTables(adminServiceInfo).some((lyr) => lyr.id === id)) {
                    addLayerIds.push(id);
                }
            });
            if (addLayerIds.length) {
                const layers = (_c = layer.layers) === null || _c === void 0 ? void 0 : _c.filter((lyr) => addLayerIds.indexOf(lyr.layerId) > -1).map((lyr) => getDefLayerJSON(lyr, props)).toArray().reverse();
                const tables = (_d = layer.tables) === null || _d === void 0 ? void 0 : _d.filter((lyr) => addLayerIds.indexOf(lyr.layerId) > -1).map((lyr) => getDefLayerJSON(lyr, props)).toArray().reverse();
                await addToDefinitionRequest$1(`${adminUrl}/addToDefinition`, {
                    layers: layers,
                    tables: tables
                }, esriRequest, props);
                // do we need to add relationships for any newly added layers?
                const callInfos = [];
                getLayersAndTables(layer)
                    .filter((fLayer) => layerIds.indexOf(fLayer.layerId) > -1)
                    .forEach(async (fLayer) => {
                    var _a, _b;
                    if ((_a = fLayer.relationships) === null || _a === void 0 ? void 0 : _a.length) {
                        // the original layer has relationships
                        const viewLayerInfo = getLayersAndTables(adminServiceInfo).find((layerInfo) => layerInfo.id === fLayer.layerId);
                        if (viewLayerInfo) {
                            // this view layer was not just added to the view
                            if (((_b = fLayer.relationships) === null || _b === void 0 ? void 0 : _b.length) !== viewLayerInfo.relationships.length) {
                                const json = {};
                                // only add relationships pointing to newly added layers
                                const relationships = fLayer.relationships.filter((relationship) => addLayerIds.indexOf(relationship.relatedTableId) > -1);
                                json.relationships = relationships;
                                const addToDefUrl = `${adminUrl}/${fLayer.layerId}/addToDefinition`;
                                callInfos.push({ addToDefUrl, json });
                            } // else view layer already has all relationships
                        } // else we sent all relationships when adding the layer to the view earlier
                    }
                });
                if (callInfos.length) {
                    if (portal.isPortal) {
                        // can't handle simultaneous requests
                        for (const callInfo of callInfos) {
                            await addToDefinitionRequest$1(callInfo.addToDefUrl, callInfo.json, esriRequest, props);
                        }
                    }
                    else {
                        const calls = [];
                        callInfos.forEach((callInfo) => {
                            calls.push(addToDefinitionRequest$1(callInfo.addToDefUrl, callInfo.json, esriRequest, props));
                        });
                        await Promise.all(calls);
                    }
                }
            }
            // update fields, filter, AOI
            // also update the new layers that were just added
            const callInfos = [];
            const calls = [];
            const makeGetUpdateLayerJSONCall = async (callInfos, fLayer) => {
                const updateDefUrl = `${adminUrl}/${fLayer.layerId}/updateDefinition`;
                const json = await getUpdateLayerJSON(fLayer, props);
                callInfos.push({ updateDefUrl, json });
                return Promise.resolve();
            };
            getLayersAndTables(layer)
                .filter((fLayer) => layerIds.indexOf(fLayer.layerId) > -1)
                .forEach((fLayer) => {
                if (hasLayerChanges(fLayer.layerId, props)) {
                    calls.push(makeGetUpdateLayerJSONCall(callInfos, fLayer));
                }
            });
            await Promise.all(calls);
            if (callInfos.length) {
                if (portal.isPortal) {
                    for (const callInfo of callInfos) {
                        await updateDefinitionRequest(callInfo.updateDefUrl, callInfo.json, esriRequest, props);
                    }
                }
                else {
                    const calls = [];
                    callInfos.forEach((callInfo) => {
                        calls.push(updateDefinitionRequest(callInfo.updateDefUrl, callInfo.json, esriRequest, props));
                    });
                    await Promise.all(calls);
                }
            }
        }
        else {
            // not a group layer
            if (hasLayerChanges(layer.layerId, props)) {
                const json = await getUpdateLayerJSON(layer, props);
                const updateDefUrl = `${adminUrl}/${layer.layerId}/updateDefinition`;
                await updateDefinitionRequest(updateDefUrl, json, esriRequest, props);
            }
        }
        return new Promise((resolve) => {
            resolve({ addLayerIds, deleteLayerIds });
        });
    }
    catch (e) {
        console.error(e);
        return new Promise((_, reject) => {
            reject(new Error("updateDefinition failed"));
        });
    }
}
async function updateDefinitionRequest(updateDefUrl, json, esriRequest, props, retry = false) {
    var _a;
    const { layer, viewItem } = props;
    const updateDefContent = {
        updateDefinition: JSON.stringify(json)
    };
    try {
        const portalItem = layer.portalItem;
        const portal = portalItem.portal;
        const isVelocityView = (viewItem === null || viewItem === void 0 ? void 0 : viewItem.typeKeywords.indexOf("IoTFeatureLayer")) > -1;
        const result = await esriRequest(updateDefUrl, {
            query: Object.assign(Object.assign({}, updateDefContent), { f: "json", async: !portal.isPortal && !isVelocityView, token: portal.credential.token }),
            method: "post",
            responseType: "json"
        });
        if (portal.isPortal || isVelocityView) {
            return new Promise((resolve) => {
                resolve();
            });
        }
        else {
            try {
                await pollForStatus$1((_a = result === null || result === void 0 ? void 0 : result.data) === null || _a === void 0 ? void 0 : _a.statusURL, {
                    f: "json",
                    token: portal.credential.token
                }, esriRequest);
                return new Promise((resolve) => {
                    resolve();
                });
            }
            catch (e) {
                // update request worked; ignore the polling error
                //return new Promise((resolve) => {
                //  resolve();
                //});
                /* real error
                {
                  "submissionTime": 1652480104360,
                  "lastUpdatedTime": 1652480104360,
                  "status": "Failed",
                  "error": {
                      "code": 500,
                      "description": "Editing definition error - USA_West2_view"
                  }
                }
                */
                return new Promise((_, reject) => {
                    reject(new Error("updateDefinition request failed (poll)"));
                });
            }
        }
    }
    catch (e) {
        if (!retry) {
            // in case it's just a fluke
            return updateDefinitionRequest(updateDefUrl, json, esriRequest, props, true);
        }
        return new Promise((_, reject) => {
            reject(new Error("updateDefinition request failed"));
        });
    }
}
async function addToDefinitionRequest$1(addToDefUrl, json, esriRequest, props, retry = false) {
    var _a;
    const { layer, viewItem } = props;
    const addToDefContent = {
        addToDefinition: JSON.stringify(json)
    };
    try {
        const portalItem = layer.portalItem;
        const portal = portalItem.portal;
        const isVelocityView = (viewItem === null || viewItem === void 0 ? void 0 : viewItem.typeKeywords.indexOf("IoTFeatureLayer")) > -1;
        const result = await esriRequest(addToDefUrl, {
            query: Object.assign(Object.assign({}, addToDefContent), { f: "json", async: !portal.isPortal && !isVelocityView, token: portal.credential.token }),
            method: "post",
            responseType: "json"
        });
        if (portal.isPortal || isVelocityView) {
            return new Promise((resolve) => {
                resolve();
            });
        }
        else {
            try {
                await pollForStatus$1((_a = result === null || result === void 0 ? void 0 : result.data) === null || _a === void 0 ? void 0 : _a.statusURL, {
                    f: "json",
                    token: portal.credential.token
                }, esriRequest);
                return new Promise((resolve) => {
                    resolve();
                });
            }
            catch (e) {
                // add request worked; ignore the polling error
                //return new Promise((resolve) => {
                //  resolve();
                //});
                /* real error
                {
                  "submissionTime": 1652480104360,
                  "lastUpdatedTime": 1652480104360,
                  "status": "Failed",
                  "error": {
                      "code": 500,
                      "description": "Editing definition error - USA_West2_view"
                  }
              }
                */
                return new Promise((_, reject) => {
                    reject(new Error("addToDefinition request failed (poll)"));
                });
            }
        }
    }
    catch (e) {
        if (!retry) {
            // in case it's just a fluke
            return addToDefinitionRequest$1(addToDefUrl, json, esriRequest, props, true);
        }
        return new Promise((_, reject) => {
            reject(new Error("addToDefinition request failed"));
        });
    }
}
async function deleteFromDefinitionRequest(deleteFromDefUrl, json, portalItem, esriRequest, retry = false) {
    const deleteFromDefContent = {
        deleteFromDefinition: JSON.stringify(json)
    };
    try {
        await esriRequest(deleteFromDefUrl, {
            query: Object.assign(Object.assign({}, deleteFromDefContent), { f: "json", token: portalItem.portal.credential.token }),
            method: "post",
            responseType: "json"
        });
        return new Promise((resolve) => {
            resolve();
        });
    }
    catch (e) {
        if (!retry) {
            // in case it's just a fluke
            return deleteFromDefinitionRequest(deleteFromDefUrl, json, portalItem, esriRequest, true);
        }
        return new Promise((_, reject) => {
            reject(new Error("deleteFromDefinition request failed"));
        });
    }
}
function getDefLayerJSON(fLayer, props) {
    /*
    // compared to service info response (layers, tables)....
    - no indexes
    - no fields
    - no serviceItemId
    - no serverGens
    - no relationships
    - + url
    - + attributes
    - + layerMetadataUrl
    - + mapViewerUrl
    - + mapViewerUrlWithGeocode
    - + newMapViewerUrl
    - + sceneViewerUrl
    - + adminLayerInfo
    */
    const { layer, layerItem } = props;
    const json = fLayer.sourceJSON;
    delete json.indexes;
    delete json.fields;
    delete json.serviceItemId;
    delete json.serverGens;
    delete json.relationships;
    json.url = `${fLayer.url}/${fLayer.layerId}?token=${layer.portalItem.portal.credential.token}`;
    json.adminLayerInfo = {
        viewLayerDefinition: {
            sourceServiceName: getServiceName(layerItem),
            sourceLayerId: fLayer.layerId,
            sourceLayerFields: "*"
        }
    };
    // can't update fields or AOI when adding layer to definition
    //console.log("getDefLayerJSON - id:", fLayer.layerId, json);
    return json;
}
async function getUpdateLayerJSON(fLayer, props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const { modules } = props;
    const json = {};
    const viewLayerProps = getViewLayerProps(fLayer.layerId, props);
    if (viewLayerProps) {
        // filter
        json.viewDefinitionQuery = viewLayerProps.filter || "";
        // AOI
        if (viewLayerProps.aoi) {
            let aoi = viewLayerProps.aoi;
            // make sure SR fits to layer
            if (!sameSR(aoi.spatialReference, fLayer.spatialReference)) {
                await modules.projection.load();
                const geom = aoi.rings ? modules.Polygon.fromJSON(aoi) : modules.Extent.fromJSON(aoi);
                aoi = (_a = modules.projection.project(geom, fLayer.spatialReference)) === null || _a === void 0 ? void 0 : _a.toJSON();
            }
            const geometryType = aoi.rings ? "esriGeometryPolygon" : "esriGeometryEnvelope";
            json.viewLayerDefinition = {
                filter: {
                    operator: "esriSpatialRelIntersects",
                    value: {
                        geometryType,
                        geometry: aoi
                    }
                }
            };
        }
        else {
            const adminLayerInfo = getAdminLayerInfo(fLayer.layerId, props);
            const aoiValue = (_e = (_d = (_c = (_b = adminLayerInfo === null || adminLayerInfo === void 0 ? void 0 : adminLayerInfo.adminLayerInfo) === null || _b === void 0 ? void 0 : _b.viewLayerDefinition) === null || _c === void 0 ? void 0 : _c.table) === null || _d === void 0 ? void 0 : _d.filter) === null || _e === void 0 ? void 0 : _e.value;
            if (aoiValue) {
                // only update if there was one before
                json.viewLayerDefinition = {
                    filter: null
                };
            }
        }
        // fields
        if (viewLayerProps.fields) {
            json.fields = fLayer.fields.map((field) => {
                return {
                    name: field.name,
                    visible: viewLayerProps.fields.indexOf(field.name) > -1
                };
            });
        }
        else {
            // all fields are visible
            json.fields = fLayer.fields.map((field) => {
                return {
                    name: field.name,
                    visible: true
                };
            });
        }
    }
    else {
        // filter
        json.viewDefinitionQuery = "";
        // fields
        json.fields = fLayer.fields.map((field) => {
            return {
                name: field.name,
                visible: true
            };
        });
        // AOI
        const adminLayerInfo = getAdminLayerInfo(fLayer.layerId, props);
        const aoiValue = (_j = (_h = (_g = (_f = adminLayerInfo === null || adminLayerInfo === void 0 ? void 0 : adminLayerInfo.adminLayerInfo) === null || _f === void 0 ? void 0 : _f.viewLayerDefinition) === null || _g === void 0 ? void 0 : _g.table) === null || _h === void 0 ? void 0 : _h.filter) === null || _j === void 0 ? void 0 : _j.value;
        if (aoiValue) {
            // only update if there was one before
            json.viewLayerDefinition = {
                filter: null
            };
        }
    }
    //console.log("getUpdateLayerJSON - id:", fLayer.layerId, json);
    return json;
}
async function moveToFolder(props, createServiceResponse, newItemProps, esriRequest) {
    const { layer } = props;
    const portalItem = layer.portalItem;
    const { portal } = portalItem;
    if (!newItemProps.folder || !newItemProps.folder.id || newItemProps.folder.id === portalItem.owner) {
        // it's already in the home folder
        return;
    }
    let baseUrl = `${portal.restUrl}/content/users/${portalItem.owner}/items/`;
    const moveUrl = `${baseUrl}${createServiceResponse.itemId}/move`;
    const moveContent = {
        folder: newItemProps.folder.id
    };
    return await esriRequest(moveUrl, {
        query: Object.assign(Object.assign({}, moveContent), { f: "json", token: portal.credential.token }),
        method: "post",
        responseType: "json"
    });
}
async function initialItemUpdate(props, createServiceResponse, newItemProps, esriRequest) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    const { layer, layerIds } = props;
    const portalItem = layer.portalItem;
    const portal = portalItem.portal;
    const itemData = await layer.portalItem.fetchData();
    const hasData = (itemData === null || itemData === void 0 ? void 0 : itemData.layers) || (itemData === null || itemData === void 0 ? void 0 : itemData.tables);
    if (hasData) {
        itemData.layers = (_a = itemData.layers) === null || _a === void 0 ? void 0 : _a.filter((lyr) => layerIds.indexOf(lyr.id) > -1);
        itemData.tables = (_b = itemData.tables) === null || _b === void 0 ? void 0 : _b.filter((lyr) => layerIds.indexOf(lyr.id) > -1);
        // if there are no existing overrides for layers or tables keep them undefined
        if (layer.type === "group" && ((_c = layer.layers) === null || _c === void 0 ? void 0 : _c.length)) {
            itemData.layers = itemData.layers || undefined;
        }
        if (layer.type === "group" && ((_d = layer.tables) === null || _d === void 0 ? void 0 : _d.length)) {
            itemData.tables = itemData.tables || undefined;
        }
        // remove parent item definitionExpression
        (_e = itemData.layers) === null || _e === void 0 ? void 0 : _e.forEach((lyr) => {
            if (lyr.layerDefinition) {
                lyr.layerDefinition.definitionExpression = undefined;
            }
        });
        (_f = itemData.tables) === null || _f === void 0 ? void 0 : _f.forEach((table) => {
            if (table.layerDefinition) {
                table.layerDefinition.definitionExpression = undefined;
            }
        });
    }
    const updateUrl = `${portal.restUrl}/content/users/${portalItem.owner}/items/${createServiceResponse.itemId}/update`;
    // need to send some info again
    const updateContent = {
        title: newItemProps.title,
        tags: ((_g = newItemProps.tags) === null || _g === void 0 ? void 0 : _g.length) ? newItemProps.tags.toString() : undefined,
        snippet: newItemProps.summary,
        categories: (_h = newItemProps.categories) === null || _h === void 0 ? void 0 : _h.join(",")
        //extent: `${portalItem.extent.xmin},${portalItem.extent.ymin},${portalItem.extent.xmax},${portalItem.extent.ymax}`,
    };
    if (hasData) {
        updateContent.text = JSON.stringify(itemData);
    }
    if ((layer.type === "group" && ((_m = (_l = (_k = (_j = layer.layers) === null || _j === void 0 ? void 0 : _j.getItemAt(0)) === null || _k === void 0 ? void 0 : _k.fullExtent) === null || _l === void 0 ? void 0 : _l.spatialReference) === null || _m === void 0 ? void 0 : _m.wkt)) ||
        (layer.type === "feature" && ((_p = (_o = layer.fullExtent) === null || _o === void 0 ? void 0 : _o.spatialReference) === null || _p === void 0 ? void 0 : _p.wkt))) {
        // fix bad item extent created by the /refresh call sent from addToDefinition
        setTimeout(() => {
            const updateContent2 = {
                extent: `${portalItem.extent.xmin},${portalItem.extent.ymin},${portalItem.extent.xmax},${portalItem.extent.ymax}`
            };
            esriRequest(updateUrl, {
                query: Object.assign(Object.assign({}, updateContent2), { f: "json", token: portal.credential.token }),
                method: "post",
                responseType: "json"
            });
        }, 7000);
    }
    return await esriRequest(updateUrl, {
        query: Object.assign(Object.assign({}, updateContent), { f: "json", token: portal.credential.token }),
        method: "post",
        responseType: "json"
    });
}
async function itemUpdate(props, addLayerIds, deleteLayerIds, esriRequest) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (!addLayerIds.length && !deleteLayerIds.length) {
        // nothing to do
        return new Promise((resolve) => {
            resolve();
        });
    }
    const { layer, viewItem } = props;
    const portalItem = layer.portalItem;
    const portal = portalItem.portal;
    const itemData = await layer.portalItem.fetchData();
    let viewItemData = await viewItem.fetchData();
    if ((!itemData || (!itemData.layers && !itemData.tables)) &&
        (!viewItemData || (!viewItemData.layers && !viewItemData.tables))) {
        return new Promise((resolve) => {
            resolve();
        });
    }
    if (deleteLayerIds.length) {
        if ((_a = viewItemData === null || viewItemData === void 0 ? void 0 : viewItemData.layers) === null || _a === void 0 ? void 0 : _a.length) {
            viewItemData.layers = viewItemData.layers.filter((lyr) => deleteLayerIds.indexOf(lyr.id) === -1);
        }
        if ((_b = viewItemData === null || viewItemData === void 0 ? void 0 : viewItemData.tables) === null || _b === void 0 ? void 0 : _b.length) {
            viewItemData.tables = viewItemData.tables.filter((lyr) => deleteLayerIds.indexOf(lyr.id) === -1);
        }
    }
    // Do we already have a layers/tables list in the item /data object?
    // If so, are we adding some new layers/tables?
    // Then we have to make sure that we add these new layers/tables to the list
    // even if there are no existing overrides for them
    const viewItemHasContent = !!((_c = viewItemData === null || viewItemData === void 0 ? void 0 : viewItemData.layers) === null || _c === void 0 ? void 0 : _c.length) || !!((_d = viewItemData === null || viewItemData === void 0 ? void 0 : viewItemData.tables) === null || _d === void 0 ? void 0 : _d.length);
    if (addLayerIds.length) {
        const newLayers = [];
        const newTables = [];
        addLayerIds.forEach((id) => {
            const fLayer = getFL(id, props);
            if (!fLayer.isTable) {
                let newLayer;
                if (itemData === null || itemData === void 0 ? void 0 : itemData.layers) {
                    newLayer = itemData.layers.find((lyr) => lyr.id === id);
                    // remove parent item definitionExpression
                    if (newLayer === null || newLayer === void 0 ? void 0 : newLayer.layerDefinition) {
                        newLayer.layerDefinition.definitionExpression = undefined;
                    }
                }
                if (!newLayer && viewItemHasContent) {
                    // we must add the newly added layer to the item /data layers list
                    // no overrides, add just id, don't need popup
                    newLayer = { id };
                }
                if (newLayer) {
                    newLayers.push(newLayer);
                }
            }
            else {
                // table
                let newTable;
                if (itemData === null || itemData === void 0 ? void 0 : itemData.tables) {
                    newTable = itemData.tables.find((lyr) => lyr.id === id);
                    // remove parent item definitionExpression
                    if (newTable === null || newTable === void 0 ? void 0 : newTable.layerDefinition) {
                        newTable.layerDefinition.definitionExpression = undefined;
                    }
                }
                if (!newTable && viewItemHasContent) {
                    // we must add the newly added layer to the item /data layers list
                    // no overrides, add just id, don't need popup
                    newTable = { id };
                }
                if (newTable) {
                    newTables.push(newTable);
                }
            }
        });
        if (newLayers === null || newLayers === void 0 ? void 0 : newLayers.length) {
            viewItemData = viewItemData || {};
            viewItemData.layers = (viewItemData.layers || []).concat(newLayers);
            // make sure it follows the parent layer's order
            // the view service might have it differently (service bug)
            const ids = [];
            (_e = layer.layers) === null || _e === void 0 ? void 0 : _e.forEach((lyr) => {
                ids.unshift(lyr.layerId);
            });
            viewItemData.layers.sort((lyrA, lyrB) => (ids.indexOf(lyrA.id) < ids.indexOf(lyrB.id) ? -1 : 1));
        }
        if (newTables === null || newTables === void 0 ? void 0 : newTables.length) {
            viewItemData = viewItemData || {};
            viewItemData.tables = (viewItemData.tables || []).concat(newTables);
            // make sure it follows the parent layer's order
            // the view service might have it differently (service bug)
            const ids = [];
            (_f = layer.tables) === null || _f === void 0 ? void 0 : _f.forEach((lyr) => {
                ids.unshift(lyr.layerId);
            });
            viewItemData.tables.sort((lyrA, lyrB) => (ids.indexOf(lyrA.id) < ids.indexOf(lyrB.id) ? -1 : 1));
        }
    }
    const updateUrl = `${portal.restUrl}/content/users/${portalItem.owner}/items/${viewItem.id}/update`;
    // need to send some info again
    const updateContent = {
        tags: ((_g = viewItem.tags) === null || _g === void 0 ? void 0 : _g.length) ? viewItem.tags.toString() : undefined,
        snippet: viewItem.snippet,
        categories: (_h = viewItem.categories) === null || _h === void 0 ? void 0 : _h.join(","),
        //extent: `${viewItem.extent.xmin},${viewItem.extent.ymin},${viewItem.extent.xmax},${viewItem.extent.ymax}`,
        text: JSON.stringify(viewItemData)
    };
    return await esriRequest(updateUrl, {
        query: Object.assign(Object.assign({}, updateContent), { f: "json", token: portal.credential.token }),
        method: "post",
        responseType: "json"
    });
}
const pollForStatus$1 = async (url, params, esriRequest) => {
    var _a;
    if (!url) {
        throw new Error("pollForStatus: no status URL");
    }
    const pendingStatuses = ["processing", "partial", "Pending", "InProgress"];
    const successStatuses = ["completed", "Completed"];
    // Keep polling status until either completed or failed
    try {
        // Do failures report as success (status 200)? May need to manually throw error on status check failure
        const statusResponse = await esriRequest(url, { query: params });
        const status = (_a = statusResponse === null || statusResponse === void 0 ? void 0 : statusResponse.data) === null || _a === void 0 ? void 0 : _a.status;
        if (pendingStatuses.includes(status)) {
            await (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__.t)(500);
            return pollForStatus$1(url, params, esriRequest);
        }
        else if (successStatuses.includes(status)) {
            return new Promise((resolve) => {
                resolve();
            });
        }
        else {
            return new Promise((_, reject) => {
                reject();
            });
        }
    }
    catch (e) {
        return new Promise((_, reject) => {
            reject(e);
        });
    }
};

const arcgisLayerViewCss = ".sc-arcgis-layer-view-h{height:100%}.panel.sc-arcgis-layer-view{height:100%}.footer.sc-arcgis-layer-view{width:100%}.error-content.sc-arcgis-layer-view{margin:0.5rem}";

const ArcgisLayerView$1 = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisLayerViewCancel = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewCancel", 7);
        this.arcgisLayerViewStepChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewStepChange", 7);
        this.arcgisLayerViewCreated = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewCreated", 7);
        this.arcgisLayerViewChanged = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewChanged", 7);
        this.status = flowStatus.LOADING;
        // --------------------------------------------------------------------------
        //
        //  Private methods
        //
        // --------------------------------------------------------------------------
        this.goCancel = () => {
            this.arcgisLayerViewCancel.emit();
        };
        this.view = undefined;
        this.itemId = undefined;
        this.config = undefined;
        this.props = undefined;
        this.reRender = false;
    }
    arcgisLayerViewStatusHandler(event) {
        var _a;
        const { props } = this;
        const { detail } = event;
        this.status = detail.status;
        if ((_a = detail.layerIds) === null || _a === void 0 ? void 0 : _a.length) {
            props.layerIds = [...detail.layerIds];
        }
        if (this.status === flowStatus.SELECTION) {
            // we might change source item in this step...
            props.sourceItemId = props.layerItem.id;
            this.arcgisLayerViewStepChange.emit(1);
        }
        else if (this.status === flowStatus.OVERVIEW) {
            this.arcgisLayerViewStepChange.emit(2);
        }
        else if (this.status === flowStatus.CREATE) {
            this.arcgisLayerViewStepChange.emit(3);
        }
        this.reRender = !this.reRender;
    }
    async arcgisLayerViewCreateDoneHandler(event) {
        this.arcgisLayerViewCreated.emit(event.detail);
    }
    async arcgisLayerViewOverviewUpdatedHandler() {
        this.arcgisLayerViewChanged.emit(this.itemId);
    }
    arcgisLayerViewSelectionCancelHandler() {
        this.arcgisLayerViewCancel.emit();
    }
    arcgisLayerViewOverviewCancelHandler() {
        this.arcgisLayerViewCancel.emit();
    }
    arcgisLayerViewCreateCancelHandler() {
        this.arcgisLayerViewCancel.emit();
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    async setStep(step) {
        const { props } = this;
        const { viewItem } = props;
        // close popovers
        document.body.querySelectorAll(".js-app-flyout").forEach((node) => {
            document.body.removeChild(node);
        });
        switch (step) {
            case 1:
                this.status = flowStatus.SELECTION;
                this.reRender = !this.reRender;
                break;
            case 2:
                this.status = flowStatus.OVERVIEW;
                this.reRender = !this.reRender;
                break;
            case 3:
                if (!viewItem) {
                    this.status = flowStatus.CREATE;
                    this.reRender = !this.reRender;
                }
                break;
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        const { itemId, view, config } = this;
        const [strings] = await (0,_locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_1__.g)(this.hostElement);
        this.strings = strings;
        this.props = { config, view, itemId, strings, layerIds: [], modules: {} };
    }
    async componentDidLoad() {
        var _a, _b, _c;
        let { props } = this;
        const { itemId, view } = props;
        if (!itemId) {
            console.error("itemId is a required property.");
            return;
        }
        try {
            const [PortalItem, Layer, Extent, projection, colorUtils, Polygon, esriRequest] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)([
                "esri/portal/PortalItem",
                "esri/layers/Layer",
                "esri/geometry/Extent",
                "esri/geometry/projection",
                "esri/views/support/colorUtils",
                "esri/geometry/Polygon",
                "esri/request"
            ]);
            props.modules.PortalItem = PortalItem;
            props.modules.projection = projection;
            props.modules.Polygon = Polygon;
            props.modules.Extent = Extent;
            props.modules.Layer = Layer;
            const item = new PortalItem({
                id: itemId
            });
            await item.load();
            if (item.type !== "Feature Service") {
                console.error("Only Feature Service items are allowed.");
                return;
            }
            let viewItem, layerItem;
            if (((_a = item.typeKeywords) === null || _a === void 0 ? void 0 : _a.indexOf("View Service")) > -1) {
                // need to look for original item
                viewItem = item;
                await item
                    .fetchRelatedItems({
                    relationshipType: "Service2Data",
                    direction: "forward"
                })
                    .then(async (results) => {
                    if (results.length) {
                        layerItem = results[0];
                    }
                });
            }
            else {
                layerItem = item;
            }
            if (!layerItem) {
                console.error("Could not find related item for view.");
                this.panelNode.loading = false;
                this.status = flowStatus.ERROR;
                this.reRender = !this.reRender;
                return;
            }
            props.sourceItemId = layerItem.id;
            let layerItemOwner = layerItem.portal.user;
            if (layerItem.portal.user.username !== layerItem.owner) {
                // get user info of owner
                await esriRequest(`${layerItem.portal.restUrl}/community/users/${layerItem.owner}`, {
                    query: { f: "json" }
                }).then((userResult) => {
                    if (userResult === null || userResult === void 0 ? void 0 : userResult.data) {
                        layerItemOwner = userResult.data;
                    }
                });
            }
            let gcsExtent = (viewItem || layerItem).extent;
            if (!gcsExtent) {
                gcsExtent = new Extent({
                    xmin: -180,
                    ymin: -90,
                    xmax: 180,
                    ymax: 90,
                    spatialReference: 4326
                });
            }
            if (view.spatialReference.wkid !== 4326) {
                await projection.load();
                const extent = projection.project(gcsExtent, view.spatialReference);
                view.goTo(extent.expand(1.1));
            }
            else {
                view.goTo(gcsExtent.expand(1.1));
            }
            const backgroundTheme = await colorUtils.getBackgroundColorTheme(view);
            // layerItem (from relatedItems call) does not contain itemControl
            // need to get the item card again to get itemControl too
            // need itemControl to create indexes
            layerItem = new PortalItem({
                id: layerItem.id
            });
            await layerItem.load();
            const layer = await Layer.fromPortalItem({
                portalItem: layerItem
            });
            this.props = Object.assign(Object.assign({}, props), { layerItem, viewItem, layer, layerItemOwner, backgroundTheme });
            props = this.props;
            //console.log("**layerItem**", layerItem);
            //console.log("**viewItem**", viewItem);
            //console.log("**layer**", layer);
            if (layer.type === "group") {
                // group layer has no layers or tables at this point
                // loadAll() loads layers and tables (at v4.23)
                await layer.loadAll();
                if ((_b = layer.layers) === null || _b === void 0 ? void 0 : _b.length) {
                    // has at least one spatial layer
                    view.map.add(layer);
                }
                props.layerIds = getLayersAndTables(layer)
                    .map((subLayer) => subLayer.layerId)
                    .toArray();
                // default popups
                (_c = layer.layers) === null || _c === void 0 ? void 0 : _c.forEach((lyr) => {
                    if (!lyr.popupTemplate && lyr.popupEnabled) {
                        lyr.popupTemplate = lyr.createPopupTemplate();
                    }
                });
            }
            else {
                await layer.load();
                if (!layer.isTable) {
                    view.map.add(layer);
                }
                props.layerIds = [layer.layerId];
                // default popup
                layer.popupTemplate = layer.createPopupTemplate();
            }
            await getAdminServiceInfo$1(props);
            /* console.log(
              "view adminServiceInfo layers",
              props.adminServiceInfo?.layers?.map((lyr: any) => {
                return {
                  id: lyr.id,
                  name: lyr.name,
                  adminLayerInfo_filter: lyr.adminLayerInfo?.viewLayerDefinition?.table?.filter?.value,
                  viewDefinitionQuery: lyr.viewDefinitionQuery,
                  fields: lyr.fields.map((field: any) => `${field.name} (${field.visible})`)
                };
              })
            ); */
            await initDefinitions(props);
            //console.log("initDefinitions", propsToString(props));
            // derivative layers
            props.derivativeLayers = { hasAny: false };
            if (viewItem) {
                const results = await item.fetchRelatedItems({
                    relationshipType: "Service2Service",
                    direction: "forward"
                });
                if (results.length) {
                    props.derivativeLayers = {
                        hasMS: results.find((item) => item.type === "Map Service"),
                        hasVTL: results.find((item) => item.type === "Vector Tile Service"),
                        hasWFS: results.find((item) => item.type === "WFS"),
                        hasScene: results.find((item) => item.type === "Scene Service"),
                        hasOGCFL: results.find((item) => item.type === "OGCFeatureServer")
                    };
                    if (props.derivativeLayers.hasMS ||
                        props.derivativeLayers.hasVTL ||
                        props.derivativeLayers.hasWFS ||
                        props.derivativeLayers.hasScene ||
                        props.derivativeLayers.hasOGCFL) {
                        props.derivativeLayers.hasAny = true;
                    }
                }
            }
            // sync and replicas
            if (viewItem && props.adminServiceInfo.capabilities.indexOf("Sync") > -1) {
                // check for replicas
                const replicaUrl = `${viewItem.url}/replicas`;
                await esriRequest(replicaUrl, {
                    query: { f: "json" }
                }).then((replicaResult) => {
                    var _a;
                    props.hasReplicas = ((_a = replicaResult.data) === null || _a === void 0 ? void 0 : _a.length) > 0;
                });
            }
            this.status = flowStatus.SELECTION;
            this.reRender = !this.reRender;
            this.arcgisLayerViewStepChange.emit(1);
        }
        catch (e) {
            console.error(e);
            this.status = flowStatus.ERROR;
            this.reRender = !this.reRender;
        }
    }
    disconnectedCallback() {
        const { props } = this;
        const { view, layer } = props;
        view.map.remove(layer);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        //console.log("render", propsToString(this.props), "status:", this.status);
        const { status } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, status === flowStatus.ERROR ? this.renderError() : null, status === flowStatus.LOADING ? this.renderLoading() : null, [flowStatus.SELECTION, flowStatus.SWAP_SOURCE, flowStatus.BROWSE_LAYER].includes(status)
            ? this.renderLayerSelection()
            : null, [flowStatus.OVERVIEW, flowStatus.DEFINITION, flowStatus.FILTER].includes(status)
            ? this.renderLayerOverview()
            : null, status === flowStatus.CREATE ? this.renderCreateView() : null));
    }
    renderError() {
        const { props } = this;
        const { viewItem, layerItem, strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { loading: false, heading: (viewItem === null || viewItem === void 0 ? void 0 : viewItem.title) || (layerItem === null || layerItem === void 0 ? void 0 : layerItem.title) || strings.msg.error, description: (viewItem === null || viewItem === void 0 ? void 0 : viewItem.title) || (layerItem === null || layerItem === void 0 ? void 0 : layerItem.title) ? strings.general.sourceLayer : undefined, class: CSS$9.panel, ref: (node) => (this.panelNode = node) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$9.errorContent }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-notice", { scale: "s", width: "full", open: true, icon: "exclamation-mark-triangle", kind: "danger" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "title" }, strings.msg.error), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "message" }, strings.msg.initFailed))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "footer", class: CSS$9.footer }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "footer", onClick: this.goCancel, appearance: "transparent", width: "full" }, strings.general.cancel))));
    }
    renderLoading() {
        const { props } = this;
        const { viewItem, layerItem, strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { loading: true, heading: (viewItem === null || viewItem === void 0 ? void 0 : viewItem.title) || (layerItem === null || layerItem === void 0 ? void 0 : layerItem.title), description: strings.general.sourceLayer, class: CSS$9.panel, ref: (node) => (this.panelNode = node) }));
    }
    renderLayerSelection() {
        const { props, status } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-layer-view-selection", { key: `selection-${status}`, props: props, status: status }));
    }
    renderLayerOverview() {
        const { props, status } = this;
        const { definitionLayerId } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-layer-view-overview", { key: `overview-${status}-${definitionLayerId}`, props: props, status: status }));
    }
    renderCreateView() {
        const { props, status } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-layer-view-create", { key: `create-${status}`, props: props }));
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisLayerView$1.style = arcgisLayerViewCss;

const arcgisLayerViewBrowseLayerCss = ".panel.sc-arcgis-layer-view-browse-layer{height:100%}";

const ArcgisLayerViewBrowseLayer = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisLayerViewStatusChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewStatusChange", 7);
        // --------------------------------------------------------------------------
        //
        //  Private methods
        //
        // --------------------------------------------------------------------------
        this.onBack = () => {
            this.arcgisLayerViewStatusChange.emit({ status: flowStatus.SWAP_SOURCE });
        };
        this.goSwapLayer = async (itemId) => {
            const { props, flowItemNode, hostElement } = this;
            const { strings } = props;
            const swapItem = this.items.find((item) => item.id === itemId);
            this.loading = true;
            const canSwapLayerErrorString = await canSwap(swapItem, this.props);
            if (canSwapLayerErrorString) {
                this.loading = false;
                this.msgNode = document.createElement("arcgis-layer-view-msg");
                this.msgNode.props = props;
                this.msgNode.flowItemElement = flowItemNode;
                this.msgNode.isError = true;
                this.msgNode.message = `${strings.msg.cannotSwap} ${canSwapLayerErrorString}`;
                hostElement.appendChild(this.msgNode);
                clearTimeout(this.timeoutHndl);
                this.timeoutHndl = setTimeout(() => {
                    this.timeoutHndl = undefined;
                    if (this.msgNode) {
                        hostElement.removeChild(this.msgNode);
                        this.msgNode = undefined;
                    }
                }, 7000);
            }
            else {
                try {
                    await swapSource(this.props);
                    this.loading = false;
                    this.msgNode = document.createElement("arcgis-layer-view-msg");
                    this.msgNode.props = props;
                    this.msgNode.flowItemElement = flowItemNode;
                    this.msgNode.message = strings.msg.successSwap.replace("${source}", swapItem.title);
                    this.msgNode.closeWithOK = true;
                    this.msgNode.addEventListener("arcgisLayerViewMsgClosed", () => {
                        this.msgNode = undefined;
                        this.arcgisLayerViewStatusChange.emit({ status: flowStatus.SELECTION });
                    });
                    hostElement.appendChild(this.msgNode);
                }
                catch (e) {
                    this.loading = false;
                    this.msgNode = document.createElement("arcgis-layer-view-msg");
                    this.msgNode.props = props;
                    this.msgNode.flowItemElement = flowItemNode;
                    this.msgNode.isError = true;
                    this.msgNode.message = strings.msg.swapFailed;
                    hostElement.appendChild(this.msgNode);
                    clearTimeout(this.timeoutHndl);
                    this.timeoutHndl = setTimeout(() => {
                        this.timeoutHndl = undefined;
                        if (this.msgNode) {
                            hostElement.removeChild(this.msgNode);
                            this.msgNode = undefined;
                        }
                    }, 7000);
                }
            }
        };
        this.props = undefined;
        this.reRender = false;
        this.loading = false;
        this.items = undefined;
        this.pagination = undefined;
        this.error = undefined;
    }
    arcgisLayerViewMsgClosedHandler() {
        if (this.msgNode) {
            this.hostElement.removeChild(this.msgNode);
            this.msgNode = undefined;
        }
        clearTimeout(this.timeoutHndl);
        this.timeoutHndl = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentDidLoad() {
        setTimeout(() => requestAnimationFrame(() => { var _a; return (_a = this.flowItemNode) === null || _a === void 0 ? void 0 : _a.setFocus(); }), 200);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const { props, loading, hostElement } = this;
        const { strings } = props;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "calcite-match-height" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { heading: strings.swapSource.browseForLayerTitle, description: strings.swapSource.subTitle, loading: loading, class: {
                panel: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.C.rtl]: rtl
            }, onCalciteFlowItemBack: this.onBack, ref: (node) => (this.flowItemNode = node) }, this.renderItemBrowser())));
    }
    renderItemBrowser() {
        const { props, pagination } = this;
        const { layer, sourceItemId, strings } = props;
        const { portalItem } = layer;
        const { portal } = portalItem;
        const user = portal.user;
        const query = `type:"Feature Service" typekeywords:"Hosted Service" -typekeywords:"View Service" owner:"${user.username}" -id:${sourceItemId}`;
        const baseUrl = `${(0,_portal_660bb43a_js__WEBPACK_IMPORTED_MODULE_6__.g)(portal)}/home/`;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser", { onArcgisItemBrowserUpdate: (e) => {
                const { results, num, start, total } = e.detail;
                this.items = results;
                this.pagination = { start, num, total };
            }, filter: query, portal: portal, user: user, api: 4, config: { baseUrl }, selection: "none" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-top-bar", { slot: "top-bar" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-search", { slot: "search", term: "" })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-sort", { options: ["modified", "title", "relevance"], slot: "sort" }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-content", { slot: "content" }, (this.items || []).map((item) => ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-card", { item: item, portal: portal, baseUrl: baseUrl, key: item.id }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { id: `swap-action-${item.id}`, icon: "arrow-right-left", text: "", scale: "s", slot: "actions-end", onClick: this.goSwapLayer.bind(this, item.id) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tooltip", { slot: "tooltip", label: strings.general.swapSource, overlayPositioning: "fixed" }, strings.general.swapSource)))))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-pagination", { total: pagination === null || pagination === void 0 ? void 0 : pagination.total, start: pagination === null || pagination === void 0 ? void 0 : pagination.start, num: pagination === null || pagination === void 0 ? void 0 : pagination.num, slot: "pagination" })));
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisLayerViewBrowseLayer.style = arcgisLayerViewBrowseLayerCss;

const CSS$8 = {
    panel: "panel",
    info: "info",
    footer: "footer"
};

const arcgisLayerViewCreateCss = ".panel.sc-arcgis-layer-view-create{height:100%}.info.sc-arcgis-layer-view-create{display:grid;grid-template-columns:repeat(1, minmax(0px, 1fr));gap:0.5rem;padding:1rem 0.75rem}.footer.sc-arcgis-layer-view-create{width:100%}";

const ArcgisLayerViewCreate$1 = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisLayerViewStatusChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewStatusChange", 7);
        this.arcgisLayerViewCreateDone = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewCreateDone", 7);
        this.arcgisLayerViewCreateCancel = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewCreateCancel", 7);
        // --------------------------------------------------------------------------
        //
        //  Private methods
        //
        // --------------------------------------------------------------------------
        this.goBack = () => {
            // save last settings
            const { props } = this;
            props.savedItemProps = {
                title: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.title,
                tags: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.tags,
                summary: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.snippet,
                categories: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.categories,
                folder: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.folder
            };
            this.arcgisLayerViewStatusChange.emit({ status: flowStatus.OVERVIEW });
        };
        this.goCreate = async () => {
            const { props, flowItemNode, hostElement } = this;
            const { strings } = props;
            // in case the create call fails
            props.savedItemProps = {
                title: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.title,
                tags: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.tags,
                summary: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.snippet,
                categories: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.categories,
                folder: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.folder
            };
            const newItemProps = {
                title: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.title,
                tags: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.tags,
                summary: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.snippet,
                categories: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.categories,
                folder: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.folder
            };
            this.loading = true;
            try {
                this.viewItemId = await createView(props, newItemProps);
                this.loading = false;
                this.msgNode = document.createElement("arcgis-layer-view-msg");
                this.msgNode.props = props;
                this.msgNode.flowItemElement = flowItemNode;
                this.msgNode.message = strings.msg.created;
                hostElement.appendChild(this.msgNode);
                clearTimeout(this.timeoutHndl);
                this.timeoutHndl = setTimeout(() => {
                    this.timeoutHndl = undefined;
                    if (this.msgNode) {
                        hostElement.removeChild(this.msgNode);
                        this.msgNode = undefined;
                        this.arcgisLayerViewCreateDone.emit(this.viewItemId);
                    }
                }, 7000);
            }
            catch (e) {
                const { props, flowItemNode } = this;
                const { strings } = props;
                this.loading = false;
                console.error("could not create view", e);
                this.msgNode = document.createElement("arcgis-layer-view-msg");
                this.msgNode.props = props;
                this.msgNode.flowItemElement = flowItemNode;
                this.msgNode.isError = true;
                if (e.message === "service name already exists") {
                    // going to have another string...
                    this.msgNode.message = strings.msg.createFailed;
                }
                else {
                    this.msgNode.message = strings.msg.createFailed;
                }
                hostElement.appendChild(this.msgNode);
                clearTimeout(this.timeoutHndl);
                this.timeoutHndl = setTimeout(() => {
                    this.timeoutHndl = undefined;
                    if (this.msgNode) {
                        hostElement.removeChild(this.msgNode);
                        this.msgNode = undefined;
                    }
                }, 7000);
            }
        };
        this.goCancel = () => {
            this.arcgisLayerViewCreateCancel.emit();
        };
        this.props = undefined;
        this.reRender = false;
        this.loading = false;
        this.title = undefined;
    }
    arcgisLayerViewMsgClosedHandler() {
        if (this.msgNode) {
            this.hostElement.removeChild(this.msgNode);
            this.msgNode = undefined;
        }
        clearTimeout(this.timeoutHndl);
        this.timeoutHndl = undefined;
        if (this.viewItemId) {
            this.arcgisLayerViewCreateDone.emit(this.viewItemId);
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        const { props } = this;
        this.title = await getSuggestedTitle(props);
    }
    async componentDidLoad() {
        requestAnimationFrame(() => { var _a; return (_a = this.backButtonNode) === null || _a === void 0 ? void 0 : _a.setFocus(); });
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        //console.log("render view-create", propsToString(this.props));
        const { props, loading } = this;
        const { viewItem, layerItem, strings } = props;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "calcite-match-height" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { heading: strings.createView.create, description: (viewItem === null || viewItem === void 0 ? void 0 : viewItem.title) || (layerItem === null || layerItem === void 0 ? void 0 : layerItem.title), loading: loading, class: {
                panel: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.C.rtl]: rtl
            }, ref: (node) => (this.flowItemNode = node) }, this.renderFooterButtons(), this.renderInfo())));
    }
    renderFooterButtons() {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "footer", class: CSS$8.footer }, this.renderBack(), this.renderCreate(), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("br", null), this.renderCancel()));
    }
    renderBack() {
        const { props } = this;
        const { strings } = props;
        const isRtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { onClick: this.goBack, appearance: "outline-fill", width: "half", "icon-start": isRtl ? "arrow-right" : "arrow-left", ref: (node) => (this.backButtonNode = node) }, strings.general.back));
    }
    renderCreate() {
        const { props, title, titleError, summaryError } = this;
        const { layer, layerIds, strings } = props;
        const enabled = (layer === null || layer === void 0 ? void 0 : layer.loaded) && layerIds.length && title && !titleError && !summaryError;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { disabled: !enabled, onClick: enabled && this.goCreate, appearance: "solid", width: "half", "icon-start": "plus-square", ref: (node) => (this.createButtonNode = node) }, strings.createView.create));
    }
    renderCancel() {
        const { props } = this;
        const { layer, layerIds, strings } = props;
        const enabled = (layer === null || layer === void 0 ? void 0 : layer.loaded) && layerIds.length;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { disabled: !enabled, onClick: enabled && this.goCancel, appearance: "transparent", width: "full" }, strings.general.cancel));
    }
    renderInfo() {
        const { props, title } = this;
        const { layer, layerItemOwner, savedItemProps } = props;
        const { portalItem } = layer;
        const { portal } = portalItem;
        const user = portal.user;
        const config = { portal, user, api: 4 };
        if (savedItemProps) {
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.title = savedItemProps.title;
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.folder = savedItemProps.folder;
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.snippet = savedItemProps.summary || "";
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.categories = savedItemProps.categories;
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.tags = savedItemProps.tags;
        }
        else {
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.title = title;
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.folder =
                portalItem.ownerFolder &&
                    {
                        id: portalItem.ownerFolder,
                        username: portalItem.owner
                    };
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.snippet = portalItem.snippet || "";
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.categories = portalItem.categories;
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.tags = portalItem.tags;
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$8.info }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-properties", { portal: portal, user: user, api: 4, config: config, type: "Feature Service", scale: "s" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-title-input", { enablePublishing: true, onArcgisTitleInputChange: async (event) => {
                const node = event.target;
                const titleError = await node.validateTitle();
                if ((!this.titleError && titleError) || (this.titleError && !titleError)) {
                    this.reRender = !this.reRender;
                }
                this.titleError = titleError;
            } }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-folder-picker", { user: layerItemOwner }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-categories-picker", null), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-tags-picker", null), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-summary-input", { onArcgisSummaryInputChange: async (event) => {
                const node = event.target;
                const summaryError = (await node.getErrorMessage());
                if ((!this.summaryError && summaryError) || (this.summaryError && !summaryError)) {
                    this.reRender = !this.reRender;
                }
                this.summaryError = summaryError;
            } }))));
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisLayerViewCreate$1.style = arcgisLayerViewCreateCss;

const CSS$7 = {
    panel: "panel",
    hook: "hook",
    notice: "notice",
    filterBlock: "filter-block",
    filterChevron: "filter-chevron",
    aoiGroup: "aoi-group",
    aoiButton: "aoi-button",
    textCenter: "text-center",
    selectFields: "select-fields"
};

const arcgisLayerViewDefinitionCss = ".panel.sc-arcgis-layer-view-definition{height:100%}.hook.sc-arcgis-layer-view-definition{height:1px}.notice.sc-arcgis-layer-view-definition{margin:8px}.filter-block.sc-arcgis-layer-view-definition{cursor:pointer}.filter-block.sc-arcgis-layer-view-definition:hover{background-color:var(--calcite-color-foreground-2)}.filter-chevron.sc-arcgis-layer-view-definition{margin-right:0.5rem}.arcgis--rtl.sc-arcgis-layer-view-definition .filter-chevron.sc-arcgis-layer-view-definition{margin-left:0.5rem;margin-right:auto}.aoi-group.sc-arcgis-layer-view-definition{width:100%;margin-bottom:0.75rem}.aoi-button.sc-arcgis-layer-view-definition{margin-top:0.75rem;border-top-width:1px;border-top-style:solid;border-top-color:var(--calcite-color-border-3)}.text-center.sc-arcgis-layer-view-definition{text-align:center}.select-fields.sc-arcgis-layer-view-definition{margin:0 0 5px 0}";

const ArcgisLayerViewDefinition = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisLayerViewOverViewRefresh = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewOverViewRefresh", 7);
        this.aoiSymbol = {
            type: "simple-fill",
            style: "solid",
            color: [0, 0, 0, 0],
            outline: {
                type: "simple-line",
                style: "solid",
                color: [255, 0, 0, 255],
                width: 2
            }
        };
        // --------------------------------------------------------------------------
        //
        //  Private methods
        //
        // --------------------------------------------------------------------------
        this.onBack = () => {
            this.arcgisLayerViewOverViewRefresh.emit();
        };
        // ---------  Filter  -------------------------------------------------------
        this.goFilter = () => {
            var _a;
            if ((_a = this.aoiBlockNode) === null || _a === void 0 ? void 0 : _a.open) {
                this.aoiBlockNode.open = false;
                this.onAOIToggle();
            }
            this.status = flowStatus.FILTER;
            this.reRender = !this.reRender;
        };
        this.onBackFilter = () => {
            this.status = flowStatus.DEFINITION;
            this.reRender = !this.reRender;
            setTimeout(() => { var _a; return (_a = this.filterActionNode) === null || _a === void 0 ? void 0 : _a.setFocus(); }, 200);
        };
        // ---------  AOI     -------------------------------------------------------
        this.onPolygonClick = (event) => {
            const { props } = this;
            const { strings } = props;
            const node = event.target;
            if (!node.active) {
                this.sketchViewModel.cancel();
                this.sketchViewModel.create("polygon");
                node.active = true;
                this.rectangleAction.active = false;
                this.drawLabel.innerHTML = strings.defineView.aoiPolygonDraw;
            }
        };
        this.onRectangleClick = (event) => {
            const { props } = this;
            const { strings } = props;
            const node = event.target;
            if (!node.active) {
                this.sketchViewModel.cancel();
                this.sketchViewModel.create("rectangle");
                node.active = true;
                this.polygonAction.active = false;
                this.drawLabel.innerHTML = strings.defineView.aoiRectangleDraw;
            }
        };
        this.onDeleteAOIClick = () => {
            const { props } = this;
            const { definitionLayerId, strings } = props;
            this.sketchViewModel.cancel();
            this.graphicsLayer.removeAll();
            const viewLayerProps = getViewLayerProps(definitionLayerId, props);
            if (viewLayerProps) {
                viewLayerProps.aoi = undefined;
            }
            sanitizeViewProps(props);
            applyLayerAOI(undefined, definitionLayerId, props);
            this.drawLabel.innerHTML = strings.defineView.aoiSelect;
            this.polygonAction.disabled = false;
            this.rectangleAction.disabled = false;
            this.aoiBlockNode.description = strings.defineView.aoiSubtext;
            this.reRender = !this.reRender;
        };
        this.onGraphicUpdate = (event) => {
            const { props } = this;
            const { view, definitionLayerId } = props;
            view.closePopup();
            if (event.state === "complete") {
                const sketchGraphic = event.graphics[0];
                const extent = sketchGraphic.geometry.extent;
                const pts = sketchGraphic.geometry.rings[0];
                let isRectangle = false;
                if (pts.length === 5 &&
                    pts.indexOf([extent.xmin, extent.ymin]) > -1 &&
                    pts.indexOf([extent.xmax, extent.ymax]) > -1) {
                    isRectangle = true;
                }
                addViewLayerProps(definitionLayerId, {
                    aoi: this.rectangleAction.active && isRectangle
                        ? extent.toJSON()
                        : sketchGraphic.geometry.toJSON()
                }, props);
                applyLayerAOI(sketchGraphic.geometry, definitionLayerId, props);
                if (this.rectangleAction.active && !isRectangle) {
                    // user updated a rectangle to a polygon
                    this.reRender = !this.reRender;
                }
            }
        };
        // ---------  Fields  -------------------------------------------------------
        this.selectFields = (fl) => {
            const { props, totalFields, requiredFieldNames } = this;
            const { view, definitionLayerId } = props;
            const viewLayerProps = getViewLayerProps(definitionLayerId, props);
            let fieldNames = [];
            if (viewLayerProps === null || viewLayerProps === void 0 ? void 0 : viewLayerProps.fields) {
                fieldNames = viewLayerProps.fields;
            }
            else {
                fieldNames = totalFields
                    .filter((field) => requiredFieldNames.indexOf(field.name) === -1)
                    .map((field) => field.name);
            }
            this.closeLayerViewDefinitionPopoversHandler();
            const nodeWidth = this.flowItemNode.getBoundingClientRect().width;
            this.arcgisFieldPickList = document.createElement("arcgis-field-pick-list");
            this.arcgisFieldPickList.popoverProps = {
                placement: "auto",
                offsetDistance: -1 * (nodeWidth ? nodeWidth - 5 : 215),
                offsetSkidding: 0,
                pointerDisabled: true,
                popoverWidth: nodeWidth ? nodeWidth + 30 : 280,
                refElement: this.flowItemNode
            };
            this.arcgisFieldPickList.fields = this.createPickListFields(fl);
            this.arcgisFieldPickList.layer = fl;
            this.arcgisFieldPickList.mapView = view;
            this.arcgisFieldPickList.showFieldInfo = true;
            this.arcgisFieldPickList.showFieldName = false;
            this.arcgisFieldPickList.selectedFields = fieldNames;
            this.arcgisFieldPickList.multiple = true;
            this.arcgisFieldPickList.addEventListener("arcgisFieldPickListDismissed", this.fieldPickListChanges);
            document.body.appendChild(this.arcgisFieldPickList);
            this.flowItemNode.disabled = true;
        };
        this.fieldPickListChanges = (event) => {
            var _a;
            event.stopPropagation();
            const { props, requiredFieldNames } = this;
            const { definitionLayerId } = props;
            const selectedFields = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.selectedFields;
            this.removeFieldsPickList();
            if (selectedFields) {
                const adminLayerInfo = getAdminLayerInfo(definitionLayerId, props);
                const totalFields = (adminLayerInfo === null || adminLayerInfo === void 0 ? void 0 : adminLayerInfo.fields) || getFL(definitionLayerId, props).fields;
                // keep order like in service
                const selectedAndRequiredFields = totalFields
                    .filter((field) => requiredFieldNames.indexOf(field.name) > -1 || selectedFields.indexOf(field.name) > -1)
                    .map((field) => field.name);
                if (selectedAndRequiredFields.length < totalFields.length) {
                    // subset of fields
                    addViewLayerProps(definitionLayerId, {
                        fields: selectedAndRequiredFields
                    }, props);
                }
                else {
                    // default; all fields
                    let viewLayerProps = getViewLayerProps(definitionLayerId, props);
                    if (viewLayerProps) {
                        viewLayerProps.fields = undefined;
                    }
                    sanitizeViewProps(props);
                }
                this.reRender = !this.reRender;
            } // else user hit cancel or close
        };
        this.removeField = (fieldName) => {
            const { props, totalFields } = this;
            const { definitionLayerId } = props;
            let viewLayerProps = getViewLayerProps(definitionLayerId, props);
            if (!viewLayerProps) {
                viewLayerProps = {
                    layerId: definitionLayerId
                };
                props.viewProps = props.viewProps || [];
                props.viewProps.push(viewLayerProps);
            }
            if (!viewLayerProps.fields) {
                viewLayerProps.fields = totalFields.map((field) => field.name);
            }
            viewLayerProps.fields.splice(viewLayerProps.fields.indexOf(fieldName), 1);
            this.reRender = !this.reRender;
        };
        this.props = undefined;
        this.status = undefined;
        this.reRender = false;
        this.loading = false;
    }
    closeLayerViewDefinitionPopoversHandler() {
        this.removeFieldsPickList();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        var _a;
        const { props } = this;
        const { definitionLayerId } = props;
        this.fl = getFL(definitionLayerId, props);
        this.adminLayerInfo = getAdminLayerInfo(definitionLayerId, props);
        this.totalFields = ((_a = this.adminLayerInfo) === null || _a === void 0 ? void 0 : _a.fields) || getFL(definitionLayerId, props).fields;
        this.requiredFieldNames = getRequiredFieldNames(props);
    }
    async componentDidLoad() {
        setTimeout(() => requestAnimationFrame(() => { var _a; return (_a = this.flowItemNode) === null || _a === void 0 ? void 0 : _a.setFocus(); }), 200);
    }
    disconnectedCallback() {
        this.removeSketchViewModel();
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        //console.log("render view-definition", propsToString(this.props));
        const { props, status } = this;
        const { definitionLayerId, strings } = props;
        const fl = getFL(definitionLayerId, props);
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "calcite-match-height" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { heading: strings.defineView.definitions, description: fl.title, class: {
                panel: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.C.rtl]: rtl
            }, onCalciteFlowItemBack: this.onBack, ref: (node) => (this.flowItemNode = node) }, this.renderInfo(), this.renderFilter(), this.renderAOI(), this.renderFields()), status === flowStatus.FILTER ? this.renderLayerFilter() : null));
    }
    renderInfo() {
        const { props } = this;
        const { config, strings } = props;
        const { helpBase, helpMap } = config;
        if ((0,_localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_8__.g)(_localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_8__.l.ARCGIS_COMPONENT_NOTIFICATIONS, _localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_8__.a.LAYER_VIEW_DEFINITION_DISMISSED)) {
            return null;
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-notice", { class: CSS$7.notice, open: true, closable: true, scale: "s", width: "auto", onCalciteNoticeClose: () => {
                (0,_localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_8__.s)(_localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_8__.l.ARCGIS_COMPONENT_NOTIFICATIONS, {
                    key: _localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_8__.a.LAYER_VIEW_DEFINITION_DISMISSED,
                    value: "true"
                });
            } }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "title" }, strings.defineView.addDefinitions), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "message" }, strings.defineView.addDefinitionsMsg), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-link", { slot: "link", title: strings.defineView.moreAboutViews, target: "_blank", href: `${helpBase}${helpMap["120002839"]}` }, strings.defineView.moreAboutViews)));
    }
    renderFilter() {
        const { props } = this;
        const { definitionLayerId, strings } = props;
        const viewLayerProps = getViewLayerProps(definitionLayerId, props);
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { heading: (viewLayerProps === null || viewLayerProps === void 0 ? void 0 : viewLayerProps.filter) ? strings.defineView.editFilter : strings.defineView.addFilter, collapsible: false, class: CSS$7.filterBlock, tabIndex: 0, onClick: this.goFilter }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { slot: "icon", icon: "filter", scale: "s" }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { slot: "control", icon: rtl ? "chevron-left" : "chevron-right", class: CSS$7.filterChevron, scale: "s", text: (viewLayerProps === null || viewLayerProps === void 0 ? void 0 : viewLayerProps.filter) ? strings.defineView.editFilter : strings.defineView.addFilter, ref: (node) => (this.filterActionNode = node) })));
    }
    renderAOI() {
        const { props, fl } = this;
        const { definitionLayerId, strings } = props;
        if (fl.isTable) {
            return null;
        }
        const viewLayerProps = getViewLayerProps(definitionLayerId, props);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { heading: strings.defineView.areaOfInterest, description: !(viewLayerProps === null || viewLayerProps === void 0 ? void 0 : viewLayerProps.aoi) ? strings.defineView.aoiSubtext : undefined, collapsible: true, onCalciteBlockOpen: () => this.onAOIToggle(), onCalciteBlockClose: () => this.onAOIToggle(), ref: (node) => (this.aoiBlockNode = node) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { slot: "icon", icon: "polygon", scale: "s" }), this.renderAOIContent()));
    }
    renderAOIContent() {
        const { props } = this;
        const { definitionLayerId, layerIds, strings } = props;
        const viewLayerProps = getViewLayerProps(definitionLayerId, props);
        const hasAOI = !!(viewLayerProps === null || viewLayerProps === void 0 ? void 0 : viewLayerProps.aoi);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action-group", { layout: "grid", class: CSS$7.aoiGroup }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { icon: "polygon", appearance: "solid", alignment: "center", active: false, disabled: hasAOI, scale: "s", text: strings.defineView.aoiSketchPolygonLabel, title: strings.defineView.aoiSketchPolygonLabel, onClick: !hasAOI ? this.onPolygonClick : undefined, ref: (node) => (this.polygonAction = node) }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { icon: "rectangle", appearance: "solid", alignment: "center", active: false, disabled: hasAOI, scale: "s", text: strings.defineView.aoiSketchRectangleLabel, title: strings.defineView.aoiSketchRectangleLabel, onClick: !hasAOI ? this.onRectangleClick : undefined, ref: (node) => (this.rectangleAction = node) }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { icon: "trash", appearance: "solid", alignment: "center", scale: "s", disabled: !hasAOI, text: strings.defineView.aoiDeleteLabel, title: strings.defineView.aoiDeleteLabel, onClick: hasAOI ? this.onDeleteAOIClick : undefined })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$7.textCenter, ref: (node) => (this.drawLabel = node) }, !hasAOI ? strings.defineView.aoiSelect : strings.defineView.aoiRestart), layerIds.length > 1 ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "transparent", width: "full", class: CSS$7.aoiButton, onClick: () => this.applyAOIToAll() }, strings.defineView.aoiApplyAll)) : null));
    }
    renderFields() {
        var _a;
        const { props, totalFields } = this;
        const { definitionLayerId, strings } = props;
        const viewLayerProps = getViewLayerProps(definitionLayerId, props);
        const totalFieldCount = totalFields.length;
        const fieldCountView = ((_a = viewLayerProps === null || viewLayerProps === void 0 ? void 0 : viewLayerProps.fields) === null || _a === void 0 ? void 0 : _a.length) || totalFieldCount;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { heading: strings.defineView.fields, description: `${fieldCountView}/${totalFieldCount}`, collapsible: true }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { slot: "icon", icon: "feature-details", scale: "s" }), this.renderFieldsContent()));
    }
    renderFieldsContent() {
        const { props, fl, requiredFieldNames, totalFields } = this;
        const { definitionLayerId, strings } = props;
        const viewLayerProps = getViewLayerProps(definitionLayerId, props);
        let fieldsList;
        if (viewLayerProps === null || viewLayerProps === void 0 ? void 0 : viewLayerProps.fields) {
            fieldsList = totalFields.filter((field) => viewLayerProps.fields.indexOf(field.name) > -1 ||
                requiredFieldNames.indexOf(field.name) > -1);
        }
        else {
            fieldsList = totalFields;
        }
        const hasFieldsToSelect = requiredFieldNames.length !== totalFields.length;
        const listItems = fieldsList.map((field) => {
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list-item", { label: field.alias || field.name }, requiredFieldNames.indexOf(field.name) === -1 ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { icon: "x", scale: "s", text: strings.general.remove, slot: "actions-end", onClick: () => this.removeField(field.name) })) : null));
        });
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, hasFieldsToSelect && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { class: CSS$7.selectFields, appearance: "outline-fill", round: true, label: strings.defineView.selectFields, scale: "s", width: "full", onClick: () => this.selectFields(fl), ref: (node) => (this.buttonNode = node) }, strings.defineView.selectFields)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list", null, listItems)));
    }
    renderLayerFilter() {
        const { props, fl } = this;
        const { view, definitionLayerId } = props;
        const viewLayerProps = getViewLayerProps(definitionLayerId, this.props);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-filter", { key: `filter-${definitionLayerId}`, view: view, layer: fl, mode: "layer-view", viewFilter: viewLayerProps === null || viewLayerProps === void 0 ? void 0 : viewLayerProps.filter, dismissible: false, hideLayerTitle: false, onArcgisFilterPanelBackClick: this.onBackFilter, onArcgisFilterWhereChange: (event) => this.applyFilter(event.detail) }));
    }
    async applyFilter(where) {
        // apply filter after arcgis-filter component closed
        const { props } = this;
        const { definitionLayerId } = props;
        if (where) {
            addViewLayerProps(definitionLayerId, {
                filter: where
            }, props);
        }
        else {
            // default; no filter
            const viewLayerProps = getViewLayerProps(definitionLayerId, props);
            if (viewLayerProps) {
                viewLayerProps.filter = undefined;
            }
            sanitizeViewProps(props);
        }
        // filter component doesn't remove effect on layerView
        //await applyLayerFilter(where, definitionLayerId, props);
    }
    async onAOIToggle() {
        if (this.aoiBlockNode.open) {
            if (!this.SketchViewModel) {
                this.aoiBlockNode.loading = true;
                const [SketchViewModel, GraphicsLayer, Graphic, Polygon, Extent] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)([
                    "esri/widgets/Sketch/SketchViewModel",
                    "esri/layers/GraphicsLayer",
                    "esri/Graphic",
                    "esri/geometry/Polygon",
                    "esri/geometry/Extent"
                ]);
                this.SketchViewModel = SketchViewModel;
                this.GraphicsLayer = GraphicsLayer;
                this.Graphic = Graphic;
                this.Polygon = Polygon;
                this.Extent = Extent;
                this.aoiBlockNode.loading = false;
            }
            this.setupSketchViewModel();
        }
        else {
            this.removeSketchViewModel();
        }
    }
    setupSketchViewModel() {
        const { props, aoiSymbol } = this;
        const { layer, view, definitionLayerId } = props;
        this.defaultAutoOpenEnabled = view.popupEnabled;
        view.popupEnabled = false;
        if (this.graphicsLayer) {
            // done that already
            return;
        }
        this.graphicsLayer = new this.GraphicsLayer();
        view.map.add(this.graphicsLayer);
        const viewLayerProps = getViewLayerProps(definitionLayerId, props);
        if (viewLayerProps === null || viewLayerProps === void 0 ? void 0 : viewLayerProps.aoi) {
            // sketch only wants polygons
            const geom = viewLayerProps.aoi;
            const geometry = geom.rings
                ? this.Polygon.fromJSON(geom)
                : new this.Polygon({
                    rings: [
                        [geom.xmin, geom.ymin],
                        [geom.xmin, geom.ymax],
                        [geom.xmax, geom.ymax],
                        [geom.xmax, geom.ymin],
                        [geom.xmin, geom.ymin]
                    ],
                    spatialReference: viewLayerProps.aoi.spatialReference
                });
            const graphic = new this.Graphic({
                geometry,
                symbol: aoiSymbol
            });
            this.graphicsLayer.add(graphic);
        }
        this.sketchViewModel = new this.SketchViewModel({
            layer: this.graphicsLayer,
            view,
            polygonSymbol: aoiSymbol,
            updateOnGraphicClick: true
        });
        this.sketchViewModel.on("create", (event) => this.onGraphicCreate(event));
        this.sketchViewModel.on("update", this.onGraphicUpdate);
        const snapping = layer.type === "group"
            ? layer.layers.map((fLayer) => {
                return { layer: fLayer };
            })
            : [{ layer }];
        this.sketchViewModel.snappingOptions.featureSources = snapping;
        this.sketchViewModel.snappingOptions.enabled = true;
    }
    removeSketchViewModel() {
        var _a, _b;
        const { props, defaultAutoOpenEnabled } = this;
        const { view } = props;
        this.graphicsLayer && view.map.remove(this.graphicsLayer);
        (_a = this.graphicsLayer) === null || _a === void 0 ? void 0 : _a.destroy();
        this.graphicsLayer = undefined;
        (_b = this.sketchViewModel) === null || _b === void 0 ? void 0 : _b.destroy();
        this.sketchViewModel = undefined;
        view.popupEnabled = defaultAutoOpenEnabled;
    }
    onGraphicCreate(event) {
        const { props } = this;
        const { definitionLayerId, strings } = props;
        if (event.state === "start" && this.polygonAction.active) {
            this.drawLabel.innerHTML = strings.defineView.aoiPolygonEnd;
        }
        if (event.state === "complete") {
            const sketchGraphic = event.graphic;
            const extent = sketchGraphic.geometry.extent;
            addViewLayerProps(definitionLayerId, {
                aoi: !this.polygonAction.active ? extent.toJSON() : sketchGraphic.geometry.toJSON()
            }, props);
            applyLayerAOI(sketchGraphic.geometry, definitionLayerId, props);
            //console.log("create complete", propsToString(props));
            this.drawLabel.innerHTML = strings.defineView.aoiRestart;
            this.polygonAction.active = false;
            this.rectangleAction.active = false;
            this.polygonAction.disabled = true;
            this.rectangleAction.disabled = true;
            this.aoiBlockNode.description = undefined;
            this.reRender = !this.reRender;
        }
    }
    applyAOIToAll() {
        const { props } = this;
        const { definitionLayerId, layer } = props;
        if (layer.type !== "group") {
            return;
        }
        const viewLayerProps = getViewLayerProps(definitionLayerId, props);
        layer.layers.map((flayer) => {
            if (flayer.layerId !== definitionLayerId) {
                if (viewLayerProps === null || viewLayerProps === void 0 ? void 0 : viewLayerProps.aoi) {
                    addViewLayerProps(flayer.layerId, {
                        aoi: JSON.parse(JSON.stringify(viewLayerProps.aoi))
                    }, props);
                }
                else {
                    const viewLayerProps2 = getViewLayerProps(flayer.layerId, props);
                    if (viewLayerProps2) {
                        viewLayerProps2.aoi = undefined;
                    }
                    sanitizeViewProps(props);
                }
                if (viewLayerProps === null || viewLayerProps === void 0 ? void 0 : viewLayerProps.aoi) {
                    const geometry = viewLayerProps.aoi.rings
                        ? this.Polygon.fromJSON(viewLayerProps.aoi)
                        : this.Extent.fromJSON(viewLayerProps.aoi);
                    applyLayerAOI(geometry, flayer.layerId, props);
                }
                else {
                    applyLayerAOI(undefined, flayer.layerId, props);
                }
            }
        });
    }
    createPickListFields(fl) {
        const { requiredFieldNames, props } = this;
        const adminLayerInfo = getAdminLayerInfo(fl.layerId, props);
        const totalFields = (adminLayerInfo === null || adminLayerInfo === void 0 ? void 0 : adminLayerInfo.fields) || getFL(fl.layerId, props).fields;
        return totalFields
            .filter((field) => requiredFieldNames.indexOf(field.name) === -1)
            .map((field) => {
            return {
                name: field.name,
                alias: field.alias || field.name,
                type: field.type
            };
        });
    }
    removeFieldsPickList() {
        this.flowItemNode.disabled = false;
        if (this.arcgisFieldPickList) {
            document.body.removeChild(this.arcgisFieldPickList);
            this.arcgisFieldPickList = null;
            setTimeout(() => {
                this.buttonNode.setFocus();
            }, 1);
        }
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisLayerViewDefinition.style = arcgisLayerViewDefinitionCss;

var joinFlowStatus;
(function (joinFlowStatus) {
    joinFlowStatus[joinFlowStatus["ERROR"] = 0] = "ERROR";
    joinFlowStatus[joinFlowStatus["LOADING"] = 1] = "LOADING";
    joinFlowStatus[joinFlowStatus["TARGET_SELECTION"] = 2] = "TARGET_SELECTION";
    joinFlowStatus[joinFlowStatus["ADD_SELECTION"] = 3] = "ADD_SELECTION";
    joinFlowStatus[joinFlowStatus["BROWSE_LAYER"] = 4] = "BROWSE_LAYER";
    joinFlowStatus[joinFlowStatus["CONFIG"] = 5] = "CONFIG";
    joinFlowStatus[joinFlowStatus["CREATE"] = 6] = "CREATE";
})(joinFlowStatus || (joinFlowStatus = {}));
function getFieldAlias(layer, fieldName) {
    var _a;
    const { fields, popupTemplate } = layer;
    const fieldInfos = popupTemplate === null || popupTemplate === void 0 ? void 0 : popupTemplate.fieldInfos;
    const field = fields.find((field) => fieldName === field.name);
    return ((field && ((_a = fieldInfos === null || fieldInfos === void 0 ? void 0 : fieldInfos.find((fieldInfo) => fieldInfo.fieldName === field.name)) === null || _a === void 0 ? void 0 : _a.label)) ||
        (field === null || field === void 0 ? void 0 : field.alias) ||
        fieldName);
}
function getFieldType(layer, fieldName) {
    const { fields } = layer;
    const field = fields.find((field) => fieldName === field.name);
    return field === null || field === void 0 ? void 0 : field.type;
}
function getLayerType(layer, props) {
    const { strings } = props;
    return layer.isTable
        ? strings.general.table
        : layer.geometryType === "point" || layer.geometryType === "multipoint"
            ? strings.join.pointLayer
            : layer.geometryType === "polyline"
                ? strings.join.polylineLayer
                : layer.geometryType === "polygon"
                    ? strings.join.polygonLayer
                    : "";
}
function hasOBAC(layer) {
    var _a, _b;
    // Only if one of allowOthersToQuery/allowAnonymousToQuery is explicitly set to false do we block join.
    // If it's true or not there we don't block join
    return (layer.sourceJSON.ownershipBasedAccessControlForFeatures &&
        (((_a = layer.sourceJSON.ownershipBasedAccessControlForFeatures) === null || _a === void 0 ? void 0 : _a.allowAnonymousToQuery) === false ||
            ((_b = layer.sourceJSON.ownershipBasedAccessControlForFeatures) === null || _b === void 0 ? void 0 : _b.allowOthersToQuery) === false));
}

/**
 * get a suggested title for the joined view
 * @param props - LayerViewJoinProps
 */
async function getSuggestedTitleForJoin(props) {
    var _a, _b;
    const { targetItem, targetLayer, strings, modules } = props;
    const { esriRequest } = modules;
    const relatedUrl = `${targetItem.itemUrl}/relatedItems`;
    const relatedContent = {
        relationshipType: "Service2Service",
        direction: "forward"
    };
    const result = await esriRequest(relatedUrl, {
        query: Object.assign(Object.assign({}, relatedContent), { f: "json", token: targetLayer.portalItem.portal.credential.token }),
        method: "post",
        responseType: "json"
    });
    // check with spaces and underscores
    const viewItems = ((_b = (_a = result === null || result === void 0 ? void 0 : result.data) === null || _a === void 0 ? void 0 : _a.relatedItems) === null || _b === void 0 ? void 0 : _b.filter((item) => item.type === "Feature Service" &&
        (item.title.indexOf(targetItem.title) > -1 ||
            item.title.indexOf(targetItem.title.replace(/ /g, "_")) > -1 ||
            item.title.replace(/ /g, "_").indexOf(targetItem.title) > -1))) || [];
    return (strings.join.joinFeaturesTo.replace("${name}", targetItem.title) +
        `${viewItems.length ? ` ${viewItems.length + 1}` : ``} ${strings.createView.view}`);
}
/**
 * Creates join layer view
 * @param props - LayerViewJoinProps
 * @param newItemProps - user input (NewItemProps)
 */
async function createJoinView(props, newItemProps) {
    const { targetItem, targetLayer, targetLayerId, addLayer, addLayerId } = props;
    const isPortal = targetItem.portal.isPortal;
    const timeStamp = Date.now();
    const targetFL = (targetLayer.type === "group"
        ? getLayersAndTables(targetLayer).find((lyr) => lyr.layerId === targetLayerId)
        : targetLayer);
    const addFL = (addLayer.type === "group"
        ? getLayersAndTables(addLayer).find((lyr) => lyr.layerId === addLayerId)
        : addLayer);
    try {
        await getAdminServiceInfo(props);
        if (!isPortal) {
            await createIndexes(props);
        }
        const createServiceResponse = await createJoinService(props, newItemProps);
        const processProps = { newItemProps, createServiceResponse, timeStamp, targetFL, addFL };
        await addToDefinitionStatsTable(props, processProps);
        await addToDefinitionAttributeJoin(props, processProps);
        await joinItemUpdate(props, processProps);
        return createServiceResponse.itemId;
    }
    catch (e) {
        return new Promise((_, reject) => {
            reject(new Error("createJoinView failed"));
        });
    }
}
async function createJoinService(props, newItemProps) {
    const { targetItem, modules } = props;
    const { esriRequest } = modules;
    const { folder } = newItemProps;
    const isOwnerFolder = !folder || !folder.id || folder.id === targetItem.owner;
    const portal = targetItem.portal;
    const createServiceUrl = `${portal.restUrl}/content/users/${targetItem.owner}${!isOwnerFolder ? `/${folder.id}` : ""}/createService`;
    // not sure why we need to send all this in...
    const createParams = {
        serviceDescription: "",
        hasVersionedData: false,
        supportsDisconnectedEditing: false,
        hasStaticData: true,
        maxRecordCount: 2000,
        supportedQueryFormats: "JSON",
        capabilities: "Query",
        description: "",
        copyrightText: "",
        allowGeometryUpdates: false,
        // this causes issues in result layer when used in network tools "units":"esriMeters",
        syncEnabled: false,
        editorTrackingInfo: {
            enableEditorTracking: false,
            enableOwnershipAccessControl: false,
            allowOthersToUpdate: true,
            allowOthersToDelete: true
        },
        xssPreventionInfo: {
            xssPreventionEnabled: true,
            xssPreventionRule: "InputOnly",
            xssInputRule: "rejectInvalid"
        },
        tables: [],
        name: newItemProps.title.replace(/ /g, "_")
    };
    if (portal.isPortal) {
        const dataSourceType = await getDataSourceType(props);
        if (dataSourceType) {
            createParams.options = { dataSourceType };
        }
    }
    let createServiceContent = {
        createParameters: JSON.stringify(createParams),
        outputType: "featureService"
    };
    try {
        const response = await esriRequest(createServiceUrl, {
            query: Object.assign(Object.assign({}, createServiceContent), { f: "json", isView: true, token: portal.credential.token }),
            method: "post",
            responseType: "json"
        });
        return response.data;
    }
    catch (e) {
        return new Promise((_, reject) => {
            reject(new Error("create service failed"));
        });
    }
}
async function addToDefinitionStatsTable(props, processProps) {
    const { createServiceResponse, addFL, timeStamp } = processProps;
    const { addLayerId, joinOperation, attributeRelationships } = props;
    if (joinOperation.type !== "one-to-one" || joinOperation.matchType !== "summarize") {
        return;
    }
    try {
        const adminUrl = createServiceResponse.serviceurl.replace("rest/services", "rest/admin/services");
        const attributeFields = attributeRelationships.map((rel) => {
            var _a;
            return {
                name: rel.addFieldName,
                alias: ((_a = addFL.fields.find((field) => field.name === rel.addFieldName)) === null || _a === void 0 ? void 0 : _a.alias) || rel.addFieldName,
                source: rel.addFieldName
            };
        });
        const summarizeFields = [];
        joinOperation.statisticsFields.forEach((statsField) => {
            statsField.types.forEach((statsType) => {
                const type = statsType.toLowerCase();
                summarizeFields.push({
                    name: `${statsField.fieldName}_${type}`,
                    alias: `${statsField.fieldName}_${type}`,
                    source: statsField.fieldName,
                    statisticType: type === "mean" ? "avg" : type
                });
            });
        });
        const json = {
            layers: [
                {
                    name: `${getSourceServiceName(addFL.url, props)}_StatsTable`,
                    description: "tablestatsjoin",
                    adminLayerInfo: {
                        viewLayerDefinition: {
                            table: {
                                materialized: false,
                                name: `${getSourceServiceName(addFL.url, props)}_${timeStamp}_StatsTable`,
                                sourceServiceName: getSourceServiceName(addFL.url, props),
                                sourceLayerId: addLayerId,
                                sourceLayerFields: [
                                    ...attributeFields,
                                    {
                                        name: "join_count",
                                        alias: "join_count",
                                        source: joinOperation.statisticsFields[0].fieldName,
                                        statisticType: "count"
                                    },
                                    ...summarizeFields
                                ],
                                groupBy: attributeRelationships.map((rel) => rel.addFieldName).join(",")
                            }
                        }
                    }
                }
            ]
        };
        await addToDefinitionRequest(`${adminUrl}/addToDefinition`, json, props);
        return new Promise((resolve) => {
            resolve();
        });
    }
    catch (e) {
        return new Promise((_, reject) => {
            reject(new Error("addToDefinition StatsTable failed"));
        });
    }
}
async function addToDefinitionAttributeJoin(props, processProps) {
    const { createServiceResponse, newItemProps, targetFL, addFL, timeStamp } = processProps;
    try {
        const adminUrl = createServiceResponse.serviceurl.replace("rest/services", "rest/admin/services");
        const json = getAttributeJoinJSON(props, newItemProps, targetFL, addFL, timeStamp);
        await addToDefinitionRequest(`${adminUrl}/addToDefinition`, json, props);
        return new Promise((resolve) => {
            resolve();
        });
    }
    catch (e) {
        return new Promise((_, reject) => {
            reject(new Error("addToDefinition AttributeJoin failed"));
        });
    }
}
function getAttributeJoinJSON(props, newItemProps, targetFL, addFL, timeStamp) {
    const { targetLayerId, addLayerId, joinOperation, attributeRelationships, adminServiceInfo } = props;
    const attributeFields = attributeRelationships.map((rel) => {
        var _a;
        return {
            name: rel.addFieldName,
            alias: ((_a = addFL.fields.find((field) => field.name === rel.addFieldName)) === null || _a === void 0 ? void 0 : _a.alias) || rel.addFieldName,
            source: rel.addFieldName
        };
    });
    let summarizeFields;
    if (joinOperation.type === "one-to-one" && joinOperation.matchType === "summarize") {
        summarizeFields = [];
        joinOperation.statisticsFields.forEach((statsField) => {
            statsField.types.forEach((statsType) => {
                const type = statsType.toLowerCase();
                summarizeFields.push({
                    name: `${statsField.fieldName}_${type}`,
                    alias: `${statsField.fieldName}_${type}`,
                    source: `${statsField.fieldName}_${type}`
                });
            });
        });
    }
    const json = {};
    json.name = newItemProps.title.replace(/ /g, "_");
    json.displayField = "";
    json.description = "AttributeJoin";
    json.adminLayerInfo = {
        viewLayerDefinition: {
            table: {
                name: `${getSourceServiceName(targetFL.url, props)}_${timeStamp}_target`,
                sourceServiceName: getSourceServiceName(targetFL.url, props),
                sourceLayerId: targetLayerId,
                sourceLayerFields: targetFL.fields
                    .filter((field) => field.type !== "oid")
                    .map((field) => {
                    return {
                        name: field.name,
                        alias: field.alias,
                        source: field.name
                    };
                }),
                relatedTables: [
                    joinOperation.type === "one-to-one" && joinOperation.matchType === "summarize"
                        ? {
                            name: `${getSourceServiceName(addFL.url, props)}_StatsTable`,
                            sourceServiceName: newItemProps.title.replace(/ /g, "_"),
                            sourceLayerId: 0,
                            sourceLayerFields: [
                                ...attributeFields.filter((attrField) => !attributeRelationships.some((rel) => attrField.name === rel.addFieldName)),
                                {
                                    name: "join_count",
                                    alias: "join_count",
                                    source: "join_count"
                                },
                                ...summarizeFields
                            ],
                            type: joinOperation.joinType,
                            parentKeyFields: attributeRelationships.map((rel) => rel.targetFieldName),
                            keyFields: attributeRelationships.map((rel) => rel.addFieldName)
                        }
                        : {
                            name: `${getSourceServiceName(addFL.url, props)}_${timeStamp}_join`,
                            sourceServiceName: getSourceServiceName(addFL.url, props),
                            sourceLayerId: addLayerId,
                            sourceLayerFields: addFL.fields
                                .filter((addField) => addField.type !== "oid")
                                .map((addField) => {
                                const isTaken = targetFL.fields.find((targetField) => targetField.name === addField.name);
                                return {
                                    name: isTaken ? `${addField.name}_${timeStamp}` : addField.name,
                                    alias: addField.alias,
                                    source: addField.name
                                };
                            }),
                            type: joinOperation.joinType,
                            parentKeyFields: attributeRelationships.map((rel) => rel.targetFieldName),
                            keyFields: attributeRelationships.map((rel) => rel.addFieldName),
                            topFilter: joinOperation.type === "one-to-one" && joinOperation.matchType === "first"
                                ? {
                                    groupByFields: attributeRelationships
                                        .map((rel) => rel.addFieldName)
                                        .join(","),
                                    orderByFields: `${joinOperation.sortByFieldName} ${joinOperation.sortOrder}`,
                                    topCount: 1
                                }
                                : undefined
                        }
                ],
                materialized: false
            }
        },
        geometryField: targetFL.isTable
            ? null
            : {
                name: `${getSourceServiceName(targetFL.url, props)}_${timeStamp}_target.${adminServiceInfo.layers.find((lyr) => lyr.id === targetLayerId).adminLayerInfo.geometryField.name}`
            }
    };
    /* not sure why we send all via layers...
    let layers, tables;
    if (targetFL.isTable) {
      tables = [json];
    } else {
      layers = [json];
    }
  
    return {
      layers: layers,
      tables: tables
    }; */
    return {
        layers: [json]
    };
}
async function addToDefinitionRequest(addToDefUrl, json, props, retry = false) {
    const { modules } = props;
    const { esriRequest, IdentityManager } = modules;
    // addToDefUrl same server as targetLayer
    const credential = IdentityManager.findCredential(addToDefUrl);
    const addToDefContent = {
        addToDefinition: JSON.stringify(json)
    };
    try {
        await esriRequest(addToDefUrl, {
            query: Object.assign(Object.assign({}, addToDefContent), { f: "json", token: credential.token }),
            method: "post",
            responseType: "json"
        });
        return new Promise((resolve) => {
            resolve();
        });
    }
    catch (e) {
        if (!retry) {
            // in case it's just a fluke
            return addToDefinitionRequest(addToDefUrl, json, props, true);
        }
        return new Promise((_, reject) => {
            reject(new Error("addToDefinition request failed"));
        });
    }
}
function getSourceServiceName(url, props) {
    const { targetItem } = props;
    const { portal } = targetItem;
    const pos = url.indexOf("/services/") + "/services/".length;
    var serviceName = url.substring(pos, url.indexOf("/FeatureServer", pos));
    if (portal.isPortal) {
        serviceName = serviceName.replace("Hosted/", "");
    }
    return serviceName;
}
async function joinItemUpdate(props, processProps) {
    var _a, _b;
    const { createServiceResponse, newItemProps } = processProps;
    const { targetItem, modules } = props;
    const { esriRequest } = modules;
    const portal = targetItem.portal;
    const updateUrl = `${portal.restUrl}/content/users/${targetItem.owner}/items/${createServiceResponse.itemId}/update`;
    // need to send some info again
    const updateContent = {
        title: newItemProps.title,
        tags: ((_a = newItemProps.tags) === null || _a === void 0 ? void 0 : _a.length) ? newItemProps.tags.toString() : undefined,
        snippet: newItemProps.summary,
        categories: (_b = newItemProps.categories) === null || _b === void 0 ? void 0 : _b.join(",")
    };
    if (portal.isPortal) {
        updateContent.typeKeywords = "Multi Services View";
    }
    try {
        return await esriRequest(updateUrl, {
            query: Object.assign(Object.assign({}, updateContent), { f: "json", token: portal.credential.token }),
            method: "post",
            responseType: "json"
        });
    }
    catch (e) {
        return new Promise((_, reject) => {
            reject(new Error("item update request failed"));
        });
    }
}
async function getDataSourceType(props) {
    var _a, _b, _c, _d;
    await getAdminServiceInfo(props);
    const { adminServiceInfo } = props;
    const dataSource = ((_b = (_a = adminServiceInfo === null || adminServiceInfo === void 0 ? void 0 : adminServiceInfo.adminServiceInfo) === null || _a === void 0 ? void 0 : _a.database) === null || _b === void 0 ? void 0 : _b.datasource) || {};
    const dataSourceType = ((_c = dataSource === null || dataSource === void 0 ? void 0 : dataSource.name) === null || _c === void 0 ? void 0 : _c.indexOf("/nosqlDatabases")) > -1
        ? "spatiotemporal"
        : ((_d = dataSource === null || dataSource === void 0 ? void 0 : dataSource.name) === null || _d === void 0 ? void 0 : _d.indexOf("/enterpriseDatabases")) > -1
            ? "relational"
            : null;
    return dataSourceType;
}
async function getAdminServiceInfo(props, noCache) {
    const { targetLayer, adminServiceInfo, modules } = props;
    const { IdentityManager, esriRequest } = modules;
    if (adminServiceInfo) {
        return;
    }
    const serviceUrl = targetLayer.portalItem.url;
    let adminUrl = serviceUrl.replace("/rest/services", "/rest/admin/services");
    if (noCache) {
        adminUrl += `${adminUrl.indexOf("?") > -1 ? "&" : "?"}_ts=${new Date().getTime()}`;
    }
    try {
        await IdentityManager.getCredential(adminUrl);
        const response = await esriRequest(adminUrl, {
            query: { f: "json" }
        });
        props.adminServiceInfo = response.data;
    }
    catch (e) {
        return new Promise((_, reject) => {
            reject(new Error("could not get admin info"));
        });
    }
}
async function createIndexes(props) {
    const { targetLayer, targetLayerId, addLayer, addLayerId, attributeRelationships } = props;
    let fl = targetLayer.type === "group"
        ? getLayersAndTables(targetLayer).find((lyr) => lyr.layerId === targetLayerId)
        : targetLayer;
    let fieldNames = attributeRelationships.map((rel) => rel.targetFieldName);
    await createIndexesForLayer(fl, fieldNames, props);
    fl =
        addLayer.type === "group"
            ? getLayersAndTables(addLayer).find((lyr) => lyr.layerId === addLayerId)
            : addLayer;
    fieldNames = attributeRelationships.map((rel) => rel.addFieldName);
    await createIndexesForLayer(fl, fieldNames, props);
}
async function createIndexesForLayer(fl, fieldNames, props) {
    const json = {
        indexes: []
    };
    fl.sourceJSON.indexes = fl.sourceJSON.indexes || [];
    fieldNames.forEach((fieldName) => {
        if (!fl.sourceJSON.indexes.some((index) => index.fields === fieldName)) {
            // index doesn't exist yet
            json.indexes.push({
                name: `${fieldName}_Index`,
                fields: fieldName,
                isUnique: false,
                isAscending: true,
                description: `${fieldName}_Index`
            });
        }
    });
    if (json.indexes.length) {
        await executeCreateIndexes(json, fl, props);
    }
}
async function executeCreateIndexes(json, fl, props) {
    var _a;
    const { targetItem, modules } = props;
    const { IdentityManager } = modules;
    const adminUrl = fl.url.replace("/rest/services", "/rest/admin/services");
    const url = `${adminUrl}/${fl.layerId}/addToDefinition`;
    const credential = IdentityManager.findCredential(url);
    const isPortal = targetItem.portal.isPortal;
    const content = {
        f: "json",
        addToDefinition: JSON.stringify(json),
        async: !isPortal,
        token: credential.token
    };
    const result = await modules.esriRequest(url, {
        query: content,
        method: "post"
    });
    if (isPortal) {
        fl.sourceJSON.indexes = fl.sourceJSON.indexes || [];
        fl.sourceJSON.indexes = fl.sourceJSON.indexes.concat(json.indexes);
    }
    else {
        try {
            await pollForStatus((_a = result === null || result === void 0 ? void 0 : result.data) === null || _a === void 0 ? void 0 : _a.statusURL, {
                f: "json",
                token: credential.token
            }, props);
            fl.sourceJSON.indexes = fl.sourceJSON.indexes || [];
            fl.sourceJSON.indexes = fl.sourceJSON.indexes.concat(json.indexes);
        }
        catch (e) {
            // not a big problem if it didn't work
        }
    }
}
const pollForStatus = async (url, params, props) => {
    var _a;
    const { modules } = props;
    if (!url) {
        throw new Error("pollForStatus: no status URL");
    }
    const pendingStatuses = ["processing", "partial", "Pending", "InProgress"];
    const successStatuses = ["completed", "Completed"];
    // Keep polling status until either completed or failed
    try {
        // Do failures report as success (status 200)? May need to manually throw error on status check failure
        const statusResponse = await modules.esriRequest(url, { query: params });
        const status = (_a = statusResponse === null || statusResponse === void 0 ? void 0 : statusResponse.data) === null || _a === void 0 ? void 0 : _a.status;
        if (pendingStatuses.includes(status)) {
            await (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__.t)(500);
            return pollForStatus(url, params, props);
        }
        else if (successStatuses.includes(status)) {
            return statusResponse;
        }
        else {
            throw statusResponse;
        }
    }
    catch (e) {
        console.error(e);
        throw e;
    }
};

const arcgisLayerViewJoinCss = ":host{height:100%}.panel{height:100%}.footer{width:100%}.error-content{margin:0.5rem}";

const ArcgisLayerView = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisLayerViewJoinCancel = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewJoinCancel", 7);
        this.arcgisLayerViewJoinTableClick = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewJoinTableClick", 7);
        this.arcgisLayerViewJoinStepChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewJoinStepChange", 7);
        this.arcgisLayerViewJoinCreated = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewJoinCreated", 7);
        this.status = joinFlowStatus.LOADING;
        // --------------------------------------------------------------------------
        //
        //  Private methods
        //
        // --------------------------------------------------------------------------
        this.goCancel = () => {
            this.arcgisLayerViewJoinCancel.emit();
        };
        this.view = undefined;
        this.itemId = undefined;
        this.config = undefined;
        this.showTableOption = false;
    }
    arcgisLayerViewStatusHandler(event) {
        const { detail } = event;
        this.status = detail.status;
        /* if (detail.layerIds?.length) {
          props.layerIds = [...detail.layerIds];
        } */
        if (this.status === joinFlowStatus.TARGET_SELECTION) {
            //props.sourceItemId = props.layerItem.id;
            this.arcgisLayerViewJoinStepChange.emit(1);
        }
        else if (this.status === joinFlowStatus.ADD_SELECTION) {
            this.arcgisLayerViewJoinStepChange.emit(2);
        }
        else if (this.status === joinFlowStatus.CONFIG) {
            this.arcgisLayerViewJoinStepChange.emit(3);
        }
        else if (this.status === joinFlowStatus.CREATE) {
            this.arcgisLayerViewJoinStepChange.emit(4);
        }
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
    }
    async arcgisLayerViewJoinCreateDoneHandler(event) {
        this.arcgisLayerViewJoinCreated.emit(event.detail);
    }
    arcgisLayerViewJoinCreateCancelHandler() {
        this.arcgisLayerViewJoinCancel.emit();
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /*
     * Got to a certain step. If successful it will return true.
     * If it's not possible, because some user input is missing, then it will return false.
     */
    async setStep(step) {
        var _a, _b;
        const { props } = this;
        const { targetLayerId, addLayerId, attributeRelationships, joinOperation } = props;
        const addSelectionPossible = (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(targetLayerId);
        const configPossible = (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(addLayerId);
        const createPossible = (attributeRelationships === null || attributeRelationships === void 0 ? void 0 : attributeRelationships.find((rel) => rel.targetFieldName && rel.addFieldName)) &&
            joinOperation &&
            ((joinOperation.matchType === "first" &&
                joinOperation.sortByFieldName &&
                joinOperation.sortOrder) ||
                (joinOperation.matchType === "summarize" &&
                    ((_a = joinOperation.statisticsFields) === null || _a === void 0 ? void 0 : _a.length) &&
                    ((_b = joinOperation.statisticsFields) === null || _b === void 0 ? void 0 : _b[0].fieldName)));
        // close popovers
        document.body.querySelectorAll(".js-app-flyout").forEach((node) => {
            document.body.removeChild(node);
        });
        switch (step) {
            case 1:
                this.status = joinFlowStatus.TARGET_SELECTION;
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                return new Promise((resolve) => resolve(true));
            case 2:
                if (addSelectionPossible) {
                    this.status = joinFlowStatus.ADD_SELECTION;
                    (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                    return new Promise((resolve) => resolve(true));
                }
                break;
            case 3:
                if (configPossible) {
                    this.status = joinFlowStatus.CONFIG;
                    (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                    return new Promise((resolve) => resolve(true));
                }
                break;
            case 4:
                if (createPossible) {
                    this.status = joinFlowStatus.CREATE;
                    (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                    return new Promise((resolve) => resolve(true));
                }
                break;
        }
        return new Promise((resolve) => resolve(false));
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        var _a, _b, _c, _d;
        const { itemId, view, showTableOption, config } = this;
        const [strings] = await (0,_locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_1__.g)(this.hostElement, "arcgis-layer-view");
        this.strings = strings;
        this.props = { config, view, itemId, showTableOption, strings, modules: {} };
        let { props } = this;
        if (!itemId) {
            console.error("itemId is a required property.");
            return;
        }
        try {
            const [PortalItem, Layer, Extent, projection, Polygon, esriRequest, IdentityManager] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)([
                "esri/portal/PortalItem",
                "esri/layers/Layer",
                "esri/geometry/Extent",
                "esri/geometry/projection",
                "esri/geometry/Polygon",
                "esri/request",
                "esri/identity/IdentityManager"
            ]);
            props.modules = {
                PortalItem,
                projection,
                Polygon,
                Extent,
                Layer,
                esriRequest,
                IdentityManager
            };
            const targetItem = new PortalItem({
                id: itemId
            });
            await targetItem.load();
            props.targetItemOwner = targetItem.portal.user;
            if (targetItem.portal.user.username !== targetItem.owner) {
                // get user info of owner
                await esriRequest(`${targetItem.portal.restUrl}/community/users/${targetItem.owner}`, {
                    query: { f: "json" }
                }).then((userResult) => {
                    if (userResult === null || userResult === void 0 ? void 0 : userResult.data) {
                        props.targetItemOwner = userResult.data;
                    }
                });
            }
            if (targetItem.type !== "Feature Service") {
                console.error("Only Feature Service items are allowed.");
                this.status = joinFlowStatus.ERROR;
                return;
            }
            if (((_a = targetItem.typeKeywords) === null || _a === void 0 ? void 0 : _a.indexOf("Hosted Service")) === -1) {
                console.error("Only hosted Feature Service items are allowed.");
                this.status = joinFlowStatus.ERROR;
                return;
            }
            if (targetItem.portal.user.username !== targetItem.owner &&
                targetItem.itemControl !== "admin") {
                console.error("Only owners and admins are allowed.");
                this.status = joinFlowStatus.ERROR;
                return;
            }
            if (((_b = targetItem.typeKeywords) === null || _b === void 0 ? void 0 : _b.indexOf("View Service")) > -1) {
                console.error("View items are not allowed.");
                this.status = joinFlowStatus.ERROR;
                return;
            }
            if ((targetItem === null || targetItem === void 0 ? void 0 : targetItem.typeKeywords.indexOf("IoTFeatureLayer")) > -1) {
                console.error("Velocity items are not allowed.");
                this.status = joinFlowStatus.ERROR;
                return;
            }
            let gcsExtent = targetItem.extent;
            if (!gcsExtent) {
                gcsExtent = new Extent({
                    xmin: -180,
                    ymin: -90,
                    xmax: 180,
                    ymax: 90,
                    spatialReference: 4326
                });
            }
            if (view.spatialReference.wkid !== 4326) {
                await projection.load();
                const extent = projection.project(gcsExtent, view.spatialReference);
                view.goTo(extent.expand(1.1));
            }
            else {
                view.goTo(gcsExtent.expand(1.1));
            }
            const targetLayer = await Layer.fromPortalItem({
                portalItem: targetItem
            });
            //console.log("**targetLayer**", targetLayer);
            //console.log("**targetItem**", targetItem);
            if (targetLayer.type === "group") {
                // group layer has no layers or tables at this point
                // loadAll() loads layers and tables (at v4.23)
                await targetLayer.loadAll();
                if ((_c = targetLayer.layers) === null || _c === void 0 ? void 0 : _c.length) {
                    // has at least one spatial layer
                    view.map.add(targetLayer);
                }
                // default popups
                (_d = targetLayer.layers) === null || _d === void 0 ? void 0 : _d.forEach((lyr) => {
                    if (!lyr.popupTemplate && lyr.popupEnabled) {
                        lyr.popupTemplate = lyr.createPopupTemplate();
                    }
                });
            }
            else {
                await targetLayer.load();
                if (!targetLayer.isTable) {
                    view.map.add(targetLayer);
                }
                // default popup
                targetLayer.popupTemplate = targetLayer.createPopupTemplate();
            }
            if (targetItem.portal.isPortal) {
                // OBAC not supported in Enterprise
                if (targetLayer.type === "group") {
                    if (!getLayersAndTables(targetLayer).find((fl) => !hasOBAC(fl))) {
                        console.error("Layers with Ownership-Based Access Control are not allowed.");
                    }
                }
                else if (hasOBAC(targetLayer)) {
                    console.error("Layers with Ownership-Based Access Control are not allowed.");
                }
            }
            props.targetItem = targetItem;
            props.targetLayer = targetLayer;
            this.status = joinFlowStatus.TARGET_SELECTION;
        }
        catch (e) {
            console.error(e);
            this.status = joinFlowStatus.ERROR;
        }
    }
    async componentDidLoad() {
        this.arcgisLayerViewJoinStepChange.emit(1);
    }
    disconnectedCallback() {
        const { props } = this;
        const { view, targetLayer, addLayer } = props;
        view.map.remove(targetLayer);
        view.map.remove(addLayer);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        //console.log("render", "status:", this.status);
        const { status } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, status === joinFlowStatus.ERROR ? this.renderError() : null, status === joinFlowStatus.LOADING ? this.renderLoading() : null, [joinFlowStatus.TARGET_SELECTION].includes(status)
            ? this.renderTargetLayerSelection()
            : null, [joinFlowStatus.ADD_SELECTION, joinFlowStatus.BROWSE_LAYER].includes(status)
            ? this.renderAddLayerSelection()
            : null, [joinFlowStatus.CONFIG].includes(status) ? this.renderConfig() : null, status === joinFlowStatus.CREATE ? this.renderCreateJoin() : null));
    }
    renderError() {
        const { props } = this;
        const { targetItem, strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { loading: false, heading: (targetItem === null || targetItem === void 0 ? void 0 : targetItem.title) || strings.msg.error, description: (targetItem === null || targetItem === void 0 ? void 0 : targetItem.title) ? strings.join.targetLayer : undefined, class: CSS$9.panel, ref: (node) => (this.flowItemNode = node) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$9.errorContent }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-notice", { scale: "s", width: "full", open: true, icon: "exclamation-mark-triangle", kind: "danger" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "title" }, strings.msg.error), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "message" }, strings.msg.initFailed))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "footer", class: CSS$9.footer }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "footer", onClick: this.goCancel, appearance: "transparent", width: "full" }, strings.general.cancel))));
    }
    renderLoading() {
        const { props } = this;
        const { targetItem, strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { loading: true, heading: targetItem === null || targetItem === void 0 ? void 0 : targetItem.title, description: strings.join.targetLayer, class: CSS$9.panel, ref: (node) => (this.flowItemNode = node) }));
    }
    renderTargetLayerSelection() {
        const { props, status } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-layer-view-join-target-selection", { key: `target-selection-${status}`, props: props, status: status }));
    }
    renderAddLayerSelection() {
        const { props, status } = this;
        const { addItem } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-layer-view-join-add-selection", { key: `add-${status}-${addItem === null || addItem === void 0 ? void 0 : addItem.id}`, props: props, status: status }));
    }
    renderConfig() {
        const { props, status } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-layer-view-join-config", { key: `create-${status}`, props: props, onArcgisLayerViewJoinConfigTableClick: (event) => this.arcgisLayerViewJoinTableClick.emit(event.detail) }));
    }
    renderCreateJoin() {
        const { props, status } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-layer-view-join-create", { key: `create-${status}`, props: props }));
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisLayerView.style = arcgisLayerViewJoinCss;

const CSS$6 = {
    flow: "flow",
    panel: "panel",
    footer: "footer",
    info: "info",
    listHeader: "list-header",
    text: "text",
    footerButton: "footer-button",
    browse: "browse"
};

const arcgisLayerViewJoinAddSelectionCss = ".flow{height:100%}.panel{height:100%}.footer{width:100%}.info{pointer-events:none;padding:1rem 0.75rem}.list-header{pointer-events:none;padding:1rem 0.75rem 0.3rem}.text{font-size:var(--calcite-font-size--2);line-height:1.375;color:var(--calcite-color-text-3);transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);pointer-events:none;word-wrap:break-word;word-break:break-word}.footer-button{margin:0 10px 5px 10px}.notice{margin:8px}.browse{width:100%}";

const ArcgisLayerViewJoinAddSelection = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisLayerViewJoinStatusChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewJoinStatusChange", 7);
        // --------------------------------------------------------------------------
        //
        //  Private methods
        //
        // --------------------------------------------------------------------------
        this.goBrowse = () => {
            this.arcgisLayerViewJoinStatusChange.emit({ status: joinFlowStatus.BROWSE_LAYER });
        };
        this.goBack = () => {
            this.arcgisLayerViewJoinStatusChange.emit({
                status: joinFlowStatus.TARGET_SELECTION
            });
        };
        this.goNext = () => {
            this.arcgisLayerViewJoinStatusChange.emit({
                status: joinFlowStatus.CONFIG
            });
        };
        this.onSelectionChange = () => {
            const { props } = this;
            this.listNode
                .querySelectorAll("calcite-pick-list-item")
                .forEach((item) => {
                if (item.selected) {
                    props.addLayerId = item.value;
                    (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                }
            });
            props.attributeRelationships = undefined;
            props.joinOperation = undefined;
        };
        this.props = undefined;
        this.status = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentWillLoad() {
        const { props } = this;
        const { addItem, targetItem, targetLayer } = props;
        if (!addItem && targetLayer.type === "group") {
            props.addItem = targetItem;
            props.addLayer = targetLayer;
        }
        if (props.addLayer && props.addLayer.type !== "group" && !(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(props.addLayerId)) {
            props.addLayerId = props.addLayer.layerId;
        }
    }
    componentDidLoad() {
        requestAnimationFrame(() => { var _a; return (_a = this.backButtonNode) === null || _a === void 0 ? void 0 : _a.setFocus(); });
    }
    componentDidRender() {
        const { props } = this;
        const { targetLayer, targetLayerId, addLayer, addLayerId } = props;
        if (targetLayer.type === "group") {
            getLayersAndTables(targetLayer).forEach((lyr) => {
                if (lyr.layerId !== targetLayerId) {
                    lyr.visible = false;
                }
            });
        }
        if (addLayer && addLayer.type === "group" && (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(addLayerId)) {
            getLayersAndTables(addLayer).forEach((lyr) => {
                if (targetLayer.id !== addLayer.id || targetLayerId !== lyr.layerId) {
                    lyr.visible = lyr.layerId === addLayerId;
                }
            });
        }
        else if (addLayer && addLayer.type !== "group") {
            addLayer.visible = true;
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const { props, status } = this;
        const { strings } = props;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "calcite-match-height" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow", { class: CSS$6.flow, dir: (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { description: strings.join.joinLayer, class: {
                panel: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.C.rtl]: rtl
            }, ref: (node) => (this.flowItemNode = node) }, this.renderFooterButtons(), this.renderOBACMsg(), this.renderBrowse(), this.renderSublayers()), status === joinFlowStatus.BROWSE_LAYER && this.renderBrowseLayer())));
    }
    renderFooterButtons() {
        const { props } = this;
        const { addItem, addLayerId, addLayer, strings } = props;
        const isRtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        let addFL;
        if (addLayer && addLayer.type === "group" && (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(addLayerId)) {
            getLayersAndTables(addLayer).forEach((lyr) => {
                if (addLayerId === lyr.layerId) {
                    addFL = lyr;
                }
            });
        }
        else if (addLayer && addLayer.type !== "group") {
            addFL = addLayer;
        }
        const nextDisabled = !addLayer || !(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(addLayerId) || (addItem.portal.isPortal && hasOBAC(addFL));
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "footer", class: CSS$6.footer }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { onClick: this.goBack, appearance: "outline-fill", width: "half", "icon-start": isRtl ? "arrow-right" : "arrow-left", ref: (node) => (this.backButtonNode = node) }, strings.general.back), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { disabled: nextDisabled, onClick: !nextDisabled && this.goNext, appearance: "solid", width: "half", iconEnd: isRtl ? "arrow-left" : "arrow-right", ref: (node) => (this.nextButtonNode = node) }, strings.general.next)));
    }
    renderOBACMsg() {
        const { props } = this;
        const { config, addItem, addLayerId, addLayer, strings } = props;
        const { helpBase, helpMap } = config;
        if (!addLayer) {
            return;
        }
        if (!addItem.portal.isPortal) {
            // message only for Enterprise
            return;
        }
        let addFL;
        if (addLayer.type === "group" && (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(addLayerId)) {
            addFL = getLayersAndTables(addLayer).find((lyr) => addLayerId === lyr.layerId);
        }
        else if (addLayer.type !== "group") {
            addFL = addLayer;
        }
        else {
            return;
        }
        if (!hasOBAC(addFL)) {
            return;
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-notice", { key: `${hasOBAC(addFL)}`, class: "notice", open: true, closable: false, scale: "s", width: "auto", kind: "warning", icon: "exclamation-mark-triangle" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "message" }, strings.join.obacNotSupportedMsg), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-link", { slot: "link", title: strings.join.learnMore, target: "_blank", href: `${helpBase}${helpMap["120004184"]}` }, strings.join.learnMore)));
    }
    renderBrowse() {
        const { props } = this;
        const { strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$6.info }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$6.text }, strings.join.selectAddLayerPanelDescription)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$6.footerButton }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { id: "arcgis-layer-view-join-browse", onClick: this.goBrowse, appearance: "outline-fill", width: "full", ref: (node) => (this.browseButtonNode = node) }, strings.join.browseForLayer))));
    }
    renderBrowseLayer() {
        const { props } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-layer-view-join-browse-layer", { props: props, class: CSS$6.browse, onArcgisLayerViewJoinStatusChange: (event) => {
                if (event.detail.status === joinFlowStatus.ADD_SELECTION) {
                    // can't make it work without using an id
                    // it seems the whole component reloads from scratch after this step here
                    setTimeout(() => {
                        var _a;
                        return (_a = document.getElementById("arcgis-layer-view-join-browse")) === null || _a === void 0 ? void 0 : _a.setFocus();
                    }, 400);
                }
            } }));
    }
    renderSublayers() {
        const { props } = this;
        const { targetLayer, addItem, addLayer, targetLayerId, strings } = props;
        if (!addLayer) {
            return null;
        }
        const listItems = [];
        if (addLayer.type === "group") {
            getLayersAndTables(addLayer).forEach((lyr) => {
                if (targetLayer.id !== addLayer.id || targetLayerId !== lyr.layerId) {
                    listItems.unshift(this.renderSublayer(lyr));
                }
            });
        }
        else {
            listItems.push(this.renderSublayer(addLayer));
        }
        const str = strings.join.selectFromItem;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.F, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$6.listHeader }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$6.text }, str.substring(0, str.indexOf("${")), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("b", null, addItem.title), str.substring(str.indexOf("}") + 1))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-pick-list", { multiple: false, onCalciteListChange: this.onSelectionChange, ref: (node) => (this.listNode = node) }, listItems)));
    }
    renderSublayer(lyr) {
        const { props } = this;
        const { addLayerId } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-pick-list-item", { key: lyr.layerId, label: lyr.title, value: lyr.layerId, description: getLayerType(lyr, props), selected: addLayerId === lyr.layerId }));
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisLayerViewJoinAddSelection.style = arcgisLayerViewJoinAddSelectionCss;

const arcgisLayerViewJoinBrowseLayerCss = ".panel.sc-arcgis-layer-view-join-browse-layer{height:100%}";

const ArcgisLayerViewJoinBrowseLayer = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisLayerViewJoinStatusChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewJoinStatusChange", 7);
        // --------------------------------------------------------------------------
        //
        //  Private methods
        //
        // --------------------------------------------------------------------------
        this.onBack = () => {
            this.arcgisLayerViewJoinStatusChange.emit({ status: joinFlowStatus.ADD_SELECTION });
        };
        this.goUseLayer = async (itemId) => {
            var _a, _b;
            const { props } = this;
            const { addLayer, targetLayer, view, modules } = props;
            this.loading = true;
            if (addLayer && addLayer.id !== targetLayer.id) {
                view.map.remove(addLayer);
            }
            const addItem = new modules.PortalItem({
                id: itemId
            });
            await addItem.load();
            const newAddLayer = await modules.Layer.fromPortalItem({
                portalItem: addItem
            });
            if (newAddLayer.type === "group") {
                // group layer has no layers or tables at this point
                // loadAll() loads layers and tables (at v4.23)
                await newAddLayer.loadAll();
                if ((_a = newAddLayer.layers) === null || _a === void 0 ? void 0 : _a.length) {
                    // has at least one spatial layer
                    view.map.add(newAddLayer);
                }
                // default popups
                (_b = newAddLayer.layers) === null || _b === void 0 ? void 0 : _b.forEach((lyr) => {
                    if (!lyr.popupTemplate && lyr.popupEnabled) {
                        lyr.popupTemplate = lyr.createPopupTemplate();
                    }
                });
            }
            else {
                await newAddLayer.load();
                if (!newAddLayer.isTable) {
                    view.map.add(newAddLayer);
                }
                // default popup
                newAddLayer.popupTemplate = newAddLayer.createPopupTemplate();
            }
            props.addItem = addItem;
            props.addLayer = newAddLayer;
            props.addLayerId = undefined;
            props.joinOperation = undefined;
            this.arcgisLayerViewJoinStatusChange.emit({ status: joinFlowStatus.ADD_SELECTION });
        };
        this.props = undefined;
        this.loading = false;
        this.items = undefined;
        this.pagination = undefined;
        this.error = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentDidLoad() {
        setTimeout(() => requestAnimationFrame(() => { var _a; return (_a = this.flowItemNode) === null || _a === void 0 ? void 0 : _a.setFocus(); }), 200);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const { props, loading, hostElement } = this;
        const { strings } = props;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "calcite-match-height" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { heading: strings.join.browseForLayerTitle, description: strings.join.browseForLayerSubTitle, loading: loading, class: {
                panel: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.C.rtl]: rtl
            }, onCalciteFlowItemBack: this.onBack, ref: (node) => (this.flowItemNode = node) }, this.renderItemBrowser())));
    }
    renderItemBrowser() {
        const { props, pagination } = this;
        const { targetItem, targetLayer, itemId, strings } = props;
        const { portalItem } = targetLayer;
        const { portal } = portalItem;
        const user = portal.user;
        const query = `type:"Feature Service" typekeywords:"Hosted Service" -typekeywords:"View Service" -typekeywords:"Spatiotemporal" owner:"${targetItem.owner}" -id:${itemId}`;
        const baseUrl = `${(0,_portal_660bb43a_js__WEBPACK_IMPORTED_MODULE_6__.g)(portal)}/home/`;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser", { onArcgisItemBrowserUpdate: (e) => {
                const { results, num, start, total } = e.detail;
                this.items = results;
                this.pagination = { start, num, total };
            }, filter: query, portal: portal, user: user, api: 4, config: { baseUrl }, selection: "none" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-top-bar", { slot: "top-bar" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-search", { slot: "search", term: "" })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-sort", { options: ["modified", "title", "relevance"], slot: "sort" }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-content", { slot: "content" }, (this.items || []).map((item) => ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-card", { item: item, portal: portal, baseUrl: baseUrl, key: item.id }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { id: `join-action-${item.id}`, icon: "plus-circle", text: "", scale: "s", slot: "actions-end", onClick: this.goUseLayer.bind(this, item.id) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tooltip", { slot: "tooltip", label: strings.join.select, overlayPositioning: "fixed" }, strings.join.select)))))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-pagination", { total: pagination === null || pagination === void 0 ? void 0 : pagination.total, start: pagination === null || pagination === void 0 ? void 0 : pagination.start, num: pagination === null || pagination === void 0 ? void 0 : pagination.num, slot: "pagination" })));
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisLayerViewJoinBrowseLayer.style = arcgisLayerViewJoinBrowseLayerCss;

const CSS$5 = {
    flow: "flow",
    panel: "panel",
    footer: "footer",
    layerSection: "layer-section",
    targetLayer: "target-layer",
    addLayer: "add-layer",
    layerHeader: "layer-header",
    layerTitle: "layer-title",
    layerIcon: "layer-icon",
    attributeRelationship: "attribute-relationship",
    removeAttributeRelationship: "remove-attribute-relationship",
    sortBySection: "sort-by-section",
    joinMatchTypeSection: "join-match-type-section",
    chip: "chip",
    separator: "separator",
    statsSection: "stats-section",
    statsFieldHeader: "stats-field-header",
    statsButton: "stats-button",
    selectAll: "select-all",
    select: "select"
};

const arcgisLayerViewJoinConfigCss = ".flow{height:100%}.panel{height:100%}.footer{width:100%}.layer-section{border:1px solid var(--calcite-color-border-3);background-color:white;margin:10px}.target-layer{padding:10px;border-bottom:1px solid var(--calcite-color-border-3);display:flex;justify-content:space-between}.add-layer{padding:10px;display:flex;justify-content:space-between}.layer-header{padding-bottom:3px;overflow-wrap:anywhere}.layer-title{font-weight:bold;overflow-wrap:anywhere}.layer-icon{align-self:center;cursor:pointer}.attribute-relationship{border:1px solid var(--calcite-color-border-3);padding:10px 10px 0 10px;margin-bottom:10px}.remove-attribute-relationship{display:flex;justify-content:flex-end}.join-match-type-section{padding:10px 0}.info{display:flex;justify-content:space-between}.info-label{display:flex;align-items:center}.chip{margin-bottom:5px}.sort-by-section{border:1px solid var(--calcite-color-border-3);padding:10px 10px 0 10px;margin:10px 0}.separator{border-bottom:1px solid var(--calcite-color-border-3);margin:10px 0 15px 0}.stats-section{border:1px solid var(--calcite-color-border-3);padding:10px 10px 0 10px;margin-bottom:10px}.stats-field-header{overflow-wrap:anywhere;width:100%}.stats-button{margin-bottom:10px}.select{cursor:pointer}";

const ArcgisLayerViewJoinConfig = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisLayerViewJoinStatusChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewJoinStatusChange", 7);
        this.arcgisLayerViewJoinConfigTableClick = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewJoinConfigTableClick", 7);
        // --------------------------------------------------------------------------
        //
        //  Private methods
        //
        // --------------------------------------------------------------------------
        this.goBack = () => {
            this.arcgisLayerViewJoinStatusChange.emit({
                status: joinFlowStatus.ADD_SELECTION
            });
        };
        this.goNext = () => {
            const { props } = this;
            const { attributeRelationships } = props;
            // clean up
            props.attributeRelationships = attributeRelationships.filter((rel) => rel.targetFieldName && rel.addFieldName);
            this.arcgisLayerViewJoinStatusChange.emit({
                status: joinFlowStatus.CREATE
            });
        };
        this.onTargetFieldSelect = (rel) => {
            const { props, targetFL } = this;
            const { strings } = props;
            const { targetFieldName } = rel;
            const shapeFields = targetFL.fields.filter((field) => field.name.toLowerCase().startsWith("shape__"));
            this.openFieldPickList({
                layer: targetFL,
                fieldName: targetFieldName,
                multiple: false,
                heading: strings.join.targetFields,
                fieldTypes: [
                    "small-integer",
                    "big-integer",
                    "integer",
                    "single",
                    "double",
                    "long",
                    "number",
                    "date",
                    "date-only",
                    "time-only",
                    "timestamp-offset",
                    "string",
                    "guid",
                    "global-id"
                ],
                excludedFields: shapeFields.map((field) => field.name),
                buttonNode: this.targetFieldNode,
                onChange: (selectedFields) => {
                    rel.targetFieldName = selectedFields[0];
                    (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                }
            });
        };
        this.onJoinFieldSelect = (rel) => {
            const { props, addFL } = this;
            const { strings } = props;
            const { addFieldName } = rel;
            const shapeFields = addFL.fields.filter((field) => field.name.toLowerCase().startsWith("shape__"));
            this.openFieldPickList({
                layer: addFL,
                fieldName: addFieldName,
                multiple: false,
                heading: strings.join.joinFields,
                fieldTypes: [
                    "small-integer",
                    "big-integer",
                    "integer",
                    "single",
                    "double",
                    "long",
                    "number",
                    "date",
                    "date-only",
                    "time-only",
                    "timestamp-offset",
                    "string",
                    "guid",
                    "global-id"
                ],
                excludedFields: shapeFields.map((field) => field.name),
                buttonNode: this.addFieldNode,
                onChange: (selectedFields) => {
                    rel.addFieldName = selectedFields[0];
                    (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                }
            });
        };
        this.onSortByFieldSelect = () => {
            const { props, addFL } = this;
            const { joinOperation, strings } = props;
            const { sortByFieldName } = joinOperation;
            const shapeFields = addFL.fields.filter((field) => field.name.toLowerCase().startsWith("shape__"));
            this.openFieldPickList({
                layer: addFL,
                fieldName: sortByFieldName,
                multiple: false,
                heading: strings.join.joinFields,
                fieldTypes: [
                    "small-integer",
                    "big-integer",
                    "integer",
                    "single",
                    "double",
                    "long",
                    "number",
                    "date",
                    "date-only",
                    "time-only",
                    "timestamp-offset",
                    "oid"
                ],
                excludedFields: shapeFields.map((field) => field.name),
                buttonNode: this.sortByFieldNode,
                onChange: (selectedFields) => {
                    joinOperation.sortByFieldName = selectedFields[0];
                    (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                }
            });
        };
        this.onStatsFieldSelect = () => {
            const { props, addFL } = this;
            const { joinOperation, strings } = props;
            const { statisticsFields } = joinOperation;
            const shapeFields = addFL.fields.filter((field) => field.name.toLowerCase().startsWith("shape__"));
            this.openFieldPickList({
                layer: addFL,
                fieldName: "",
                multiple: true,
                heading: strings.join.selectFields,
                fieldTypes: [
                    "small-integer",
                    "big-integer",
                    "integer",
                    "single",
                    "double",
                    "long",
                    "number",
                    "date",
                    "date-only",
                    "time-only",
                    "timestamp-offset"
                ],
                excludedFields: statisticsFields
                    .map((field) => field.fieldName)
                    .concat(shapeFields.map((field) => field.name)),
                buttonNode: this.statsButtonNode,
                onChange: (selectedFields) => {
                    selectedFields.forEach((fieldName) => {
                        const isDate = ["date", "date-only", "time-only", "timestamp-offset"].indexOf(getFieldType(addFL, fieldName)) > -1;
                        statisticsFields.push({ fieldName, types: [isDate ? "MIN" : "SUM"] });
                    });
                    (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                }
            });
        };
        this.props = undefined;
        this.status = undefined;
        this.showTableOption = false;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        var _a;
        const { props } = this;
        const { targetLayer, targetLayerId, addLayer, addLayerId, attributeRelationships, joinOperation } = props;
        this.targetFL = (targetLayer.type === "group"
            ? getLayersAndTables(targetLayer).find((lyr) => lyr.layerId === targetLayerId)
            : targetLayer);
        this.addFL = (addLayer.type === "group"
            ? getLayersAndTables(addLayer).find((lyr) => lyr.layerId === addLayerId)
            : addLayer);
        if (!(attributeRelationships === null || attributeRelationships === void 0 ? void 0 : attributeRelationships.length)) {
            props.attributeRelationships = [];
            // look for relationship fields
            const { targetFL, addFL } = this;
            if (targetFL.relationships && addFL.relationships) {
                const targetRels = targetFL.relationships.filter((rel) => rel.relatedTableId === addLayerId);
                const addRels = addFL.relationships.filter((rel) => rel.relatedTableId === targetLayerId);
                if (targetRels.length && addRels.length) {
                    targetRels.forEach((targetRel) => {
                        const addRel = addRels.find((addRel) => targetRel.id === addRel.id);
                        if (addRel) {
                            props.attributeRelationships.push({
                                targetFieldName: targetRel.keyField,
                                addFieldName: addRel.keyField
                            });
                        }
                    });
                }
            }
            if (!((_a = props.attributeRelationships) === null || _a === void 0 ? void 0 : _a.length)) {
                props.attributeRelationships.push({});
            }
        }
        if (!joinOperation) {
            props.joinOperation = {
                type: "one-to-one",
                matchType: "first",
                sortByFieldName: this.addFL.objectIdField,
                sortOrder: "ASC",
                joinType: "INNER",
                statisticsFields: []
            };
        }
    }
    async componentDidLoad() {
        requestAnimationFrame(() => { var _a; return (_a = this.backButtonNode) === null || _a === void 0 ? void 0 : _a.setFocus(); });
    }
    disconnectedCallback() {
        this.removeInfoPopover();
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const { props } = this;
        const { strings } = props;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "calcite-match-height" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow", { class: CSS$5.flow, dir: (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { heading: strings.join.configureJoin, class: {
                panel: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.C.rtl]: rtl
            }, ref: (node) => (this.flowItemNode = node) }, this.renderFooterButtons(), this.renderContent()))));
    }
    renderFooterButtons() {
        var _a, _b;
        const { props } = this;
        const { attributeRelationships, joinOperation, strings } = props;
        const isRtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        const nextEnabled = !!attributeRelationships.find((rel) => rel.targetFieldName && rel.addFieldName) &&
            (joinOperation.type === "one-to-many" ||
                (joinOperation.matchType === "first" &&
                    joinOperation.sortByFieldName &&
                    joinOperation.sortOrder) ||
                (joinOperation.matchType === "summarize" &&
                    ((_a = joinOperation.statisticsFields) === null || _a === void 0 ? void 0 : _a.length) &&
                    ((_b = joinOperation.statisticsFields) === null || _b === void 0 ? void 0 : _b[0].fieldName)));
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "footer", class: CSS$5.footer }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { onClick: this.goBack, appearance: "outline-fill", width: "half", "icon-start": isRtl ? "arrow-right" : "arrow-left", ref: (node) => (this.backButtonNode = node) }, strings.general.back), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { disabled: !nextEnabled, onClick: nextEnabled && this.goNext, appearance: "solid", width: "half", iconEnd: isRtl ? "arrow-left" : "arrow-right", ref: (node) => (this.nextButtonNode = node) }, strings.general.next)));
    }
    renderContent() {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.F, null, this.renderLayers(), this.renderAttributeRelationships(), this.renderJoinOperation()));
    }
    renderLayers() {
        const { props, targetFL, addFL } = this;
        const { targetItem, targetLayer, targetLayerId, addItem, addLayer, addLayerId, showTableOption, strings } = props;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        const targetTitle = targetLayer.type === "group"
            ? rtl
                ? `${targetFL.title} / ${targetItem.title}`
                : `${targetItem.title} / ${targetFL.title}`
            : targetLayer.title;
        const addTitle = addLayer.type === "group"
            ? rtl
                ? `${addFL.title} / ${addItem.title}`
                : `${addItem.title} / ${addFL.title}`
            : addLayer.title;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$5.layerSection }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$5.targetLayer }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$5.layerHeader }, strings.join.targetLayer), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$5.layerTitle }, targetTitle)), showTableOption && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { scale: "s", icon: "table", class: CSS$5.layerIcon, text: strings.join.showTable, textEnabled: false, onClick: () => {
                var _a, _b;
                if (targetLayer.type === "group") {
                    (_a = targetLayer.tables) === null || _a === void 0 ? void 0 : _a.forEach((lyr) => {
                        if (lyr.layerId === targetLayerId) {
                            this.arcgisLayerViewJoinConfigTableClick.emit(lyr);
                        }
                    });
                    (_b = targetLayer.layers) === null || _b === void 0 ? void 0 : _b.forEach((lyr) => {
                        if (lyr.layerId === targetLayerId) {
                            this.arcgisLayerViewJoinConfigTableClick.emit(lyr);
                        }
                    });
                }
                else {
                    this.arcgisLayerViewJoinConfigTableClick.emit(targetLayer);
                }
            } }))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$5.addLayer }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$5.layerHeader }, strings.join.joinLayer), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$5.layerTitle }, addTitle)), showTableOption && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { scale: "s", icon: "table", class: CSS$5.layerIcon, text: strings.join.showTable, textEnabled: false, onClick: () => {
                var _a, _b;
                if (addLayer.type === "group") {
                    (_a = addLayer.tables) === null || _a === void 0 ? void 0 : _a.forEach((lyr) => {
                        if (lyr.layerId === addLayerId) {
                            this.arcgisLayerViewJoinConfigTableClick.emit(lyr);
                        }
                    });
                    (_b = addLayer.layers) === null || _b === void 0 ? void 0 : _b.forEach((lyr) => {
                        if (lyr.layerId === addLayerId) {
                            this.arcgisLayerViewJoinConfigTableClick.emit(lyr);
                        }
                    });
                }
                else {
                    this.arcgisLayerViewJoinConfigTableClick.emit(addLayer);
                }
            } })))));
    }
    renderAttributeRelationships() {
        const { props } = this;
        const { attributeRelationships, strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { heading: strings.join.attributeJoin, description: strings.join.attributeJoinMsg, open: true, collapsible: true, ref: (node) => (this.attrBlockNode = node) }, attributeRelationships.map((rel, idx) => this.renderAttributeRelationship(rel, idx)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { onClick: () => {
                attributeRelationships.push({});
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
            }, appearance: "outline-fill", width: "full", ref: (node) => (this.fieldButtonNode = node) }, strings.join.fields)));
    }
    renderAttributeRelationship(rel, idx) {
        const { targetFL, addFL, props } = this;
        const { attributeRelationships, strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$5.attributeRelationship }, attributeRelationships.length > 1 && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$5.removeAttributeRelationship }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { scale: "s", icon: "trash", text: strings.general.remove, onClick: () => {
                attributeRelationships.splice(idx, 1);
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
            } }))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, strings.join.targetField, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "outline-fill", kind: "neutral", width: "full", alignment: "icon-end-space-between", iconEnd: "chevron-down", onClick: () => this.onTargetFieldSelect(rel), ref: (node) => (this.targetFieldNode = node) }, rel.targetFieldName
            ? getFieldAlias(targetFL, rel.targetFieldName)
            : strings.join.selectField)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, strings.join.joinField, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "outline-fill", kind: "neutral", width: "full", alignment: "icon-end-space-between", iconEnd: "chevron-down", onClick: () => this.onJoinFieldSelect(rel), ref: (node) => (this.addFieldNode = node) }, rel.addFieldName ? getFieldAlias(addFL, rel.addFieldName) : strings.join.selectField))));
    }
    renderJoinOperation() {
        const { props } = this;
        const { joinOperation, strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { heading: strings.join.joinSettings, description: strings.join.joinSettingsMsg, open: true, collapsible: true, ref: (node) => (this.operationBlockNode = node) }, this.renderJoinOperationType(), joinOperation.type === "one-to-one" && this.renderMatchType(), joinOperation.type === "one-to-one" &&
            joinOperation.matchType === "first" &&
            this.renderJoinOperationSortBy(), joinOperation.type === "one-to-one" &&
            joinOperation.matchType === "summarize" &&
            this.renderJoinOperationStatistics(), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$5.separator }), this.renderJoinType()));
    }
    renderJoinOperationType() {
        const { props } = this;
        const { joinOperation, strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "info" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "info-label" }, strings.join.joinOperation), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { class: "link-info", tabindex: "0", scale: "s", icon: "information", onClick: (event) => this.handleInfoClick(event, "join-operation"), text: strings.join.moreInfo, ref: (element) => {
                this.joinOperationInfoIconNode = element;
                element.addEventListener("keyup", (event) => {
                    event.stopPropagation();
                    if (event.key === " " || (!this.infoPopoverNode && event.key === "Enter")) {
                        this.handleInfoClick(event, "join-operation");
                    }
                });
                element.addEventListener("keydown", (event) => {
                    if (event.key === " ") {
                        // prevent panel from scrolling
                        event.stopPropagation();
                        event.preventDefault();
                    }
                });
            } })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-chip", { value: "one-to-one", appearance: joinOperation.type === "one-to-one" ? "solid" : "outline-fill", kind: "brand", class: `${CSS$5.chip} ${joinOperation.type === "one-to-many" ? CSS$5.select : ""}`, onClick: joinOperation.type === "one-to-many"
                ? () => {
                    joinOperation.type = "one-to-one";
                    (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                }
                : undefined }, strings.join.oneToOne), "\u00A0", (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-chip", { value: "one-to-many", appearance: joinOperation.type === "one-to-many" ? "solid" : "outline-fill", kind: "brand", class: `${CSS$5.chip} ${joinOperation.type === "one-to-one" ? CSS$5.select : ""}`, onClick: joinOperation.type === "one-to-one"
                ? () => {
                    joinOperation.type = "one-to-many";
                    (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                }
                : undefined }, strings.join.oneToMany))));
    }
    renderMatchType() {
        const { props } = this;
        const { joinOperation, strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-radio-button-group", { name: "matchType", layout: "vertical", class: CSS$5.joinMatchTypeSection }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { layout: "inline", class: CSS$5.select, onClick: () => {
                joinOperation.matchType = "first";
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
            } }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-radio-button", { checked: joinOperation.matchType === "first", value: "first", onClick: () => {
                joinOperation.matchType = "first";
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
            } }), strings.join.onlyFirst), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { layout: "inline", class: CSS$5.select, onClick: () => {
                joinOperation.matchType = "summarize";
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
            } }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-radio-button", { checked: joinOperation.matchType === "summarize", value: "summarize", onClick: () => {
                joinOperation.matchType = "summarize";
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
            } }), strings.join.summarizeMatching)));
    }
    renderJoinOperationSortBy() {
        const { addFL, props } = this;
        const { joinOperation, strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$5.sortBySection }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, strings.join.sortBy, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "outline-fill", kind: "neutral", width: "full", alignment: "icon-end-space-between", iconEnd: "chevron-down", onClick: () => this.onSortByFieldSelect(), ref: (node) => (this.sortByFieldNode = node) }, getFieldAlias(addFL, joinOperation.sortByFieldName))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, strings.join.sortOrder, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-select", { width: "full", onCalciteSelectChange: (event) => {
                const selectNode = event.target;
                joinOperation.sortOrder = selectNode.value;
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
            }, label: strings.join.sortOrder }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { label: strings.join.asc, selected: joinOperation.sortOrder === "ASC", value: "ASC" }, strings.join.asc), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { label: strings.join.desc, selected: joinOperation.sortOrder === "DESC", value: "DESC" }, strings.join.desc)))));
    }
    renderJoinOperationStatistics() {
        var _a;
        const { props, addFL } = this;
        const { joinOperation, strings } = props;
        const { statisticsFields } = joinOperation;
        const excludedFields = statisticsFields.map((field) => field.fieldName);
        const fieldTypes = [
            "small-integer",
            "big-integer",
            "integer",
            "single",
            "double",
            "long",
            "number",
            "date",
            "date-only",
            "time-only",
            "timestamp-offset"
        ];
        const layerFields = addFL.fields
            .filter((field) => excludedFields.indexOf(field.name) === -1)
            .filter((field) => fieldTypes.indexOf(field.type) > -1);
        const noMoreFields = !layerFields.length;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.F, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "l" }, strings.join.fieldStats), (_a = joinOperation.statisticsFields) === null || _a === void 0 ? void 0 :
            _a.map((statsField, idx) => this.renderJoinOperationStatistic(statsField, idx)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { onClick: !noMoreFields && this.onStatsFieldSelect, appearance: "outline-fill", "icon-start": "plus", width: "full", disabled: noMoreFields, class: CSS$5.statsButton, ref: (node) => (this.statsButtonNode = node) }, strings.join.addStats)));
    }
    renderJoinOperationStatistic(statsField, idx) {
        const { props, addFL } = this;
        const { joinOperation, strings } = props;
        const isDate = ["date", "date-only", "time-only", "timestamp-offset"].indexOf(getFieldType(addFL, statsField.fieldName)) > -1;
        const hasAllTypes = isDate
            ? statsField.types.indexOf("MIN") > -1 && statsField.types.indexOf("MAX") > -1
            : statsField.types.indexOf("SUM") > -1 &&
                statsField.types.indexOf("MIN") > -1 &&
                statsField.types.indexOf("MAX") > -1 &&
                statsField.types.indexOf("MEAN") > -1 &&
                statsField.types.indexOf("STDDEV") > -1;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$5.statsSection }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { class: CSS$5.statsFieldHeader, layout: "inline-space-between" }, getFieldAlias(addFL, statsField.fieldName), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { scale: "s", icon: "trash", text: strings.general.remove, onClick: () => {
                joinOperation.statisticsFields.splice(idx, 1);
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
            } })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, !isDate && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.F, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-chip", { value: "SUM", appearance: statsField.types.indexOf("SUM") > -1 ? "solid" : "outline-fill", kind: "brand", class: `${CSS$5.chip} ${statsField.types.length > 1 || statsField.types.indexOf("SUM") === -1
                ? CSS$5.select
                : ""}`, onClick: () => {
                statsField.types.indexOf("SUM") === -1
                    ? statsField.types.push("SUM")
                    : statsField.types.length > 1
                        ? statsField.types.splice(statsField.types.indexOf("SUM"), 1)
                        : undefined;
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
            } }, strings.join.sum), "\u00A0")), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-chip", { value: "MIN", appearance: statsField.types.indexOf("MIN") > -1 ? "solid" : "outline-fill", kind: "brand", class: `${CSS$5.chip} ${statsField.types.length > 1 || statsField.types.indexOf("MIN") === -1
                ? CSS$5.select
                : ""}`, onClick: () => {
                statsField.types.indexOf("MIN") === -1
                    ? statsField.types.push("MIN")
                    : statsField.types.length > 1
                        ? statsField.types.splice(statsField.types.indexOf("MIN"), 1)
                        : undefined;
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
            } }, strings.join.min), "\u00A0", (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-chip", { value: "MAX", appearance: statsField.types.indexOf("MAX") > -1 ? "solid" : "outline-fill", kind: "brand", class: `${CSS$5.chip} ${statsField.types.length > 1 || statsField.types.indexOf("MAX") === -1
                ? CSS$5.select
                : ""}`, onClick: () => {
                statsField.types.indexOf("MAX") === -1
                    ? statsField.types.push("MAX")
                    : statsField.types.length > 1
                        ? statsField.types.splice(statsField.types.indexOf("MAX"), 1)
                        : undefined;
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
            } }, strings.join.max), !isDate && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.F, null, "\u00A0", (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-chip", { value: "MEAN", appearance: statsField.types.indexOf("MEAN") > -1 ? "solid" : "outline-fill", kind: "brand", class: `${CSS$5.chip} ${statsField.types.length > 1 || statsField.types.indexOf("MEAN") === -1
                ? CSS$5.select
                : ""}`, onClick: () => {
                statsField.types.indexOf("MEAN") === -1
                    ? statsField.types.push("MEAN")
                    : statsField.types.length > 1
                        ? statsField.types.splice(statsField.types.indexOf("MEAN"), 1)
                        : undefined;
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
            } }, strings.join.mean), "\u00A0", (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-chip", { value: "STDDEV", appearance: statsField.types.indexOf("STDDEV") > -1 ? "solid" : "outline-fill", kind: "brand", class: `${CSS$5.chip} ${statsField.types.length > 1 || statsField.types.indexOf("STDDEV") === -1
                ? CSS$5.select
                : ""}`, onClick: () => {
                statsField.types.indexOf("STDDEV") === -1
                    ? statsField.types.push("STDDEV")
                    : statsField.types.length > 1
                        ? statsField.types.splice(statsField.types.indexOf("STDDEV"), 1)
                        : undefined;
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
            } }, strings.join.stdDev))), !hasAllTypes && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.F, null, "\u00A0", (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "transparent", label: strings.join.selectAll, onClick: () => {
                !isDate && statsField.types.indexOf("SUM") === -1 && statsField.types.push("SUM");
                statsField.types.indexOf("MIN") === -1 && statsField.types.push("MIN");
                statsField.types.indexOf("MAX") === -1 && statsField.types.push("MAX");
                !isDate &&
                    statsField.types.indexOf("MEAN") === -1 &&
                    statsField.types.push("MEAN");
                !isDate &&
                    statsField.types.indexOf("STDDEV") === -1 &&
                    statsField.types.push("STDDEV");
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
            } }, strings.join.selectAll))))));
    }
    renderJoinType() {
        const { props } = this;
        const { joinOperation, strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "info" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "info-label" }, strings.join.joinType), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { class: "link-info", tabindex: "0", scale: "s", icon: "information", onClick: (event) => this.handleInfoClick(event, "join-type"), text: strings.join.moreInfo, ref: (element) => {
                this.joinTypeInfoIconNode = element;
                element.addEventListener("keyup", (event) => {
                    event.stopPropagation();
                    if (event.key === " " || (!this.infoPopoverNode && event.key === "Enter")) {
                        this.handleInfoClick(event, "join-type");
                    }
                });
                element.addEventListener("keydown", (event) => {
                    if (event.key === " ") {
                        // prevent panel from scrolling
                        event.stopPropagation();
                        event.preventDefault();
                    }
                });
            } })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-chip", { value: "inner-join", appearance: joinOperation.joinType === "INNER" ? "solid" : "outline-fill", kind: "brand", class: `${CSS$5.chip} ${joinOperation.joinType === "LEFT" ? CSS$5.select : ""}`, onClick: joinOperation.joinType === "LEFT"
                ? () => {
                    joinOperation.joinType = "INNER";
                    (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                }
                : undefined }, strings.join.innerJoin), "\u00A0", (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-chip", { value: "left-join", appearance: joinOperation.joinType === "LEFT" ? "solid" : "outline-fill", kind: "brand", class: `${CSS$5.chip} ${joinOperation.joinType === "INNER" ? CSS$5.select : ""}`, onClick: joinOperation.joinType === "INNER"
                ? () => {
                    joinOperation.joinType = "LEFT";
                    (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                }
                : undefined }, strings.join.leftJoin))));
    }
    openFieldPickList({ layer, fieldName, multiple, heading, fieldTypes, excludedFields, buttonNode, onChange }) {
        const { props, fieldPickListSortBy, flowItemNode } = this;
        const { view } = props;
        const nodeWidth = flowItemNode.getBoundingClientRect().width || 215;
        this.arcgisFieldPickList = document.createElement("arcgis-field-pick-list");
        this.arcgisFieldPickList.popoverProps = {
            placement: "auto",
            offsetDistance: -1 * (nodeWidth - 2),
            offsetSkidding: 0,
            pointerDisabled: true,
            popoverWidth: nodeWidth + 7,
            refElement: flowItemNode
        };
        this.arcgisFieldPickList.fields = this.createPickListFields(layer, fieldTypes, excludedFields);
        this.arcgisFieldPickList.layer = layer;
        this.arcgisFieldPickList.mapView = view;
        this.arcgisFieldPickList.showFieldInfo = true;
        this.arcgisFieldPickList.showFieldName = false;
        this.arcgisFieldPickList.selectedFields = fieldName ? [fieldName] : [];
        this.arcgisFieldPickList.sortBy = fieldPickListSortBy;
        this.arcgisFieldPickList.multiple = multiple;
        this.arcgisFieldPickList.heading = heading;
        this.arcgisFieldPickList.addEventListener("arcgisFieldPickListDismissed", (event) => {
            var _a;
            event.stopPropagation();
            const selectedFields = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.selectedFields;
            flowItemNode.disabled = false;
            if (this.arcgisFieldPickList) {
                document.body.removeChild(this.arcgisFieldPickList);
                this.arcgisFieldPickList = null;
                setTimeout(() => {
                    buttonNode.setFocus();
                }, 1);
            }
            if (selectedFields === null || selectedFields === void 0 ? void 0 : selectedFields.length) {
                onChange(selectedFields);
            } // else user hit cancel or close
        });
        this.arcgisFieldPickList.addEventListener("arcgisFieldPickListSortByChange", (event) => (this.fieldPickListSortBy = event.detail));
        document.body.appendChild(this.arcgisFieldPickList);
        flowItemNode.disabled = true;
    }
    createPickListFields(layer, fieldTypes, excludedFields) {
        const { fields, popupTemplate } = layer;
        const layerFields = fields
            .filter((field) => excludedFields.indexOf(field.name) === -1)
            .filter((field) => fieldTypes.indexOf(field.type) > -1);
        return layerFields.map((field) => {
            var _a, _b;
            return {
                name: field.name,
                alias: ((_b = (_a = popupTemplate === null || popupTemplate === void 0 ? void 0 : popupTemplate.fieldInfos) === null || _a === void 0 ? void 0 : _a.find((fieldInfo) => fieldInfo.fieldName === field.name)) === null || _b === void 0 ? void 0 : _b.label) || field.alias,
                type: field.type
            };
        });
    }
    handleInfoClick(event, type) {
        // don't execute the event on the entire tile
        event.stopPropagation();
        this.removeInfoPopover();
        const { props } = this;
        const refElement = type === "join-operation" ? this.joinOperationInfoIconNode : this.joinTypeInfoIconNode;
        this.infoPopoverNode = document.createElement("arcgis-layer-view-join-info-popover");
        this.infoPopoverNode.props = props;
        this.infoPopoverNode.type = type;
        this.infoPopoverNode.referenceElement = refElement;
        this.infoPopoverNode.addEventListener("arcgisLayerViewJoinInfoPopoverClose", (event) => {
            event.stopPropagation();
            this.removeInfoPopover();
            setTimeout(() => refElement.setFocus(), 200);
        });
        this.infoPopoverNode.addEventListener("arcgisLayerViewJoinInfoPopoverDisconnected", (event) => {
            event.stopPropagation();
            this.removeInfoPopover();
        });
        document.body.appendChild(this.infoPopoverNode);
        this.infoPopoverNode.setOpen(true);
        // need to wait until it's all visible
        setTimeout(() => this.infoPopoverNode.setFocus(), 100);
    }
    removeInfoPopover() {
        var _a;
        if (this.infoPopoverNode) {
            (_a = this.infoPopoverNode.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this.infoPopoverNode);
            this.infoPopoverNode = null;
        }
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisLayerViewJoinConfig.style = arcgisLayerViewJoinConfigCss;

const CSS$4 = {
    panel: "panel",
    info: "info",
    footer: "footer",
    layerSection: "layer-section",
    targetLayer: "target-layer",
    addLayer: "add-layer",
    layerHeader: "layer-header",
    layerTitle: "layer-title"
};

const arcgisLayerViewJoinCreateCss = ".panel.sc-arcgis-layer-view-join-create{height:100%}.info.sc-arcgis-layer-view-join-create{display:grid;grid-template-columns:repeat(1, minmax(0px, 1fr));gap:0.5rem;padding:0 0.75rem}.footer.sc-arcgis-layer-view-join-create{width:100%}.layer-section.sc-arcgis-layer-view-join-create{border:1px solid var(--calcite-color-border-3);background-color:white;margin:10px}.target-layer.sc-arcgis-layer-view-join-create{padding:10px;border-bottom:1px solid var(--calcite-color-border-3)}.add-layer.sc-arcgis-layer-view-join-create{padding:10px}.layer-header.sc-arcgis-layer-view-join-create{padding-bottom:3px}.layer-title.sc-arcgis-layer-view-join-create{font-weight:bold}.notice.sc-arcgis-layer-view-join-create{margin:8px}";

const ArcgisLayerViewJoinCreate = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisLayerViewJoinStatusChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewJoinStatusChange", 7);
        this.arcgisLayerViewJoinCreateDone = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewJoinCreateDone", 7);
        this.arcgisLayerViewJoinCreateCancel = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewJoinCreateCancel", 7);
        // --------------------------------------------------------------------------
        //
        //  Private methods
        //
        // --------------------------------------------------------------------------
        this.goBack = () => {
            // save last settings
            const { props } = this;
            props.savedItemProps = {
                title: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.title,
                tags: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.tags,
                summary: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.snippet,
                categories: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.categories,
                folder: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.folder
            };
            this.arcgisLayerViewJoinStatusChange.emit({
                status: joinFlowStatus.CONFIG
            });
        };
        this.goCreate = async () => {
            const { props, flowItemNode, hostElement } = this;
            const { strings } = props;
            // in case the create call fails
            props.savedItemProps = {
                title: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.title,
                tags: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.tags,
                summary: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.snippet,
                categories: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.categories,
                folder: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.folder
            };
            const newItemProps = {
                title: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.title,
                tags: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.tags,
                summary: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.snippet,
                categories: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.categories,
                folder: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.folder
            };
            this.loading = true;
            try {
                this.viewItemId = await createJoinView(props, newItemProps);
                this.loading = false;
                this.msgNode = document.createElement("arcgis-layer-view-msg");
                this.msgNode.props = props;
                this.msgNode.flowItemElement = flowItemNode;
                this.msgNode.message = strings.msg.created;
                hostElement.appendChild(this.msgNode);
                clearTimeout(this.timeoutHndl);
                this.timeoutHndl = setTimeout(() => {
                    this.timeoutHndl = undefined;
                    if (this.msgNode) {
                        hostElement.removeChild(this.msgNode);
                        this.msgNode = undefined;
                        this.arcgisLayerViewJoinCreateDone.emit(this.viewItemId);
                    }
                }, 7000);
            }
            catch (e) {
                const { props, flowItemNode } = this;
                const { strings } = props;
                this.loading = false;
                console.error("could not create join view", e);
                this.msgNode = document.createElement("arcgis-layer-view-msg");
                this.msgNode.props = props;
                this.msgNode.flowItemElement = flowItemNode;
                this.msgNode.isError = true;
                this.msgNode.message = strings.msg.createFailed;
                hostElement.appendChild(this.msgNode);
                clearTimeout(this.timeoutHndl);
                this.timeoutHndl = setTimeout(() => {
                    this.timeoutHndl = undefined;
                    if (this.msgNode) {
                        hostElement.removeChild(this.msgNode);
                        this.msgNode = undefined;
                    }
                }, 7000);
            }
        };
        this.goCancel = () => {
            this.arcgisLayerViewJoinCreateCancel.emit();
        };
        this.props = undefined;
        this.loading = false;
        this.title = undefined;
    }
    arcgisLayerViewMsgClosedHandler() {
        if (this.msgNode) {
            this.hostElement.removeChild(this.msgNode);
            this.msgNode = undefined;
        }
        clearTimeout(this.timeoutHndl);
        this.timeoutHndl = undefined;
        if (this.viewItemId) {
            this.arcgisLayerViewJoinCreateDone.emit(this.viewItemId);
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        const { props } = this;
        const { targetLayer, targetLayerId, addLayer, addLayerId } = props;
        this.targetFL = (targetLayer.type === "group"
            ? getLayersAndTables(targetLayer).find((lyr) => lyr.layerId === targetLayerId)
            : targetLayer);
        this.addFL = (addLayer.type === "group"
            ? getLayersAndTables(addLayer).find((lyr) => lyr.layerId === addLayerId)
            : addLayer);
        this.title = await getSuggestedTitleForJoin(props);
    }
    async componentDidLoad() {
        requestAnimationFrame(() => { var _a; return (_a = this.backButtonNode) === null || _a === void 0 ? void 0 : _a.setFocus(); });
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const { props, loading } = this;
        const { strings } = props;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "calcite-match-height" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { heading: strings.join.create, loading: loading, class: {
                panel: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.C.rtl]: rtl
            }, ref: (node) => (this.flowItemNode = node) }, this.renderFooterButtons(), this.renderNotice(), this.renderLayers(), this.renderInfo())));
    }
    renderFooterButtons() {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "footer", class: CSS$4.footer }, this.renderBack(), this.renderCreate(), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("br", null), this.renderCancel()));
    }
    renderBack() {
        const { props } = this;
        const { strings } = props;
        const isRtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { onClick: this.goBack, appearance: "outline-fill", width: "half", "icon-start": isRtl ? "arrow-right" : "arrow-left", ref: (node) => (this.backButtonNode = node) }, strings.general.back));
    }
    renderCreate() {
        const { props, title, titleError, summaryError } = this;
        const { strings } = props;
        const enabled = title && !titleError && !summaryError;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { disabled: !enabled, onClick: enabled && this.goCreate, appearance: "solid", width: "half", "icon-start": "plus-square", ref: (node) => (this.createButtonNode = node) }, strings.createView.create));
    }
    renderCancel() {
        const { props } = this;
        const { strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { onClick: this.goCancel, appearance: "transparent", width: "full" }, strings.general.cancel));
    }
    renderNotice() {
        {
            return;
        }
    }
    renderLayers() {
        const { props, targetFL, addFL } = this;
        const { targetItem, targetLayer, addItem, addLayer, strings } = props;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        const targetTitle = targetLayer.type === "group"
            ? rtl
                ? `${targetFL.title} / ${targetItem.title}`
                : `${targetItem.title} / ${targetFL.title}`
            : targetLayer.title;
        const addTitle = addLayer.type === "group"
            ? rtl
                ? `${addFL.title} / ${addItem.title}`
                : `${addItem.title} / ${addFL.title}`
            : addLayer.title;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$4.layerSection }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$4.targetLayer }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$4.layerHeader }, strings.join.targetLayer), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$4.layerTitle }, targetTitle)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$4.addLayer }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$4.layerHeader }, strings.join.joinLayer), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$4.layerTitle }, addTitle))));
    }
    renderInfo() {
        const { props, title } = this;
        const { targetItem, targetItemOwner, savedItemProps } = props;
        const { portal } = targetItem;
        const user = portal.user;
        const config = { portal, user, api: 4 };
        if (savedItemProps) {
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.title = savedItemProps.title;
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.folder = savedItemProps.folder;
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.snippet = savedItemProps.summary || "";
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.categories = savedItemProps.categories;
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.tags = savedItemProps.tags;
        }
        else {
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.title = title;
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.folder =
                targetItem.ownerFolder &&
                    {
                        id: targetItem.ownerFolder,
                        username: targetItem.owner
                    };
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.snippet = targetItem.snippet || "";
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.categories = targetItem.categories;
            _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_7__.i.tags = targetItem.tags;
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$4.info }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-properties", { portal: portal, user: user, api: 4, config: config, type: "Feature Service", scale: "s" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-title-input", { enablePublishing: true, onArcgisTitleInputChange: async (event) => {
                const node = event.target;
                const titleError = await node.validateTitle();
                if ((!this.titleError && titleError) || (this.titleError && !titleError)) {
                    (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                }
                this.titleError = titleError;
            } }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-folder-picker", { user: targetItemOwner }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-categories-picker", null), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-tags-picker", null), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-summary-input", { onArcgisSummaryInputChange: async (event) => {
                const node = event.target;
                const summaryError = (await node.getErrorMessage());
                if ((!this.summaryError && summaryError) || (this.summaryError && !summaryError)) {
                    (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                }
                this.summaryError = summaryError;
            } }))));
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisLayerViewJoinCreate.style = arcgisLayerViewJoinCreateCss;

const CSS$3 = {
    flow: "flow",
    panel: "panel",
    footer: "footer",
    info: "info",
    text: "text"
};

const arcgisLayerViewJoinTargetSelectionCss = ".flow{height:100%}.panel{height:100%}.footer{width:100%}.info{pointer-events:none;padding:1rem 0.75rem}.text{font-size:var(--calcite-font-size--2);line-height:1.375;color:var(--calcite-color-text-3);transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);pointer-events:none}.notice{margin:8px}";

const ArcgisLayerViewJoinTargetSelection = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisLayerViewJoinStatusChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewJoinStatusChange", 7);
        // --------------------------------------------------------------------------
        //
        //  Private methods
        //
        // --------------------------------------------------------------------------
        this.goNext = () => {
            this.arcgisLayerViewJoinStatusChange.emit({
                status: joinFlowStatus.ADD_SELECTION
            });
        };
        this.onSelectionChange = () => {
            const { props } = this;
            const { targetLayer } = props;
            this.listNode
                .querySelectorAll("calcite-pick-list-item")
                .forEach((item) => {
                if (item.selected) {
                    props.targetLayerId = item.value;
                    (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                }
                if (targetLayer.type === "group") {
                    getLayersAndTables(targetLayer).find((subLayer) => subLayer.layerId === item.value).visible = item.selected;
                }
                else {
                    targetLayer.visible = item.selected;
                }
            });
            props.attributeRelationships = undefined;
            props.joinOperation = undefined;
        };
        this.props = undefined;
        this.status = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        const { props } = this;
        const { targetLayer } = props;
        if (targetLayer.type !== "group") {
            props.targetLayerId = targetLayer.layerId;
        }
    }
    async componentDidLoad() {
        requestAnimationFrame(() => { var _a; return (_a = this.listNode) === null || _a === void 0 ? void 0 : _a.setFocus(); });
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        //console.log("render target-selection", this.props, "status:", this.status);
        const { props } = this;
        const { targetItem, strings } = props;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "calcite-match-height" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow", { class: CSS$3.flow, dir: (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { heading: targetItem === null || targetItem === void 0 ? void 0 : targetItem.title, description: strings.join.targetLayer, class: {
                panel: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.C.rtl]: rtl
            }, ref: (node) => (this.flowItemNode = node) }, this.renderFooterButtons(), this.renderOBACMsg(), this.renderInfo(), this.renderSublayers()))));
    }
    renderFooterButtons() {
        const { props } = this;
        const { targetItem, targetLayer, targetLayerId, strings } = props;
        const isRtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        let targetFL;
        if (targetLayer.type === "group" && (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(targetLayerId)) {
            targetFL = getLayersAndTables(targetLayer).find((lyr) => targetLayerId === lyr.layerId);
        }
        else if (targetLayer.type !== "group") {
            targetFL = targetLayer;
        }
        const nextDisabled = !(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(targetLayerId) || (targetItem.portal.isPortal && hasOBAC(targetFL));
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "footer", class: CSS$3.footer }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { disabled: nextDisabled, onClick: !nextDisabled && this.goNext, appearance: "solid", width: "full", iconEnd: isRtl ? "arrow-left" : "arrow-right", ref: (node) => (this.nextButtonNode = node) }, strings.general.next)));
    }
    renderOBACMsg() {
        const { props } = this;
        const { config, targetItem, targetLayerId, targetLayer, strings } = props;
        const { helpBase, helpMap } = config;
        if (!targetItem.portal.isPortal) {
            // message only for Enterprise
            return;
        }
        let targetFL;
        if (targetLayer.type === "group" && (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(targetLayerId)) {
            targetFL = getLayersAndTables(targetLayer).find((lyr) => targetLayerId === lyr.layerId);
        }
        else if (targetLayer.type !== "group") {
            targetFL = targetLayer;
        }
        else {
            // no group sublayer selected yet
            return;
        }
        if (!hasOBAC(targetFL)) {
            return;
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-notice", { key: `${hasOBAC(targetFL)}`, class: "notice", open: true, closable: false, scale: "s", width: "auto", kind: "warning", icon: "exclamation-mark-triangle" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "message" }, strings.join.obacNotSupportedMsg), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-link", { slot: "link", title: strings.join.learnMore, target: "_blank", href: `${helpBase}${helpMap["120004184"]}` }, strings.join.learnMore)));
    }
    renderInfo() {
        const { props } = this;
        const { strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$3.info }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$3.text }, strings.join.selectTargetLayerPanelDescription)));
    }
    renderSublayers() {
        var _a, _b;
        const { props } = this;
        const { targetLayer } = props;
        const listItems = [];
        if (targetLayer.type === "group") {
            (_a = targetLayer.tables) === null || _a === void 0 ? void 0 : _a.forEach((lyr) => {
                listItems.unshift(this.renderSublayer(lyr));
            });
            (_b = targetLayer.layers) === null || _b === void 0 ? void 0 : _b.forEach((lyr) => {
                listItems.unshift(this.renderSublayer(lyr));
            });
        }
        else {
            listItems.push(this.renderSublayer(targetLayer));
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-pick-list", { multiple: false, onCalciteListChange: this.onSelectionChange, ref: (node) => (this.listNode = node) }, listItems));
    }
    renderSublayer(lyr) {
        const { props } = this;
        const { targetLayerId } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-pick-list-item", { key: lyr.layerId, label: lyr.title, value: lyr.layerId, description: getLayerType(lyr, props), selected: targetLayerId === lyr.layerId }));
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisLayerViewJoinTargetSelection.style = arcgisLayerViewJoinTargetSelectionCss;

const ArcgisLayerViewCreate = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisLayerViewMsgClosed = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewMsgClosed", 7);
        this.props = undefined;
        this.flowItemElement = undefined;
        this.isError = false;
        this.isWarning = false;
        this.message = undefined;
        this.closeWithOK = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentDidLoad() {
        if (this.flowItemElement) {
            this.flowItemElement.disabled = true;
        }
        requestAnimationFrame(() => { var _a; return (_a = this.okNode) === null || _a === void 0 ? void 0 : _a.setFocus(); });
    }
    disconnectedCallback() {
        if (this.flowItemElement) {
            this.flowItemElement.disabled = false;
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const { props, hostElement, flowItemElement, isError, isWarning, message, closeWithOK } = this;
        const { strings } = props;
        const dir = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(hostElement);
        const panelWidth = Math.round(flowItemElement.getBoundingClientRect().width);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "js-app-flyout" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-popover", { dir: dir, placement: "trailing-start", open: true, pointerDisabled: true, referenceElement: flowItemElement, offsetDistance: -1 * (panelWidth - 10), offsetSkidding: 200, label: message, style: {
                zIndex: "100",
                width: `${panelWidth - 20}px`
            } }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-notice", { scale: "s", width: "full", open: true, closable: !closeWithOK, icon: isError || isWarning ? "exclamation-mark-triangle" : "check-circle", kind: isError ? "danger" : isWarning ? "warning" : "success", onCalciteNoticeClose: () => {
                this.arcgisLayerViewMsgClosed.emit();
            } }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "title" }, isError ? strings.msg.error : isWarning ? strings.msg.warning : strings.msg.success), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "message", ref: (node) => {
                // must use div and ref, otherwise <b> inside the string doesn't work
                node.innerHTML = message;
            } }), closeWithOK && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "transparent", slot: "actions-end", onClick: () => {
                this.arcgisLayerViewMsgClosed.emit();
            }, ref: (node) => (this.okNode = node) }, strings.msg.ok))))));
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};

const CSS$2 = {
    flow: "flow",
    panel: "panel",
    info: "info",
    infoDescription: "info-description",
    hasDefinitionIcon: "has-definition-icon",
    definitionIcon: "definition-icon",
    footer: "footer",
    footerTop: "footer-top"
};

const arcgisLayerViewOverviewCss = ".flow.sc-arcgis-layer-view-overview{height:100%}.panel.sc-arcgis-layer-view-overview{height:100%}.info.sc-arcgis-layer-view-overview{display:grid;grid-template-columns:repeat(1, minmax(0px, 1fr));gap:0.5rem;pointer-events:none;padding:1rem 0.75rem}.info-description.sc-arcgis-layer-view-overview{font-size:var(--calcite-font-size--2);line-height:1.375;color:var(--calcite-color-text-3);transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);pointer-events:none}.has-definition-icon.sc-arcgis-layer-view-overview{color:var(--calcite-color-border-1);cursor:pointer}.definition-icon.sc-arcgis-layer-view-overview{color:var(--calcite-color-text-2);cursor:pointer}.footer.sc-arcgis-layer-view-overview{width:100%}.footer-top.sc-arcgis-layer-view-overview{display:flex}";

const ArcgisLayerViewOverview = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisLayerViewStatusChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewStatusChange", 7);
        this.arcgisLayerViewOverviewUpdated = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewOverviewUpdated", 7);
        this.arcgisLayerViewOverviewCancel = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewOverviewCancel", 7);
        this.listItemNodes = [];
        // --------------------------------------------------------------------------
        //
        //  Private methods
        //
        // --------------------------------------------------------------------------
        this.goBack = () => {
            this.arcgisLayerViewStatusChange.emit({ status: flowStatus.SELECTION });
        };
        this.goNext = () => {
            this.arcgisLayerViewStatusChange.emit({ status: flowStatus.CREATE });
        };
        this.goUpdate = async () => {
            const { props, hostElement } = this;
            const { strings } = props;
            const showSuccessMsg = () => {
                this.msgNode = document.createElement("arcgis-layer-view-msg");
                this.msgNode.props = props;
                this.msgNode.flowItemElement = this.flowItemNode;
                this.msgNode.message = strings.msg.updated;
                hostElement.appendChild(this.msgNode);
                clearTimeout(this.timeoutHndl);
                this.timeoutHndl = setTimeout(() => {
                    this.timeoutHndl = undefined;
                    if (this.msgNode) {
                        hostElement.removeChild(this.msgNode);
                        this.msgNode = undefined;
                        this.arcgisLayerViewOverviewUpdated.emit();
                    }
                }, 7000);
            };
            const hasAnyChanges = hasChanges(props);
            if (!hasAnyChanges) {
                showSuccessMsg();
                return;
            }
            this.loading = true;
            try {
                // update view
                await updateView(this.props);
                // max-age cache is 30 sec; might not get the latest
                await this.getLatestAdminServiceInfo();
                if (hasChanges(this.props)) {
                    // wait up to 30 sec with increasing interval
                    // and make other adminServiceInfo requests
                    // until we really have the latest
                    let waitTime = 1000;
                    const tryAgain = async () => {
                        var _a, _b;
                        await this.getLatestAdminServiceInfo();
                        if (!hasChanges(this.props) || waitTime > 30000) {
                            // need to get latest saved AOI because it rounds coordinates when saving
                            (_b = (_a = this.props.adminServiceInfo) === null || _a === void 0 ? void 0 : _a.layers) === null || _b === void 0 ? void 0 : _b.forEach(async (layerInfo) => {
                                var _a, _b, _c, _d;
                                const aoiValue = (_d = (_c = (_b = (_a = layerInfo.adminLayerInfo) === null || _a === void 0 ? void 0 : _a.viewLayerDefinition) === null || _b === void 0 ? void 0 : _b.table) === null || _c === void 0 ? void 0 : _c.filter) === null || _d === void 0 ? void 0 : _d.value;
                                if (aoiValue) {
                                    addViewLayerProps(layerInfo.id, {
                                        aoi: JSON.parse(JSON.stringify(aoiValue.geometry))
                                    }, this.props);
                                }
                            });
                        }
                        else {
                            waitTime *= 2;
                            setTimeout(tryAgain, waitTime);
                        }
                    };
                    setTimeout(tryAgain, waitTime);
                }
                this.loading = false;
                showSuccessMsg();
            }
            catch (e) {
                const { strings } = props;
                this.loading = false;
                console.error("could not create view", e);
                this.msgNode = document.createElement("arcgis-layer-view-msg");
                this.msgNode.props = props;
                this.msgNode.flowItemElement = this.flowItemNode;
                this.msgNode.isError = true;
                this.msgNode.message = strings.msg.updateFailed;
                hostElement.appendChild(this.msgNode);
                clearTimeout(this.timeoutHndl);
                this.timeoutHndl = setTimeout(() => {
                    this.timeoutHndl = undefined;
                    if (this.msgNode) {
                        hostElement.removeChild(this.msgNode);
                        this.msgNode = undefined;
                    }
                }, 7000);
            }
        };
        this.goCancel = () => {
            this.arcgisLayerViewOverviewCancel.emit();
        };
        this.props = undefined;
        this.status = undefined;
        this.reRender = false;
        this.loading = false;
    }
    arcgisLayerViewOverviewRefreshHandler() {
        this.status = flowStatus.OVERVIEW;
        this.reRender = !this.reRender;
    }
    arcgisLayerViewMsgClosedHandler() {
        const { props } = this;
        const { strings } = props;
        if (this.msgNode) {
            if (this.msgNode.message === strings.msg.updated) {
                this.arcgisLayerViewOverviewUpdated.emit();
            }
            this.hostElement.removeChild(this.msgNode);
            this.msgNode = undefined;
        }
        clearTimeout(this.timeoutHndl);
        this.timeoutHndl = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() { }
    async componentDidLoad() {
        requestAnimationFrame(() => { var _a; return (_a = this.backButtonNode) === null || _a === void 0 ? void 0 : _a.setFocus(); });
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        //console.log("render view-overview", propsToString(this.props));
        const { props, status, loading } = this;
        const { viewItem, layerItem, strings } = props;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "calcite-match-height" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow", { class: CSS$2.flow, dir: (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { key: status, heading: strings.general.includedLayerPanelTitle, description: (viewItem === null || viewItem === void 0 ? void 0 : viewItem.title) || (layerItem === null || layerItem === void 0 ? void 0 : layerItem.title), loading: loading, class: {
                panel: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.C.rtl]: rtl
            }, ref: (node) => (this.flowItemNode = node) }, this.renderFooterButtons(), this.renderInfo(), this.renderSublayers()), [flowStatus.DEFINITION, flowStatus.FILTER].includes(status)
            ? this.renderLayerDefinition()
            : null)));
    }
    renderFooterButtons() {
        const { props } = this;
        const { viewItem } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "footer", class: CSS$2.footer }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.footerTop }, this.renderBack(), viewItem ? this.renderUpdate() : this.renderNext()), viewItem ? this.renderCancel() : null));
    }
    renderBack() {
        const { props } = this;
        const { strings } = props;
        const isRtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "footer", onClick: this.goBack, appearance: "outline-fill", width: "half", "icon-start": isRtl ? "arrow-right" : "arrow-left", ref: (node) => (this.backButtonNode = node) }, strings.general.back));
    }
    renderNext() {
        const { props } = this;
        const { strings } = props;
        const isRtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "footer", onClick: this.goNext, appearance: "solid", width: "half", iconEnd: isRtl ? "arrow-left" : "arrow-right", ref: (node) => (this.nextButtonNode = node) }, strings.general.next));
    }
    renderUpdate() {
        const { props } = this;
        const { strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "footer", onClick: this.goUpdate, appearance: "solid", width: "half", "icon-start": "plus-square", ref: (node) => (this.nextButtonNode = node) }, strings.general.update));
    }
    renderCancel() {
        const { props } = this;
        const { layer, layerIds, strings } = props;
        const enabled = (layer === null || layer === void 0 ? void 0 : layer.loaded) && layerIds.length;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { disabled: !enabled, onClick: enabled && this.goCancel, appearance: "transparent", width: "full" }, strings.general.close));
    }
    renderInfo() {
        const { props } = this;
        const { strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "info" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.infoDescription }, strings.general.includedLayerPanelDescription)));
    }
    renderSublayers() {
        var _a, _b;
        const { props } = this;
        const { layer, layerIds } = props;
        const listItems = [];
        if (layer.type === "group") {
            (_a = layer.tables) === null || _a === void 0 ? void 0 : _a.forEach((lyr) => {
                if (layerIds.includes(lyr.layerId)) {
                    listItems.unshift(this.renderSublayer(lyr));
                }
            });
            (_b = layer.layers) === null || _b === void 0 ? void 0 : _b.forEach((lyr) => {
                if (layerIds.includes(lyr.layerId)) {
                    listItems.unshift(this.renderSublayer(lyr));
                }
            });
        }
        else {
            listItems.push(this.renderSublayer(layer));
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list", { ref: (node) => (this.listNode = node) }, listItems));
    }
    renderSublayer(fl) {
        const { props } = this;
        const { strings } = props;
        const isRtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        const viewLayerProps = getViewLayerProps(fl.layerId, props);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list-item", { key: fl.layerId, label: fl.title, description: fl.isTable ? strings.general.table : strings.general.layer, onClick: this.goDefinition.bind(this, fl.layerId), ref: (node) => {
                if (node) {
                    this.listItemNodes[fl.layerId] = node;
                } // not sure why it's null sometimes
            } }, !!viewLayerProps ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { class: CSS$2.hasDefinitionIcon, slot: "content-end", icon: "sliders", scale: "s" })) : null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { class: CSS$2.definitionIcon, slot: "content-end", icon: isRtl ? "chevron-left" : "chevron-right", scale: "s" })));
    }
    renderLayerDefinition() {
        const { props, status } = this;
        const { definitionLayerId } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-layer-view-definition", { key: `definition-${definitionLayerId}`, props: props, status: status, class: "calcite-match-height", onArcgisLayerViewOverViewRefresh: () => setTimeout(() => { var _a; return (_a = this.listItemNodes[definitionLayerId]) === null || _a === void 0 ? void 0 : _a.setFocus(); }, 200) }));
    }
    goDefinition(layerId) {
        const { props } = this;
        this.status = flowStatus.DEFINITION;
        props.definitionLayerId = layerId;
        this.reRender = !this.reRender;
    }
    async getLatestAdminServiceInfo() {
        this.props.adminServiceInfo = undefined;
        await getAdminServiceInfo$1(this.props, true);
        /* console.log(
          "updated view adminServiceInfo",
          this.props.adminServiceInfo?.layers?.map((lyr: any) => {
            return {
              id: lyr.id,
              name: lyr.name,
              adminLayerInfo_filter: lyr.adminLayerInfo?.viewLayerDefinition?.table?.filter?.value,
              viewDefinitionQuery: lyr.viewDefinitionQuery,
              fields: lyr.fields.map((field: any) => `${field.name} (${field.visible})`)
            };
          }),
          this.props.adminServiceInfo?.tables?.map((lyr: any) => {
            return {
              id: lyr.id,
              name: lyr.name,
              viewDefinitionQuery: lyr.viewDefinitionQuery,
              fields: lyr.fields.map((field: any) => `${field.name} (${field.visible})`)
            };
          })
        ); */
        this.reRender = !this.reRender;
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisLayerViewOverview.style = arcgisLayerViewOverviewCss;

const CSS$1 = {
    flow: "flow",
    panel: "panel",
    footer: "footer",
    info: "info",
    infoHeading: "info-heading",
    infoDescription: "info-description",
    fixedListItem: "fixed-list-item"
};

const arcgisLayerViewSelectionCss = ".flow.sc-arcgis-layer-view-selection{height:100%}.panel.sc-arcgis-layer-view-selection{height:100%}.footer.sc-arcgis-layer-view-selection{width:100%}.info.sc-arcgis-layer-view-selection{display:grid;grid-template-columns:repeat(1, minmax(0px, 1fr));gap:0.5rem;pointer-events:none;padding:1rem 0.75rem}.info-heading.sc-arcgis-layer-view-selection{font-size:var(--calcite-font-size--1);line-height:1.375;color:var(--calcite-color-text-2);transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);font-weight:var(--calcite-font-weight-medium);pointer-events:none}.info-description.sc-arcgis-layer-view-selection{font-size:var(--calcite-font-size--2);line-height:1.375;color:var(--calcite-color-text-3);transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);pointer-events:none}.fixed-list-item.sc-arcgis-layer-view-selection{margin-bottom:10px}";

const ArcgisLayerViewSelection = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisLayerViewStatusChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewStatusChange", 7);
        this.arcgisLayerViewSelectionCancel = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewSelectionCancel", 7);
        // --------------------------------------------------------------------------
        //
        //  Private methods
        //
        // --------------------------------------------------------------------------
        this.goNext = () => {
            const { props } = this;
            const { layerIds } = props;
            this.arcgisLayerViewStatusChange.emit({
                status: flowStatus.OVERVIEW,
                layerIds
            });
        };
        this.goSwapSource = () => {
            const { props } = this;
            const { layerIds } = props;
            this.arcgisLayerViewStatusChange.emit({
                status: flowStatus.SWAP_SOURCE,
                layerIds
            });
        };
        this.onSelectionChange = () => {
            const { props, hostElement } = this;
            const { layer, strings } = props;
            const layerIds = [];
            this.listNode
                .querySelectorAll("calcite-pick-list-item")
                .forEach((item) => {
                if (item.selected) {
                    layerIds.push(item.value);
                }
                if (layer.type === "group") {
                    getLayersAndTables(layer).find((subLayer) => subLayer.layerId === item.value).visible = item.selected;
                }
                else {
                    layer.visible = item.selected;
                }
            });
            if (layerIds.length) {
                this.props.layerIds = layerIds;
            }
            else {
                // must have at least one layer selected
                this.msgNode = document.createElement("arcgis-layer-view-msg");
                this.msgNode.props = props;
                this.msgNode.flowItemElement = this.flowItemNode;
                this.msgNode.message = strings.msg.atLeastOne;
                this.msgNode.isWarning = true;
                hostElement.appendChild(this.msgNode);
                clearTimeout(this.timeoutHndl);
                this.timeoutHndl = setTimeout(() => {
                    this.timeoutHndl = undefined;
                    if (this.msgNode) {
                        hostElement.removeChild(this.msgNode);
                        this.msgNode = undefined;
                        this.reRender = !this.reRender;
                    }
                }, 7000);
                // check that last list item again
                this.listNode
                    .querySelectorAll("calcite-pick-list-item")
                    .forEach((item) => {
                    if (props.layerIds.indexOf(item.value) > -1) {
                        item.selected = true;
                    }
                });
            }
            this.reRender = !this.reRender;
        };
        this.props = undefined;
        this.status = undefined;
        this.reRender = false;
    }
    arcgisLayerViewMsgClosedHandler() {
        if (this.msgNode) {
            this.hostElement.removeChild(this.msgNode);
            this.msgNode = undefined;
        }
        clearTimeout(this.timeoutHndl);
        this.timeoutHndl = undefined;
        this.reRender = !this.reRender;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() { }
    async componentDidLoad() {
        const { props } = this;
        const { derivativeLayers } = props;
        if (derivativeLayers.hasAny) {
            requestAnimationFrame(() => { var _a; return (_a = this.swapButtonNode) === null || _a === void 0 ? void 0 : _a.setFocus(); });
        }
        else {
            requestAnimationFrame(() => { var _a; return (_a = this.listNode) === null || _a === void 0 ? void 0 : _a.setFocus(); });
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        //console.log("render view-selection", propsToString(this.props), "status:", this.status);
        const { props, status } = this;
        const { viewItem, layerItem, strings } = props;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "calcite-match-height" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow", { class: CSS$1.flow, dir: (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { heading: (viewItem === null || viewItem === void 0 ? void 0 : viewItem.title) || (layerItem === null || layerItem === void 0 ? void 0 : layerItem.title), description: strings.general.sourceLayer, class: {
                panel: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.C.rtl]: rtl
            }, ref: (node) => (this.flowItemNode = node) }, this.renderFooterButtons(), this.renderInfo(), this.renderSublayers()), [flowStatus.SWAP_SOURCE, flowStatus.BROWSE_LAYER].includes(status)
            ? this.renderSwapSource()
            : null)));
    }
    renderFooterButtons() {
        const { props } = this;
        const { layer, layerIds, viewItem, derivativeLayers, hasReplicas, strings } = props;
        const isRtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        const isVelocityView = (viewItem === null || viewItem === void 0 ? void 0 : viewItem.typeKeywords.indexOf("IoTFeatureLayer")) > -1;
        const hasSwapRights = !isVelocityView && ["admin", "update"].indexOf(viewItem === null || viewItem === void 0 ? void 0 : viewItem.itemControl) > -1;
        const nextEnabled = (layer === null || layer === void 0 ? void 0 : layer.loaded) && layerIds.length && !derivativeLayers.hasAny;
        if (hasSwapRights && derivativeLayers.hasAny) {
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "footer", class: "footer" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { onClick: !hasReplicas && this.goSwapSource, disabled: hasReplicas, appearance: "solid", width: "full", iconStart: "arrow-right-left", ref: (node) => (this.swapButtonNode = node) }, strings.general.swapSource), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { onClick: () => this.arcgisLayerViewSelectionCancel.emit(), appearance: "transparent", width: "full" }, strings.general.close)));
        }
        else {
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "footer", class: "footer" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { disabled: !nextEnabled, onClick: nextEnabled && this.goNext, appearance: "solid", width: "full", iconEnd: isRtl ? "arrow-left" : "arrow-right", ref: (node) => (this.nextButtonNode = node) }, strings.general.next), hasSwapRights && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { disabled: !nextEnabled || hasReplicas, onClick: nextEnabled && !hasReplicas && this.goSwapSource, appearance: "transparent", width: "full", iconStart: "arrow-right-left", ref: (node) => (this.swapButtonNode = node) }, strings.general.swapSource)))));
        }
    }
    renderInfo() {
        const { props } = this;
        const { viewItem, derivativeLayers, hasReplicas, strings } = props;
        const hasSwapRights = ["admin", "update"].indexOf(viewItem === null || viewItem === void 0 ? void 0 : viewItem.itemControl) > -1;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "info" }, derivativeLayers.hasAny ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-notice", { scale: "s", width: "full", open: true, icon: "information" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "message" }, strings.general.derivativeLayerNotice))) : null, hasReplicas && hasSwapRights ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-notice", { scale: "s", width: "full", open: true, icon: "information" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "message" }, strings.general.selectLayerPanelReplicaNotice))) : null, !derivativeLayers.hasAny ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.infoHeading }, strings.general.selectLayerPanelTitle), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.infoDescription }, strings.general.selectLayerPanelDescription))) : null));
    }
    renderSublayers() {
        const { props } = this;
        const { derivativeLayers } = props;
        if (derivativeLayers.hasAny) {
            return this.renderNonEditableSublayers();
        }
        else {
            return this.renderEditableSublayers();
        }
    }
    renderNonEditableSublayers() {
        var _a, _b;
        const { props } = this;
        const { layer, layerIds, strings } = props;
        const layerListItems = [];
        const tableListItems = [];
        if (layer.type === "group") {
            (_a = layer.tables) === null || _a === void 0 ? void 0 : _a.forEach((lyr) => {
                if (layerIds.indexOf(lyr.layerId) > -1) {
                    tableListItems.unshift(this.renderNonEditableSublayer(lyr));
                }
            });
            (_b = layer.layers) === null || _b === void 0 ? void 0 : _b.forEach((lyr) => {
                if (layerIds.indexOf(lyr.layerId) > -1) {
                    layerListItems.unshift(this.renderNonEditableSublayer(lyr));
                }
            });
        }
        else {
            (layer.isTable ? tableListItems : layerListItems).push(this.renderNonEditableSublayer(layer));
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.info }, layerListItems.length > 0 ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.infoHeading }, strings.general.layers)) : null, layerListItems.length > 0 ? (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("ul", null, layerListItems) : null, tableListItems.length > 0 ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.infoHeading }, strings.general.tables)) : null, tableListItems.length > 0 ? (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("ul", null, tableListItems) : null));
    }
    renderNonEditableSublayer(lyr) {
        return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("li", { class: CSS$1.fixedListItem }, lyr.title);
    }
    renderEditableSublayers() {
        var _a, _b;
        const { props } = this;
        const { layer } = props;
        const listItems = [];
        if (layer.type === "group") {
            (_a = layer.tables) === null || _a === void 0 ? void 0 : _a.forEach((lyr) => {
                listItems.unshift(this.renderEditableSublayer(lyr));
            });
            (_b = layer.layers) === null || _b === void 0 ? void 0 : _b.forEach((lyr) => {
                listItems.unshift(this.renderEditableSublayer(lyr));
            });
        }
        else {
            listItems.push(this.renderEditableSublayer(layer));
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-pick-list", { multiple: true, onCalciteListChange: this.onSelectionChange, ref: (node) => (this.listNode = node) }, listItems));
    }
    renderEditableSublayer(lyr) {
        const { props } = this;
        const { layerIds, strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-pick-list-item", { key: lyr.layerId, label: lyr.title, value: lyr.layerId, description: lyr.isTable ? strings.general.table : strings.general.layer, selected: layerIds.indexOf(lyr.layerId) > -1 }));
    }
    renderSwapSource() {
        const { props, status } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-layer-view-swap-source", {
            //key={`selection-${status}`}
            props: props, status: status, onArcgisLayerViewStatusChange: () => setTimeout(() => { var _a; return (_a = this.flowItemNode) === null || _a === void 0 ? void 0 : _a.setFocus(); }, 200)
        }));
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisLayerViewSelection.style = arcgisLayerViewSelectionCss;

const CSS = {
    panel: "panel",
    browse: "browse",
    info: "info",
    text: "text",
    check: "check",
    checkText: "check-text",
    footerButton: "footer-button"
};

const arcgisLayerViewSwapSourceCss = ".panel.sc-arcgis-layer-view-swap-source{height:100%}.browse.sc-arcgis-layer-view-swap-source{width:100%}.info.sc-arcgis-layer-view-swap-source{margin:10px}.text.sc-arcgis-layer-view-swap-source{margin-bottom:8px}.check.sc-arcgis-layer-view-swap-source{color:green}.check-text.sc-arcgis-layer-view-swap-source{font-weight:bold}.footer-button.sc-arcgis-layer-view-swap-source{margin:0 10px 5px 10px}";

const ArcgisLayerViewSwapSource = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisLayerViewStatusChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLayerViewStatusChange", 7);
        // --------------------------------------------------------------------------
        //
        //  Private methods
        //
        // --------------------------------------------------------------------------
        this.onBack = () => {
            this.arcgisLayerViewStatusChange.emit({ status: flowStatus.SELECTION });
        };
        this.goBrowse = () => {
            this.arcgisLayerViewStatusChange.emit({ status: flowStatus.BROWSE_LAYER });
        };
        this.props = undefined;
        this.status = undefined;
        this.reRender = false;
        this.loading = false;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentDidLoad() {
        // requestAnimationFrame nor working the second time...
        setTimeout(() => requestAnimationFrame(() => { var _a; return (_a = this.flowItemNode) === null || _a === void 0 ? void 0 : _a.setFocus(); }), 200);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        //console.log("render swap-source", propsToString(this.props), "status", this.status);
        const { props, status, loading } = this;
        const { strings } = props;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "calcite-match-height" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { key: status, heading: strings.swapSource.title, description: strings.swapSource.subTitle, loading: loading, class: {
                panel: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__.C.rtl]: rtl
            }, onCalciteFlowItemBack: this.onBack, ref: (node) => (this.flowItemNode = node) }, this.renderInfo(), this.renderDerivativeInfo(), this.renderBrowse()), status === flowStatus.BROWSE_LAYER && this.renderBrowseLayer()));
    }
    renderInfo() {
        const { props } = this;
        const { strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.info }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.text }, strings.swapSource.msg1), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.text }, strings.swapSource.msg2), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { layout: "inline" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { icon: "check", class: CSS.check }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: CSS.checkText }, strings.swapSource.requirement1)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { layout: "inline" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { icon: "check", class: CSS.check }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: CSS.checkText }, strings.swapSource.requirement2)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { layout: "inline" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { icon: "check", class: CSS.check }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: CSS.checkText }, strings.swapSource.requirement3)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.text }, strings.swapSource.msg3)));
    }
    renderDerivativeInfo() {
        const { props } = this;
        const { derivativeLayers, strings } = props;
        if (!derivativeLayers.hasMS && !derivativeLayers.hasVTL && !derivativeLayers.hasScene) {
            return null;
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.info }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.text }, strings.swapSource.derivativeMsg)));
    }
    renderBrowse() {
        const { props } = this;
        const { strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.footerButton }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { id: "arcgis-layer-view-swap-source-browse", onClick: this.goBrowse, appearance: "outline-fill", width: "full", ref: (node) => (this.browseButtonNode = node) }, strings.swapSource.browseForLayer)));
    }
    renderBrowseLayer() {
        const { props } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-layer-view-browse-layer", { props: props, class: CSS.browse, onArcgisLayerViewStatusChange: (event) => {
                if (event.detail.status === flowStatus.SWAP_SOURCE) {
                    // can't make it work without using an id
                    // it seems the whole component reloads from scratch after this step here
                    setTimeout(() => {
                        var _a;
                        return (_a = document.getElementById("arcgis-layer-view-swap-source-browse")) === null || _a === void 0 ? void 0 : _a.setFocus();
                    }, 400);
                }
            } }));
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisLayerViewSwapSource.style = arcgisLayerViewSwapSourceCss;



//# sourceMappingURL=arcgis-layer-view_14.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
    let timeout;
    let status = "idle";
    function flush(...args) {
        status = "flushed";
        return debounced(...args);
    }
    function invoke(...args) {
        status = "invoked";
        return debounced(...args);
    }
    function cancel(...args) {
        status = "cancelled";
        return debounced(...args);
    }
    function getStatus() {
        return status;
    }
    const debounced = (...args) => new Promise((resolve) => {
        switch (status) {
            case "flushed":
                status = "idle";
                if (timeout) {
                    clearTimeout(timeout);
                    resolve(fn(...args));
                }
                else {
                    resolve(null);
                }
                break;
            case "invoked":
                clearTimeout(timeout);
                status = "idle";
                resolve(fn(...args));
                break;
            case "cancelled":
                clearTimeout(timeout);
                status = "idle";
                resolve(null);
                break;
            default:
                if (timeout) {
                    clearTimeout(timeout);
                }
                status = "pending";
                timeout = setTimeout(() => {
                    status = "idle";
                    return resolve(fn(...args));
                }, delay);
                break;
        }
    });
    debounced.flush = flush;
    debounced.invoke = invoke;
    debounced.cancel = cancel;
    debounced.getStatus = getStatus;
    return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
    let timeout;
    return (...args) => new Promise((resolve) => {
        if (timeout) {
            return;
        }
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            timeout = undefined;
            resolve(fn(...args));
        }, delay);
    });
};
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
    await Promise.all([promise, timeout(minDelay)]);
    return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
    const { key, data } = getKeyAndItem(item);
    return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
    const resultArr = [];
    const lookupMap = {};
    myArr.forEach((item) => {
        const id = getItemId(item);
        if (lookupMap[id] == null) {
            lookupMap[id] = item;
            resultArr.push(item);
        }
    });
    return resultArr;
}
function unique(myArr) {
    const primitives = { boolean: {}, number: {}, string: {} };
    const objs = [];
    return myArr.filter((item) => {
        let type = typeof item;
        if (type in primitives) {
            return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
        }
        else {
            return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
    });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));



//# sourceMappingURL=functional-44de8fcf.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createStore)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const appendToMap = (map, propName, value) => {
    const items = map.get(propName);
    if (!items) {
        map.set(propName, [value]);
    }
    else if (!items.includes(value)) {
        items.push(value);
    }
};
const debounce = (fn, ms) => {
    let timeoutId;
    return (...args) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
            timeoutId = 0;
            fn(...args);
        }, ms);
    };
};

/**
 * Check if a possible element isConnected.
 * The property might not be there, so we check for it.
 *
 * We want it to return true if isConnected is not a property,
 * otherwise we would remove these elements and would not update.
 *
 * Better leak in Edge than to be useless.
 */
const isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;
const cleanupElements = debounce((map) => {
    for (let key of map.keys()) {
        map.set(key, map.get(key).filter(isConnected));
    }
}, 2000);
const stencilSubscription = () => {
    if (typeof _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.g !== 'function') {
        // If we are not in a stencil project, we do nothing.
        // This function is not really exported by @stencil/core.
        return {};
    }
    const elmsToUpdate = new Map();
    return {
        dispose: () => elmsToUpdate.clear(),
        get: (propName) => {
            const elm = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.g)();
            if (elm) {
                appendToMap(elmsToUpdate, propName, elm);
            }
        },
        set: (propName) => {
            const elements = elmsToUpdate.get(propName);
            if (elements) {
                elmsToUpdate.set(propName, elements.filter(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f));
            }
            cleanupElements(elmsToUpdate);
        },
        reset: () => {
            elmsToUpdate.forEach((elms) => elms.forEach(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f));
            cleanupElements(elmsToUpdate);
        },
    };
};

const unwrap = (val) => (typeof val === 'function' ? val() : val);
const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
    const unwrappedState = unwrap(defaultState);
    let states = new Map(Object.entries(unwrappedState !== null && unwrappedState !== void 0 ? unwrappedState : {}));
    const handlers = {
        dispose: [],
        get: [],
        set: [],
        reset: [],
    };
    const reset = () => {
        var _a;
        // When resetting the state, the default state may be a function - unwrap it to invoke it.
        // otherwise, the state won't be properly reset
        states = new Map(Object.entries((_a = unwrap(defaultState)) !== null && _a !== void 0 ? _a : {}));
        handlers.reset.forEach((cb) => cb());
    };
    const dispose = () => {
        // Call first dispose as resetting the state would
        // cause less updates ;)
        handlers.dispose.forEach((cb) => cb());
        reset();
    };
    const get = (propName) => {
        handlers.get.forEach((cb) => cb(propName));
        return states.get(propName);
    };
    const set = (propName, value) => {
        const oldValue = states.get(propName);
        if (shouldUpdate(value, oldValue, propName)) {
            states.set(propName, value);
            handlers.set.forEach((cb) => cb(propName, value, oldValue));
        }
    };
    const state = (typeof Proxy === 'undefined'
        ? {}
        : new Proxy(unwrappedState, {
            get(_, propName) {
                return get(propName);
            },
            ownKeys(_) {
                return Array.from(states.keys());
            },
            getOwnPropertyDescriptor() {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            has(_, propName) {
                return states.has(propName);
            },
            set(_, propName, value) {
                set(propName, value);
                return true;
            },
        }));
    const on = (eventName, callback) => {
        handlers[eventName].push(callback);
        return () => {
            removeFromArray(handlers[eventName], callback);
        };
    };
    const onChange = (propName, cb) => {
        const unSet = on('set', (key, newValue) => {
            if (key === propName) {
                cb(newValue);
            }
        });
        // We need to unwrap the defaultState because it might be a function.
        // Otherwise we might not be sending the right reset value.
        const unReset = on('reset', () => cb(unwrap(defaultState)[propName]));
        return () => {
            unSet();
            unReset();
        };
    };
    const use = (...subscriptions) => {
        const unsubs = subscriptions.reduce((unsubs, subscription) => {
            if (subscription.set) {
                unsubs.push(on('set', subscription.set));
            }
            if (subscription.get) {
                unsubs.push(on('get', subscription.get));
            }
            if (subscription.reset) {
                unsubs.push(on('reset', subscription.reset));
            }
            if (subscription.dispose) {
                unsubs.push(on('dispose', subscription.dispose));
            }
            return unsubs;
        }, []);
        return () => unsubs.forEach((unsub) => unsub());
    };
    const forceUpdate = (key) => {
        const oldValue = states.get(key);
        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));
    };
    return {
        state,
        get,
        set,
        on,
        onChange,
        use,
        dispose,
        reset,
        forceUpdate,
    };
};
const removeFromArray = (array, item) => {
    const index = array.indexOf(item);
    if (index >= 0) {
        array[index] = array[array.length - 1];
        array.length--;
    }
};

const createStore = (defaultState, shouldUpdate) => {
    const map = createObservableMap(defaultState, shouldUpdate);
    map.use(stencilSubscription());
    return map;
};



//# sourceMappingURL=index-05956cab.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-properties-10491b2e.js":
/*!*********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-properties-10491b2e.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ itemPropertiesStore),
/* harmony export */   i: () => (/* binding */ itemPropertiesState)
/* harmony export */ });
/* harmony import */ var _index_05956cab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-05956cab.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const itemPropertiesStore = (0,_index_05956cab_js__WEBPACK_IMPORTED_MODULE_0__.c)({
    title: "",
    snippet: "",
    tags: [],
    categories: []
});
const itemPropertiesState = itemPropertiesStore.state;



//# sourceMappingURL=item-properties-10491b2e.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/localStorage-9c4e7a3a.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/localStorage-9c4e7a3a.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arcgisComponentNotificationsKeys),
/* harmony export */   g: () => (/* binding */ getSingleObjectLocalStorage),
/* harmony export */   l: () => (/* binding */ localStorageKeys),
/* harmony export */   s: () => (/* binding */ setSingleObjectLocalStorage)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
var localStorageKeys;
(function (localStorageKeys) {
    localStorageKeys["ARCGIS_COMPONENT_NOTIFICATIONS"] = "arcgisComponent_notifications";
})(localStorageKeys || (localStorageKeys = {}));
var arcgisComponentNotificationsKeys;
(function (arcgisComponentNotificationsKeys) {
    arcgisComponentNotificationsKeys["FEATURE_REDUCTION_WARNING_DISMISSED"] = "arcgis_feature_reduction_warning_dismissed";
    arcgisComponentNotificationsKeys["POPUP_WARNING_DISMISSED"] = "arcgis_popup_warning_dismissed";
    arcgisComponentNotificationsKeys["INCOMPATIBLE_VECTOR_SYMBOLS_DISMISSED"] = "arcgis_symbol_styler_incompatible_vector_symbols_dismissed";
    arcgisComponentNotificationsKeys["EFFECTS_TIP_DISMISSED"] = "arcgis_effects_tip_dismissed";
    arcgisComponentNotificationsKeys["LAYER_VIEW_DEFINITION_DISMISSED"] = "arcgis_layer_view_definition_dismissed";
    arcgisComponentNotificationsKeys["LAYER_OVERRIDE_STATUS_TIP_DISMISSED"] = "arcgis_layer_override_status_tip_dismissed";
    arcgisComponentNotificationsKeys["SMART_MAPPING_TIP1_DISMISSED"] = "arcgis_smart_mapping_tip1_dismissed";
    arcgisComponentNotificationsKeys["SMART_MAPPING_TIP2_DISMISSED"] = "arcgis_smart_mapping_tip2_dismissed";
    arcgisComponentNotificationsKeys["LAYER_VIEW_JOIN_TIP_DISMISSED"] = "arcgis_layer_view_join_tip_dismissed";
    arcgisComponentNotificationsKeys["MULTIDIMENSIONAL_INFO_TIP_DISMISSED"] = "arcgis_multidimensional_info_tip_dismissed";
})(arcgisComponentNotificationsKeys || (arcgisComponentNotificationsKeys = {}));
const getLocalStorage = (localStorageKey) => {
    return localStorage.getItem(localStorageKey);
};
const setLocalStorage = (localStorageKey, value) => {
    localStorage.setItem(localStorageKey, value);
};
const getObjectLocalStorage = (localStorageKey) => {
    return JSON.parse(getLocalStorage(localStorageKey)) || {};
};
const setSingleObjectLocalStorage = (localStorageKey, keyValueObject) => {
    const setLocalStorageVal = getObjectLocalStorage(localStorageKey);
    setLocalStorageVal[keyValueObject.key] = keyValueObject.value;
    setLocalStorage(localStorageKey, JSON.stringify(setLocalStorageVal));
};
const getSingleObjectLocalStorage = (localStorageKey, objectKey) => {
    const getLocalStorageVal = getObjectLocalStorage(localStorageKey);
    if (getLocalStorageVal === null || getLocalStorageVal === void 0 ? void 0 : getLocalStorageVal.hasOwnProperty(objectKey)) {
        return getLocalStorageVal[objectKey];
    }
    else {
        return null;
    }
};



//# sourceMappingURL=localStorage-9c4e7a3a.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
    var _a, _b, _c;
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        // "ru-RU" maps to "ru" use case
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
        }
        else {
            return "en";
        }
    }
}
function getComponentClosestLanguageIntl(element) {
    var _a, _b, _c;
    // it's OK if we don't have the 4 letter language file for it
    // 4 letter language code needed for formatting numbers
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            // we support the 2 letter coded language
            // e.g. it-CH vs it
            return lang;
        }
        else {
            return "en";
        }
    }
}
function fetchLocaleStringsForComponent(componentName, locale) {
    return new Promise((resolve, reject) => {
        fetch((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
            if (result.ok)
                resolve(result.json());
            else
                reject();
        }, () => reject());
    });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
    const id = `${componentName}${locale}`;
    if (!stringCache[id]) {
        stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
    }
    return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
    const componentName = tagName || element.tagName.toLowerCase();
    const componentLanguage = getComponentClosestLanguage(element);
    const componentLanguageIntl = getComponentClosestLanguageIntl(element);
    let strings;
    try {
        strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
    }
    catch (e) {
        console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
        strings = await fetchLocaleStringsFromCache(componentName, "en");
    }
    return [strings, componentLanguage, componentLanguageIntl];
}



//# sourceMappingURL=locale-050b6db9.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-660bb43a.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-660bb43a.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ getPortalBaseUrl)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
function getPortalBaseUrl(portal) {
    const { customBaseUrl, portalHostname, urlKey } = portal;
    const { protocol } = window.location;
    const url = urlKey ? `${urlKey}.${customBaseUrl}` : portalHostname;
    return `${protocol}//${url}`;
}



//# sourceMappingURL=portal-660bb43a.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTkxMDRiYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQzhJO0FBQ3hFO0FBQ1Q7QUFDRTtBQUNQO0FBQzBCO0FBQ3JCO0FBQ1k7QUFDcUc7QUFDbko7QUFDUTtBQUNOOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsbUVBQW1FLFdBQVc7QUFDOUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBUztBQUNqQixRQUFRLCtEQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0RBQVMsY0FBYywrREFBUztBQUMxQyxhQUFhLCtEQUFTLG9CQUFvQiwrREFBUztBQUNuRCxhQUFhLCtEQUFTLGNBQWMsK0RBQVM7QUFDN0MsYUFBYSwrREFBUyxvQkFBb0IsK0RBQVM7QUFDbkQ7QUFDQTtBQUNBLDJCQUEyQiwrREFBUyxhQUFhLCtEQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLCtEQUFTO0FBQ3hHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hELFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGtDQUFrQztBQUN2RjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVEQUF1RCxvQ0FBb0M7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvQ0FBb0M7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscUJBQXFCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQywyREFBVztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsMkRBQVc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLHVEQUF1RDtBQUNuRSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxlQUFlLEdBQUcsa0JBQWtCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBOztBQUU0RTs7QUFFNUU7Ozs7Ozs7Ozs7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdDQUF3QztBQUNwRCxZQUFZLFdBQVc7QUFDdkIsNEJBQTRCLE9BQU8sR0FBRyxjQUFjO0FBQ3BELGNBQWMsU0FBUyxJQUFJLElBQUk7QUFDL0I7O0FBRWlDOztBQUVqQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2FyY2dpcy1sYXllci12aWV3XzE0LmVudHJ5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vaW5kZXgtMDU5NTZjYWIuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vaXRlbS1wcm9wZXJ0aWVzLTEwNDkxYjJlLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2xvY2FsU3RvcmFnZS05YzRlN2EzYS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9sb2NhbGUtMDUwYjZkYjkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vcG9ydGFsLTY2MGJiNDNhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBjIGFzIGNyZWF0ZUV2ZW50LCBoLCBIIGFzIEhvc3QsIGQgYXMgZ2V0RWxlbWVudCwgZiBhcyBmb3JjZVVwZGF0ZSwgRiBhcyBGcmFnbWVudCB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIH0gZnJvbSAnLi9sb2NhbGUtMDUwYjZkYjkuanMnO1xuaW1wb3J0IHsgbCBhcyBsb2FkTW9kdWxlcyB9IGZyb20gJy4vbG9hZE1vZHVsZXMtYjRhYzEyNDcuanMnO1xuaW1wb3J0IHsgaSBhcyBpc0RlZmluZWQgfSBmcm9tICcuL2NvbW1vbkZ1bmN0aW9ucy1iMDgzMGU5ZS5qcyc7XG5pbXBvcnQgeyB0IGFzIHRpbWVvdXQgfSBmcm9tICcuL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRFbGVtZW50RGlyLCBDIGFzIENTU19VVElMSVRZIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRQb3J0YWxCYXNlVXJsIH0gZnJvbSAnLi9wb3J0YWwtNjYwYmI0M2EuanMnO1xuaW1wb3J0IHsgaSBhcyBpdGVtUHJvcGVydGllc1N0YXRlIH0gZnJvbSAnLi9pdGVtLXByb3BlcnRpZXMtMTA0OTFiMmUuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRTaW5nbGVPYmplY3RMb2NhbFN0b3JhZ2UsIHMgYXMgc2V0U2luZ2xlT2JqZWN0TG9jYWxTdG9yYWdlLCBhIGFzIGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzLCBsIGFzIGxvY2FsU3RvcmFnZUtleXMgfSBmcm9tICcuL2xvY2FsU3RvcmFnZS05YzRlN2EzYS5qcyc7XG5pbXBvcnQgJy4vZG9tLTRkMzY3Njc3LmpzJztcbmltcG9ydCAnLi9jb21tb25FbnVtcy1mY2YxMzY2MS5qcyc7XG5pbXBvcnQgJy4vaW5kZXgtMDU5NTZjYWIuanMnO1xuXG5jb25zdCBDU1MkOSA9IHtcbiAgICBwYW5lbDogXCJwYW5lbFwiLFxuICAgIGZvb3RlcjogXCJmb290ZXJcIixcbiAgICBlcnJvckNvbnRlbnQ6IFwiZXJyb3ItY29udGVudFwiXG59O1xuXG52YXIgZmxvd1N0YXR1cztcbihmdW5jdGlvbiAoZmxvd1N0YXR1cykge1xuICAgIGZsb3dTdGF0dXNbZmxvd1N0YXR1c1tcIkVSUk9SXCJdID0gMF0gPSBcIkVSUk9SXCI7XG4gICAgZmxvd1N0YXR1c1tmbG93U3RhdHVzW1wiTE9BRElOR1wiXSA9IDFdID0gXCJMT0FESU5HXCI7XG4gICAgZmxvd1N0YXR1c1tmbG93U3RhdHVzW1wiU0VMRUNUSU9OXCJdID0gMl0gPSBcIlNFTEVDVElPTlwiO1xuICAgIGZsb3dTdGF0dXNbZmxvd1N0YXR1c1tcIk9WRVJWSUVXXCJdID0gM10gPSBcIk9WRVJWSUVXXCI7XG4gICAgZmxvd1N0YXR1c1tmbG93U3RhdHVzW1wiU1dBUF9TT1VSQ0VcIl0gPSA0XSA9IFwiU1dBUF9TT1VSQ0VcIjtcbiAgICBmbG93U3RhdHVzW2Zsb3dTdGF0dXNbXCJCUk9XU0VfTEFZRVJcIl0gPSA1XSA9IFwiQlJPV1NFX0xBWUVSXCI7XG4gICAgZmxvd1N0YXR1c1tmbG93U3RhdHVzW1wiREVGSU5JVElPTlwiXSA9IDZdID0gXCJERUZJTklUSU9OXCI7XG4gICAgZmxvd1N0YXR1c1tmbG93U3RhdHVzW1wiRklMVEVSXCJdID0gN10gPSBcIkZJTFRFUlwiO1xuICAgIGZsb3dTdGF0dXNbZmxvd1N0YXR1c1tcIkNSRUFURVwiXSA9IDhdID0gXCJDUkVBVEVcIjtcbn0pKGZsb3dTdGF0dXMgfHwgKGZsb3dTdGF0dXMgPSB7fSkpO1xudmFyIGFjdGlvbnM7XG4oZnVuY3Rpb24gKGFjdGlvbnMpIHtcbiAgICBhY3Rpb25zW2FjdGlvbnNbXCJDQU5DRUxcIl0gPSAwXSA9IFwiQ0FOQ0VMXCI7XG4gICAgYWN0aW9uc1thY3Rpb25zW1wiQ1JFQVRFXCJdID0gMV0gPSBcIkNSRUFURVwiO1xufSkoYWN0aW9ucyB8fCAoYWN0aW9ucyA9IHt9KSk7XG4vKipcbiAqIENoZWNrcyBpZiBhIGZlYXR1cmVFZmZlY3Qgb24gYSBsYXllciBpcyBlbXB0eVxuICogQHBhcmFtIGVmZmVjdCAtIGxheWVyLmZlYXR1cmVFZmZlY3RcbiAqL1xuZnVuY3Rpb24gaXNFZmZlY3RFbXB0eShlZmZlY3QpIHtcbiAgICBpZiAoIWVmZmVjdCB8fCAhZWZmZWN0LmZpbHRlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgY2hlY2tQcm9wcyA9IFtcImdlb21ldHJ5XCIsIFwiZGlzdGFuY2VcIiwgXCJvYmplY3RJZHNcIiwgXCJ0aW1lRXh0ZW50XCIsIFwid2hlcmVcIl07XG4gICAgcmV0dXJuICFjaGVja1Byb3BzLnNvbWUoKHByb3ApID0+IGVmZmVjdC5maWx0ZXIuaGFzT3duUHJvcGVydHkocHJvcCkpO1xufVxuZnVuY3Rpb24gY3JlYXRlRWZmZWN0KGZsLCBGZWF0dXJlRWZmZWN0LCBwcm9wcykge1xuICAgIGNvbnN0IHsgYmFja2dyb3VuZFRoZW1lIH0gPSBwcm9wcztcbiAgICBsZXQgYnJpZ2h0bmVzcyA9IGJhY2tncm91bmRUaGVtZSA9PT0gXCJsaWdodFwiID8gMTAwIDogNjU7XG4gICAgZmwuZmVhdHVyZUVmZmVjdCA9IG5ldyBGZWF0dXJlRWZmZWN0KHtcbiAgICAgICAgZmlsdGVyOiB7fSxcbiAgICAgICAgZXhjbHVkZWRFZmZlY3Q6IGBncmF5c2NhbGUoMTAwJSkgb3BhY2l0eSgzMCUpIGJyaWdodG5lc3MoJHticmlnaHRuZXNzfSUpYCxcbiAgICAgICAgZXhjbHVkZWRMYWJlbHNWaXNpYmxlOiB0cnVlXG4gICAgfSk7XG59XG5mdW5jdGlvbiBzYW1lQ29vcmQodmFsMSwgdmFsMikge1xuICAgIHJldHVybiB2YWwxID09PSB2YWwyIHx8IE1hdGgucm91bmQodmFsMSAqIDEwMDAwMDApIC8gMTAwMDAwMCA9PT0gTWF0aC5yb3VuZCh2YWwyICogMTAwMDAwMCkgLyAxMDAwMDAwO1xufVxuZnVuY3Rpb24gc2FtZVNSKHNwMSwgc3AyKSB7XG4gICAgLy8gd29ya3MgZm9yIF9fZXNyaS5TcGF0aWFsUmVmZXJlbmNlIGFuZCBKU09OIG9iamVjdHNcbiAgICB2YXIgbWVyY2F0b3IgPSBbMTAyMTEzLCAxMDIxMDAsIDM4NTddO1xuICAgIGlmIChzcDEgJiZcbiAgICAgICAgc3AyICYmXG4gICAgICAgIGlzRGVmaW5lZChzcDEud2tpZCkgJiZcbiAgICAgICAgaXNEZWZpbmVkKHNwMi53a2lkKSAmJlxuICAgICAgICBtZXJjYXRvci5pbmRleE9mKHNwMS53a2lkKSA+IC0xICYmXG4gICAgICAgIG1lcmNhdG9yLmluZGV4T2Yoc3AyLndraWQpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNwMSAmJlxuICAgICAgICBzcDIgJiZcbiAgICAgICAgKChpc0RlZmluZWQoc3AxLndraWQpICYmIGlzRGVmaW5lZChzcDIud2tpZCkgJiYgc3AxLndraWQgPT0gc3AyLndraWQpIHx8XG4gICAgICAgICAgICAoaXNEZWZpbmVkKHNwMS5sYXRlc3RXa2lkKSAmJiBpc0RlZmluZWQoc3AyLndraWQpICYmIHNwMS5sYXRlc3RXa2lkID09IHNwMi53a2lkKSB8fFxuICAgICAgICAgICAgKGlzRGVmaW5lZChzcDEud2tpZCkgJiYgaXNEZWZpbmVkKHNwMi5sYXRlc3RXa2lkKSAmJiBzcDEud2tpZCA9PSBzcDIubGF0ZXN0V2tpZCkgfHxcbiAgICAgICAgICAgIChpc0RlZmluZWQoc3AxLmxhdGVzdFdraWQpICYmIGlzRGVmaW5lZChzcDIubGF0ZXN0V2tpZCkgJiYgc3AxLmxhdGVzdFdraWQgPT0gc3AyLmxhdGVzdFdraWQpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3AxICYmIHNwMiAmJiBpc0RlZmluZWQoc3AxLndrdCkgJiYgaXNEZWZpbmVkKHNwMi53a3QpICYmIHNwMS53a3QgPT09IHNwMi53a3QpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBwcm9wc1xuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0UmVxdWlyZWRGaWVsZE5hbWVzKHByb3BzLCBsYXllcikge1xuICAgIGNvbnN0IHJlcXVpcmVkRmllbGRUeXBlcyA9IFtcbiAgICAgICAgXCJvaWRcIixcbiAgICAgICAgXCJlc3JpRmllbGRUeXBlT0lEXCIsXG4gICAgICAgIFwiZ2xvYmFsLWlkXCIsXG4gICAgICAgIFwiZXNyaUZpZWxkVHlwZUdsb2JhbElEXCIsXG4gICAgICAgIFwiZ2VvbWV0cnlcIixcbiAgICAgICAgXCJlc3JpRmllbGRUeXBlR2VvbWV0cnlcIlxuICAgIF07XG4gICAgbGV0IHRvdGFsRmllbGRzO1xuICAgIGlmIChsYXllcikge1xuICAgICAgICB0b3RhbEZpZWxkcyA9IGxheWVyLmZpZWxkcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgZGVmaW5pdGlvbkxheWVySWQgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBhZG1pbkxheWVySW5mbyA9IGdldEFkbWluTGF5ZXJJbmZvKGRlZmluaXRpb25MYXllcklkLCBwcm9wcyk7XG4gICAgICAgIHRvdGFsRmllbGRzID0gKGFkbWluTGF5ZXJJbmZvID09PSBudWxsIHx8IGFkbWluTGF5ZXJJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZG1pbkxheWVySW5mby5maWVsZHMpIHx8IGdldEZMKGRlZmluaXRpb25MYXllcklkLCBwcm9wcykuZmllbGRzO1xuICAgIH1cbiAgICByZXR1cm4gdG90YWxGaWVsZHNcbiAgICAgICAgLmZpbHRlcigoZmllbGQpID0+IHJlcXVpcmVkRmllbGRUeXBlcy5pbmRleE9mKGZpZWxkLnR5cGUpID4gLTEgfHwgKCFmaWVsZC5udWxsYWJsZSAmJiAhaXNEZWZpbmVkKGZpZWxkLmRlZmF1bHRWYWx1ZSkpKVxuICAgICAgICAubWFwKChmaWVsZCkgPT4gZmllbGQubmFtZSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBzZXR0aW5ncyBvZiBjdXJyZW50IHZpZXdcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5pdERlZmluaXRpb25zKHByb3BzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgeyB2aWV3SXRlbSwgYWRtaW5TZXJ2aWNlSW5mbywgbGF5ZXIgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgbW9kdWxlcyB9ID0gcHJvcHM7XG4gICAgaWYgKCF2aWV3SXRlbSkge1xuICAgICAgICAvLyB1c2UgcGFyZW50J3MgZGVmaW5pdGlvbkV4cHJlc3Npb24gYXMgZGVmYXVsdCBmaWx0ZXJcbiAgICAgICAgaWYgKGxheWVyLnR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgKF9hID0gbGF5ZXIubGF5ZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgobHlyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGx5ci5kZWZpbml0aW9uRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBhZGRWaWV3TGF5ZXJQcm9wcyhseXIubGF5ZXJJZCwgeyBmaWx0ZXI6IGx5ci5kZWZpbml0aW9uRXhwcmVzc2lvbiB9LCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5TGF5ZXJGaWx0ZXIobHlyLmRlZmluaXRpb25FeHByZXNzaW9uLCBseXIubGF5ZXJJZCwgcHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBseXIuZGVmaW5pdGlvbkV4cHJlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKF9iID0gbGF5ZXIudGFibGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZm9yRWFjaCgodGFibGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGFibGUuZGVmaW5pdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkVmlld0xheWVyUHJvcHModGFibGUubGF5ZXJJZCwgeyBmaWx0ZXI6IHRhYmxlLmRlZmluaXRpb25FeHByZXNzaW9uIH0sIHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlMYXllckZpbHRlcih0YWJsZS5kZWZpbml0aW9uRXhwcmVzc2lvbiwgdGFibGUubGF5ZXJJZCwgcHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB0YWJsZS5kZWZpbml0aW9uRXhwcmVzc2lvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobGF5ZXIuZGVmaW5pdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBhZGRWaWV3TGF5ZXJQcm9wcyhsYXllci5sYXllcklkLCB7IGZpbHRlcjogbGF5ZXIuZGVmaW5pdGlvbkV4cHJlc3Npb24gfSwgcHJvcHMpO1xuICAgICAgICAgICAgICAgIGFwcGx5TGF5ZXJGaWx0ZXIobGF5ZXIuZGVmaW5pdGlvbkV4cHJlc3Npb24sIGxheWVyLmxheWVySWQsIHByb3BzKTtcbiAgICAgICAgICAgICAgICBsYXllci5kZWZpbml0aW9uRXhwcmVzc2lvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghYWRtaW5TZXJ2aWNlSW5mbykge1xuICAgICAgICAgICAgLy8gcHJvYmFibHkgbm90IGEgdmlldyB5ZXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9wcy5sYXllcklkcyA9IFtdO1xuICAgICAgICBnZXRMYXllcnNBbmRUYWJsZXMoYWRtaW5TZXJ2aWNlSW5mbykuZm9yRWFjaChhc3luYyAobGF5ZXJJbmZvKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICBwcm9wcy5sYXllcklkcy5wdXNoKGxheWVySW5mby5pZCk7XG4gICAgICAgICAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICAgICAgICAgIGxheWVySW5mby5maWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQudmlzaWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLnB1c2goZmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZmllbGRzLmxlbmd0aCAhPT0gbGF5ZXJJbmZvLmZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhZGRWaWV3TGF5ZXJQcm9wcyhsYXllckluZm8uaWQsIHsgZmllbGRzIH0sIHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdoZXJlQ2xhdXNlID0gbGF5ZXJJbmZvLnZpZXdEZWZpbml0aW9uUXVlcnk7XG4gICAgICAgICAgICBpZiAod2hlcmVDbGF1c2UpIHtcbiAgICAgICAgICAgICAgICBhZGRWaWV3TGF5ZXJQcm9wcyhsYXllckluZm8uaWQsIHsgZmlsdGVyOiB3aGVyZUNsYXVzZSB9LCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgYXBwbHlMYXllckZpbHRlcih3aGVyZUNsYXVzZSwgbGF5ZXJJbmZvLmlkLCBwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhb2lWYWx1ZSA9IChfZCA9IChfYyA9IChfYiA9IChfYSA9IGxheWVySW5mby5hZG1pbkxheWVySW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZpZXdMYXllckRlZmluaXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50YWJsZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZpbHRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGFvaVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byBjaGVjayBTUiBvZiBzYXZlZCBBT0ksIGFueSBTUiB3b3JrXG4gICAgICAgICAgICAgICAgYWRkVmlld0xheWVyUHJvcHMobGF5ZXJJbmZvLmlkLCB7XG4gICAgICAgICAgICAgICAgICAgIGFvaTogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhb2lWYWx1ZS5nZW9tZXRyeSkpXG4gICAgICAgICAgICAgICAgfSwgcHJvcHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gYW9pVmFsdWUuZ2VvbWV0cnkucmluZ3NcbiAgICAgICAgICAgICAgICAgICAgPyBtb2R1bGVzLlBvbHlnb24uZnJvbUpTT04oYW9pVmFsdWUuZ2VvbWV0cnkpXG4gICAgICAgICAgICAgICAgICAgIDogbW9kdWxlcy5FeHRlbnQuZnJvbUpTT04oYW9pVmFsdWUuZ2VvbWV0cnkpO1xuICAgICAgICAgICAgICAgIGFwcGx5TGF5ZXJBT0koZ2VvbWV0cnksIGxheWVySW5mby5pZCwgcHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gc2V0IGxheWVyIHZpc2liaWxpdHkgb24gbWFwIGFuZCByZW1vdmUgZGVmaW5pdGlvbkV4cHJlc3Npb25cbiAgICAgICAgaWYgKGxheWVyLnR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgbGF5ZXIubGF5ZXJzLmZvckVhY2goKGZMYXllcikgPT4ge1xuICAgICAgICAgICAgICAgIGZMYXllci52aXNpYmxlID0gcHJvcHMubGF5ZXJJZHMuaW5kZXhPZihmTGF5ZXIubGF5ZXJJZCkgPiAtMTtcbiAgICAgICAgICAgICAgICBmTGF5ZXIuZGVmaW5pdGlvbkV4cHJlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAoX2MgPSBsYXllci50YWJsZXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5mb3JFYWNoKCh0YWJsZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRhYmxlLmRlZmluaXRpb25FeHByZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGF5ZXIudmlzaWJsZSA9IHByb3BzLmxheWVySWRzLmluZGV4T2YobGF5ZXIubGF5ZXJJZCkgPiAtMTtcbiAgICAgICAgICAgIGxheWVyLmRlZmluaXRpb25FeHByZXNzaW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBkZWZpbmVkXG4gKiBAcGFyYW0gbGF5ZXJJZCAtIGxheWVyIGlkXG4gKi9cbmZ1bmN0aW9uIGdldFZpZXdMYXllclByb3BzKGxheWVySWQsIHByb3BzKSB7XG4gICAgY29uc3QgeyB2aWV3UHJvcHMgfSA9IHByb3BzO1xuICAgIHJldHVybiB2aWV3UHJvcHMgPT09IG51bGwgfHwgdmlld1Byb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWV3UHJvcHMuZmluZCgodmlld0xheWVyUHJvcHMpID0+IGxheWVySWQgPT09IHZpZXdMYXllclByb3BzLmxheWVySWQpO1xufVxuLyoqXG4gKiBjaGVjayBpZiBvbmUgVmlld0xheWVyUHJvcCBpcyBlbXB0eSwgdGhlbiBkZWxldGUgaXRcbiAqL1xuZnVuY3Rpb24gc2FuaXRpemVWaWV3UHJvcHMocHJvcHMpIHtcbiAgICBjb25zdCB7IHZpZXdQcm9wcyB9ID0gcHJvcHM7XG4gICAgaWYgKCF2aWV3UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwcm9wcy52aWV3UHJvcHMgPSB2aWV3UHJvcHMuZmlsdGVyKCh2aWV3TGF5ZXJQcm9wcykgPT4gdmlld0xheWVyUHJvcHMuZmlsdGVyIHx8IHZpZXdMYXllclByb3BzLmFvaSB8fCB2aWV3TGF5ZXJQcm9wcy5maWVsZHMpO1xuICAgIGlmICghcHJvcHMudmlld1Byb3BzLmxlbmd0aCkge1xuICAgICAgICBwcm9wcy52aWV3UHJvcHMgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBhZGQgcHJvcHMgZm9yIG9uZSBsYXllclxuICovXG5mdW5jdGlvbiBhZGRWaWV3TGF5ZXJQcm9wcyhsYXllcklkLCBhZGRQcm9wcywgcHJvcHMpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHZpZXdMYXllclByb3BzID0gZ2V0Vmlld0xheWVyUHJvcHMobGF5ZXJJZCwgcHJvcHMpO1xuICAgIGlmICghdmlld0xheWVyUHJvcHMpIHtcbiAgICAgICAgdmlld0xheWVyUHJvcHMgPSB7IGxheWVySWQgfTtcbiAgICB9XG4gICAgY29uc3QgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZpZXdMYXllclByb3BzKSwgYWRkUHJvcHMpO1xuICAgIHByb3BzLnZpZXdQcm9wcyA9IChfYSA9IHByb3BzLnZpZXdQcm9wcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcigodmlld0xheWVyUHJvcCkgPT4gdmlld0xheWVyUHJvcC5sYXllcklkICE9PSBsYXllcklkKTtcbiAgICBwcm9wcy52aWV3UHJvcHMgPSBwcm9wcy52aWV3UHJvcHMgfHwgW107XG4gICAgcHJvcHMudmlld1Byb3BzLnB1c2gobmV3UHJvcHMpO1xufVxuXG4vKipcbiAqIFJldHVybnMgbm9uLXZpZXcgRkxcbiAqIEBwYXJhbSBsYXllcklkIC0gbGF5ZXIgaWRcbiAqL1xuZnVuY3Rpb24gZ2V0RkwobGF5ZXJJZCwgcHJvcHMpIHtcbiAgICBjb25zdCB7IGxheWVyIH0gPSBwcm9wcztcbiAgICByZXR1cm4gbGF5ZXIudHlwZSA9PT0gXCJncm91cFwiXG4gICAgICAgID8gZ2V0TGF5ZXJzQW5kVGFibGVzKGxheWVyKS5maW5kKChseXIpID0+IGx5ci5sYXllcklkID09PSBsYXllcklkKVxuICAgICAgICA6IGxheWVyO1xufVxuLyoqXG4gKiBhcHBseSBmaWx0ZXIgdG8gbGF5ZXIgYXMgZWZmZWN0XG4gKiBAcGFyYW0gd2hlcmUgLSB3aGVyZSBjbGF1c2VcbiAqIEBwYXJhbSBsYXllcklkIC0gbGF5ZXIgaWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXBwbHlMYXllckZpbHRlcih3aGVyZSwgbGF5ZXJJZCwgcHJvcHMpIHtcbiAgICBjb25zdCBmbCA9IGdldEZMKGxheWVySWQsIHByb3BzKTtcbiAgICBpZiAoZmwuaXNUYWJsZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IFtGZWF0dXJlRWZmZWN0XSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvbGF5ZXJzL3N1cHBvcnQvRmVhdHVyZUVmZmVjdFwiXSk7XG4gICAgaWYgKHdoZXJlKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIC8vIHdhaXQgdW50aWwgdGhlIGZpbHRlciBjb21wb25lbnQgaXMgZG9uZVxuICAgICAgICBjb25zdCBpbnRlcnZhbEhhbmRsZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoISgoX2EgPSBmbC5mZWF0dXJlRWZmZWN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVmZmVjdChmbCwgRmVhdHVyZUVmZmVjdCwgcHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmwuZmVhdHVyZUVmZmVjdC5maWx0ZXIud2hlcmUgPSB3aGVyZTtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDIwMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmbC5mZWF0dXJlRWZmZWN0LmZpbHRlci53aGVyZSA9IG51bGw7XG4gICAgICAgIGlmIChpc0VmZmVjdEVtcHR5KGZsLmZlYXR1cmVFZmZlY3QpKSB7XG4gICAgICAgICAgICBmbC5mZWF0dXJlRWZmZWN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogYXBwbHkgQU9JIHRvIGxheWVyIGFzIGVmZmVjdFxuICogQHBhcmFtIGdyYXBoaWMgLSBHcmFwaGljIHdpdGggZ2VvbWV0cnlcbiAqIEBwYXJhbSBsYXllcklkIC0gbGF5ZXIgaWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXBwbHlMYXllckFPSShnZW9tZXRyeSwgbGF5ZXJJZCwgcHJvcHMpIHtcbiAgICBjb25zdCBmbCA9IGdldEZMKGxheWVySWQsIHByb3BzKTtcbiAgICBjb25zdCBbRmVhdHVyZUVmZmVjdCwgUG9seWdvbiwgRXh0ZW50XSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcbiAgICAgICAgXCJlc3JpL2xheWVycy9zdXBwb3J0L0ZlYXR1cmVFZmZlY3RcIixcbiAgICAgICAgXCJlc3JpL2dlb21ldHJ5L1BvbHlnb25cIixcbiAgICAgICAgXCJlc3JpL2dlb21ldHJ5L0V4dGVudFwiXG4gICAgXSk7XG4gICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIC8vIHdhaXQgdW50aWwgdGhlIGZpbHRlciBjb21wb25lbnQgaXMgZG9uZVxuICAgICAgICBjb25zdCBpbnRlcnZhbEhhbmRsZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoISgoX2EgPSBmbC5mZWF0dXJlRWZmZWN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVmZmVjdChmbCwgRmVhdHVyZUVmZmVjdCwgcHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ2VvbSA9IGdlb21ldHJ5LnR5cGUgPT09IFwicG9seWdvblwiID8gUG9seWdvbi5mcm9tSlNPTihnZW9tZXRyeS50b0pTT04oKSkgOiBFeHRlbnQuZnJvbUpTT04oZ2VvbWV0cnkudG9KU09OKCkpO1xuICAgICAgICAgICAgZmwuZmVhdHVyZUVmZmVjdC5maWx0ZXIuZ2VvbWV0cnkgPSBnZW9tO1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMykge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZsLmZlYXR1cmVFZmZlY3QuZmlsdGVyLmdlb21ldHJ5ID0gbnVsbDtcbiAgICAgICAgaWYgKGlzRWZmZWN0RW1wdHkoZmwuZmVhdHVyZUVmZmVjdCkpIHtcbiAgICAgICAgICAgIGZsLmZlYXR1cmVFZmZlY3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBnZXQgbmFtZSBvZiBzZXJ2aWNlIGZyb20gVVJMXG4gKiBAcGFyYW0gcG9ydGFsSXRlbSAtIF9fZXNyaS5Qb3J0YWxJdGVtXG4gKiBAcmV0dXJuIHNlcnZpY2UgbmFtZVxuICovXG5mdW5jdGlvbiBnZXRTZXJ2aWNlTmFtZShwb3J0YWxJdGVtKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgdXJsIH0gPSBwb3J0YWxJdGVtO1xuICAgIGlmICghdXJsKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCBzZXJ2ZXJUeXBlcyA9IFtcIi9GZWF0dXJlU2VydmVyXCIsIFwiL01hcFNlcnZlclwiXTtcbiAgICBjb25zdCBzZXJ2ZXJUeXBlID0gKF9hID0gc2VydmVyVHlwZXMuZmlsdGVyKCh0eXBlKSA9PiB1cmwudG9Mb3dlckNhc2UoKS5pbmRleE9mKHR5cGUudG9Mb3dlckNhc2UoKSkgPiAtMSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTtcbiAgICBsZXQgdGl0bGUgPSBcIlwiO1xuICAgIGlmIChzZXJ2ZXJUeXBlKSB7XG4gICAgICAgIHRpdGxlID0gdXJsLnN1YnN0cmluZygwLCB1cmwuaW5kZXhPZihzZXJ2ZXJUeXBlKSk7XG4gICAgICAgIHRpdGxlID0gdGl0bGUuc3Vic3RyaW5nKHRpdGxlLmxhc3RJbmRleE9mKFwiL1wiKSArIDEsIHRpdGxlLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB0aXRsZTtcbn1cbi8qKlxuICogZ2V0IG5hbWUgb2Ygc2VydmljZSBmcm9tIFVSTFxuICogQGxheWVyIGdyb3VwIGxheWVyIG9yIGFkbWluU2VydmljZUluZm9cbiAqIEByZXR1cm4gQ29sbGVjY3Rpb24gb2YgbGF5ZXJzIGFuZCB0YWJsZXNcbiAqL1xuZnVuY3Rpb24gZ2V0TGF5ZXJzQW5kVGFibGVzKGxheWVyKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKCgoX2EgPSBsYXllci5sYXllcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICYmICgoX2IgPSBsYXllci50YWJsZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBsYXllci5sYXllcnMuY29uY2F0KGxheWVyLnRhYmxlcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChfYyA9IGxheWVyLmxheWVycykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbGF5ZXIubGF5ZXJzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxheWVyLnRhYmxlcztcbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNhblN3YXAoc3dhcEl0ZW0sIHByb3BzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCB7IGxheWVySXRlbSwgbGF5ZXIsIGFkbWluU2VydmljZUluZm8sIG1vZHVsZXMsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgTGF5ZXIsIFBvcnRhbEl0ZW0gfSA9IG1vZHVsZXM7XG4gICAgcHJvcHMuc3dhcEl0ZW0gPSBwcm9wcy5zd2FwTGF5ZXIgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGxheWVySXRlbS5pZCA9PT0gc3dhcEl0ZW0uaWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcIlwiKTtcbiAgICB9XG4gICAgY29uc3QgcG9ydGFsSXRlbSA9IFBvcnRhbEl0ZW0uZnJvbUpTT04oc3dhcEl0ZW0pO1xuICAgIGF3YWl0IHBvcnRhbEl0ZW0ubG9hZCgpO1xuICAgIGNvbnN0IHN3YXBMYXllciA9IGF3YWl0IExheWVyLmZyb21Qb3J0YWxJdGVtKHtcbiAgICAgICAgcG9ydGFsSXRlbVxuICAgIH0pO1xuICAgIGlmIChsYXllci50eXBlICE9PSBzd2FwTGF5ZXIudHlwZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcImxheWVyIHR5cGUgZG9lcyBub3QgbWF0Y2gsXCIsIGxheWVyLnR5cGUsIFwiIT1cIiwgc3dhcExheWVyLnR5cGUpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHN0cmluZ3MubXNnLnN3YXBFcnJvcnMubGF5ZXJUeXBlKTtcbiAgICB9XG4gICAgaWYgKGxheWVyLnR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICAvLyBncm91cCBsYXllciBoYXMgbm8gbGF5ZXJzIG9yIHRhYmxlcyBhdCB0aGlzIHBvaW50XG4gICAgICAgIC8vIGxvYWRBbGwoKSBsb2FkcyBsYXllcnMsIHRhYmxlcyAoYXQgdjQuMjMpIGFuZCBjYXBhYmlsaXRpZXNcbiAgICAgICAgYXdhaXQgc3dhcExheWVyLmxvYWRBbGwoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFwiZmVhdHVyZVwiXG4gICAgICAgIGF3YWl0IHN3YXBMYXllci5sb2FkKCk7XG4gICAgfVxuICAgIC8vIGlmIHZpZXcgaGFzIGVkaXRvciB0cmFja2luZyBzd2FwIGhhcyB0byBoYXZlIGl0IHRvbyAoY2hlY2sgc2VydmljZSlcbiAgICAvLyBzeW5jXG4gICAgaWYgKGxheWVyLnR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICAvLyBqdXN0IG5lZWQgdG8gY2hlY2sgb25lIHN1YmxheWVyL3RhYmxlXG4gICAgICAgIGNvbnN0IGhhc1N5bmMgPSBhZG1pblNlcnZpY2VJbmZvLmxheWVyc1swXS5jYXBhYmlsaXRpZXMuaW5kZXhPZihcIlN5bmNcIikgPiAtMTtcbiAgICAgICAgY29uc3QgZmlyc3RTd2FwTHlyID0gKCgoX2EgPSBzd2FwTGF5ZXIubGF5ZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSA/IHN3YXBMYXllci5sYXllcnMgOiBzd2FwTGF5ZXIudGFibGVzKS5nZXRJdGVtQXQoMCk7XG4gICAgICAgIGNvbnN0IHN3YXBIYXNTeW5jID0gZmlyc3RTd2FwTHlyLnNvdXJjZUpTT04uY2FwYWJpbGl0aWVzLmluZGV4T2YoXCJTeW5jXCIpID4gLTE7XG4gICAgICAgIGlmIChoYXNTeW5jICE9PSBzd2FwSGFzU3luYykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJuZXcgc291cmNlIGxheWVyIFN5bmMgbm90IG1hdGNoaW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzdHJpbmdzLm1zZy5zd2FwRXJyb3JzLnN5bmMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBcImZlYXR1cmVcIlxuICAgICAgICBjb25zdCBoYXNTeW5jID0gYWRtaW5TZXJ2aWNlSW5mby5jYXBhYmlsaXRpZXMuaW5kZXhPZihcIlN5bmNcIikgPiAtMTtcbiAgICAgICAgY29uc3Qgc3dhcEhhc1N5bmMgPSBzd2FwTGF5ZXIuc291cmNlSlNPTi5jYXBhYmlsaXRpZXMuaW5kZXhPZihcIlN5bmNcIikgPiAtMTtcbiAgICAgICAgaWYgKGhhc1N5bmMgIT09IHN3YXBIYXNTeW5jKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIm5ldyBzb3VyY2UgbGF5ZXIgU3luYyBub3QgbWF0Y2hpbmdcIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHN0cmluZ3MubXNnLnN3YXBFcnJvcnMuc3luYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc2FtZSBzdWJsYXllcnNcbiAgICBpZiAobGF5ZXIudHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgICAgIC8vIGdyb3VwIGxheWVyIGhhcyBubyBsYXllcnMgb3IgdGFibGVzIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgLy8gbG9hZEFsbCgpIGxvYWRzIGxheWVycyBhbmQgdGFibGVzIChhdCB2NC4yMylcbiAgICAgICAgaWYgKCgoX2IgPSBsYXllci5sYXllcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpICE9PSAoKF9jID0gc3dhcExheWVyLmxheWVycykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkgfHwgKChfZCA9IGxheWVyLnRhYmxlcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgIT09ICgoX2UgPSBzd2FwTGF5ZXIudGFibGVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UubGVuZ3RoKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJsYXllciBzdWJsYXllcnMgY291bnQgZG9lcyBub3QgbWF0Y2hcIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHN0cmluZ3MubXNnLnN3YXBFcnJvcnMubGF5ZXJDb3VudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hhbmdlIGluIHN1YmxheWVycyBvciBmaWVsZHNcbiAgICBpZiAobGF5ZXIudHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgICAgIGNvbnN0IGxheWVyc0FuZFRhYmxlcyA9IGdldExheWVyc0FuZFRhYmxlcyhsYXllcik7XG4gICAgICAgIGNvbnN0IHN3YXBMYXllcnNBbmRUYWJsZXMgPSBnZXRMYXllcnNBbmRUYWJsZXMoc3dhcExheWVyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXllcnNBbmRUYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YkxheWVyID0gbGF5ZXJzQW5kVGFibGVzLmdldEl0ZW1BdChpKTtcbiAgICAgICAgICAgIGNvbnN0IHN3YXBTdWJMYXllciA9IHN3YXBMYXllcnNBbmRUYWJsZXMuZ2V0SXRlbUF0KGkpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInN1YmxheWVyXCIsIGksIHN1YkxheWVyLCBcIj09XCIsIHN3YXBTdWJMYXllcik7XG4gICAgICAgICAgICBsZXQgY2hlY2sgPSBjaGVja1N1YkxheWVycyhzdWJMYXllciwgc3dhcFN1YkxheWVyLCBwcm9wcyk7XG4gICAgICAgICAgICBpZiAoY2hlY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrID0gY2hlY2tGaWVsZHMoc3ViTGF5ZXIsIHN3YXBTdWJMYXllciwgcHJvcHMpO1xuICAgICAgICAgICAgaWYgKGNoZWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFwiZmVhdHVyZVwiXG4gICAgICAgIGxldCBjaGVjayA9IGNoZWNrU3ViTGF5ZXJzKGxheWVyLCBzd2FwTGF5ZXIsIHByb3BzKTtcbiAgICAgICAgaWYgKGNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNoZWNrKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVjayA9IGNoZWNrRmllbGRzKGxheWVyLCBzd2FwTGF5ZXIsIHByb3BzKTtcbiAgICAgICAgaWYgKGNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNoZWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9wcy5zd2FwSXRlbSA9IHN3YXBJdGVtO1xuICAgIHByb3BzLnN3YXBMYXllciA9IHN3YXBMYXllcjtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xufVxuYXN5bmMgZnVuY3Rpb24gc3dhcFNvdXJjZShwcm9wcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgbGV0IHsgbGF5ZXIsIGxheWVySWRzLCBtb2R1bGVzIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IFBvcnRhbEl0ZW0gfSA9IG1vZHVsZXM7XG4gICAgY29uc3QgeyB2aWV3LCBzd2FwSXRlbSwgc3dhcExheWVyIH0gPSBwcm9wcztcbiAgICBjb25zdCBbZXNyaVJlcXVlc3RdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9yZXF1ZXN0XCJdKTtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBlbXB0eVZpZXcocHJvcHMsIGVzcmlSZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgcG9ydGFsSXRlbSA9IFBvcnRhbEl0ZW0uZnJvbUpTT04oc3dhcEl0ZW0pO1xuICAgICAgICBhd2FpdCBwb3J0YWxJdGVtLmxvYWQoKTtcbiAgICAgICAgLy9jb25zdCBvbGRMYXllckl0ZW0gPSBwcm9wcy5sYXllckl0ZW07XG4gICAgICAgIC8vY29uc3Qgb2xkTGF5ZXIgPSBsYXllcjtcbiAgICAgICAgcHJvcHMubGF5ZXJJdGVtID0gcG9ydGFsSXRlbTtcbiAgICAgICAgcHJvcHMubGF5ZXIgPSBzd2FwTGF5ZXI7XG4gICAgICAgIHByb3BzLnN3YXBJdGVtID0gcHJvcHMuc3dhcExheWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyB3ZSB3YW50IHRvIGJlaGF2ZSBhcyBpZiB3ZSdyZSBjcmVhdGluZyBhIG5ldyB2aWV3XG4gICAgICAgIC8vIGN1cnJlbnQgc2V0dGluZ3MgYXJlIGJhc2VkIG9mZiB0aGUgc291cmNlIGl0ZW1cbiAgICAgICAgY29uc3Qgc2F2ZWRWaWV3SXRlbSA9IHByb3BzLnZpZXdJdGVtO1xuICAgICAgICBwcm9wcy52aWV3SXRlbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcHJvcHMuYWRtaW5TZXJ2aWNlSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgYXdhaXQgZ2V0QWRtaW5TZXJ2aWNlSW5mbyQxKHByb3BzKTtcbiAgICAgICAgYXdhaXQgaW5pdGlhbEFkZFRvRGVmaW5pdGlvbihwcm9wcywgeyBzZXJ2aWNldXJsOiBzYXZlZFZpZXdJdGVtLnVybCB9LCBlc3JpUmVxdWVzdCk7XG4gICAgICAgIHByb3BzLnZpZXdJdGVtID0gc2F2ZWRWaWV3SXRlbTtcbiAgICAgICAgLy8gbm93IGdldCB2aWV3IGluZm9cbiAgICAgICAgcHJvcHMuYWRtaW5TZXJ2aWNlSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgYXdhaXQgZ2V0QWRtaW5TZXJ2aWNlSW5mbyQxKHByb3BzKTtcbiAgICAgICAgLyogY29uc29sZS5sb2coXG4gICAgICAgICAgXCJ2aWV3IGFkbWluU2VydmljZUluZm8gbGF5ZXJzXCIsXG4gICAgICAgICAgcHJvcHMuYWRtaW5TZXJ2aWNlSW5mbz8ubGF5ZXJzPy5tYXAoKGx5cjogYW55KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpZDogbHlyLmlkLFxuICAgICAgICAgICAgICBuYW1lOiBseXIubmFtZSxcbiAgICAgICAgICAgICAgYWRtaW5MYXllckluZm9fZmlsdGVyOiBseXIuYWRtaW5MYXllckluZm8/LnZpZXdMYXllckRlZmluaXRpb24/LnRhYmxlPy5maWx0ZXI/LnZhbHVlLFxuICAgICAgICAgICAgICB2aWV3RGVmaW5pdGlvblF1ZXJ5OiBseXIudmlld0RlZmluaXRpb25RdWVyeSxcbiAgICAgICAgICAgICAgZmllbGRzOiBseXIuZmllbGRzLm1hcCgoZmllbGQ6IGFueSkgPT4gYCR7ZmllbGQubmFtZX0gKCR7ZmllbGQudmlzaWJsZX0pYClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgKTsgKi9cbiAgICAgICAgLy8gdXBkYXRlIG1hcFxuICAgICAgICB2aWV3Lm1hcC5yZW1vdmUobGF5ZXIpO1xuICAgICAgICBsYXllciA9IHByb3BzLmxheWVyO1xuICAgICAgICBpZiAobGF5ZXIudHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgICAgICAgICBpZiAoKF9hID0gbGF5ZXIubGF5ZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFzIGF0IGxlYXN0IG9uZSBzcGF0aWFsIGxheWVyXG4gICAgICAgICAgICAgICAgaWYgKGxheWVySWRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgbWFrZSBpbmNsdWRlZCBzdWJsYXllcnMgdmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICBsYXllci5sYXllcnMuZm9yRWFjaCgoc3ViTGF5ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YkxheWVyLnZpc2libGUgPSBsYXllcklkcy5pbmRleE9mKHN1YkxheWVyLmxheWVySWQpID4gLTE7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aWV3Lm1hcC5hZGQobGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVmYXVsdCBwb3B1cHNcbiAgICAgICAgICAgIChfYiA9IGxheWVyLmxheWVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZvckVhY2goKGx5cikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghbHlyLnBvcHVwVGVtcGxhdGUgJiYgbHlyLnBvcHVwRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBseXIucG9wdXBUZW1wbGF0ZSA9IGx5ci5jcmVhdGVQb3B1cFRlbXBsYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWxheWVyLmlzVGFibGUpIHtcbiAgICAgICAgICAgICAgICB2aWV3Lm1hcC5hZGQobGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVmYXVsdCBwb3B1cFxuICAgICAgICAgICAgbGF5ZXIucG9wdXBUZW1wbGF0ZSA9IGxheWVyLmNyZWF0ZVBvcHVwVGVtcGxhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSBjb3JyZWN0IGZpbHRlciBhbmQgQU9JIG9uIG1hcFxuICAgICAgICBnZXRMYXllcnNBbmRUYWJsZXMocHJvcHMuYWRtaW5TZXJ2aWNlSW5mbykuZm9yRWFjaChhc3luYyAobGF5ZXJJbmZvKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICBjb25zdCB3aGVyZUNsYXVzZSA9IGxheWVySW5mby52aWV3RGVmaW5pdGlvblF1ZXJ5O1xuICAgICAgICAgICAgaWYgKHdoZXJlQ2xhdXNlKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlMYXllckZpbHRlcih3aGVyZUNsYXVzZSwgbGF5ZXJJbmZvLmlkLCBwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhb2lWYWx1ZSA9IChfZCA9IChfYyA9IChfYiA9IChfYSA9IGxheWVySW5mby5hZG1pbkxheWVySW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZpZXdMYXllckRlZmluaXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50YWJsZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZpbHRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGFvaVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBhb2lWYWx1ZS5nZW9tZXRyeS5yaW5nc1xuICAgICAgICAgICAgICAgICAgICA/IG1vZHVsZXMuUG9seWdvbi5mcm9tSlNPTihhb2lWYWx1ZS5nZW9tZXRyeSlcbiAgICAgICAgICAgICAgICAgICAgOiBtb2R1bGVzLkV4dGVudC5mcm9tSlNPTihhb2lWYWx1ZS5nZW9tZXRyeSk7XG4gICAgICAgICAgICAgICAgYXBwbHlMYXllckFPSShnZW9tZXRyeSwgbGF5ZXJJbmZvLmlkLCBwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInN3YXAgc291cmNlIGZhaWxlZFwiKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU3ViTGF5ZXJzKGxheWVyLCBzd2FwTGF5ZXIsIHByb3BzKSB7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBpZiAobGF5ZXIuZ2VvbWV0cnlUeXBlICE9PSBzd2FwTGF5ZXIuZ2VvbWV0cnlUeXBlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibGF5ZXIgZ2VvbWV0cnkgdHlwZSBkb2VzIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ3MubXNnLnN3YXBFcnJvcnMuZ2VvbWV0cnlUeXBlO1xuICAgIH1cbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkobGF5ZXIuc3BhdGlhbFJlZmVyZW5jZS50b0pTT04oKSkgIT09IEpTT04uc3RyaW5naWZ5KHN3YXBMYXllci5zcGF0aWFsUmVmZXJlbmNlLnRvSlNPTigpKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcImxheWVyIHNwYXRpYWwgcmVmZXJlbmNlIGRvZXMgbm90IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gc3RyaW5ncy5tc2cuc3dhcEVycm9ycy5zcGF0aWFsUmVmZXJlbmNlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNoZWNrRmllbGRzKGxheWVyLCBzd2FwTGF5ZXIsIHByb3BzKSB7XG4gICAgLy8gYWxsIHZpc2libGUgZmllbGRzIGluIGN1cnJlbnQgdmlldyBtdXN0IGJlIGNvbnRhaW5lZCBpbiBuZXcgc291cmNlXG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBjb25zdCByZXF1aXJlZEZpZWxkTmFtZXMgPSBnZXRSZXF1aXJlZEZpZWxkTmFtZXMocHJvcHMsIGxheWVyKTtcbiAgICBjb25zdCB2aWV3TGF5ZXJQcm9wcyA9IGdldFZpZXdMYXllclByb3BzKGxheWVyLmxheWVySWQsIHByb3BzKTtcbiAgICBsZXQgdmlzRmllbGRzO1xuICAgIGlmICh2aWV3TGF5ZXJQcm9wcyA9PT0gbnVsbCB8fCB2aWV3TGF5ZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlld0xheWVyUHJvcHMuZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGFsbEZpZWxkcyA9IHZpZXdMYXllclByb3BzLmZpZWxkcy5jb25jYXQocmVxdWlyZWRGaWVsZE5hbWVzKTtcbiAgICAgICAgdmlzRmllbGRzID0gbGF5ZXIuZmllbGRzLmZpbHRlcigoZmllbGQpID0+IGFsbEZpZWxkcy5pbmRleE9mKGZpZWxkLm5hbWUpID4gLTEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlzRmllbGRzID0gbGF5ZXIuZmllbGRzO1xuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKFwiY2hlY2tGaWVsZHMgLSB2aXNGaWVsZHNcIiwgdmlzRmllbGRzLm1hcCgoZikgPT5mLm5hbWUpKTtcbiAgICAvL2NvbnNvbGUubG9nKFwic3dhcExheWVyIC0gZmllbGRzXCIsIHN3YXBMYXllci5maWVsZHMubWFwKChmKSA9PiBmLm5hbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpc0ZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmaWVsZCA9IHZpc0ZpZWxkc1tpXTtcbiAgICAgICAgY29uc3Qgc3dhcEZpZWxkID0gc3dhcExheWVyLmZpZWxkcy5maW5kKChzd2FwRmllbGQpID0+IGZpZWxkLm5hbWUgPT09IHN3YXBGaWVsZC5uYW1lKTtcbiAgICAgICAgaWYgKCFzd2FwRmllbGQpIHtcbiAgICAgICAgICAgIC8vaWYgKFtcImdsb2JhbC1pZFwiLCBcIm9pZFwiXS5pbmRleE9mKGZpZWxkLnR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJsYXllclwiLCBsYXllci5sYXllcklkLCBsYXllci50aXRsZSwgXCI6IGZpZWxkXCIsIGZpZWxkLm5hbWUsIFwibWlzc2luZyBpbiBuZXcgc291cmNlIGxheWVyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3MubXNnLnN3YXBFcnJvcnMubWlzc2luZ0ZpZWxkO1xuICAgICAgICAgICAgLy99IGVsc2Uge1xuICAgICAgICAgICAgLy8gIGNvbnNvbGUubG9nKFwiZmllbGRcIiwgZmllbGQubmFtZSwgXCJtaXNzaW5nIGluIG5ldyBzb3VyY2UgbGF5ZXIsIGlnbm9yaW5nXCIpO1xuICAgICAgICAgICAgLy99XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGQudHlwZSAhPT0gc3dhcEZpZWxkLnR5cGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibGF5ZXJcIiwgbGF5ZXIubGF5ZXJJZCwgbGF5ZXIudGl0bGUsIFwiOiBmaWVsZCB0eXBlIG9mXCIsIGZpZWxkLm5hbWUsIFwiZGlmZmVyZW50IGluIGxheWVyc1wiKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm1zZy5zd2FwRXJyb3JzLmZpZWxkVHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBnZXQgYSBzdWdnZXN0ZWQgdGl0bGUgZm9yIHRoZSB2aWV3XG4gKiBAcGFyYW0gcHJvcHMgLSBMYXllclZpZXdQcm9wc1xuICovXG5hc3luYyBmdW5jdGlvbiBnZXRTdWdnZXN0ZWRUaXRsZShwcm9wcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBsYXllckl0ZW0sIGxheWVyLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBjb25zdCBbZXNyaVJlcXVlc3RdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9yZXF1ZXN0XCJdKTtcbiAgICBjb25zdCByZWxhdGVkVXJsID0gYCR7bGF5ZXJJdGVtLml0ZW1Vcmx9L3JlbGF0ZWRJdGVtc2A7XG4gICAgY29uc3QgcmVsYXRlZENvbnRlbnQgPSB7XG4gICAgICAgIHJlbGF0aW9uc2hpcFR5cGU6IFwiU2VydmljZTJTZXJ2aWNlXCIsXG4gICAgICAgIGRpcmVjdGlvbjogXCJmb3J3YXJkXCJcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVzcmlSZXF1ZXN0KHJlbGF0ZWRVcmwsIHtcbiAgICAgICAgcXVlcnk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVsYXRlZENvbnRlbnQpLCB7IGY6IFwianNvblwiLCB0b2tlbjogbGF5ZXIucG9ydGFsSXRlbS5wb3J0YWwuY3JlZGVudGlhbC50b2tlbiB9KSxcbiAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgcmVzcG9uc2VUeXBlOiBcImpzb25cIlxuICAgIH0pO1xuICAgIC8vIGNoZWNrIHdpdGggc3BhY2VzIGFuZCB1bmRlcnNjb3Jlc1xuICAgIGNvbnN0IHZpZXdJdGVtcyA9ICgoX2IgPSAoX2EgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbGF0ZWRJdGVtcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZpbHRlcigoaXRlbSkgPT4gaXRlbS50eXBlID09PSBcIkZlYXR1cmUgU2VydmljZVwiICYmXG4gICAgICAgIChpdGVtLnRpdGxlLmluZGV4T2YobGF5ZXJJdGVtLnRpdGxlKSA+IC0xIHx8XG4gICAgICAgICAgICBpdGVtLnRpdGxlLmluZGV4T2YobGF5ZXJJdGVtLnRpdGxlLnJlcGxhY2UoLyAvZywgXCJfXCIpKSA+IC0xIHx8XG4gICAgICAgICAgICBpdGVtLnRpdGxlLnJlcGxhY2UoLyAvZywgXCJfXCIpLmluZGV4T2YobGF5ZXJJdGVtLnRpdGxlKSA+IC0xKSkpIHx8IFtdO1xuICAgIHJldHVybiBgJHtsYXllckl0ZW0udGl0bGV9JHt2aWV3SXRlbXMubGVuZ3RoID8gYCAke3ZpZXdJdGVtcy5sZW5ndGggKyAxfWAgOiBgYH0gJHtzdHJpbmdzLmNyZWF0ZVZpZXcudmlld31gO1xufVxuLyoqXG4gKiBNYWtlIGFkbWluIHNlcnZpY2UgaW5mbyByZXF1ZXN0IGZvciB2aWV3IGxheWVyXG4gKiBAcGFyYW0gcHJvcHMgLSBMYXllclZpZXdQcm9wc1xuICovXG5hc3luYyBmdW5jdGlvbiBnZXRBZG1pblNlcnZpY2VJbmZvJDEocHJvcHMsIG5vQ2FjaGUpIHtcbiAgICBjb25zdCB7IGxheWVyLCB2aWV3SXRlbSwgYWRtaW5TZXJ2aWNlSW5mbyB9ID0gcHJvcHM7XG4gICAgaWYgKGFkbWluU2VydmljZUluZm8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZXJ2aWNlVXJsID0gKHZpZXdJdGVtID09PSBudWxsIHx8IHZpZXdJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWV3SXRlbS51cmwpIHx8IGxheWVyLnBvcnRhbEl0ZW0udXJsO1xuICAgIGxldCBhZG1pblVybCA9IHNlcnZpY2VVcmwucmVwbGFjZShcIi9yZXN0L3NlcnZpY2VzXCIsIFwiL3Jlc3QvYWRtaW4vc2VydmljZXNcIik7XG4gICAgaWYgKG5vQ2FjaGUpIHtcbiAgICAgICAgYWRtaW5VcmwgKz0gYCR7YWRtaW5VcmwuaW5kZXhPZihcIj9cIikgPiAtMSA/IFwiJlwiIDogXCI/XCJ9X3RzPSR7bmV3IERhdGUoKS5nZXRUaW1lKCl9YDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgW0lkZW50aXR5TWFuYWdlciwgZXNyaVJlcXVlc3RdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9pZGVudGl0eS9JZGVudGl0eU1hbmFnZXJcIiwgXCJlc3JpL3JlcXVlc3RcIl0pO1xuICAgICAgICBhd2FpdCBJZGVudGl0eU1hbmFnZXIuZ2V0Q3JlZGVudGlhbChhZG1pblVybCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZXNyaVJlcXVlc3QoYWRtaW5VcmwsIHtcbiAgICAgICAgICAgIHF1ZXJ5OiB7IGY6IFwianNvblwiIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHByb3BzLmFkbWluU2VydmljZUluZm8gPSByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcImNvdWxkIG5vdCBnZXQgYWRtaW4gaW5mb1wiKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBsYXllciB2aWV3XG4gKiBAcGFyYW0gbGF5ZXJJZCAtIGxheWVyIGlkXG4gKiBAcGFyYW0gcHJvcHMgLSBMYXllclZpZXdQcm9wc1xuICovXG5mdW5jdGlvbiBnZXRBZG1pbkxheWVySW5mbyhsYXllcklkLCBwcm9wcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBhZG1pblNlcnZpY2VJbmZvIH0gPSBwcm9wcztcbiAgICBjb25zdCBsYXllciA9IChfYSA9IGFkbWluU2VydmljZUluZm8gPT09IG51bGwgfHwgYWRtaW5TZXJ2aWNlSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWRtaW5TZXJ2aWNlSW5mby5sYXllcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maW5kKChsYXllcikgPT4gbGF5ZXIuaWQgPT09IGxheWVySWQpO1xuICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuIChfYiA9IGFkbWluU2VydmljZUluZm8gPT09IG51bGwgfHwgYWRtaW5TZXJ2aWNlSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWRtaW5TZXJ2aWNlSW5mby50YWJsZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5maW5kKCh0YWJsZSkgPT4gdGFibGUuaWQgPT09IGxheWVySWQpO1xuICAgIH1cbiAgICByZXR1cm4gbGF5ZXI7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdXNlciBtYWRlIHJlY2VudCBjaGFuZ2VzXG4gKiBAcGFyYW0gcHJvcHNcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqL1xuZnVuY3Rpb24gaGFzQ2hhbmdlcyhwcm9wcykge1xuICAgIGNvbnN0IHsgbGF5ZXIsIGxheWVySWRzLCBhZG1pblNlcnZpY2VJbmZvIH0gPSBwcm9wcztcbiAgICBpZiAobGF5ZXIudHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgICAgIGNvbnN0IGxheWVyc0FuZFRhYmxlcyA9IGFkbWluU2VydmljZUluZm8gJiYgZ2V0TGF5ZXJzQW5kVGFibGVzKGFkbWluU2VydmljZUluZm8pO1xuICAgICAgICBjb25zdCBjb250YWluc0FsbExheWVycyA9IGFkbWluU2VydmljZUluZm8gJiZcbiAgICAgICAgICAgIGxheWVyc0FuZFRhYmxlcy5sZW5ndGggPT09IGxheWVySWRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgbGF5ZXJzQW5kVGFibGVzLmV2ZXJ5KChseXIpID0+IGxheWVySWRzLmluZGV4T2YobHlyLmlkKSA+IC0xKTtcbiAgICAgICAgcmV0dXJuICghY29udGFpbnNBbGxMYXllcnMgfHxcbiAgICAgICAgICAgIGdldExheWVyc0FuZFRhYmxlcyhsYXllcilcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChmTGF5ZXIpID0+IGxheWVySWRzLmluZGV4T2YoZkxheWVyLmxheWVySWQpID4gLTEpXG4gICAgICAgICAgICAgICAgLnNvbWUoKGZMYXllcikgPT4gaGFzTGF5ZXJDaGFuZ2VzKGZMYXllci5sYXllcklkLCBwcm9wcykpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBoYXNMYXllckNoYW5nZXMobGF5ZXIubGF5ZXJJZCwgcHJvcHMpO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB1c2VyIG1hZGUgcmVjZW50IGNoYW5nZXMgdG8gdGhlIGZlYXR1cmUgbGF5ZXJcbiAqIEBwYXJhbSBsYXllcklkXG4gKiBAcGFyYW0gcHJvcHNcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGhhc0xheWVyQ2hhbmdlcyhsYXllcklkLCBwcm9wcykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCB7IHZpZXdJdGVtIH0gPSBwcm9wcztcbiAgICBjb25zdCBmTGF5ZXIgPSBnZXRGTChsYXllcklkLCBwcm9wcyk7XG4gICAgY29uc3Qgdmlld0xheWVyUHJvcHMgPSBnZXRWaWV3TGF5ZXJQcm9wcyhsYXllcklkLCBwcm9wcyk7XG4gICAgY29uc3QgYWRtaW5MYXllckluZm8gPSBnZXRBZG1pbkxheWVySW5mbyhsYXllcklkLCBwcm9wcyk7XG4gICAgLy8gaWdub3JlIGZpZWxkLnZpc2libGUgcHJvcCBvbiBwYXJlbnQgbGF5ZXJzXG4gICAgY29uc3Qgdmlld0ZpZWxkcyA9IHZpZXdJdGVtICYmIChhZG1pbkxheWVySW5mbyA9PT0gbnVsbCB8fCBhZG1pbkxheWVySW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWRtaW5MYXllckluZm8uZmllbGRzKVxuICAgICAgICA/IGFkbWluTGF5ZXJJbmZvLmZpZWxkcy5maWx0ZXIoKGZpZWxkKSA9PiBmaWVsZC52aXNpYmxlKVxuICAgICAgICA6IChhZG1pbkxheWVySW5mbyA9PT0gbnVsbCB8fCBhZG1pbkxheWVySW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWRtaW5MYXllckluZm8uZmllbGRzKSB8fCBmTGF5ZXIuZmllbGRzO1xuICAgIGlmICh2aWV3TGF5ZXJQcm9wcykge1xuICAgICAgICBpZiAodmlld0xheWVyUHJvcHMuZmlsdGVyICE9PSAoYWRtaW5MYXllckluZm8gPT09IG51bGwgfHwgYWRtaW5MYXllckluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkbWluTGF5ZXJJbmZvLnZpZXdEZWZpbml0aW9uUXVlcnkpIHx8XG4gICAgICAgICAgICAhISh2aWV3TGF5ZXJQcm9wcy5maWVsZHMgJiYgdmlld0xheWVyUHJvcHMuZmllbGRzLmxlbmd0aCAhPT0gdmlld0ZpZWxkcy5sZW5ndGgpIHx8XG4gICAgICAgICAgICAhISghdmlld0xheWVyUHJvcHMuZmllbGRzICYmIHZpZXdGaWVsZHMubGVuZ3RoICE9PSBmTGF5ZXIuZmllbGRzLmxlbmd0aCkgfHxcbiAgICAgICAgICAgICghZkxheWVyLmlzVGFibGUgJiYgIWlzU2FtZUFPSSh2aWV3TGF5ZXJQcm9wcywgYWRtaW5MYXllckluZm8pKSkge1xuICAgICAgICAgICAgLyogY29uc29sZS5sb2coXG4gICAgICAgICAgICAgIFwiaGFzTGF5ZXJDaGFuZ2VzPXRydWUgKHByb3BzKSBpZDpcIixcbiAgICAgICAgICAgICAgbGF5ZXJJZCxcbiAgICAgICAgICAgICAgXCJmaWx0ZXI6XCIsXG4gICAgICAgICAgICAgIHZpZXdMYXllclByb3BzLmZpbHRlciAhPT0gYWRtaW5MYXllckluZm8/LnZpZXdEZWZpbml0aW9uUXVlcnksXG4gICAgICAgICAgICAgIC8vYCgke3ZpZXdMYXllclByb3BzLmZpbHRlcn18JHthZG1pbkxheWVySW5mbz8udmlld0RlZmluaXRpb25RdWVyeX0pYCxcbiAgICAgICAgICAgICAgXCJmaWVsZHMtaGFzLXByb3BzOlwiLFxuICAgICAgICAgICAgICAhISh2aWV3TGF5ZXJQcm9wcy5maWVsZHMgJiYgdmlld0xheWVyUHJvcHMuZmllbGRzLmxlbmd0aCAhPT0gdmlld0ZpZWxkcy5sZW5ndGgpLFxuICAgICAgICAgICAgICBcImZpZWxkcy1uby1wcm9wczpcIixcbiAgICAgICAgICAgICAgISEoIXZpZXdMYXllclByb3BzLmZpZWxkcyAmJiB2aWV3RmllbGRzLmxlbmd0aCAhPT0gZkxheWVyLmZpZWxkcy5sZW5ndGgpLFxuICAgICAgICAgICAgICBcIiFzYW1lQU9JOlwiLFxuICAgICAgICAgICAgICAhaXNTYW1lQU9JKHZpZXdMYXllclByb3BzLCBhZG1pbkxheWVySW5mbylcbiAgICAgICAgICAgICk7ICovXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKChhZG1pbkxheWVySW5mbyA9PT0gbnVsbCB8fCBhZG1pbkxheWVySW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWRtaW5MYXllckluZm8udmlld0RlZmluaXRpb25RdWVyeSkgfHxcbiAgICAgICAgICAgIHZpZXdGaWVsZHMubGVuZ3RoIDwgZkxheWVyLmZpZWxkcy5sZW5ndGggfHxcbiAgICAgICAgICAgICghZkxheWVyLmlzVGFibGUgJiYgKChfZCA9IChfYyA9IChfYiA9IChfYSA9IGFkbWluTGF5ZXJJbmZvID09PSBudWxsIHx8IGFkbWluTGF5ZXJJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZG1pbkxheWVySW5mby5hZG1pbkxheWVySW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZpZXdMYXllckRlZmluaXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50YWJsZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZpbHRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnZhbHVlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogQ3JlYXRlcyBsYXllciB2aWV3XG4gKiBAcGFyYW0gcHJvcHMgLSBMYXllclZpZXdQcm9wc1xuICogQHBhcmFtIG5ld0l0ZW1Qcm9wcyAtIHVzZXIgaW5wdXQgKE5ld0l0ZW1Qcm9wcylcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlVmlldyhwcm9wcywgbmV3SXRlbVByb3BzKSB7XG4gICAgY29uc3QgW2VzcmlSZXF1ZXN0XSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvcmVxdWVzdFwiXSk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY3JlYXRlU2VydmljZVJlc3BvbnNlID0gYXdhaXQgY3JlYXRlU2VydmljZShwcm9wcywgbmV3SXRlbVByb3BzLCBlc3JpUmVxdWVzdCk7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJjcmVhdGVTZXJ2aWNlUmVzcG9uc2VcIiwgY3JlYXRlU2VydmljZVJlc3BvbnNlKTtcbiAgICAgICAgYXdhaXQgaW5pdGlhbEFkZFRvRGVmaW5pdGlvbihwcm9wcywgY3JlYXRlU2VydmljZVJlc3BvbnNlLCBlc3JpUmVxdWVzdCk7XG4gICAgICAgIGF3YWl0IGluaXRpYWxJdGVtVXBkYXRlKHByb3BzLCBjcmVhdGVTZXJ2aWNlUmVzcG9uc2UsIG5ld0l0ZW1Qcm9wcywgZXNyaVJlcXVlc3QpO1xuICAgICAgICBhd2FpdCBtb3ZlVG9Gb2xkZXIocHJvcHMsIGNyZWF0ZVNlcnZpY2VSZXNwb25zZSwgbmV3SXRlbVByb3BzLCBlc3JpUmVxdWVzdCk7XG4gICAgICAgIHJldHVybiBjcmVhdGVTZXJ2aWNlUmVzcG9uc2UuaXRlbUlkO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGUubWVzc2FnZSA9PT0gXCJzZXJ2aWNlIG5hbWUgYWxyZWFkeSBleGlzdHNcIikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJjcmVhdGVWaWV3IGZhaWxlZFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBsYXllciB2aWV3XG4gKiBAcGFyYW0gcHJvcHMgLSBMYXllclZpZXdQcm9wc1xuICovXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVWaWV3KHByb3BzKSB7XG4gICAgY29uc3QgeyB2aWV3SXRlbSB9ID0gcHJvcHM7XG4gICAgY29uc3QgW2VzcmlSZXF1ZXN0XSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvcmVxdWVzdFwiXSk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBhZGRMYXllcklkcywgZGVsZXRlTGF5ZXJJZHMgfSA9IGF3YWl0IHVwZGF0ZURlZmluaXRpb24ocHJvcHMsIHZpZXdJdGVtLCBlc3JpUmVxdWVzdCk7XG4gICAgICAgIGF3YWl0IGl0ZW1VcGRhdGUocHJvcHMsIGFkZExheWVySWRzLCBkZWxldGVMYXllcklkcywgZXNyaVJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwidXBkYXRlVmlldyBmYWlsZWRcIikpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFJlbW92ZXMgYWxsIGxheWVycyBmcm9tIHRoZSB2aWV3XG4gKiBAcGFyYW0gcHJvcHMgLSBMYXllclZpZXdQcm9wc1xuICovXG5hc3luYyBmdW5jdGlvbiBlbXB0eVZpZXcocHJvcHMsIGVzcmlSZXF1ZXN0KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IGxheWVyLCB2aWV3SXRlbSwgYWRtaW5TZXJ2aWNlSW5mbyB9ID0gcHJvcHM7XG4gICAgY29uc3QgcG9ydGFsSXRlbSA9IGxheWVyLnBvcnRhbEl0ZW07XG4gICAgLy8gZGVsZXRlXG4gICAgY29uc3QgZGVsZXRlTGF5ZXJJZHMgPSBbXTtcbiAgICAoX2EgPSBhZG1pblNlcnZpY2VJbmZvID09PSBudWxsIHx8IGFkbWluU2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkbWluU2VydmljZUluZm8ubGF5ZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgobHlyKSA9PiB7XG4gICAgICAgIGRlbGV0ZUxheWVySWRzLnB1c2gobHlyLmlkKTtcbiAgICB9KTtcbiAgICBjb25zdCBkZWxldGVUYWJsZUlkcyA9IFtdO1xuICAgIChfYiA9IGFkbWluU2VydmljZUluZm8gPT09IG51bGwgfHwgYWRtaW5TZXJ2aWNlSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWRtaW5TZXJ2aWNlSW5mby50YWJsZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mb3JFYWNoKChseXIpID0+IHtcbiAgICAgICAgZGVsZXRlVGFibGVJZHMucHVzaChseXIuaWQpO1xuICAgIH0pO1xuICAgIGlmIChkZWxldGVMYXllcklkcy5sZW5ndGggfHwgZGVsZXRlVGFibGVJZHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGFkbWluVXJsID0gdmlld0l0ZW0udXJsLnJlcGxhY2UoXCJyZXN0L3NlcnZpY2VzXCIsIFwicmVzdC9hZG1pbi9zZXJ2aWNlc1wiKTtcbiAgICAgICAgY29uc3QgZGVsZXRlRnJvbURlZlVybCA9IGAke2FkbWluVXJsfS9kZWxldGVGcm9tRGVmaW5pdGlvbmA7XG4gICAgICAgIGF3YWl0IGRlbGV0ZUZyb21EZWZpbml0aW9uUmVxdWVzdChkZWxldGVGcm9tRGVmVXJsLCB7XG4gICAgICAgICAgICBsYXllcnM6IGRlbGV0ZUxheWVySWRzID09PSBudWxsIHx8IGRlbGV0ZUxheWVySWRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWxldGVMYXllcklkcy5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaWQgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGFibGVzOiBkZWxldGVUYWJsZUlkcyA9PT0gbnVsbCB8fCBkZWxldGVUYWJsZUlkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVsZXRlVGFibGVJZHMubWFwKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGlkIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCBwb3J0YWxJdGVtLCBlc3JpUmVxdWVzdCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc1NhbWVBT0kodmlld0xheWVyUHJvcHMsIGFkbWluTGF5ZXJJbmZvKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IGFkbWluQU9JVmFsdWUgPSAoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSBhZG1pbkxheWVySW5mbyA9PT0gbnVsbCB8fCBhZG1pbkxheWVySW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWRtaW5MYXllckluZm8uYWRtaW5MYXllckluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52aWV3TGF5ZXJEZWZpbml0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudGFibGUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5maWx0ZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC52YWx1ZTtcbiAgICAvL2NvbnNvbGUubG9nKFwiaXNTYW1lQU9JIGFkbWluOlwiLCBhZG1pbkFPSVZhbHVlPy5nZW9tZXRyeSwgXCJwcm9wOlwiLCB2aWV3TGF5ZXJQcm9wcz8uYW9pKTtcbiAgICBpZiAoISh2aWV3TGF5ZXJQcm9wcyA9PT0gbnVsbCB8fCB2aWV3TGF5ZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlld0xheWVyUHJvcHMuYW9pKSAmJiAhYWRtaW5BT0lWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKCh2aWV3TGF5ZXJQcm9wcyA9PT0gbnVsbCB8fCB2aWV3TGF5ZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlld0xheWVyUHJvcHMuYW9pKSAmJiAhYWRtaW5BT0lWYWx1ZSkgfHwgKCEodmlld0xheWVyUHJvcHMgPT09IG51bGwgfHwgdmlld0xheWVyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZXdMYXllclByb3BzLmFvaSkgJiYgYWRtaW5BT0lWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoKHZpZXdMYXllclByb3BzLmFvaS5yaW5ncyAmJiBhZG1pbkFPSVZhbHVlLmdlb21ldHJ5VHlwZSAhPT0gXCJlc3JpR2VvbWV0cnlQb2x5Z29uXCIpIHx8XG4gICAgICAgICh2aWV3TGF5ZXJQcm9wcy5hb2kueG1pbiAmJiBhZG1pbkFPSVZhbHVlLmdlb21ldHJ5VHlwZSAhPT0gXCJlc3JpR2VvbWV0cnlFbnZlbG9wZVwiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2aWV3TGF5ZXJQcm9wcy5hb2kueG1pbikge1xuICAgICAgICBjb25zdCBwcm9wc0V4dCA9IHZpZXdMYXllclByb3BzLmFvaTtcbiAgICAgICAgY29uc3QgYWRtaW5FeHQgPSBhZG1pbkFPSVZhbHVlLmdlb21ldHJ5O1xuICAgICAgICAvLyBjb21wYXJlIGNvb3JkcyB3aXRoIGEgbWFyZ2luOyBzZXJ2aWNlIHJvdW5kcyBwYXNzZWQgaW4gY29vcmRzXG4gICAgICAgIGlmIChzYW1lQ29vcmQocHJvcHNFeHQueG1pbiwgYWRtaW5FeHQueG1pbikgJiZcbiAgICAgICAgICAgIHNhbWVDb29yZChwcm9wc0V4dC54bWF4LCBhZG1pbkV4dC54bWF4KSAmJlxuICAgICAgICAgICAgc2FtZUNvb3JkKHByb3BzRXh0LnltaW4sIGFkbWluRXh0LnltaW4pICYmXG4gICAgICAgICAgICBzYW1lQ29vcmQocHJvcHNFeHQueW1heCwgYWRtaW5FeHQueW1heCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHZpZXdMYXllclByb3BzLmFvaS5yaW5ncykge1xuICAgICAgICBpZiAodmlld0xheWVyUHJvcHMuYW9pLnJpbmdzWzBdLmxlbmd0aCAhPT0gYWRtaW5BT0lWYWx1ZS5nZW9tZXRyeS5yaW5nc1swXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlzU2FtZSA9IHZpZXdMYXllclByb3BzLmFvaS5yaW5nc1swXS5ldmVyeSgocHQxKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkbWluQU9JVmFsdWUuZ2VvbWV0cnkucmluZ3NbMF0uc29tZSgocHQyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgY29vcmRzIHdpdGggYSBtYXJnaW47IHNlcnZpY2Ugcm91bmRzIHBhc3NlZCBpbiBjb29yZHNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNhbWVDb29yZChwdDFbMF0sIHB0MlswXSkgJiYgc2FtZUNvb3JkKHB0MVsxXSwgcHQyWzFdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGlzU2FtZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNlcnZpY2UocHJvcHMsIG5ld0l0ZW1Qcm9wcywgZXNyaVJlcXVlc3QpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCB7IGxheWVyLCBsYXllcklkcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgcG9ydGFsSXRlbSA9IGxheWVyLnBvcnRhbEl0ZW07XG4gICAgY29uc3QgcG9ydGFsID0gcG9ydGFsSXRlbS5wb3J0YWw7XG4gICAgbGV0IGZsID0gZ2V0RkwobGF5ZXJJZHNbMF0sIHByb3BzKTtcbiAgICBjb25zdCBjcmVhdGVTZXJ2aWNlVXJsID0gYCR7cG9ydGFsLnJlc3RVcmx9L2NvbnRlbnQvdXNlcnMvJHtwb3J0YWxJdGVtLm93bmVyfS9jcmVhdGVTZXJ2aWNlYDtcbiAgICBjb25zdCBjcmVhdGVQYXJhbXMgPSB7XG4gICAgICAgIG5hbWU6IG5ld0l0ZW1Qcm9wcy50aXRsZS5yZXBsYWNlKC8gL2csIFwiX1wiKSxcbiAgICAgICAgaXNWaWV3OiB0cnVlLFxuICAgICAgICBzb3VyY2VTY2hlbWFDaGFuZ2VzQWxsb3dlZDogdHJ1ZSxcbiAgICAgICAgaXNVcGRhdGFibGVWaWV3OiB0cnVlLFxuICAgICAgICBzcGF0aWFsUmVmZXJlbmNlOiAoX2EgPSBmbC5zb3VyY2VKU09OLmV4dGVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNwYXRpYWxSZWZlcmVuY2UsXG4gICAgICAgIGluaXRpYWxFeHRlbnQ6IGZsLnNvdXJjZUpTT04uZXh0ZW50LFxuICAgICAgICBjYXBhYmlsaXRpZXM6IFwiUXVlcnlcIixcbiAgICAgICAgcHJlc2VydmVMYXllcklkczogdHJ1ZVxuICAgIH07XG4gICAgaWYgKHBvcnRhbC5pc1BvcnRhbCkge1xuICAgICAgICBjb25zdCBkYXRhU291cmNlVHlwZSA9IGdldERhdGFTb3VyY2VUeXBlJDEocHJvcHMpO1xuICAgICAgICBpZiAoZGF0YVNvdXJjZVR5cGUpIHtcbiAgICAgICAgICAgIGNyZWF0ZVBhcmFtcy5vcHRpb25zID0geyBkYXRhU291cmNlVHlwZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjcmVhdGVTZXJ2aWNlQ29udGVudCA9IHtcbiAgICAgICAgY3JlYXRlUGFyYW1ldGVyczogSlNPTi5zdHJpbmdpZnkoY3JlYXRlUGFyYW1zKSxcbiAgICAgICAgb3V0cHV0VHlwZTogXCJmZWF0dXJlU2VydmljZVwiLFxuICAgICAgICB0YWdzOiAoKF9iID0gbmV3SXRlbVByb3BzLnRhZ3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpID8gbmV3SXRlbVByb3BzLnRhZ3MudG9TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc25pcHBldDogbmV3SXRlbVByb3BzLnN1bW1hcnksXG4gICAgICAgIGNhdGVnb3JpZXM6IChfYyA9IG5ld0l0ZW1Qcm9wcy5jYXRlZ29yaWVzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muam9pbihcIixcIiksXG4gICAgICAgIGlzVmlldzogdHJ1ZVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBlc3JpUmVxdWVzdChjcmVhdGVTZXJ2aWNlVXJsLCB7XG4gICAgICAgICAgICBxdWVyeTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjcmVhdGVTZXJ2aWNlQ29udGVudCksIHsgZjogXCJqc29uXCIsIHRva2VuOiBwb3J0YWwuY3JlZGVudGlhbC50b2tlbiB9KSxcbiAgICAgICAgICAgIG1ldGhvZDogXCJwb3N0XCIsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6IFwianNvblwiXG4gICAgICAgIH0pO1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwibmV3U2VydmljZVJlc3BvbnNlXCIsIHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5tZXNzYWdlLmluZGV4T2YoXCIgYWxyZWFkeSBleGlzdHMgXCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwic2VydmljZSBuYW1lIGFscmVhZHkgZXhpc3RzXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJjcmVhdGUgc2VydmljZSBmYWlsZWRcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXREYXRhU291cmNlVHlwZSQxKHByb3BzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHsgYWRtaW5TZXJ2aWNlSW5mbyB9ID0gcHJvcHM7XG4gICAgY29uc3QgZGF0YVNvdXJjZSA9ICgoX2IgPSAoX2EgPSBhZG1pblNlcnZpY2VJbmZvID09PSBudWxsIHx8IGFkbWluU2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkbWluU2VydmljZUluZm8uYWRtaW5TZXJ2aWNlSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGFiYXNlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGF0YXNvdXJjZSkgfHwge307XG4gICAgY29uc3QgZGF0YVNvdXJjZVR5cGUgPSAoKF9jID0gZGF0YVNvdXJjZSA9PT0gbnVsbCB8fCBkYXRhU291cmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhU291cmNlLm5hbWUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pbmRleE9mKFwiL25vc3FsRGF0YWJhc2VzXCIpKSA+IC0xXG4gICAgICAgID8gXCJzcGF0aW90ZW1wb3JhbFwiXG4gICAgICAgIDogKChfZCA9IGRhdGFTb3VyY2UgPT09IG51bGwgfHwgZGF0YVNvdXJjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YVNvdXJjZS5uYW1lKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaW5kZXhPZihcIi9lbnRlcnByaXNlRGF0YWJhc2VzXCIpKSA+IC0xXG4gICAgICAgICAgICA/IFwicmVsYXRpb25hbFwiXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgcmV0dXJuIGRhdGFTb3VyY2VUeXBlO1xufVxuYXN5bmMgZnVuY3Rpb24gaW5pdGlhbEFkZFRvRGVmaW5pdGlvbihwcm9wcywgY3JlYXRlU2VydmljZVJlc3BvbnNlLCBlc3JpUmVxdWVzdCkge1xuICAgIC8qIFRPRE8/P1xuICAgIHVwZGF0ZVBvcHVwQWZ0ZXJGaWVsZERlZmluaXRpb25DaGFuZ2U6IGZ1bmN0aW9uKG1hcExheWVyKSB7XG4gIFxuICAgICAgaWYgKCFtYXBMYXllci5wb3B1cEluZm8gfHwgIW1hcExheWVyLnBvcHVwSW5mby5maWVsZEluZm9zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgXG4gICAgICB2YXIgZmllbGRJbmZvcyA9IG1hcExheWVyLnBvcHVwSW5mby5maWVsZEluZm9zO1xuICAgICAgdmFyIG5ld0ZpZWxkSW5mb3MgPSBbXTtcbiAgICAgIHZhciBkZWZhdWx0UG9wdXBJbmZvID0gYXJjZ2lzb25saW5lLm1hcC5wb3B1cC5nZXREZWZhdWx0UG9wdXBJbmZvKG1hcExheWVyLnNlcnZpY2VJbmZvLCBtYXBMYXllci5sYXllci5pc0VkaXRhYmxlKCksIG1hcExheWVyLmxheWVyKTtcbiAgXG4gICAgICAvLyByZW1vdmUgZmllbGRzIHRoYXQgYXJlIG5vdCBhdmFpbGFibGUgYW55bW9yZSBhbmQgYWRkIG5ldyBmaWVsZHNcbiAgICAgIGRvam8uZm9yRWFjaChkZWZhdWx0UG9wdXBJbmZvLmZpZWxkSW5mb3MsIGZ1bmN0aW9uKGRlZkluZm8pIHtcbiAgICAgICAgdmFyIGN1ckZJbmZvO1xuICAgICAgICBkb2pvLmZvckVhY2goZmllbGRJbmZvcywgZnVuY3Rpb24oZkluZm8pIHtcbiAgICAgICAgICBpZiAoZkluZm8uZmllbGROYW1lID09PSBkZWZJbmZvLmZpZWxkTmFtZSkge1xuICAgICAgICAgICAgY3VyRkluZm8gPSBmSW5mbztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWN1ckZJbmZvKSB7XG4gICAgICAgICAgLy8gYWRkIG5ldyBmaWVsZHMgdG8gdGhlIHBvcHVwXG4gICAgICAgICAgbmV3RmllbGRJbmZvcy5wdXNoKGRlZkluZm8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGtlZXAgdGhlIG9uZSB3ZSBoYXZlXG4gICAgICAgICAgbmV3RmllbGRJbmZvcy5wdXNoKGN1ckZJbmZvKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBrZWVwIHNwZWNpYWwgZmllbGRzXG4gICAgICB2YXIgcmVsYXRlZEZpZWxkUHJlZml4ID0gXCJyZWxhdGlvbnNoaXBzL1wiO1xuICAgICAgdmFyIGV4cHJlc3Npb25QcmVmaXggPSBcImV4cHJlc3Npb24vXCI7XG4gICAgICB2YXIgcmFzdGVyUHJlZml4ID0gXCJSYXN0ZXIuXCI7XG4gICAgICBkb2pvLmZvckVhY2goZmllbGRJbmZvcywgZnVuY3Rpb24oZkluZm8pIHtcbiAgICAgICAgaWYgKGZJbmZvLmZpZWxkTmFtZS5zdGFydHNXaXRoKHJlbGF0ZWRGaWVsZFByZWZpeCkgfHxcbiAgICAgICAgICBmSW5mby5maWVsZE5hbWUuc3RhcnRzV2l0aChleHByZXNzaW9uUHJlZml4KSB8fFxuICAgICAgICAgIGZJbmZvLmZpZWxkTmFtZS5zdGFydHNXaXRoKHJhc3RlclByZWZpeCkpIHtcbiAgICAgICAgICBuZXdGaWVsZEluZm9zLnB1c2goZkluZm8pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChkb2pvLmpzb24uc3RyaW5naWZ5KG1hcExheWVyLnBvcHVwSW5mby5maWVsZEluZm9zKSAhPT0gZG9qby5qc29uLnN0cmluZ2lmeShuZXdGaWVsZEluZm9zKSkge1xuICAgICAgICBtYXBMYXllci5wb3B1cEluZm8uZmllbGRJbmZvcyA9IG5ld0ZpZWxkSW5mb3M7XG4gICAgICAgIGFyY2dpc29ubGluZS5tYXAubWFwVXRpbC5zZXRJbmZvVGVtcGxhdGUobWFwTGF5ZXIubGF5ZXIsIG1hcExheWVyLnBvcHVwSW5mbyk7XG4gICAgICAgIG1hcExheWVyLnBvcHVwQ2hhbmdlZCA9IHRydWU7XG4gIFxuICAgICAgICBpZiAobWFwTGF5ZXIub3JpZ0l0ZW1MYXllcnMpIHtcbiAgICAgICAgICAvLyBzYXZlIG5ldyBwb3B1cCBvbiBsYXllciBpdGVtXG4gIFxuICAgICAgICAgIHZhciBnZXRJdGVtTGF5ZXJJbmZvc0hhbmRsZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy8gbWFwTGF5ZXIub3JpZ0l0ZW1MYXllcnMgY29udGFpbnMgd2hhdCdzIHNhdmVkIG9uIHRoZSBpdGVtIGN1cnJlbnRseVxuICBcbiAgICAgICAgICAgIHZhciBpdGVtRGF0YSA9IGFyY2dpc29ubGluZS5tYXAuaXRlbURhdGEuaXRlbURhdGFDb250ZW50c1ttYXBMYXllci5pdGVtSWRdIHx8IHt9O1xuICBcbiAgICAgICAgICAgIHZhciBpZCA9IHBhcnNlSW50KG1hcExheWVyLmxheWVyLnVybC5zdWJzdHJpbmcobWFwTGF5ZXIubGF5ZXIudXJsLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpKTtcbiAgICAgICAgICAgIHZhciBsYXllckluZm8gPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBMYXllci5vcmlnSXRlbUxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAobWFwTGF5ZXIub3JpZ0l0ZW1MYXllcnNbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJJbmZvID0gbWFwTGF5ZXIub3JpZ0l0ZW1MYXllcnNbaV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICBpZiAoIWxheWVySW5mbykge1xuICAgICAgICAgICAgICAvL3Nob3VsZCBub3QgaGFwcGVuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICAvLyBvbmx5IHVwZGF0ZSBwb3B1cEluZm9cbiAgICAgICAgICAgIGxheWVySW5mby5wb3B1cEluZm8gPSBtYXBMYXllci5wb3B1cEluZm87XG4gIFxuICAgICAgICAgICAgdmFyIGpzb24gPSB7XG4gICAgICAgICAgICAgIGxheWVyczogbWFwTGF5ZXIub3JpZ0l0ZW1MYXllcnNcbiAgICAgICAgICAgIH07XG4gIFxuICAgICAgICAgICAgZGVsZXRlIGl0ZW1EYXRhLmxheWVycztcbiAgICAgICAgICAgIGpzb24gPSBkb2pvLm1peGluKGl0ZW1EYXRhLCBqc29uKTtcbiAgXG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgdGV4dDogZG9qby5qc29uLnN0cmluZ2lmeShqc29uKVxuICAgICAgICAgICAgfTtcbiAgXG4gICAgICAgICAgICB2YXIgdXNlciA9IGFyY2dpc29ubGluZS5zaGFyaW5nLnV0aWwuZ2V0VXNlcigpO1xuICAgICAgICAgICAgdmFyIHVybCA9IGVzcmlHZW93Q29uZmlnLnJlc3RCYXNlVXJsICsgJ2NvbnRlbnQvdXNlcnMvJyArIG1hcExheWVyLml0ZW1DYXJkLm93bmVyOyAvLyB1c2VyIG1pZ2h0IGJlIGFkbWluIGFuZCBpdGVtIG93bmVyIGlzIHNvbWVvbmUgZWxzZVxuICAgICAgICAgICAgdXJsICs9IChtYXBMYXllci5pdGVtQ2FyZC5vd25lckZvbGRlcikgPyAoJy8nICsgbWFwTGF5ZXIuaXRlbUNhcmQub3duZXJGb2xkZXIpIDogJyc7XG4gICAgICAgICAgICB1cmwgKz0gJy9pdGVtcy8nICsgbWFwTGF5ZXIuaXRlbUNhcmQuaWQgKyAnL3VwZGF0ZSc7XG4gICAgICAgICAgICBhcmNnaXNvbmxpbmUuc2hhcmluZy51dGlsLnBvc3RKc29uKHJlcXVlc3QsIHVybCwgZG9qby5oaXRjaCh0aGlzLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBkZWxldGUgbWFwTGF5ZXIucG9wdXBDaGFuZ2VkO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH07XG4gIFxuICAgICAgICAgIC8vIGdldCB0aGUgbGF0ZXN0IGxheWVySW5mb3MgZnJvbSB0aGUgaXRlbSBpbiBjYXNlIHRoZXkgZ290IGNoYW5nZWQgYnkgYW5vdGhlciBsYXllciBpbiB0aGUgbWFwXG4gICAgICAgICAgYXJjZ2lzb25saW5lLm1hcC5pdGVtRGF0YS5nZXRJdGVtTGF5ZXJJbmZvcyhtYXBMYXllciwgZG9qby5oaXRjaCh0aGlzLCBnZXRJdGVtTGF5ZXJJbmZvc0hhbmRsZXIpLCBkb2pvLmhpdGNoKHRoaXMsIGdldEl0ZW1MYXllckluZm9zSGFuZGxlcikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAqL1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBsYXllciwgbGF5ZXJJZHMgfSA9IHByb3BzO1xuICAgIGxldCBsYXllcnMsIHRhYmxlcztcbiAgICBpZiAobGF5ZXIudHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgICAgIGxheWVycyA9IChfYSA9IGxheWVyLmxheWVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcigobHlyKSA9PiBsYXllcklkcy5pbmRleE9mKGx5ci5sYXllcklkKSA+IC0xKS5tYXAoKGx5cikgPT4gZ2V0RGVmTGF5ZXJKU09OKGx5ciwgcHJvcHMpKS50b0FycmF5KCkucmV2ZXJzZSgpO1xuICAgICAgICB0YWJsZXMgPSAoX2IgPSBsYXllci50YWJsZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5maWx0ZXIoKGx5cikgPT4gbGF5ZXJJZHMuaW5kZXhPZihseXIubGF5ZXJJZCkgPiAtMSkubWFwKChseXIpID0+IGdldERlZkxheWVySlNPTihseXIsIHByb3BzKSkudG9BcnJheSgpLnJldmVyc2UoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChsYXllci5pc1RhYmxlKSB7XG4gICAgICAgICAgICB0YWJsZXMgPSBbZ2V0RGVmTGF5ZXJKU09OKGxheWVyLCBwcm9wcyldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGF5ZXJzID0gW2dldERlZkxheWVySlNPTihsYXllciwgcHJvcHMpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB0aGUgcmVzcG9uc2UgZnJvbSBhIGNyZWF0ZVNlcnZpY2UgY2FsbCByZXR1cm5zICdzZXJ2aWNldXJsJ1xuICAgICAgICBjb25zdCBhZG1pblVybCA9IGNyZWF0ZVNlcnZpY2VSZXNwb25zZS5zZXJ2aWNldXJsLnJlcGxhY2UoXCJyZXN0L3NlcnZpY2VzXCIsIFwicmVzdC9hZG1pbi9zZXJ2aWNlc1wiKTtcbiAgICAgICAgYXdhaXQgYWRkVG9EZWZpbml0aW9uUmVxdWVzdCQxKGAke2FkbWluVXJsfS9hZGRUb0RlZmluaXRpb25gLCB7XG4gICAgICAgICAgICBsYXllcnM6IGxheWVycyxcbiAgICAgICAgICAgIHRhYmxlczogdGFibGVzXG4gICAgICAgIH0sIGVzcmlSZXF1ZXN0LCBwcm9wcyk7XG4gICAgICAgIGF3YWl0IHVwZGF0ZURlZmluaXRpb25zKHByb3BzLCBjcmVhdGVTZXJ2aWNlUmVzcG9uc2UsIGVzcmlSZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcImluaXRpYWxBZGRUb0RlZmluaXRpb24gZmFpbGVkXCIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlRGVmaW5pdGlvbnMocHJvcHMsIGNyZWF0ZVNlcnZpY2VSZXNwb25zZSwgZXNyaVJlcXVlc3QpIHtcbiAgICBjb25zdCB7IGxheWVyLCBsYXllcklkcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyBwb3J0YWxJdGVtIH0gPSBsYXllcjtcbiAgICBjb25zdCB7IHBvcnRhbCB9ID0gcG9ydGFsSXRlbTtcbiAgICBjb25zdCBhZG1pblVybCA9IGNyZWF0ZVNlcnZpY2VSZXNwb25zZS5zZXJ2aWNldXJsLnJlcGxhY2UoXCJyZXN0L3NlcnZpY2VzXCIsIFwicmVzdC9hZG1pbi9zZXJ2aWNlc1wiKTtcbiAgICB0cnkge1xuICAgICAgICAvLyBub3cgdXBkYXRlIGRlZmluaXRpb25zIGxpa2UgZmlsdGVyLCBmaWVsZHMsIGFuZCBBT0lcbiAgICAgICAgLy8gY2hhbmdpbmcgZmllbGRzIGFuZCBBT0kgbm90IHN1cHBvcnRlZCB3aXRoIGFkZFRvRGVmaW5pdGlvblxuICAgICAgICBpZiAobGF5ZXIudHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsSW5mb3MgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGx5cnMgPSBnZXRMYXllcnNBbmRUYWJsZXMobGF5ZXIpLmZpbHRlcigoZkxheWVyKSA9PiBsYXllcklkcy5pbmRleE9mKGZMYXllci5sYXllcklkKSA+IC0xKTtcbiAgICAgICAgICAgIC8vIHVzZSBmb3IgbG9vcCBzbyBhd2FpdCB3b3Jrc1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBseXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZkxheWVyID0gbHlycy5nZXRJdGVtQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0xheWVyQ2hhbmdlcyhmTGF5ZXIubGF5ZXJJZCwgcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCBnZXRVcGRhdGVMYXllckpTT04oZkxheWVyLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZURlZlVybCA9IGAke2FkbWluVXJsfS8ke2ZMYXllci5sYXllcklkfS91cGRhdGVEZWZpbml0aW9uYDtcbiAgICAgICAgICAgICAgICAgICAgY2FsbEluZm9zLnB1c2goeyB1cGRhdGVEZWZVcmwsIGpzb24gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxJbmZvcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9ydGFsLmlzUG9ydGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbid0IGhhbmRsZSBzaW11bHRhbmVvdXMgcmVxdWVzdHNcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsSW5mbyBvZiBjYWxsSW5mb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZURlZmluaXRpb25SZXF1ZXN0KGNhbGxJbmZvLnVwZGF0ZURlZlVybCwgY2FsbEluZm8uanNvbiwgZXNyaVJlcXVlc3QsIHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbEluZm9zLmZvckVhY2goKGNhbGxJbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxscy5wdXNoKHVwZGF0ZURlZmluaXRpb25SZXF1ZXN0KGNhbGxJbmZvLnVwZGF0ZURlZlVybCwgY2FsbEluZm8uanNvbiwgZXNyaVJlcXVlc3QsIHByb3BzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjYWxscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm90IGEgZ3JvdXAgbGF5ZXJcbiAgICAgICAgICAgIGlmIChoYXNMYXllckNoYW5nZXMobGF5ZXIubGF5ZXJJZCwgcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IGdldFVwZGF0ZUxheWVySlNPTihsYXllciwgcHJvcHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZURlZlVybCA9IGAke2FkbWluVXJsfS8ke2xheWVyLmxheWVySWR9L3VwZGF0ZURlZmluaXRpb25gO1xuICAgICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZURlZmluaXRpb25SZXF1ZXN0KHVwZGF0ZURlZlVybCwganNvbiwgZXNyaVJlcXVlc3QsIHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwidXBkYXRlRGVmaW5pdGlvbnMgZmFpbGVkXCIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlRGVmaW5pdGlvbihwcm9wcywgdmlld0l0ZW0sIGVzcmlSZXF1ZXN0KSB7XG4gICAgLypcbiAgICBUT0RPPz9cbiAgICBpZiAoYXJjZ2lzb25saW5lLnNoYXJpbmcudXRpbC5pc1BvcnRhbCgpKSB7XG4gICAgICAvLyBjYW4ndCBzZW5kIGFsbCBvZiB0aG9zZSByZXF1ZXN0cyBvdXQgYXQgdGhlIHNhbWUgdGltZSBbIzE5MzAxXVxuICAgICovXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHsgbGF5ZXIsIGxheWVySWRzLCBhZG1pblNlcnZpY2VJbmZvIH0gPSBwcm9wcztcbiAgICBjb25zdCBwb3J0YWxJdGVtID0gbGF5ZXIucG9ydGFsSXRlbTtcbiAgICBjb25zdCB7IHBvcnRhbCB9ID0gcG9ydGFsSXRlbTtcbiAgICBjb25zdCBkZWxldGVMYXllcklkcyA9IFtdO1xuICAgIGNvbnN0IGFkZExheWVySWRzID0gW107XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gdGhlIHJlc3BvbnNlIGZyb20gYW4gaXRlbSBjYXJkIGNhbGwgcmV0dXJucyAndXJsJ1xuICAgICAgICBjb25zdCBhZG1pblVybCA9IHZpZXdJdGVtLnVybC5yZXBsYWNlKFwicmVzdC9zZXJ2aWNlc1wiLCBcInJlc3QvYWRtaW4vc2VydmljZXNcIik7XG4gICAgICAgIGlmIChsYXllci50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgICAgICAgIC8vIGRlbGV0ZVxuICAgICAgICAgICAgKF9hID0gYWRtaW5TZXJ2aWNlSW5mbyA9PT0gbnVsbCB8fCBhZG1pblNlcnZpY2VJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZG1pblNlcnZpY2VJbmZvLmxheWVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGx5cikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsYXllcklkcy5pbmRleE9mKGx5ci5pZCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxheWVySWRzLnB1c2gobHlyLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVRhYmxlSWRzID0gW107XG4gICAgICAgICAgICAoX2IgPSBhZG1pblNlcnZpY2VJbmZvID09PSBudWxsIHx8IGFkbWluU2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkbWluU2VydmljZUluZm8udGFibGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZm9yRWFjaCgobHlyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVySWRzLmluZGV4T2YobHlyLmlkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlVGFibGVJZHMucHVzaChseXIuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGRlbGV0ZUxheWVySWRzLmxlbmd0aCB8fCBkZWxldGVUYWJsZUlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxldGVGcm9tRGVmVXJsID0gYCR7YWRtaW5Vcmx9L2RlbGV0ZUZyb21EZWZpbml0aW9uYDtcbiAgICAgICAgICAgICAgICBhd2FpdCBkZWxldGVGcm9tRGVmaW5pdGlvblJlcXVlc3QoZGVsZXRlRnJvbURlZlVybCwge1xuICAgICAgICAgICAgICAgICAgICBsYXllcnM6IGRlbGV0ZUxheWVySWRzID09PSBudWxsIHx8IGRlbGV0ZUxheWVySWRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWxldGVMYXllcklkcy5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpZCB9O1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgdGFibGVzOiBkZWxldGVUYWJsZUlkcyA9PT0gbnVsbCB8fCBkZWxldGVUYWJsZUlkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVsZXRlVGFibGVJZHMubWFwKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaWQgfTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9LCBwb3J0YWxJdGVtLCBlc3JpUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgLy8gZG8gd2UgbmVlZCB0byByZW1vdmUgcmVsYXRpb25zaGlwcyBmcm9tIGV4aXN0aW5nIHZpZXcgbGF5ZXJzXG4gICAgICAgICAgICAgICAgLy8gcG9pbnRpbmcgdG8gYW55IHJlbW92ZWQgbGF5ZXJzP1xuICAgICAgICAgICAgICAgIGxldCBjYWxsSW5mb3MgPSBbXTtcbiAgICAgICAgICAgICAgICBnZXRMYXllcnNBbmRUYWJsZXMobGF5ZXIpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGZMYXllcikgPT4gbGF5ZXJJZHMuaW5kZXhPZihmTGF5ZXIubGF5ZXJJZCkgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goYXN5bmMgKGZMYXllcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gZkxheWVyLnJlbGF0aW9uc2hpcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCBsYXllciBoYXMgcmVsYXRpb25zaGlwc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgdmlld0xheWVySW5mbyA9IGdldExheWVyc0FuZFRhYmxlcyhhZG1pblNlcnZpY2VJbmZvKS5maW5kKChsYXllckluZm8pID0+IGxheWVySW5mby5pZCA9PT0gZkxheWVyLmxheWVySWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfYiA9IHZpZXdMYXllckluZm8gPT09IG51bGwgfHwgdmlld0xheWVySW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlld0xheWVySW5mby5yZWxhdGlvbnNoaXBzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHJlbGF0aW9uc2hpcHMgcG9pbnRpbmcgdG8gbmV3bHkgcmVtb3ZlZCBsYXllcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxhdGlvbnNoaXBzID0gdmlld0xheWVySW5mby5yZWxhdGlvbnNoaXBzLmZpbHRlcigocmVsYXRpb25zaGlwKSA9PiBkZWxldGVMYXllcklkcy5pbmRleE9mKHJlbGF0aW9uc2hpcC5yZWxhdGVkVGFibGVJZCkgPiAtMSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVUYWJsZUlkcy5pbmRleE9mKHJlbGF0aW9uc2hpcC5yZWxhdGVkVGFibGVJZCkgPiAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF0aW9uc2hpcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0IGxlYXN0IG9uZSByZWxhdGlvbnNoaXAgbmVlZHMgdG8gYmUgcmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24ucmVsYXRpb25zaGlwcyA9IHJlbGF0aW9uc2hpcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbEZyb21EZWZVcmwgPSBgJHthZG1pblVybH0vJHtmTGF5ZXIubGF5ZXJJZH0vZGVsZXRlRnJvbURlZmluaXRpb25gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsSW5mb3MucHVzaCh7IGRlbEZyb21EZWZVcmwsIGpzb24gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBlbHNlIHZpZXcgbGF5ZXIgbm90IHlldCBwYXJ0IG9mIHZpZXcgb3IgYWxyZWFkeSBoYXMgYWxsIHJlbGF0aW9uc2hpcHNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsSW5mb3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3J0YWwuaXNQb3J0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbid0IGhhbmRsZSBzaW11bHRhbmVvdXMgcmVxdWVzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbEluZm8gb2YgY2FsbEluZm9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGVsZXRlRnJvbURlZmluaXRpb25SZXF1ZXN0KGNhbGxJbmZvLmRlbEZyb21EZWZVcmwsIGNhbGxJbmZvLmpzb24sIHBvcnRhbEl0ZW0sIGVzcmlSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsSW5mb3MuZm9yRWFjaCgoY2FsbEluZm8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxscy5wdXNoKGRlbGV0ZUZyb21EZWZpbml0aW9uUmVxdWVzdChjYWxsSW5mby5kZWxGcm9tRGVmVXJsLCBjYWxsSW5mby5qc29uLCBwb3J0YWxJdGVtLCBlc3JpUmVxdWVzdCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjYWxscyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGRcbiAgICAgICAgICAgIGxheWVySWRzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFnZXRMYXllcnNBbmRUYWJsZXMoYWRtaW5TZXJ2aWNlSW5mbykuc29tZSgobHlyKSA9PiBseXIuaWQgPT09IGlkKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRMYXllcklkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhZGRMYXllcklkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXllcnMgPSAoX2MgPSBsYXllci5sYXllcnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5maWx0ZXIoKGx5cikgPT4gYWRkTGF5ZXJJZHMuaW5kZXhPZihseXIubGF5ZXJJZCkgPiAtMSkubWFwKChseXIpID0+IGdldERlZkxheWVySlNPTihseXIsIHByb3BzKSkudG9BcnJheSgpLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZXMgPSAoX2QgPSBsYXllci50YWJsZXMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5maWx0ZXIoKGx5cikgPT4gYWRkTGF5ZXJJZHMuaW5kZXhPZihseXIubGF5ZXJJZCkgPiAtMSkubWFwKChseXIpID0+IGdldERlZkxheWVySlNPTihseXIsIHByb3BzKSkudG9BcnJheSgpLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBhZGRUb0RlZmluaXRpb25SZXF1ZXN0JDEoYCR7YWRtaW5Vcmx9L2FkZFRvRGVmaW5pdGlvbmAsIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJzOiBsYXllcnMsXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlczogdGFibGVzXG4gICAgICAgICAgICAgICAgfSwgZXNyaVJlcXVlc3QsIHByb3BzKTtcbiAgICAgICAgICAgICAgICAvLyBkbyB3ZSBuZWVkIHRvIGFkZCByZWxhdGlvbnNoaXBzIGZvciBhbnkgbmV3bHkgYWRkZWQgbGF5ZXJzP1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxJbmZvcyA9IFtdO1xuICAgICAgICAgICAgICAgIGdldExheWVyc0FuZFRhYmxlcyhsYXllcilcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZkxheWVyKSA9PiBsYXllcklkcy5pbmRleE9mKGZMYXllci5sYXllcklkKSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChhc3luYyAoZkxheWVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSBmTGF5ZXIucmVsYXRpb25zaGlwcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsIGxheWVyIGhhcyByZWxhdGlvbnNoaXBzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3TGF5ZXJJbmZvID0gZ2V0TGF5ZXJzQW5kVGFibGVzKGFkbWluU2VydmljZUluZm8pLmZpbmQoKGxheWVySW5mbykgPT4gbGF5ZXJJbmZvLmlkID09PSBmTGF5ZXIubGF5ZXJJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlld0xheWVySW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgdmlldyBsYXllciB3YXMgbm90IGp1c3QgYWRkZWQgdG8gdGhlIHZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChfYiA9IGZMYXllci5yZWxhdGlvbnNoaXBzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSAhPT0gdmlld0xheWVySW5mby5yZWxhdGlvbnNoaXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgYWRkIHJlbGF0aW9uc2hpcHMgcG9pbnRpbmcgdG8gbmV3bHkgYWRkZWQgbGF5ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGF0aW9uc2hpcHMgPSBmTGF5ZXIucmVsYXRpb25zaGlwcy5maWx0ZXIoKHJlbGF0aW9uc2hpcCkgPT4gYWRkTGF5ZXJJZHMuaW5kZXhPZihyZWxhdGlvbnNoaXAucmVsYXRlZFRhYmxlSWQpID4gLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uLnJlbGF0aW9uc2hpcHMgPSByZWxhdGlvbnNoaXBzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRUb0RlZlVybCA9IGAke2FkbWluVXJsfS8ke2ZMYXllci5sYXllcklkfS9hZGRUb0RlZmluaXRpb25gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsSW5mb3MucHVzaCh7IGFkZFRvRGVmVXJsLCBqc29uIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gZWxzZSB2aWV3IGxheWVyIGFscmVhZHkgaGFzIGFsbCByZWxhdGlvbnNoaXBzXG4gICAgICAgICAgICAgICAgICAgICAgICB9IC8vIGVsc2Ugd2Ugc2VudCBhbGwgcmVsYXRpb25zaGlwcyB3aGVuIGFkZGluZyB0aGUgbGF5ZXIgdG8gdGhlIHZpZXcgZWFybGllclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxJbmZvcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcnRhbC5pc1BvcnRhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuJ3QgaGFuZGxlIHNpbXVsdGFuZW91cyByZXF1ZXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsSW5mbyBvZiBjYWxsSW5mb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBhZGRUb0RlZmluaXRpb25SZXF1ZXN0JDEoY2FsbEluZm8uYWRkVG9EZWZVcmwsIGNhbGxJbmZvLmpzb24sIGVzcmlSZXF1ZXN0LCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxscyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEluZm9zLmZvckVhY2goKGNhbGxJbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbHMucHVzaChhZGRUb0RlZmluaXRpb25SZXF1ZXN0JDEoY2FsbEluZm8uYWRkVG9EZWZVcmwsIGNhbGxJbmZvLmpzb24sIGVzcmlSZXF1ZXN0LCBwcm9wcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjYWxscyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1cGRhdGUgZmllbGRzLCBmaWx0ZXIsIEFPSVxuICAgICAgICAgICAgLy8gYWxzbyB1cGRhdGUgdGhlIG5ldyBsYXllcnMgdGhhdCB3ZXJlIGp1c3QgYWRkZWRcbiAgICAgICAgICAgIGNvbnN0IGNhbGxJbmZvcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgY2FsbHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IG1ha2VHZXRVcGRhdGVMYXllckpTT05DYWxsID0gYXN5bmMgKGNhbGxJbmZvcywgZkxheWVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlRGVmVXJsID0gYCR7YWRtaW5Vcmx9LyR7ZkxheWVyLmxheWVySWR9L3VwZGF0ZURlZmluaXRpb25gO1xuICAgICAgICAgICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCBnZXRVcGRhdGVMYXllckpTT04oZkxheWVyLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgY2FsbEluZm9zLnB1c2goeyB1cGRhdGVEZWZVcmwsIGpzb24gfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdldExheWVyc0FuZFRhYmxlcyhsYXllcilcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChmTGF5ZXIpID0+IGxheWVySWRzLmluZGV4T2YoZkxheWVyLmxheWVySWQpID4gLTEpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGZMYXllcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChoYXNMYXllckNoYW5nZXMoZkxheWVyLmxheWVySWQsIHByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxscy5wdXNoKG1ha2VHZXRVcGRhdGVMYXllckpTT05DYWxsKGNhbGxJbmZvcywgZkxheWVyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjYWxscyk7XG4gICAgICAgICAgICBpZiAoY2FsbEluZm9zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3J0YWwuaXNQb3J0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsSW5mbyBvZiBjYWxsSW5mb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZURlZmluaXRpb25SZXF1ZXN0KGNhbGxJbmZvLnVwZGF0ZURlZlVybCwgY2FsbEluZm8uanNvbiwgZXNyaVJlcXVlc3QsIHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbEluZm9zLmZvckVhY2goKGNhbGxJbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxscy5wdXNoKHVwZGF0ZURlZmluaXRpb25SZXF1ZXN0KGNhbGxJbmZvLnVwZGF0ZURlZlVybCwgY2FsbEluZm8uanNvbiwgZXNyaVJlcXVlc3QsIHByb3BzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjYWxscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm90IGEgZ3JvdXAgbGF5ZXJcbiAgICAgICAgICAgIGlmIChoYXNMYXllckNoYW5nZXMobGF5ZXIubGF5ZXJJZCwgcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IGdldFVwZGF0ZUxheWVySlNPTihsYXllciwgcHJvcHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZURlZlVybCA9IGAke2FkbWluVXJsfS8ke2xheWVyLmxheWVySWR9L3VwZGF0ZURlZmluaXRpb25gO1xuICAgICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZURlZmluaXRpb25SZXF1ZXN0KHVwZGF0ZURlZlVybCwganNvbiwgZXNyaVJlcXVlc3QsIHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoeyBhZGRMYXllcklkcywgZGVsZXRlTGF5ZXJJZHMgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInVwZGF0ZURlZmluaXRpb24gZmFpbGVkXCIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlRGVmaW5pdGlvblJlcXVlc3QodXBkYXRlRGVmVXJsLCBqc29uLCBlc3JpUmVxdWVzdCwgcHJvcHMsIHJldHJ5ID0gZmFsc2UpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBsYXllciwgdmlld0l0ZW0gfSA9IHByb3BzO1xuICAgIGNvbnN0IHVwZGF0ZURlZkNvbnRlbnQgPSB7XG4gICAgICAgIHVwZGF0ZURlZmluaXRpb246IEpTT04uc3RyaW5naWZ5KGpzb24pXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwb3J0YWxJdGVtID0gbGF5ZXIucG9ydGFsSXRlbTtcbiAgICAgICAgY29uc3QgcG9ydGFsID0gcG9ydGFsSXRlbS5wb3J0YWw7XG4gICAgICAgIGNvbnN0IGlzVmVsb2NpdHlWaWV3ID0gKHZpZXdJdGVtID09PSBudWxsIHx8IHZpZXdJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWV3SXRlbS50eXBlS2V5d29yZHMuaW5kZXhPZihcIklvVEZlYXR1cmVMYXllclwiKSkgPiAtMTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXNyaVJlcXVlc3QodXBkYXRlRGVmVXJsLCB7XG4gICAgICAgICAgICBxdWVyeTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB1cGRhdGVEZWZDb250ZW50KSwgeyBmOiBcImpzb25cIiwgYXN5bmM6ICFwb3J0YWwuaXNQb3J0YWwgJiYgIWlzVmVsb2NpdHlWaWV3LCB0b2tlbjogcG9ydGFsLmNyZWRlbnRpYWwudG9rZW4gfSksXG4gICAgICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiBcImpzb25cIlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBvcnRhbC5pc1BvcnRhbCB8fCBpc1ZlbG9jaXR5Vmlldykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHBvbGxGb3JTdGF0dXMkMSgoX2EgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXR1c1VSTCwge1xuICAgICAgICAgICAgICAgICAgICBmOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IHBvcnRhbC5jcmVkZW50aWFsLnRva2VuXG4gICAgICAgICAgICAgICAgfSwgZXNyaVJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSByZXF1ZXN0IHdvcmtlZDsgaWdub3JlIHRoZSBwb2xsaW5nIGVycm9yXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIC8vfSk7XG4gICAgICAgICAgICAgICAgLyogcmVhbCBlcnJvclxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIFwic3VibWlzc2lvblRpbWVcIjogMTY1MjQ4MDEwNDM2MCxcbiAgICAgICAgICAgICAgICAgIFwibGFzdFVwZGF0ZWRUaW1lXCI6IDE2NTI0ODAxMDQzNjAsXG4gICAgICAgICAgICAgICAgICBcInN0YXR1c1wiOiBcIkZhaWxlZFwiLFxuICAgICAgICAgICAgICAgICAgXCJlcnJvclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJjb2RlXCI6IDUwMCxcbiAgICAgICAgICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiRWRpdGluZyBkZWZpbml0aW9uIGVycm9yIC0gVVNBX1dlc3QyX3ZpZXdcIlxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJ1cGRhdGVEZWZpbml0aW9uIHJlcXVlc3QgZmFpbGVkIChwb2xsKVwiKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKCFyZXRyeSkge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSBpdCdzIGp1c3QgYSBmbHVrZVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZURlZmluaXRpb25SZXF1ZXN0KHVwZGF0ZURlZlVybCwganNvbiwgZXNyaVJlcXVlc3QsIHByb3BzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInVwZGF0ZURlZmluaXRpb24gcmVxdWVzdCBmYWlsZWRcIikpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBhZGRUb0RlZmluaXRpb25SZXF1ZXN0JDEoYWRkVG9EZWZVcmwsIGpzb24sIGVzcmlSZXF1ZXN0LCBwcm9wcywgcmV0cnkgPSBmYWxzZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGxheWVyLCB2aWV3SXRlbSB9ID0gcHJvcHM7XG4gICAgY29uc3QgYWRkVG9EZWZDb250ZW50ID0ge1xuICAgICAgICBhZGRUb0RlZmluaXRpb246IEpTT04uc3RyaW5naWZ5KGpzb24pXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwb3J0YWxJdGVtID0gbGF5ZXIucG9ydGFsSXRlbTtcbiAgICAgICAgY29uc3QgcG9ydGFsID0gcG9ydGFsSXRlbS5wb3J0YWw7XG4gICAgICAgIGNvbnN0IGlzVmVsb2NpdHlWaWV3ID0gKHZpZXdJdGVtID09PSBudWxsIHx8IHZpZXdJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWV3SXRlbS50eXBlS2V5d29yZHMuaW5kZXhPZihcIklvVEZlYXR1cmVMYXllclwiKSkgPiAtMTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXNyaVJlcXVlc3QoYWRkVG9EZWZVcmwsIHtcbiAgICAgICAgICAgIHF1ZXJ5OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFkZFRvRGVmQ29udGVudCksIHsgZjogXCJqc29uXCIsIGFzeW5jOiAhcG9ydGFsLmlzUG9ydGFsICYmICFpc1ZlbG9jaXR5VmlldywgdG9rZW46IHBvcnRhbC5jcmVkZW50aWFsLnRva2VuIH0pLFxuICAgICAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogXCJqc29uXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwb3J0YWwuaXNQb3J0YWwgfHwgaXNWZWxvY2l0eVZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBwb2xsRm9yU3RhdHVzJDEoKF9hID0gcmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0dXNVUkwsIHtcbiAgICAgICAgICAgICAgICAgICAgZjogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBwb3J0YWwuY3JlZGVudGlhbC50b2tlblxuICAgICAgICAgICAgICAgIH0sIGVzcmlSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgcmVxdWVzdCB3b3JrZWQ7IGlnbm9yZSB0aGUgcG9sbGluZyBlcnJvclxuICAgICAgICAgICAgICAgIC8vcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAvL30pO1xuICAgICAgICAgICAgICAgIC8qIHJlYWwgZXJyb3JcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBcInN1Ym1pc3Npb25UaW1lXCI6IDE2NTI0ODAxMDQzNjAsXG4gICAgICAgICAgICAgICAgICBcImxhc3RVcGRhdGVkVGltZVwiOiAxNjUyNDgwMTA0MzYwLFxuICAgICAgICAgICAgICAgICAgXCJzdGF0dXNcIjogXCJGYWlsZWRcIixcbiAgICAgICAgICAgICAgICAgIFwiZXJyb3JcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiY29kZVwiOiA1MDAsXG4gICAgICAgICAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkVkaXRpbmcgZGVmaW5pdGlvbiBlcnJvciAtIFVTQV9XZXN0Ml92aWV3XCJcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcImFkZFRvRGVmaW5pdGlvbiByZXF1ZXN0IGZhaWxlZCAocG9sbClcIikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmICghcmV0cnkpIHtcbiAgICAgICAgICAgIC8vIGluIGNhc2UgaXQncyBqdXN0IGEgZmx1a2VcbiAgICAgICAgICAgIHJldHVybiBhZGRUb0RlZmluaXRpb25SZXF1ZXN0JDEoYWRkVG9EZWZVcmwsIGpzb24sIGVzcmlSZXF1ZXN0LCBwcm9wcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJhZGRUb0RlZmluaXRpb24gcmVxdWVzdCBmYWlsZWRcIikpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBkZWxldGVGcm9tRGVmaW5pdGlvblJlcXVlc3QoZGVsZXRlRnJvbURlZlVybCwganNvbiwgcG9ydGFsSXRlbSwgZXNyaVJlcXVlc3QsIHJldHJ5ID0gZmFsc2UpIHtcbiAgICBjb25zdCBkZWxldGVGcm9tRGVmQ29udGVudCA9IHtcbiAgICAgICAgZGVsZXRlRnJvbURlZmluaXRpb246IEpTT04uc3RyaW5naWZ5KGpzb24pXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBlc3JpUmVxdWVzdChkZWxldGVGcm9tRGVmVXJsLCB7XG4gICAgICAgICAgICBxdWVyeTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWxldGVGcm9tRGVmQ29udGVudCksIHsgZjogXCJqc29uXCIsIHRva2VuOiBwb3J0YWxJdGVtLnBvcnRhbC5jcmVkZW50aWFsLnRva2VuIH0pLFxuICAgICAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogXCJqc29uXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKCFyZXRyeSkge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSBpdCdzIGp1c3QgYSBmbHVrZVxuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZUZyb21EZWZpbml0aW9uUmVxdWVzdChkZWxldGVGcm9tRGVmVXJsLCBqc29uLCBwb3J0YWxJdGVtLCBlc3JpUmVxdWVzdCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJkZWxldGVGcm9tRGVmaW5pdGlvbiByZXF1ZXN0IGZhaWxlZFwiKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldERlZkxheWVySlNPTihmTGF5ZXIsIHByb3BzKSB7XG4gICAgLypcbiAgICAvLyBjb21wYXJlZCB0byBzZXJ2aWNlIGluZm8gcmVzcG9uc2UgKGxheWVycywgdGFibGVzKS4uLi5cbiAgICAtIG5vIGluZGV4ZXNcbiAgICAtIG5vIGZpZWxkc1xuICAgIC0gbm8gc2VydmljZUl0ZW1JZFxuICAgIC0gbm8gc2VydmVyR2Vuc1xuICAgIC0gbm8gcmVsYXRpb25zaGlwc1xuICAgIC0gKyB1cmxcbiAgICAtICsgYXR0cmlidXRlc1xuICAgIC0gKyBsYXllck1ldGFkYXRhVXJsXG4gICAgLSArIG1hcFZpZXdlclVybFxuICAgIC0gKyBtYXBWaWV3ZXJVcmxXaXRoR2VvY29kZVxuICAgIC0gKyBuZXdNYXBWaWV3ZXJVcmxcbiAgICAtICsgc2NlbmVWaWV3ZXJVcmxcbiAgICAtICsgYWRtaW5MYXllckluZm9cbiAgICAqL1xuICAgIGNvbnN0IHsgbGF5ZXIsIGxheWVySXRlbSB9ID0gcHJvcHM7XG4gICAgY29uc3QganNvbiA9IGZMYXllci5zb3VyY2VKU09OO1xuICAgIGRlbGV0ZSBqc29uLmluZGV4ZXM7XG4gICAgZGVsZXRlIGpzb24uZmllbGRzO1xuICAgIGRlbGV0ZSBqc29uLnNlcnZpY2VJdGVtSWQ7XG4gICAgZGVsZXRlIGpzb24uc2VydmVyR2VucztcbiAgICBkZWxldGUganNvbi5yZWxhdGlvbnNoaXBzO1xuICAgIGpzb24udXJsID0gYCR7ZkxheWVyLnVybH0vJHtmTGF5ZXIubGF5ZXJJZH0/dG9rZW49JHtsYXllci5wb3J0YWxJdGVtLnBvcnRhbC5jcmVkZW50aWFsLnRva2VufWA7XG4gICAganNvbi5hZG1pbkxheWVySW5mbyA9IHtcbiAgICAgICAgdmlld0xheWVyRGVmaW5pdGlvbjoge1xuICAgICAgICAgICAgc291cmNlU2VydmljZU5hbWU6IGdldFNlcnZpY2VOYW1lKGxheWVySXRlbSksXG4gICAgICAgICAgICBzb3VyY2VMYXllcklkOiBmTGF5ZXIubGF5ZXJJZCxcbiAgICAgICAgICAgIHNvdXJjZUxheWVyRmllbGRzOiBcIipcIlxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBjYW4ndCB1cGRhdGUgZmllbGRzIG9yIEFPSSB3aGVuIGFkZGluZyBsYXllciB0byBkZWZpbml0aW9uXG4gICAgLy9jb25zb2xlLmxvZyhcImdldERlZkxheWVySlNPTiAtIGlkOlwiLCBmTGF5ZXIubGF5ZXJJZCwganNvbik7XG4gICAgcmV0dXJuIGpzb247XG59XG5hc3luYyBmdW5jdGlvbiBnZXRVcGRhdGVMYXllckpTT04oZkxheWVyLCBwcm9wcykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgIGNvbnN0IHsgbW9kdWxlcyB9ID0gcHJvcHM7XG4gICAgY29uc3QganNvbiA9IHt9O1xuICAgIGNvbnN0IHZpZXdMYXllclByb3BzID0gZ2V0Vmlld0xheWVyUHJvcHMoZkxheWVyLmxheWVySWQsIHByb3BzKTtcbiAgICBpZiAodmlld0xheWVyUHJvcHMpIHtcbiAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIGpzb24udmlld0RlZmluaXRpb25RdWVyeSA9IHZpZXdMYXllclByb3BzLmZpbHRlciB8fCBcIlwiO1xuICAgICAgICAvLyBBT0lcbiAgICAgICAgaWYgKHZpZXdMYXllclByb3BzLmFvaSkge1xuICAgICAgICAgICAgbGV0IGFvaSA9IHZpZXdMYXllclByb3BzLmFvaTtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBTUiBmaXRzIHRvIGxheWVyXG4gICAgICAgICAgICBpZiAoIXNhbWVTUihhb2kuc3BhdGlhbFJlZmVyZW5jZSwgZkxheWVyLnNwYXRpYWxSZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbW9kdWxlcy5wcm9qZWN0aW9uLmxvYWQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnZW9tID0gYW9pLnJpbmdzID8gbW9kdWxlcy5Qb2x5Z29uLmZyb21KU09OKGFvaSkgOiBtb2R1bGVzLkV4dGVudC5mcm9tSlNPTihhb2kpO1xuICAgICAgICAgICAgICAgIGFvaSA9IChfYSA9IG1vZHVsZXMucHJvamVjdGlvbi5wcm9qZWN0KGdlb20sIGZMYXllci5zcGF0aWFsUmVmZXJlbmNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvSlNPTigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnlUeXBlID0gYW9pLnJpbmdzID8gXCJlc3JpR2VvbWV0cnlQb2x5Z29uXCIgOiBcImVzcmlHZW9tZXRyeUVudmVsb3BlXCI7XG4gICAgICAgICAgICBqc29uLnZpZXdMYXllckRlZmluaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcImVzcmlTcGF0aWFsUmVsSW50ZXJzZWN0c1wiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGFvaVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGFkbWluTGF5ZXJJbmZvID0gZ2V0QWRtaW5MYXllckluZm8oZkxheWVyLmxheWVySWQsIHByb3BzKTtcbiAgICAgICAgICAgIGNvbnN0IGFvaVZhbHVlID0gKF9lID0gKF9kID0gKF9jID0gKF9iID0gYWRtaW5MYXllckluZm8gPT09IG51bGwgfHwgYWRtaW5MYXllckluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkbWluTGF5ZXJJbmZvLmFkbWluTGF5ZXJJbmZvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iudmlld0xheWVyRGVmaW5pdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRhYmxlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZmlsdGVyKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UudmFsdWU7XG4gICAgICAgICAgICBpZiAoYW9pVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHVwZGF0ZSBpZiB0aGVyZSB3YXMgb25lIGJlZm9yZVxuICAgICAgICAgICAgICAgIGpzb24udmlld0xheWVyRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmaWVsZHNcbiAgICAgICAgaWYgKHZpZXdMYXllclByb3BzLmZpZWxkcykge1xuICAgICAgICAgICAganNvbi5maWVsZHMgPSBmTGF5ZXIuZmllbGRzLm1hcCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmaWVsZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiB2aWV3TGF5ZXJQcm9wcy5maWVsZHMuaW5kZXhPZihmaWVsZC5uYW1lKSA+IC0xXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYWxsIGZpZWxkcyBhcmUgdmlzaWJsZVxuICAgICAgICAgICAganNvbi5maWVsZHMgPSBmTGF5ZXIuZmllbGRzLm1hcCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmaWVsZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAganNvbi52aWV3RGVmaW5pdGlvblF1ZXJ5ID0gXCJcIjtcbiAgICAgICAgLy8gZmllbGRzXG4gICAgICAgIGpzb24uZmllbGRzID0gZkxheWVyLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFPSVxuICAgICAgICBjb25zdCBhZG1pbkxheWVySW5mbyA9IGdldEFkbWluTGF5ZXJJbmZvKGZMYXllci5sYXllcklkLCBwcm9wcyk7XG4gICAgICAgIGNvbnN0IGFvaVZhbHVlID0gKF9qID0gKF9oID0gKF9nID0gKF9mID0gYWRtaW5MYXllckluZm8gPT09IG51bGwgfHwgYWRtaW5MYXllckluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkbWluTGF5ZXJJbmZvLmFkbWluTGF5ZXJJbmZvKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yudmlld0xheWVyRGVmaW5pdGlvbikgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnRhYmxlKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZmlsdGVyKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2oudmFsdWU7XG4gICAgICAgIGlmIChhb2lWYWx1ZSkge1xuICAgICAgICAgICAgLy8gb25seSB1cGRhdGUgaWYgdGhlcmUgd2FzIG9uZSBiZWZvcmVcbiAgICAgICAgICAgIGpzb24udmlld0xheWVyRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9jb25zb2xlLmxvZyhcImdldFVwZGF0ZUxheWVySlNPTiAtIGlkOlwiLCBmTGF5ZXIubGF5ZXJJZCwganNvbik7XG4gICAgcmV0dXJuIGpzb247XG59XG5hc3luYyBmdW5jdGlvbiBtb3ZlVG9Gb2xkZXIocHJvcHMsIGNyZWF0ZVNlcnZpY2VSZXNwb25zZSwgbmV3SXRlbVByb3BzLCBlc3JpUmVxdWVzdCkge1xuICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHByb3BzO1xuICAgIGNvbnN0IHBvcnRhbEl0ZW0gPSBsYXllci5wb3J0YWxJdGVtO1xuICAgIGNvbnN0IHsgcG9ydGFsIH0gPSBwb3J0YWxJdGVtO1xuICAgIGlmICghbmV3SXRlbVByb3BzLmZvbGRlciB8fCAhbmV3SXRlbVByb3BzLmZvbGRlci5pZCB8fCBuZXdJdGVtUHJvcHMuZm9sZGVyLmlkID09PSBwb3J0YWxJdGVtLm93bmVyKSB7XG4gICAgICAgIC8vIGl0J3MgYWxyZWFkeSBpbiB0aGUgaG9tZSBmb2xkZXJcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgYmFzZVVybCA9IGAke3BvcnRhbC5yZXN0VXJsfS9jb250ZW50L3VzZXJzLyR7cG9ydGFsSXRlbS5vd25lcn0vaXRlbXMvYDtcbiAgICBjb25zdCBtb3ZlVXJsID0gYCR7YmFzZVVybH0ke2NyZWF0ZVNlcnZpY2VSZXNwb25zZS5pdGVtSWR9L21vdmVgO1xuICAgIGNvbnN0IG1vdmVDb250ZW50ID0ge1xuICAgICAgICBmb2xkZXI6IG5ld0l0ZW1Qcm9wcy5mb2xkZXIuaWRcbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCBlc3JpUmVxdWVzdChtb3ZlVXJsLCB7XG4gICAgICAgIHF1ZXJ5OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1vdmVDb250ZW50KSwgeyBmOiBcImpzb25cIiwgdG9rZW46IHBvcnRhbC5jcmVkZW50aWFsLnRva2VuIH0pLFxuICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxuICAgICAgICByZXNwb25zZVR5cGU6IFwianNvblwiXG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBpbml0aWFsSXRlbVVwZGF0ZShwcm9wcywgY3JlYXRlU2VydmljZVJlc3BvbnNlLCBuZXdJdGVtUHJvcHMsIGVzcmlSZXF1ZXN0KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vLCBfcDtcbiAgICBjb25zdCB7IGxheWVyLCBsYXllcklkcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgcG9ydGFsSXRlbSA9IGxheWVyLnBvcnRhbEl0ZW07XG4gICAgY29uc3QgcG9ydGFsID0gcG9ydGFsSXRlbS5wb3J0YWw7XG4gICAgY29uc3QgaXRlbURhdGEgPSBhd2FpdCBsYXllci5wb3J0YWxJdGVtLmZldGNoRGF0YSgpO1xuICAgIGNvbnN0IGhhc0RhdGEgPSAoaXRlbURhdGEgPT09IG51bGwgfHwgaXRlbURhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGl0ZW1EYXRhLmxheWVycykgfHwgKGl0ZW1EYXRhID09PSBudWxsIHx8IGl0ZW1EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpdGVtRGF0YS50YWJsZXMpO1xuICAgIGlmIChoYXNEYXRhKSB7XG4gICAgICAgIGl0ZW1EYXRhLmxheWVycyA9IChfYSA9IGl0ZW1EYXRhLmxheWVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcigobHlyKSA9PiBsYXllcklkcy5pbmRleE9mKGx5ci5pZCkgPiAtMSk7XG4gICAgICAgIGl0ZW1EYXRhLnRhYmxlcyA9IChfYiA9IGl0ZW1EYXRhLnRhYmxlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZpbHRlcigobHlyKSA9PiBsYXllcklkcy5pbmRleE9mKGx5ci5pZCkgPiAtMSk7XG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBleGlzdGluZyBvdmVycmlkZXMgZm9yIGxheWVycyBvciB0YWJsZXMga2VlcCB0aGVtIHVuZGVmaW5lZFxuICAgICAgICBpZiAobGF5ZXIudHlwZSA9PT0gXCJncm91cFwiICYmICgoX2MgPSBsYXllci5sYXllcnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpKSB7XG4gICAgICAgICAgICBpdGVtRGF0YS5sYXllcnMgPSBpdGVtRGF0YS5sYXllcnMgfHwgdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXllci50eXBlID09PSBcImdyb3VwXCIgJiYgKChfZCA9IGxheWVyLnRhYmxlcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGl0ZW1EYXRhLnRhYmxlcyA9IGl0ZW1EYXRhLnRhYmxlcyB8fCB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIHBhcmVudCBpdGVtIGRlZmluaXRpb25FeHByZXNzaW9uXG4gICAgICAgIChfZSA9IGl0ZW1EYXRhLmxheWVycykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmZvckVhY2goKGx5cikgPT4ge1xuICAgICAgICAgICAgaWYgKGx5ci5sYXllckRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICBseXIubGF5ZXJEZWZpbml0aW9uLmRlZmluaXRpb25FeHByZXNzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgKF9mID0gaXRlbURhdGEudGFibGVzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuZm9yRWFjaCgodGFibGUpID0+IHtcbiAgICAgICAgICAgIGlmICh0YWJsZS5sYXllckRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0YWJsZS5sYXllckRlZmluaXRpb24uZGVmaW5pdGlvbkV4cHJlc3Npb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVVcmwgPSBgJHtwb3J0YWwucmVzdFVybH0vY29udGVudC91c2Vycy8ke3BvcnRhbEl0ZW0ub3duZXJ9L2l0ZW1zLyR7Y3JlYXRlU2VydmljZVJlc3BvbnNlLml0ZW1JZH0vdXBkYXRlYDtcbiAgICAvLyBuZWVkIHRvIHNlbmQgc29tZSBpbmZvIGFnYWluXG4gICAgY29uc3QgdXBkYXRlQ29udGVudCA9IHtcbiAgICAgICAgdGl0bGU6IG5ld0l0ZW1Qcm9wcy50aXRsZSxcbiAgICAgICAgdGFnczogKChfZyA9IG5ld0l0ZW1Qcm9wcy50YWdzKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cubGVuZ3RoKSA/IG5ld0l0ZW1Qcm9wcy50YWdzLnRvU3RyaW5nKCkgOiB1bmRlZmluZWQsXG4gICAgICAgIHNuaXBwZXQ6IG5ld0l0ZW1Qcm9wcy5zdW1tYXJ5LFxuICAgICAgICBjYXRlZ29yaWVzOiAoX2ggPSBuZXdJdGVtUHJvcHMuY2F0ZWdvcmllcykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmpvaW4oXCIsXCIpXG4gICAgICAgIC8vZXh0ZW50OiBgJHtwb3J0YWxJdGVtLmV4dGVudC54bWlufSwke3BvcnRhbEl0ZW0uZXh0ZW50LnltaW59LCR7cG9ydGFsSXRlbS5leHRlbnQueG1heH0sJHtwb3J0YWxJdGVtLmV4dGVudC55bWF4fWAsXG4gICAgfTtcbiAgICBpZiAoaGFzRGF0YSkge1xuICAgICAgICB1cGRhdGVDb250ZW50LnRleHQgPSBKU09OLnN0cmluZ2lmeShpdGVtRGF0YSk7XG4gICAgfVxuICAgIGlmICgobGF5ZXIudHlwZSA9PT0gXCJncm91cFwiICYmICgoX20gPSAoX2wgPSAoX2sgPSAoX2ogPSBsYXllci5sYXllcnMpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5nZXRJdGVtQXQoMCkpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5mdWxsRXh0ZW50KSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wuc3BhdGlhbFJlZmVyZW5jZSkgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tLndrdCkpIHx8XG4gICAgICAgIChsYXllci50eXBlID09PSBcImZlYXR1cmVcIiAmJiAoKF9wID0gKF9vID0gbGF5ZXIuZnVsbEV4dGVudCkgPT09IG51bGwgfHwgX28gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vLnNwYXRpYWxSZWZlcmVuY2UpID09PSBudWxsIHx8IF9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcC53a3QpKSkge1xuICAgICAgICAvLyBmaXggYmFkIGl0ZW0gZXh0ZW50IGNyZWF0ZWQgYnkgdGhlIC9yZWZyZXNoIGNhbGwgc2VudCBmcm9tIGFkZFRvRGVmaW5pdGlvblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUNvbnRlbnQyID0ge1xuICAgICAgICAgICAgICAgIGV4dGVudDogYCR7cG9ydGFsSXRlbS5leHRlbnQueG1pbn0sJHtwb3J0YWxJdGVtLmV4dGVudC55bWlufSwke3BvcnRhbEl0ZW0uZXh0ZW50LnhtYXh9LCR7cG9ydGFsSXRlbS5leHRlbnQueW1heH1gXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXNyaVJlcXVlc3QodXBkYXRlVXJsLCB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXBkYXRlQ29udGVudDIpLCB7IGY6IFwianNvblwiLCB0b2tlbjogcG9ydGFsLmNyZWRlbnRpYWwudG9rZW4gfSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6IFwianNvblwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgNzAwMCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBlc3JpUmVxdWVzdCh1cGRhdGVVcmwsIHtcbiAgICAgICAgcXVlcnk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXBkYXRlQ29udGVudCksIHsgZjogXCJqc29uXCIsIHRva2VuOiBwb3J0YWwuY3JlZGVudGlhbC50b2tlbiB9KSxcbiAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgcmVzcG9uc2VUeXBlOiBcImpzb25cIlxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gaXRlbVVwZGF0ZShwcm9wcywgYWRkTGF5ZXJJZHMsIGRlbGV0ZUxheWVySWRzLCBlc3JpUmVxdWVzdCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgaWYgKCFhZGRMYXllcklkcy5sZW5ndGggJiYgIWRlbGV0ZUxheWVySWRzLmxlbmd0aCkge1xuICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgeyBsYXllciwgdmlld0l0ZW0gfSA9IHByb3BzO1xuICAgIGNvbnN0IHBvcnRhbEl0ZW0gPSBsYXllci5wb3J0YWxJdGVtO1xuICAgIGNvbnN0IHBvcnRhbCA9IHBvcnRhbEl0ZW0ucG9ydGFsO1xuICAgIGNvbnN0IGl0ZW1EYXRhID0gYXdhaXQgbGF5ZXIucG9ydGFsSXRlbS5mZXRjaERhdGEoKTtcbiAgICBsZXQgdmlld0l0ZW1EYXRhID0gYXdhaXQgdmlld0l0ZW0uZmV0Y2hEYXRhKCk7XG4gICAgaWYgKCghaXRlbURhdGEgfHwgKCFpdGVtRGF0YS5sYXllcnMgJiYgIWl0ZW1EYXRhLnRhYmxlcykpICYmXG4gICAgICAgICghdmlld0l0ZW1EYXRhIHx8ICghdmlld0l0ZW1EYXRhLmxheWVycyAmJiAhdmlld0l0ZW1EYXRhLnRhYmxlcykpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRlbGV0ZUxheWVySWRzLmxlbmd0aCkge1xuICAgICAgICBpZiAoKF9hID0gdmlld0l0ZW1EYXRhID09PSBudWxsIHx8IHZpZXdJdGVtRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlld0l0ZW1EYXRhLmxheWVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkge1xuICAgICAgICAgICAgdmlld0l0ZW1EYXRhLmxheWVycyA9IHZpZXdJdGVtRGF0YS5sYXllcnMuZmlsdGVyKChseXIpID0+IGRlbGV0ZUxheWVySWRzLmluZGV4T2YobHlyLmlkKSA9PT0gLTEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoX2IgPSB2aWV3SXRlbURhdGEgPT09IG51bGwgfHwgdmlld0l0ZW1EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWV3SXRlbURhdGEudGFibGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSB7XG4gICAgICAgICAgICB2aWV3SXRlbURhdGEudGFibGVzID0gdmlld0l0ZW1EYXRhLnRhYmxlcy5maWx0ZXIoKGx5cikgPT4gZGVsZXRlTGF5ZXJJZHMuaW5kZXhPZihseXIuaWQpID09PSAtMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRG8gd2UgYWxyZWFkeSBoYXZlIGEgbGF5ZXJzL3RhYmxlcyBsaXN0IGluIHRoZSBpdGVtIC9kYXRhIG9iamVjdD9cbiAgICAvLyBJZiBzbywgYXJlIHdlIGFkZGluZyBzb21lIG5ldyBsYXllcnMvdGFibGVzP1xuICAgIC8vIFRoZW4gd2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB3ZSBhZGQgdGhlc2UgbmV3IGxheWVycy90YWJsZXMgdG8gdGhlIGxpc3RcbiAgICAvLyBldmVuIGlmIHRoZXJlIGFyZSBubyBleGlzdGluZyBvdmVycmlkZXMgZm9yIHRoZW1cbiAgICBjb25zdCB2aWV3SXRlbUhhc0NvbnRlbnQgPSAhISgoX2MgPSB2aWV3SXRlbURhdGEgPT09IG51bGwgfHwgdmlld0l0ZW1EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWV3SXRlbURhdGEubGF5ZXJzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGVuZ3RoKSB8fCAhISgoX2QgPSB2aWV3SXRlbURhdGEgPT09IG51bGwgfHwgdmlld0l0ZW1EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWV3SXRlbURhdGEudGFibGVzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKTtcbiAgICBpZiAoYWRkTGF5ZXJJZHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG5ld0xheWVycyA9IFtdO1xuICAgICAgICBjb25zdCBuZXdUYWJsZXMgPSBbXTtcbiAgICAgICAgYWRkTGF5ZXJJZHMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZMYXllciA9IGdldEZMKGlkLCBwcm9wcyk7XG4gICAgICAgICAgICBpZiAoIWZMYXllci5pc1RhYmxlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0xheWVyO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtRGF0YSA9PT0gbnVsbCB8fCBpdGVtRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXRlbURhdGEubGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0xheWVyID0gaXRlbURhdGEubGF5ZXJzLmZpbmQoKGx5cikgPT4gbHlyLmlkID09PSBpZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBwYXJlbnQgaXRlbSBkZWZpbml0aW9uRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3TGF5ZXIgPT09IG51bGwgfHwgbmV3TGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5ld0xheWVyLmxheWVyRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGF5ZXIubGF5ZXJEZWZpbml0aW9uLmRlZmluaXRpb25FeHByZXNzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbmV3TGF5ZXIgJiYgdmlld0l0ZW1IYXNDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG11c3QgYWRkIHRoZSBuZXdseSBhZGRlZCBsYXllciB0byB0aGUgaXRlbSAvZGF0YSBsYXllcnMgbGlzdFxuICAgICAgICAgICAgICAgICAgICAvLyBubyBvdmVycmlkZXMsIGFkZCBqdXN0IGlkLCBkb24ndCBuZWVkIHBvcHVwXG4gICAgICAgICAgICAgICAgICAgIG5ld0xheWVyID0geyBpZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TGF5ZXJzLnB1c2gobmV3TGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRhYmxlXG4gICAgICAgICAgICAgICAgbGV0IG5ld1RhYmxlO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtRGF0YSA9PT0gbnVsbCB8fCBpdGVtRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXRlbURhdGEudGFibGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1RhYmxlID0gaXRlbURhdGEudGFibGVzLmZpbmQoKGx5cikgPT4gbHlyLmlkID09PSBpZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBwYXJlbnQgaXRlbSBkZWZpbml0aW9uRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VGFibGUgPT09IG51bGwgfHwgbmV3VGFibGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5ld1RhYmxlLmxheWVyRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VGFibGUubGF5ZXJEZWZpbml0aW9uLmRlZmluaXRpb25FeHByZXNzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbmV3VGFibGUgJiYgdmlld0l0ZW1IYXNDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG11c3QgYWRkIHRoZSBuZXdseSBhZGRlZCBsYXllciB0byB0aGUgaXRlbSAvZGF0YSBsYXllcnMgbGlzdFxuICAgICAgICAgICAgICAgICAgICAvLyBubyBvdmVycmlkZXMsIGFkZCBqdXN0IGlkLCBkb24ndCBuZWVkIHBvcHVwXG4gICAgICAgICAgICAgICAgICAgIG5ld1RhYmxlID0geyBpZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3VGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VGFibGVzLnB1c2gobmV3VGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdMYXllcnMgPT09IG51bGwgfHwgbmV3TGF5ZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXdMYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2aWV3SXRlbURhdGEgPSB2aWV3SXRlbURhdGEgfHwge307XG4gICAgICAgICAgICB2aWV3SXRlbURhdGEubGF5ZXJzID0gKHZpZXdJdGVtRGF0YS5sYXllcnMgfHwgW10pLmNvbmNhdChuZXdMYXllcnMpO1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGl0IGZvbGxvd3MgdGhlIHBhcmVudCBsYXllcidzIG9yZGVyXG4gICAgICAgICAgICAvLyB0aGUgdmlldyBzZXJ2aWNlIG1pZ2h0IGhhdmUgaXQgZGlmZmVyZW50bHkgKHNlcnZpY2UgYnVnKVxuICAgICAgICAgICAgY29uc3QgaWRzID0gW107XG4gICAgICAgICAgICAoX2UgPSBsYXllci5sYXllcnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5mb3JFYWNoKChseXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZHMudW5zaGlmdChseXIubGF5ZXJJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZpZXdJdGVtRGF0YS5sYXllcnMuc29ydCgobHlyQSwgbHlyQikgPT4gKGlkcy5pbmRleE9mKGx5ckEuaWQpIDwgaWRzLmluZGV4T2YobHlyQi5pZCkgPyAtMSA6IDEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VGFibGVzID09PSBudWxsIHx8IG5ld1RhYmxlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV3VGFibGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmlld0l0ZW1EYXRhID0gdmlld0l0ZW1EYXRhIHx8IHt9O1xuICAgICAgICAgICAgdmlld0l0ZW1EYXRhLnRhYmxlcyA9ICh2aWV3SXRlbURhdGEudGFibGVzIHx8IFtdKS5jb25jYXQobmV3VGFibGVzKTtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBpdCBmb2xsb3dzIHRoZSBwYXJlbnQgbGF5ZXIncyBvcmRlclxuICAgICAgICAgICAgLy8gdGhlIHZpZXcgc2VydmljZSBtaWdodCBoYXZlIGl0IGRpZmZlcmVudGx5IChzZXJ2aWNlIGJ1ZylcbiAgICAgICAgICAgIGNvbnN0IGlkcyA9IFtdO1xuICAgICAgICAgICAgKF9mID0gbGF5ZXIudGFibGVzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuZm9yRWFjaCgobHlyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWRzLnVuc2hpZnQobHlyLmxheWVySWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2aWV3SXRlbURhdGEudGFibGVzLnNvcnQoKGx5ckEsIGx5ckIpID0+IChpZHMuaW5kZXhPZihseXJBLmlkKSA8IGlkcy5pbmRleE9mKGx5ckIuaWQpID8gLTEgOiAxKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXBkYXRlVXJsID0gYCR7cG9ydGFsLnJlc3RVcmx9L2NvbnRlbnQvdXNlcnMvJHtwb3J0YWxJdGVtLm93bmVyfS9pdGVtcy8ke3ZpZXdJdGVtLmlkfS91cGRhdGVgO1xuICAgIC8vIG5lZWQgdG8gc2VuZCBzb21lIGluZm8gYWdhaW5cbiAgICBjb25zdCB1cGRhdGVDb250ZW50ID0ge1xuICAgICAgICB0YWdzOiAoKF9nID0gdmlld0l0ZW0udGFncykgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmxlbmd0aCkgPyB2aWV3SXRlbS50YWdzLnRvU3RyaW5nKCkgOiB1bmRlZmluZWQsXG4gICAgICAgIHNuaXBwZXQ6IHZpZXdJdGVtLnNuaXBwZXQsXG4gICAgICAgIGNhdGVnb3JpZXM6IChfaCA9IHZpZXdJdGVtLmNhdGVnb3JpZXMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5qb2luKFwiLFwiKSxcbiAgICAgICAgLy9leHRlbnQ6IGAke3ZpZXdJdGVtLmV4dGVudC54bWlufSwke3ZpZXdJdGVtLmV4dGVudC55bWlufSwke3ZpZXdJdGVtLmV4dGVudC54bWF4fSwke3ZpZXdJdGVtLmV4dGVudC55bWF4fWAsXG4gICAgICAgIHRleHQ6IEpTT04uc3RyaW5naWZ5KHZpZXdJdGVtRGF0YSlcbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCBlc3JpUmVxdWVzdCh1cGRhdGVVcmwsIHtcbiAgICAgICAgcXVlcnk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXBkYXRlQ29udGVudCksIHsgZjogXCJqc29uXCIsIHRva2VuOiBwb3J0YWwuY3JlZGVudGlhbC50b2tlbiB9KSxcbiAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgcmVzcG9uc2VUeXBlOiBcImpzb25cIlxuICAgIH0pO1xufVxuY29uc3QgcG9sbEZvclN0YXR1cyQxID0gYXN5bmMgKHVybCwgcGFyYW1zLCBlc3JpUmVxdWVzdCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXVybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb2xsRm9yU3RhdHVzOiBubyBzdGF0dXMgVVJMXCIpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nU3RhdHVzZXMgPSBbXCJwcm9jZXNzaW5nXCIsIFwicGFydGlhbFwiLCBcIlBlbmRpbmdcIiwgXCJJblByb2dyZXNzXCJdO1xuICAgIGNvbnN0IHN1Y2Nlc3NTdGF0dXNlcyA9IFtcImNvbXBsZXRlZFwiLCBcIkNvbXBsZXRlZFwiXTtcbiAgICAvLyBLZWVwIHBvbGxpbmcgc3RhdHVzIHVudGlsIGVpdGhlciBjb21wbGV0ZWQgb3IgZmFpbGVkXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRG8gZmFpbHVyZXMgcmVwb3J0IGFzIHN1Y2Nlc3MgKHN0YXR1cyAyMDApPyBNYXkgbmVlZCB0byBtYW51YWxseSB0aHJvdyBlcnJvciBvbiBzdGF0dXMgY2hlY2sgZmFpbHVyZVxuICAgICAgICBjb25zdCBzdGF0dXNSZXNwb25zZSA9IGF3YWl0IGVzcmlSZXF1ZXN0KHVybCwgeyBxdWVyeTogcGFyYW1zIH0pO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSAoX2EgPSBzdGF0dXNSZXNwb25zZSA9PT0gbnVsbCB8fCBzdGF0dXNSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdHVzUmVzcG9uc2UuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXR1cztcbiAgICAgICAgaWYgKHBlbmRpbmdTdGF0dXNlcy5pbmNsdWRlcyhzdGF0dXMpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aW1lb3V0KDUwMCk7XG4gICAgICAgICAgICByZXR1cm4gcG9sbEZvclN0YXR1cyQxKHVybCwgcGFyYW1zLCBlc3JpUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3VjY2Vzc1N0YXR1c2VzLmluY2x1ZGVzKHN0YXR1cykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbmNvbnN0IGFyY2dpc0xheWVyVmlld0NzcyA9IFwiLnNjLWFyY2dpcy1sYXllci12aWV3LWh7aGVpZ2h0OjEwMCV9LnBhbmVsLnNjLWFyY2dpcy1sYXllci12aWV3e2hlaWdodDoxMDAlfS5mb290ZXIuc2MtYXJjZ2lzLWxheWVyLXZpZXd7d2lkdGg6MTAwJX0uZXJyb3ItY29udGVudC5zYy1hcmNnaXMtbGF5ZXItdmlld3ttYXJnaW46MC41cmVtfVwiO1xuXG5jb25zdCBBcmNnaXNMYXllclZpZXckMSA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Q2FuY2VsID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNMYXllclZpZXdDYW5jZWxcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3U3RlcENoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzTGF5ZXJWaWV3U3RlcENoYW5nZVwiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdDcmVhdGVkID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNMYXllclZpZXdDcmVhdGVkXCIsIDcpO1xuICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld0NoYW5nZWQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0xheWVyVmlld0NoYW5nZWRcIiwgNyk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gZmxvd1N0YXR1cy5MT0FESU5HO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvL1xuICAgICAgICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMuZ29DYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld0NhbmNlbC5lbWl0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudmlldyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pdGVtSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29uZmlnID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnByb3BzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlUmVuZGVyID0gZmFsc2U7XG4gICAgfVxuICAgIGFyY2dpc0xheWVyVmlld1N0YXR1c0hhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGRldGFpbCB9ID0gZXZlbnQ7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gZGV0YWlsLnN0YXR1cztcbiAgICAgICAgaWYgKChfYSA9IGRldGFpbC5sYXllcklkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkge1xuICAgICAgICAgICAgcHJvcHMubGF5ZXJJZHMgPSBbLi4uZGV0YWlsLmxheWVySWRzXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IGZsb3dTdGF0dXMuU0VMRUNUSU9OKSB7XG4gICAgICAgICAgICAvLyB3ZSBtaWdodCBjaGFuZ2Ugc291cmNlIGl0ZW0gaW4gdGhpcyBzdGVwLi4uXG4gICAgICAgICAgICBwcm9wcy5zb3VyY2VJdGVtSWQgPSBwcm9wcy5sYXllckl0ZW0uaWQ7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld1N0ZXBDaGFuZ2UuZW1pdCgxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXR1cyA9PT0gZmxvd1N0YXR1cy5PVkVSVklFVykge1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdTdGVwQ2hhbmdlLmVtaXQoMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0dXMgPT09IGZsb3dTdGF0dXMuQ1JFQVRFKSB7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld1N0ZXBDaGFuZ2UuZW1pdCgzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgfVxuICAgIGFzeW5jIGFyY2dpc0xheWVyVmlld0NyZWF0ZURvbmVIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Q3JlYXRlZC5lbWl0KGV2ZW50LmRldGFpbCk7XG4gICAgfVxuICAgIGFzeW5jIGFyY2dpc0xheWVyVmlld092ZXJ2aWV3VXBkYXRlZEhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Q2hhbmdlZC5lbWl0KHRoaXMuaXRlbUlkKTtcbiAgICB9XG4gICAgYXJjZ2lzTGF5ZXJWaWV3U2VsZWN0aW9uQ2FuY2VsSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdDYW5jZWwuZW1pdCgpO1xuICAgIH1cbiAgICBhcmNnaXNMYXllclZpZXdPdmVydmlld0NhbmNlbEhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Q2FuY2VsLmVtaXQoKTtcbiAgICB9XG4gICAgYXJjZ2lzTGF5ZXJWaWV3Q3JlYXRlQ2FuY2VsSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdDYW5jZWwuZW1pdCgpO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUHVibGljIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyBzZXRTdGVwKHN0ZXApIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB2aWV3SXRlbSB9ID0gcHJvcHM7XG4gICAgICAgIC8vIGNsb3NlIHBvcG92ZXJzXG4gICAgICAgIGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvckFsbChcIi5qcy1hcHAtZmx5b3V0XCIpLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IGZsb3dTdGF0dXMuU0VMRUNUSU9OO1xuICAgICAgICAgICAgICAgIHRoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IGZsb3dTdGF0dXMuT1ZFUlZJRVc7XG4gICAgICAgICAgICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGlmICghdmlld0l0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBmbG93U3RhdHVzLkNSRUFURTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgTGlmZWN5Y2xlXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgICAgIGNvbnN0IHsgaXRlbUlkLCB2aWV3LCBjb25maWcgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IFtzdHJpbmdzXSA9IGF3YWl0IGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3ModGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgIHRoaXMucHJvcHMgPSB7IGNvbmZpZywgdmlldywgaXRlbUlkLCBzdHJpbmdzLCBsYXllcklkczogW10sIG1vZHVsZXM6IHt9IH07XG4gICAgfVxuICAgIGFzeW5jIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBpdGVtSWQsIHZpZXcgfSA9IHByb3BzO1xuICAgICAgICBpZiAoIWl0ZW1JZCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIml0ZW1JZCBpcyBhIHJlcXVpcmVkIHByb3BlcnR5LlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgW1BvcnRhbEl0ZW0sIExheWVyLCBFeHRlbnQsIHByb2plY3Rpb24sIGNvbG9yVXRpbHMsIFBvbHlnb24sIGVzcmlSZXF1ZXN0XSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcbiAgICAgICAgICAgICAgICBcImVzcmkvcG9ydGFsL1BvcnRhbEl0ZW1cIixcbiAgICAgICAgICAgICAgICBcImVzcmkvbGF5ZXJzL0xheWVyXCIsXG4gICAgICAgICAgICAgICAgXCJlc3JpL2dlb21ldHJ5L0V4dGVudFwiLFxuICAgICAgICAgICAgICAgIFwiZXNyaS9nZW9tZXRyeS9wcm9qZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJlc3JpL3ZpZXdzL3N1cHBvcnQvY29sb3JVdGlsc1wiLFxuICAgICAgICAgICAgICAgIFwiZXNyaS9nZW9tZXRyeS9Qb2x5Z29uXCIsXG4gICAgICAgICAgICAgICAgXCJlc3JpL3JlcXVlc3RcIlxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBwcm9wcy5tb2R1bGVzLlBvcnRhbEl0ZW0gPSBQb3J0YWxJdGVtO1xuICAgICAgICAgICAgcHJvcHMubW9kdWxlcy5wcm9qZWN0aW9uID0gcHJvamVjdGlvbjtcbiAgICAgICAgICAgIHByb3BzLm1vZHVsZXMuUG9seWdvbiA9IFBvbHlnb247XG4gICAgICAgICAgICBwcm9wcy5tb2R1bGVzLkV4dGVudCA9IEV4dGVudDtcbiAgICAgICAgICAgIHByb3BzLm1vZHVsZXMuTGF5ZXIgPSBMYXllcjtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBuZXcgUG9ydGFsSXRlbSh7XG4gICAgICAgICAgICAgICAgaWQ6IGl0ZW1JZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBpdGVtLmxvYWQoKTtcbiAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgIT09IFwiRmVhdHVyZSBTZXJ2aWNlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiT25seSBGZWF0dXJlIFNlcnZpY2UgaXRlbXMgYXJlIGFsbG93ZWQuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB2aWV3SXRlbSwgbGF5ZXJJdGVtO1xuICAgICAgICAgICAgaWYgKCgoX2EgPSBpdGVtLnR5cGVLZXl3b3JkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluZGV4T2YoXCJWaWV3IFNlcnZpY2VcIikpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGxvb2sgZm9yIG9yaWdpbmFsIGl0ZW1cbiAgICAgICAgICAgICAgICB2aWV3SXRlbSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgYXdhaXQgaXRlbVxuICAgICAgICAgICAgICAgICAgICAuZmV0Y2hSZWxhdGVkSXRlbXMoe1xuICAgICAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBUeXBlOiBcIlNlcnZpY2UyRGF0YVwiLFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFwiZm9yd2FyZFwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllckl0ZW0gPSByZXN1bHRzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXllckl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsYXllckl0ZW0pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IGZpbmQgcmVsYXRlZCBpdGVtIGZvciB2aWV3LlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhbmVsTm9kZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBmbG93U3RhdHVzLkVSUk9SO1xuICAgICAgICAgICAgICAgIHRoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wcy5zb3VyY2VJdGVtSWQgPSBsYXllckl0ZW0uaWQ7XG4gICAgICAgICAgICBsZXQgbGF5ZXJJdGVtT3duZXIgPSBsYXllckl0ZW0ucG9ydGFsLnVzZXI7XG4gICAgICAgICAgICBpZiAobGF5ZXJJdGVtLnBvcnRhbC51c2VyLnVzZXJuYW1lICE9PSBsYXllckl0ZW0ub3duZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdXNlciBpbmZvIG9mIG93bmVyXG4gICAgICAgICAgICAgICAgYXdhaXQgZXNyaVJlcXVlc3QoYCR7bGF5ZXJJdGVtLnBvcnRhbC5yZXN0VXJsfS9jb21tdW5pdHkvdXNlcnMvJHtsYXllckl0ZW0ub3duZXJ9YCwge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeTogeyBmOiBcImpzb25cIiB9XG4gICAgICAgICAgICAgICAgfSkudGhlbigodXNlclJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlclJlc3VsdCA9PT0gbnVsbCB8fCB1c2VyUmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyUmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVySXRlbU93bmVyID0gdXNlclJlc3VsdC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZ2NzRXh0ZW50ID0gKHZpZXdJdGVtIHx8IGxheWVySXRlbSkuZXh0ZW50O1xuICAgICAgICAgICAgaWYgKCFnY3NFeHRlbnQpIHtcbiAgICAgICAgICAgICAgICBnY3NFeHRlbnQgPSBuZXcgRXh0ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgeG1pbjogLTE4MCxcbiAgICAgICAgICAgICAgICAgICAgeW1pbjogLTkwLFxuICAgICAgICAgICAgICAgICAgICB4bWF4OiAxODAsXG4gICAgICAgICAgICAgICAgICAgIHltYXg6IDkwLFxuICAgICAgICAgICAgICAgICAgICBzcGF0aWFsUmVmZXJlbmNlOiA0MzI2XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlldy5zcGF0aWFsUmVmZXJlbmNlLndraWQgIT09IDQzMjYpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBwcm9qZWN0aW9uLmxvYWQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHRlbnQgPSBwcm9qZWN0aW9uLnByb2plY3QoZ2NzRXh0ZW50LCB2aWV3LnNwYXRpYWxSZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgIHZpZXcuZ29UbyhleHRlbnQuZXhwYW5kKDEuMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmlldy5nb1RvKGdjc0V4dGVudC5leHBhbmQoMS4xKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kVGhlbWUgPSBhd2FpdCBjb2xvclV0aWxzLmdldEJhY2tncm91bmRDb2xvclRoZW1lKHZpZXcpO1xuICAgICAgICAgICAgLy8gbGF5ZXJJdGVtIChmcm9tIHJlbGF0ZWRJdGVtcyBjYWxsKSBkb2VzIG5vdCBjb250YWluIGl0ZW1Db250cm9sXG4gICAgICAgICAgICAvLyBuZWVkIHRvIGdldCB0aGUgaXRlbSBjYXJkIGFnYWluIHRvIGdldCBpdGVtQ29udHJvbCB0b29cbiAgICAgICAgICAgIC8vIG5lZWQgaXRlbUNvbnRyb2wgdG8gY3JlYXRlIGluZGV4ZXNcbiAgICAgICAgICAgIGxheWVySXRlbSA9IG5ldyBQb3J0YWxJdGVtKHtcbiAgICAgICAgICAgICAgICBpZDogbGF5ZXJJdGVtLmlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IGxheWVySXRlbS5sb2FkKCk7XG4gICAgICAgICAgICBjb25zdCBsYXllciA9IGF3YWl0IExheWVyLmZyb21Qb3J0YWxJdGVtKHtcbiAgICAgICAgICAgICAgICBwb3J0YWxJdGVtOiBsYXllckl0ZW1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCB7IGxheWVySXRlbSwgdmlld0l0ZW0sIGxheWVyLCBsYXllckl0ZW1Pd25lciwgYmFja2dyb3VuZFRoZW1lIH0pO1xuICAgICAgICAgICAgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIioqbGF5ZXJJdGVtKipcIiwgbGF5ZXJJdGVtKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCIqKnZpZXdJdGVtKipcIiwgdmlld0l0ZW0pO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIioqbGF5ZXIqKlwiLCBsYXllcik7XG4gICAgICAgICAgICBpZiAobGF5ZXIudHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gZ3JvdXAgbGF5ZXIgaGFzIG5vIGxheWVycyBvciB0YWJsZXMgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgICAgIC8vIGxvYWRBbGwoKSBsb2FkcyBsYXllcnMgYW5kIHRhYmxlcyAoYXQgdjQuMjMpXG4gICAgICAgICAgICAgICAgYXdhaXQgbGF5ZXIubG9hZEFsbCgpO1xuICAgICAgICAgICAgICAgIGlmICgoX2IgPSBsYXllci5sYXllcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzIGF0IGxlYXN0IG9uZSBzcGF0aWFsIGxheWVyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcubWFwLmFkZChsYXllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb3BzLmxheWVySWRzID0gZ2V0TGF5ZXJzQW5kVGFibGVzKGxheWVyKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChzdWJMYXllcikgPT4gc3ViTGF5ZXIubGF5ZXJJZClcbiAgICAgICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHBvcHVwc1xuICAgICAgICAgICAgICAgIChfYyA9IGxheWVyLmxheWVycykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZvckVhY2goKGx5cikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWx5ci5wb3B1cFRlbXBsYXRlICYmIGx5ci5wb3B1cEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGx5ci5wb3B1cFRlbXBsYXRlID0gbHlyLmNyZWF0ZVBvcHVwVGVtcGxhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbGF5ZXIubG9hZCgpO1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXIuaXNUYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3Lm1hcC5hZGQobGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9wcy5sYXllcklkcyA9IFtsYXllci5sYXllcklkXTtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHBvcHVwXG4gICAgICAgICAgICAgICAgbGF5ZXIucG9wdXBUZW1wbGF0ZSA9IGxheWVyLmNyZWF0ZVBvcHVwVGVtcGxhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGdldEFkbWluU2VydmljZUluZm8kMShwcm9wcyk7XG4gICAgICAgICAgICAvKiBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgXCJ2aWV3IGFkbWluU2VydmljZUluZm8gbGF5ZXJzXCIsXG4gICAgICAgICAgICAgIHByb3BzLmFkbWluU2VydmljZUluZm8/LmxheWVycz8ubWFwKChseXI6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBpZDogbHlyLmlkLFxuICAgICAgICAgICAgICAgICAgbmFtZTogbHlyLm5hbWUsXG4gICAgICAgICAgICAgICAgICBhZG1pbkxheWVySW5mb19maWx0ZXI6IGx5ci5hZG1pbkxheWVySW5mbz8udmlld0xheWVyRGVmaW5pdGlvbj8udGFibGU/LmZpbHRlcj8udmFsdWUsXG4gICAgICAgICAgICAgICAgICB2aWV3RGVmaW5pdGlvblF1ZXJ5OiBseXIudmlld0RlZmluaXRpb25RdWVyeSxcbiAgICAgICAgICAgICAgICAgIGZpZWxkczogbHlyLmZpZWxkcy5tYXAoKGZpZWxkOiBhbnkpID0+IGAke2ZpZWxkLm5hbWV9ICgke2ZpZWxkLnZpc2libGV9KWApXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7ICovXG4gICAgICAgICAgICBhd2FpdCBpbml0RGVmaW5pdGlvbnMocHJvcHMpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImluaXREZWZpbml0aW9uc1wiLCBwcm9wc1RvU3RyaW5nKHByb3BzKSk7XG4gICAgICAgICAgICAvLyBkZXJpdmF0aXZlIGxheWVyc1xuICAgICAgICAgICAgcHJvcHMuZGVyaXZhdGl2ZUxheWVycyA9IHsgaGFzQW55OiBmYWxzZSB9O1xuICAgICAgICAgICAgaWYgKHZpZXdJdGVtKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGl0ZW0uZmV0Y2hSZWxhdGVkSXRlbXMoe1xuICAgICAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBUeXBlOiBcIlNlcnZpY2UyU2VydmljZVwiLFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFwiZm9yd2FyZFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmRlcml2YXRpdmVMYXllcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNNUzogcmVzdWx0cy5maW5kKChpdGVtKSA9PiBpdGVtLnR5cGUgPT09IFwiTWFwIFNlcnZpY2VcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNWVEw6IHJlc3VsdHMuZmluZCgoaXRlbSkgPT4gaXRlbS50eXBlID09PSBcIlZlY3RvciBUaWxlIFNlcnZpY2VcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNXRlM6IHJlc3VsdHMuZmluZCgoaXRlbSkgPT4gaXRlbS50eXBlID09PSBcIldGU1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1NjZW5lOiByZXN1bHRzLmZpbmQoKGl0ZW0pID0+IGl0ZW0udHlwZSA9PT0gXCJTY2VuZSBTZXJ2aWNlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzT0dDRkw6IHJlc3VsdHMuZmluZCgoaXRlbSkgPT4gaXRlbS50eXBlID09PSBcIk9HQ0ZlYXR1cmVTZXJ2ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLmRlcml2YXRpdmVMYXllcnMuaGFzTVMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmRlcml2YXRpdmVMYXllcnMuaGFzVlRMIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5kZXJpdmF0aXZlTGF5ZXJzLmhhc1dGUyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuZGVyaXZhdGl2ZUxheWVycy5oYXNTY2VuZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuZGVyaXZhdGl2ZUxheWVycy5oYXNPR0NGTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuZGVyaXZhdGl2ZUxheWVycy5oYXNBbnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3luYyBhbmQgcmVwbGljYXNcbiAgICAgICAgICAgIGlmICh2aWV3SXRlbSAmJiBwcm9wcy5hZG1pblNlcnZpY2VJbmZvLmNhcGFiaWxpdGllcy5pbmRleE9mKFwiU3luY1wiKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHJlcGxpY2FzXG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGljYVVybCA9IGAke3ZpZXdJdGVtLnVybH0vcmVwbGljYXNgO1xuICAgICAgICAgICAgICAgIGF3YWl0IGVzcmlSZXF1ZXN0KHJlcGxpY2FVcmwsIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHsgZjogXCJqc29uXCIgfVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKHJlcGxpY2FSZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5oYXNSZXBsaWNhcyA9ICgoX2EgPSByZXBsaWNhUmVzdWx0LmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpID4gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gZmxvd1N0YXR1cy5TRUxFQ1RJT047XG4gICAgICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld1N0ZXBDaGFuZ2UuZW1pdCgxKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gZmxvd1N0YXR1cy5FUlJPUjtcbiAgICAgICAgICAgIHRoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB2aWV3LCBsYXllciB9ID0gcHJvcHM7XG4gICAgICAgIHZpZXcubWFwLnJlbW92ZShsYXllcik7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUmVuZGVyIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJyZW5kZXJcIiwgcHJvcHNUb1N0cmluZyh0aGlzLnByb3BzKSwgXCJzdGF0dXM6XCIsIHRoaXMuc3RhdHVzKTtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBzdGF0dXMgPT09IGZsb3dTdGF0dXMuRVJST1IgPyB0aGlzLnJlbmRlckVycm9yKCkgOiBudWxsLCBzdGF0dXMgPT09IGZsb3dTdGF0dXMuTE9BRElORyA/IHRoaXMucmVuZGVyTG9hZGluZygpIDogbnVsbCwgW2Zsb3dTdGF0dXMuU0VMRUNUSU9OLCBmbG93U3RhdHVzLlNXQVBfU09VUkNFLCBmbG93U3RhdHVzLkJST1dTRV9MQVlFUl0uaW5jbHVkZXMoc3RhdHVzKVxuICAgICAgICAgICAgPyB0aGlzLnJlbmRlckxheWVyU2VsZWN0aW9uKClcbiAgICAgICAgICAgIDogbnVsbCwgW2Zsb3dTdGF0dXMuT1ZFUlZJRVcsIGZsb3dTdGF0dXMuREVGSU5JVElPTiwgZmxvd1N0YXR1cy5GSUxURVJdLmluY2x1ZGVzKHN0YXR1cylcbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJMYXllck92ZXJ2aWV3KClcbiAgICAgICAgICAgIDogbnVsbCwgc3RhdHVzID09PSBmbG93U3RhdHVzLkNSRUFURSA/IHRoaXMucmVuZGVyQ3JlYXRlVmlldygpIDogbnVsbCkpO1xuICAgIH1cbiAgICByZW5kZXJFcnJvcigpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB2aWV3SXRlbSwgbGF5ZXJJdGVtLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1mbG93LWl0ZW1cIiwgeyBsb2FkaW5nOiBmYWxzZSwgaGVhZGluZzogKHZpZXdJdGVtID09PSBudWxsIHx8IHZpZXdJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWV3SXRlbS50aXRsZSkgfHwgKGxheWVySXRlbSA9PT0gbnVsbCB8fCBsYXllckl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVySXRlbS50aXRsZSkgfHwgc3RyaW5ncy5tc2cuZXJyb3IsIGRlc2NyaXB0aW9uOiAodmlld0l0ZW0gPT09IG51bGwgfHwgdmlld0l0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZXdJdGVtLnRpdGxlKSB8fCAobGF5ZXJJdGVtID09PSBudWxsIHx8IGxheWVySXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXJJdGVtLnRpdGxlKSA/IHN0cmluZ3MuZ2VuZXJhbC5zb3VyY2VMYXllciA6IHVuZGVmaW5lZCwgY2xhc3M6IENTUyQ5LnBhbmVsLCByZWY6IChub2RlKSA9PiAodGhpcy5wYW5lbE5vZGUgPSBub2RlKSB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQ5LmVycm9yQ29udGVudCB9LCBoKFwiY2FsY2l0ZS1ub3RpY2VcIiwgeyBzY2FsZTogXCJzXCIsIHdpZHRoOiBcImZ1bGxcIiwgb3BlbjogdHJ1ZSwgaWNvbjogXCJleGNsYW1hdGlvbi1tYXJrLXRyaWFuZ2xlXCIsIGtpbmQ6IFwiZGFuZ2VyXCIgfSwgaChcImRpdlwiLCB7IHNsb3Q6IFwidGl0bGVcIiB9LCBzdHJpbmdzLm1zZy5lcnJvciksIGgoXCJkaXZcIiwgeyBzbG90OiBcIm1lc3NhZ2VcIiB9LCBzdHJpbmdzLm1zZy5pbml0RmFpbGVkKSkpLCBoKFwiZGl2XCIsIHsgc2xvdDogXCJmb290ZXJcIiwgY2xhc3M6IENTUyQ5LmZvb3RlciB9LCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBzbG90OiBcImZvb3RlclwiLCBvbkNsaWNrOiB0aGlzLmdvQ2FuY2VsLCBhcHBlYXJhbmNlOiBcInRyYW5zcGFyZW50XCIsIHdpZHRoOiBcImZ1bGxcIiB9LCBzdHJpbmdzLmdlbmVyYWwuY2FuY2VsKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyTG9hZGluZygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB2aWV3SXRlbSwgbGF5ZXJJdGVtLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1mbG93LWl0ZW1cIiwgeyBsb2FkaW5nOiB0cnVlLCBoZWFkaW5nOiAodmlld0l0ZW0gPT09IG51bGwgfHwgdmlld0l0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZXdJdGVtLnRpdGxlKSB8fCAobGF5ZXJJdGVtID09PSBudWxsIHx8IGxheWVySXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXJJdGVtLnRpdGxlKSwgZGVzY3JpcHRpb246IHN0cmluZ3MuZ2VuZXJhbC5zb3VyY2VMYXllciwgY2xhc3M6IENTUyQ5LnBhbmVsLCByZWY6IChub2RlKSA9PiAodGhpcy5wYW5lbE5vZGUgPSBub2RlKSB9KSk7XG4gICAgfVxuICAgIHJlbmRlckxheWVyU2VsZWN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBzdGF0dXMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoaChcImFyY2dpcy1sYXllci12aWV3LXNlbGVjdGlvblwiLCB7IGtleTogYHNlbGVjdGlvbi0ke3N0YXR1c31gLCBwcm9wczogcHJvcHMsIHN0YXR1czogc3RhdHVzIH0pKTtcbiAgICB9XG4gICAgcmVuZGVyTGF5ZXJPdmVydmlldygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgc3RhdHVzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGRlZmluaXRpb25MYXllcklkIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIChoKFwiYXJjZ2lzLWxheWVyLXZpZXctb3ZlcnZpZXdcIiwgeyBrZXk6IGBvdmVydmlldy0ke3N0YXR1c30tJHtkZWZpbml0aW9uTGF5ZXJJZH1gLCBwcm9wczogcHJvcHMsIHN0YXR1czogc3RhdHVzIH0pKTtcbiAgICB9XG4gICAgcmVuZGVyQ3JlYXRlVmlldygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgc3RhdHVzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGgoXCJhcmNnaXMtbGF5ZXItdmlldy1jcmVhdGVcIiwgeyBrZXk6IGBjcmVhdGUtJHtzdGF0dXN9YCwgcHJvcHM6IHByb3BzIH0pKTtcbiAgICB9XG4gICAgZ2V0IGhvc3RFbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc0xheWVyVmlldyQxLnN0eWxlID0gYXJjZ2lzTGF5ZXJWaWV3Q3NzO1xuXG5jb25zdCBhcmNnaXNMYXllclZpZXdCcm93c2VMYXllckNzcyA9IFwiLnBhbmVsLnNjLWFyY2dpcy1sYXllci12aWV3LWJyb3dzZS1sYXllcntoZWlnaHQ6MTAwJX1cIjtcblxuY29uc3QgQXJjZ2lzTGF5ZXJWaWV3QnJvd3NlTGF5ZXIgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld1N0YXR1c0NoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzTGF5ZXJWaWV3U3RhdHVzQ2hhbmdlXCIsIDcpO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvL1xuICAgICAgICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMub25CYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdTdGF0dXNDaGFuZ2UuZW1pdCh7IHN0YXR1czogZmxvd1N0YXR1cy5TV0FQX1NPVVJDRSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nb1N3YXBMYXllciA9IGFzeW5jIChpdGVtSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIGZsb3dJdGVtTm9kZSwgaG9zdEVsZW1lbnQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICAgICAgY29uc3Qgc3dhcEl0ZW0gPSB0aGlzLml0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uaWQgPT09IGl0ZW1JZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgY2FuU3dhcExheWVyRXJyb3JTdHJpbmcgPSBhd2FpdCBjYW5Td2FwKHN3YXBJdGVtLCB0aGlzLnByb3BzKTtcbiAgICAgICAgICAgIGlmIChjYW5Td2FwTGF5ZXJFcnJvclN0cmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhcmNnaXMtbGF5ZXItdmlldy1tc2dcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlLnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlLmZsb3dJdGVtRWxlbWVudCA9IGZsb3dJdGVtTm9kZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUuaXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlLm1lc3NhZ2UgPSBgJHtzdHJpbmdzLm1zZy5jYW5ub3RTd2FwfSAke2NhblN3YXBMYXllckVycm9yU3RyaW5nfWA7XG4gICAgICAgICAgICAgICAgaG9zdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5tc2dOb2RlKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SG5kbCk7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0SG5kbCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRIbmRsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tc2dOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLm1zZ05vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgNzAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzd2FwU291cmNlKHRoaXMucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFyY2dpcy1sYXllci12aWV3LW1zZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlLnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZS5mbG93SXRlbUVsZW1lbnQgPSBmbG93SXRlbU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZS5tZXNzYWdlID0gc3RyaW5ncy5tc2cuc3VjY2Vzc1N3YXAucmVwbGFjZShcIiR7c291cmNlfVwiLCBzd2FwSXRlbS50aXRsZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZS5jbG9zZVdpdGhPSyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZS5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzTGF5ZXJWaWV3TXNnQ2xvc2VkXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3U3RhdHVzQ2hhbmdlLmVtaXQoeyBzdGF0dXM6IGZsb3dTdGF0dXMuU0VMRUNUSU9OIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaG9zdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5tc2dOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhcmNnaXMtbGF5ZXItdmlldy1tc2dcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZS5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUuZmxvd0l0ZW1FbGVtZW50ID0gZmxvd0l0ZW1Ob2RlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUuaXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZS5tZXNzYWdlID0gc3RyaW5ncy5tc2cuc3dhcEZhaWxlZDtcbiAgICAgICAgICAgICAgICAgICAgaG9zdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5tc2dOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dEhuZGwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRIbmRsID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRIbmRsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubXNnTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMubXNnTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCA3MDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVSZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXRlbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucGFnaW5hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5lcnJvciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXJjZ2lzTGF5ZXJWaWV3TXNnQ2xvc2VkSGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMubXNnTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5ob3N0RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLm1zZ05vZGUpO1xuICAgICAgICAgICAgdGhpcy5tc2dOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRIbmRsKTtcbiAgICAgICAgdGhpcy50aW1lb3V0SG5kbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIExpZmVjeWNsZVxuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFzeW5jIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5mbG93SXRlbU5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRGb2N1cygpOyB9KSwgMjAwKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBSZW5kZXIgTWV0aG9kc1xuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgbG9hZGluZywgaG9zdEVsZW1lbnQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHJ0bCA9IGdldEVsZW1lbnREaXIoaG9zdEVsZW1lbnQpID09PSBcInJ0bFwiO1xuICAgICAgICByZXR1cm4gKGgoSG9zdCwgeyBjbGFzczogXCJjYWxjaXRlLW1hdGNoLWhlaWdodFwiIH0sIGgoXCJjYWxjaXRlLWZsb3ctaXRlbVwiLCB7IGhlYWRpbmc6IHN0cmluZ3Muc3dhcFNvdXJjZS5icm93c2VGb3JMYXllclRpdGxlLCBkZXNjcmlwdGlvbjogc3RyaW5ncy5zd2FwU291cmNlLnN1YlRpdGxlLCBsb2FkaW5nOiBsb2FkaW5nLCBjbGFzczoge1xuICAgICAgICAgICAgICAgIHBhbmVsOiB0cnVlLFxuICAgICAgICAgICAgICAgIFtDU1NfVVRJTElUWS5ydGxdOiBydGxcbiAgICAgICAgICAgIH0sIG9uQ2FsY2l0ZUZsb3dJdGVtQmFjazogdGhpcy5vbkJhY2ssIHJlZjogKG5vZGUpID0+ICh0aGlzLmZsb3dJdGVtTm9kZSA9IG5vZGUpIH0sIHRoaXMucmVuZGVySXRlbUJyb3dzZXIoKSkpKTtcbiAgICB9XG4gICAgcmVuZGVySXRlbUJyb3dzZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHBhZ2luYXRpb24gfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIsIHNvdXJjZUl0ZW1JZCwgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHsgcG9ydGFsSXRlbSB9ID0gbGF5ZXI7XG4gICAgICAgIGNvbnN0IHsgcG9ydGFsIH0gPSBwb3J0YWxJdGVtO1xuICAgICAgICBjb25zdCB1c2VyID0gcG9ydGFsLnVzZXI7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gYHR5cGU6XCJGZWF0dXJlIFNlcnZpY2VcIiB0eXBla2V5d29yZHM6XCJIb3N0ZWQgU2VydmljZVwiIC10eXBla2V5d29yZHM6XCJWaWV3IFNlcnZpY2VcIiBvd25lcjpcIiR7dXNlci51c2VybmFtZX1cIiAtaWQ6JHtzb3VyY2VJdGVtSWR9YDtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGAke2dldFBvcnRhbEJhc2VVcmwocG9ydGFsKX0vaG9tZS9gO1xuICAgICAgICByZXR1cm4gKGgoXCJhcmNnaXMtaXRlbS1icm93c2VyXCIsIHsgb25BcmNnaXNJdGVtQnJvd3NlclVwZGF0ZTogKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlc3VsdHMsIG51bSwgc3RhcnQsIHRvdGFsIH0gPSBlLmRldGFpbDtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zID0gcmVzdWx0cztcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2luYXRpb24gPSB7IHN0YXJ0LCBudW0sIHRvdGFsIH07XG4gICAgICAgICAgICB9LCBmaWx0ZXI6IHF1ZXJ5LCBwb3J0YWw6IHBvcnRhbCwgdXNlcjogdXNlciwgYXBpOiA0LCBjb25maWc6IHsgYmFzZVVybCB9LCBzZWxlY3Rpb246IFwibm9uZVwiIH0sIGgoXCJhcmNnaXMtaXRlbS1icm93c2VyLXRvcC1iYXJcIiwgeyBzbG90OiBcInRvcC1iYXJcIiB9LCBoKFwiYXJjZ2lzLWl0ZW0tYnJvd3Nlci1zZWFyY2hcIiwgeyBzbG90OiBcInNlYXJjaFwiLCB0ZXJtOiBcIlwiIH0pKSwgaChcImFyY2dpcy1pdGVtLWJyb3dzZXItc29ydFwiLCB7IG9wdGlvbnM6IFtcIm1vZGlmaWVkXCIsIFwidGl0bGVcIiwgXCJyZWxldmFuY2VcIl0sIHNsb3Q6IFwic29ydFwiIH0pLCBoKFwiYXJjZ2lzLWl0ZW0tYnJvd3Nlci1jb250ZW50XCIsIHsgc2xvdDogXCJjb250ZW50XCIgfSwgKHRoaXMuaXRlbXMgfHwgW10pLm1hcCgoaXRlbSkgPT4gKGgoXCJhcmNnaXMtaXRlbS1icm93c2VyLWNhcmRcIiwgeyBpdGVtOiBpdGVtLCBwb3J0YWw6IHBvcnRhbCwgYmFzZVVybDogYmFzZVVybCwga2V5OiBpdGVtLmlkIH0sIGgoXCJjYWxjaXRlLWFjdGlvblwiLCB7IGlkOiBgc3dhcC1hY3Rpb24tJHtpdGVtLmlkfWAsIGljb246IFwiYXJyb3ctcmlnaHQtbGVmdFwiLCB0ZXh0OiBcIlwiLCBzY2FsZTogXCJzXCIsIHNsb3Q6IFwiYWN0aW9ucy1lbmRcIiwgb25DbGljazogdGhpcy5nb1N3YXBMYXllci5iaW5kKHRoaXMsIGl0ZW0uaWQpIH0sIGgoXCJjYWxjaXRlLXRvb2x0aXBcIiwgeyBzbG90OiBcInRvb2x0aXBcIiwgbGFiZWw6IHN0cmluZ3MuZ2VuZXJhbC5zd2FwU291cmNlLCBvdmVybGF5UG9zaXRpb25pbmc6IFwiZml4ZWRcIiB9LCBzdHJpbmdzLmdlbmVyYWwuc3dhcFNvdXJjZSkpKSkpKSwgaChcImFyY2dpcy1pdGVtLWJyb3dzZXItcGFnaW5hdGlvblwiLCB7IHRvdGFsOiBwYWdpbmF0aW9uID09PSBudWxsIHx8IHBhZ2luYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhZ2luYXRpb24udG90YWwsIHN0YXJ0OiBwYWdpbmF0aW9uID09PSBudWxsIHx8IHBhZ2luYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhZ2luYXRpb24uc3RhcnQsIG51bTogcGFnaW5hdGlvbiA9PT0gbnVsbCB8fCBwYWdpbmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYWdpbmF0aW9uLm51bSwgc2xvdDogXCJwYWdpbmF0aW9uXCIgfSkpKTtcbiAgICB9XG4gICAgZ2V0IGhvc3RFbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc0xheWVyVmlld0Jyb3dzZUxheWVyLnN0eWxlID0gYXJjZ2lzTGF5ZXJWaWV3QnJvd3NlTGF5ZXJDc3M7XG5cbmNvbnN0IENTUyQ4ID0ge1xuICAgIHBhbmVsOiBcInBhbmVsXCIsXG4gICAgaW5mbzogXCJpbmZvXCIsXG4gICAgZm9vdGVyOiBcImZvb3RlclwiXG59O1xuXG5jb25zdCBhcmNnaXNMYXllclZpZXdDcmVhdGVDc3MgPSBcIi5wYW5lbC5zYy1hcmNnaXMtbGF5ZXItdmlldy1jcmVhdGV7aGVpZ2h0OjEwMCV9LmluZm8uc2MtYXJjZ2lzLWxheWVyLXZpZXctY3JlYXRle2Rpc3BsYXk6Z3JpZDtncmlkLXRlbXBsYXRlLWNvbHVtbnM6cmVwZWF0KDEsIG1pbm1heCgwcHgsIDFmcikpO2dhcDowLjVyZW07cGFkZGluZzoxcmVtIDAuNzVyZW19LmZvb3Rlci5zYy1hcmNnaXMtbGF5ZXItdmlldy1jcmVhdGV7d2lkdGg6MTAwJX1cIjtcblxuY29uc3QgQXJjZ2lzTGF5ZXJWaWV3Q3JlYXRlJDEgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld1N0YXR1c0NoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzTGF5ZXJWaWV3U3RhdHVzQ2hhbmdlXCIsIDcpO1xuICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld0NyZWF0ZURvbmUgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0xheWVyVmlld0NyZWF0ZURvbmVcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Q3JlYXRlQ2FuY2VsID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNMYXllclZpZXdDcmVhdGVDYW5jZWxcIiwgNyk7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vXG4gICAgICAgIC8vICBQcml2YXRlIG1ldGhvZHNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdGhpcy5nb0JhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBzYXZlIGxhc3Qgc2V0dGluZ3NcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgICAgICBwcm9wcy5zYXZlZEl0ZW1Qcm9wcyA9IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogaXRlbVByb3BlcnRpZXNTdGF0ZS50aXRsZSxcbiAgICAgICAgICAgICAgICB0YWdzOiBpdGVtUHJvcGVydGllc1N0YXRlLnRhZ3MsXG4gICAgICAgICAgICAgICAgc3VtbWFyeTogaXRlbVByb3BlcnRpZXNTdGF0ZS5zbmlwcGV0LFxuICAgICAgICAgICAgICAgIGNhdGVnb3JpZXM6IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUuY2F0ZWdvcmllcyxcbiAgICAgICAgICAgICAgICBmb2xkZXI6IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUuZm9sZGVyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdTdGF0dXNDaGFuZ2UuZW1pdCh7IHN0YXR1czogZmxvd1N0YXR1cy5PVkVSVklFVyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nb0NyZWF0ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIGZsb3dJdGVtTm9kZSwgaG9zdEVsZW1lbnQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgY3JlYXRlIGNhbGwgZmFpbHNcbiAgICAgICAgICAgIHByb3BzLnNhdmVkSXRlbVByb3BzID0ge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBpdGVtUHJvcGVydGllc1N0YXRlLnRpdGxlLFxuICAgICAgICAgICAgICAgIHRhZ3M6IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUudGFncyxcbiAgICAgICAgICAgICAgICBzdW1tYXJ5OiBpdGVtUHJvcGVydGllc1N0YXRlLnNuaXBwZXQsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcmllczogaXRlbVByb3BlcnRpZXNTdGF0ZS5jYXRlZ29yaWVzLFxuICAgICAgICAgICAgICAgIGZvbGRlcjogaXRlbVByb3BlcnRpZXNTdGF0ZS5mb2xkZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUudGl0bGUsXG4gICAgICAgICAgICAgICAgdGFnczogaXRlbVByb3BlcnRpZXNTdGF0ZS50YWdzLFxuICAgICAgICAgICAgICAgIHN1bW1hcnk6IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUuc25pcHBldCxcbiAgICAgICAgICAgICAgICBjYXRlZ29yaWVzOiBpdGVtUHJvcGVydGllc1N0YXRlLmNhdGVnb3JpZXMsXG4gICAgICAgICAgICAgICAgZm9sZGVyOiBpdGVtUHJvcGVydGllc1N0YXRlLmZvbGRlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld0l0ZW1JZCA9IGF3YWl0IGNyZWF0ZVZpZXcocHJvcHMsIG5ld0l0ZW1Qcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFyY2dpcy1sYXllci12aWV3LW1zZ1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUuZmxvd0l0ZW1FbGVtZW50ID0gZmxvd0l0ZW1Ob2RlO1xuICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZS5tZXNzYWdlID0gc3RyaW5ncy5tc2cuY3JlYXRlZDtcbiAgICAgICAgICAgICAgICBob3N0RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLm1zZ05vZGUpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRIbmRsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRIbmRsID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZW91dEhuZGwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1zZ05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMubXNnTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld0NyZWF0ZURvbmUuZW1pdCh0aGlzLnZpZXdJdGVtSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgNzAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIGZsb3dJdGVtTm9kZSB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJjb3VsZCBub3QgY3JlYXRlIHZpZXdcIiwgZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFyY2dpcy1sYXllci12aWV3LW1zZ1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUuZmxvd0l0ZW1FbGVtZW50ID0gZmxvd0l0ZW1Ob2RlO1xuICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZS5pc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZS5tZXNzYWdlID09PSBcInNlcnZpY2UgbmFtZSBhbHJlYWR5IGV4aXN0c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdvaW5nIHRvIGhhdmUgYW5vdGhlciBzdHJpbmcuLi5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlLm1lc3NhZ2UgPSBzdHJpbmdzLm1zZy5jcmVhdGVGYWlsZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUubWVzc2FnZSA9IHN0cmluZ3MubXNnLmNyZWF0ZUZhaWxlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaG9zdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5tc2dOb2RlKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SG5kbCk7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0SG5kbCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRIbmRsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tc2dOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLm1zZ05vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgNzAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ29DYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld0NyZWF0ZUNhbmNlbC5lbWl0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVSZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGl0bGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFyY2dpc0xheWVyVmlld01zZ0Nsb3NlZEhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLm1zZ05vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuaG9zdEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5tc2dOb2RlKTtcbiAgICAgICAgICAgIHRoaXMubXNnTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SG5kbCk7XG4gICAgICAgIHRoaXMudGltZW91dEhuZGwgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLnZpZXdJdGVtSWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Q3JlYXRlRG9uZS5lbWl0KHRoaXMudmlld0l0ZW1JZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIExpZmVjeWNsZVxuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnRpdGxlID0gYXdhaXQgZ2V0U3VnZ2VzdGVkVGl0bGUocHJvcHMpO1xuICAgIH1cbiAgICBhc3luYyBjb21wb25lbnREaWRMb2FkKCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aGlzLmJhY2tCdXR0b25Ob2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Rm9jdXMoKTsgfSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUmVuZGVyIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJyZW5kZXIgdmlldy1jcmVhdGVcIiwgcHJvcHNUb1N0cmluZyh0aGlzLnByb3BzKSk7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGxvYWRpbmcgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdmlld0l0ZW0sIGxheWVySXRlbSwgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHJ0bCA9IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCkgPT09IFwicnRsXCI7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCB7IGNsYXNzOiBcImNhbGNpdGUtbWF0Y2gtaGVpZ2h0XCIgfSwgaChcImNhbGNpdGUtZmxvdy1pdGVtXCIsIHsgaGVhZGluZzogc3RyaW5ncy5jcmVhdGVWaWV3LmNyZWF0ZSwgZGVzY3JpcHRpb246ICh2aWV3SXRlbSA9PT0gbnVsbCB8fCB2aWV3SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlld0l0ZW0udGl0bGUpIHx8IChsYXllckl0ZW0gPT09IG51bGwgfHwgbGF5ZXJJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllckl0ZW0udGl0bGUpLCBsb2FkaW5nOiBsb2FkaW5nLCBjbGFzczoge1xuICAgICAgICAgICAgICAgIHBhbmVsOiB0cnVlLFxuICAgICAgICAgICAgICAgIFtDU1NfVVRJTElUWS5ydGxdOiBydGxcbiAgICAgICAgICAgIH0sIHJlZjogKG5vZGUpID0+ICh0aGlzLmZsb3dJdGVtTm9kZSA9IG5vZGUpIH0sIHRoaXMucmVuZGVyRm9vdGVyQnV0dG9ucygpLCB0aGlzLnJlbmRlckluZm8oKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyRm9vdGVyQnV0dG9ucygpIHtcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgc2xvdDogXCJmb290ZXJcIiwgY2xhc3M6IENTUyQ4LmZvb3RlciB9LCB0aGlzLnJlbmRlckJhY2soKSwgdGhpcy5yZW5kZXJDcmVhdGUoKSwgaChcImJyXCIsIG51bGwpLCB0aGlzLnJlbmRlckNhbmNlbCgpKSk7XG4gICAgfVxuICAgIHJlbmRlckJhY2soKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGlzUnRsID0gZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSA9PT0gXCJydGxcIjtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBvbkNsaWNrOiB0aGlzLmdvQmFjaywgYXBwZWFyYW5jZTogXCJvdXRsaW5lLWZpbGxcIiwgd2lkdGg6IFwiaGFsZlwiLCBcImljb24tc3RhcnRcIjogaXNSdGwgPyBcImFycm93LXJpZ2h0XCIgOiBcImFycm93LWxlZnRcIiwgcmVmOiAobm9kZSkgPT4gKHRoaXMuYmFja0J1dHRvbk5vZGUgPSBub2RlKSB9LCBzdHJpbmdzLmdlbmVyYWwuYmFjaykpO1xuICAgIH1cbiAgICByZW5kZXJDcmVhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHRpdGxlLCB0aXRsZUVycm9yLCBzdW1tYXJ5RXJyb3IgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIsIGxheWVySWRzLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgZW5hYmxlZCA9IChsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXIubG9hZGVkKSAmJiBsYXllcklkcy5sZW5ndGggJiYgdGl0bGUgJiYgIXRpdGxlRXJyb3IgJiYgIXN1bW1hcnlFcnJvcjtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBkaXNhYmxlZDogIWVuYWJsZWQsIG9uQ2xpY2s6IGVuYWJsZWQgJiYgdGhpcy5nb0NyZWF0ZSwgYXBwZWFyYW5jZTogXCJzb2xpZFwiLCB3aWR0aDogXCJoYWxmXCIsIFwiaWNvbi1zdGFydFwiOiBcInBsdXMtc3F1YXJlXCIsIHJlZjogKG5vZGUpID0+ICh0aGlzLmNyZWF0ZUJ1dHRvbk5vZGUgPSBub2RlKSB9LCBzdHJpbmdzLmNyZWF0ZVZpZXcuY3JlYXRlKSk7XG4gICAgfVxuICAgIHJlbmRlckNhbmNlbCgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsYXllciwgbGF5ZXJJZHMsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBlbmFibGVkID0gKGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllci5sb2FkZWQpICYmIGxheWVySWRzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBkaXNhYmxlZDogIWVuYWJsZWQsIG9uQ2xpY2s6IGVuYWJsZWQgJiYgdGhpcy5nb0NhbmNlbCwgYXBwZWFyYW5jZTogXCJ0cmFuc3BhcmVudFwiLCB3aWR0aDogXCJmdWxsXCIgfSwgc3RyaW5ncy5nZW5lcmFsLmNhbmNlbCkpO1xuICAgIH1cbiAgICByZW5kZXJJbmZvKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCB0aXRsZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsYXllciwgbGF5ZXJJdGVtT3duZXIsIHNhdmVkSXRlbVByb3BzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgeyBwb3J0YWxJdGVtIH0gPSBsYXllcjtcbiAgICAgICAgY29uc3QgeyBwb3J0YWwgfSA9IHBvcnRhbEl0ZW07XG4gICAgICAgIGNvbnN0IHVzZXIgPSBwb3J0YWwudXNlcjtcbiAgICAgICAgY29uc3QgY29uZmlnID0geyBwb3J0YWwsIHVzZXIsIGFwaTogNCB9O1xuICAgICAgICBpZiAoc2F2ZWRJdGVtUHJvcHMpIHtcbiAgICAgICAgICAgIGl0ZW1Qcm9wZXJ0aWVzU3RhdGUudGl0bGUgPSBzYXZlZEl0ZW1Qcm9wcy50aXRsZTtcbiAgICAgICAgICAgIGl0ZW1Qcm9wZXJ0aWVzU3RhdGUuZm9sZGVyID0gc2F2ZWRJdGVtUHJvcHMuZm9sZGVyO1xuICAgICAgICAgICAgaXRlbVByb3BlcnRpZXNTdGF0ZS5zbmlwcGV0ID0gc2F2ZWRJdGVtUHJvcHMuc3VtbWFyeSB8fCBcIlwiO1xuICAgICAgICAgICAgaXRlbVByb3BlcnRpZXNTdGF0ZS5jYXRlZ29yaWVzID0gc2F2ZWRJdGVtUHJvcHMuY2F0ZWdvcmllcztcbiAgICAgICAgICAgIGl0ZW1Qcm9wZXJ0aWVzU3RhdGUudGFncyA9IHNhdmVkSXRlbVByb3BzLnRhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtUHJvcGVydGllc1N0YXRlLnRpdGxlID0gdGl0bGU7XG4gICAgICAgICAgICBpdGVtUHJvcGVydGllc1N0YXRlLmZvbGRlciA9XG4gICAgICAgICAgICAgICAgcG9ydGFsSXRlbS5vd25lckZvbGRlciAmJlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcG9ydGFsSXRlbS5vd25lckZvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBwb3J0YWxJdGVtLm93bmVyXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpdGVtUHJvcGVydGllc1N0YXRlLnNuaXBwZXQgPSBwb3J0YWxJdGVtLnNuaXBwZXQgfHwgXCJcIjtcbiAgICAgICAgICAgIGl0ZW1Qcm9wZXJ0aWVzU3RhdGUuY2F0ZWdvcmllcyA9IHBvcnRhbEl0ZW0uY2F0ZWdvcmllcztcbiAgICAgICAgICAgIGl0ZW1Qcm9wZXJ0aWVzU3RhdGUudGFncyA9IHBvcnRhbEl0ZW0udGFncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDguaW5mbyB9LCBoKFwiYXJjZ2lzLWl0ZW0tcHJvcGVydGllc1wiLCB7IHBvcnRhbDogcG9ydGFsLCB1c2VyOiB1c2VyLCBhcGk6IDQsIGNvbmZpZzogY29uZmlnLCB0eXBlOiBcIkZlYXR1cmUgU2VydmljZVwiLCBzY2FsZTogXCJzXCIgfSwgaChcImFyY2dpcy10aXRsZS1pbnB1dFwiLCB7IGVuYWJsZVB1Ymxpc2hpbmc6IHRydWUsIG9uQXJjZ2lzVGl0bGVJbnB1dENoYW5nZTogYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICBjb25zdCB0aXRsZUVycm9yID0gYXdhaXQgbm9kZS52YWxpZGF0ZVRpdGxlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCghdGhpcy50aXRsZUVycm9yICYmIHRpdGxlRXJyb3IpIHx8ICh0aGlzLnRpdGxlRXJyb3IgJiYgIXRpdGxlRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50aXRsZUVycm9yID0gdGl0bGVFcnJvcjtcbiAgICAgICAgICAgIH0gfSksIGgoXCJhcmNnaXMtZm9sZGVyLXBpY2tlclwiLCB7IHVzZXI6IGxheWVySXRlbU93bmVyIH0pLCBoKFwiYXJjZ2lzLWNhdGVnb3JpZXMtcGlja2VyXCIsIG51bGwpLCBoKFwiYXJjZ2lzLXRhZ3MtcGlja2VyXCIsIG51bGwpLCBoKFwiYXJjZ2lzLXN1bW1hcnktaW5wdXRcIiwgeyBvbkFyY2dpc1N1bW1hcnlJbnB1dENoYW5nZTogYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICBjb25zdCBzdW1tYXJ5RXJyb3IgPSAoYXdhaXQgbm9kZS5nZXRFcnJvck1lc3NhZ2UoKSk7XG4gICAgICAgICAgICAgICAgaWYgKCghdGhpcy5zdW1tYXJ5RXJyb3IgJiYgc3VtbWFyeUVycm9yKSB8fCAodGhpcy5zdW1tYXJ5RXJyb3IgJiYgIXN1bW1hcnlFcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN1bW1hcnlFcnJvciA9IHN1bW1hcnlFcnJvcjtcbiAgICAgICAgICAgIH0gfSkpKSk7XG4gICAgfVxuICAgIGdldCBob3N0RWxlbWVudCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbn07XG5BcmNnaXNMYXllclZpZXdDcmVhdGUkMS5zdHlsZSA9IGFyY2dpc0xheWVyVmlld0NyZWF0ZUNzcztcblxuY29uc3QgQ1NTJDcgPSB7XG4gICAgcGFuZWw6IFwicGFuZWxcIixcbiAgICBob29rOiBcImhvb2tcIixcbiAgICBub3RpY2U6IFwibm90aWNlXCIsXG4gICAgZmlsdGVyQmxvY2s6IFwiZmlsdGVyLWJsb2NrXCIsXG4gICAgZmlsdGVyQ2hldnJvbjogXCJmaWx0ZXItY2hldnJvblwiLFxuICAgIGFvaUdyb3VwOiBcImFvaS1ncm91cFwiLFxuICAgIGFvaUJ1dHRvbjogXCJhb2ktYnV0dG9uXCIsXG4gICAgdGV4dENlbnRlcjogXCJ0ZXh0LWNlbnRlclwiLFxuICAgIHNlbGVjdEZpZWxkczogXCJzZWxlY3QtZmllbGRzXCJcbn07XG5cbmNvbnN0IGFyY2dpc0xheWVyVmlld0RlZmluaXRpb25Dc3MgPSBcIi5wYW5lbC5zYy1hcmNnaXMtbGF5ZXItdmlldy1kZWZpbml0aW9ue2hlaWdodDoxMDAlfS5ob29rLnNjLWFyY2dpcy1sYXllci12aWV3LWRlZmluaXRpb257aGVpZ2h0OjFweH0ubm90aWNlLnNjLWFyY2dpcy1sYXllci12aWV3LWRlZmluaXRpb257bWFyZ2luOjhweH0uZmlsdGVyLWJsb2NrLnNjLWFyY2dpcy1sYXllci12aWV3LWRlZmluaXRpb257Y3Vyc29yOnBvaW50ZXJ9LmZpbHRlci1ibG9jay5zYy1hcmNnaXMtbGF5ZXItdmlldy1kZWZpbml0aW9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS1jb2xvci1mb3JlZ3JvdW5kLTIpfS5maWx0ZXItY2hldnJvbi5zYy1hcmNnaXMtbGF5ZXItdmlldy1kZWZpbml0aW9ue21hcmdpbi1yaWdodDowLjVyZW19LmFyY2dpcy0tcnRsLnNjLWFyY2dpcy1sYXllci12aWV3LWRlZmluaXRpb24gLmZpbHRlci1jaGV2cm9uLnNjLWFyY2dpcy1sYXllci12aWV3LWRlZmluaXRpb257bWFyZ2luLWxlZnQ6MC41cmVtO21hcmdpbi1yaWdodDphdXRvfS5hb2ktZ3JvdXAuc2MtYXJjZ2lzLWxheWVyLXZpZXctZGVmaW5pdGlvbnt3aWR0aDoxMDAlO21hcmdpbi1ib3R0b206MC43NXJlbX0uYW9pLWJ1dHRvbi5zYy1hcmNnaXMtbGF5ZXItdmlldy1kZWZpbml0aW9ue21hcmdpbi10b3A6MC43NXJlbTtib3JkZXItdG9wLXdpZHRoOjFweDtib3JkZXItdG9wLXN0eWxlOnNvbGlkO2JvcmRlci10b3AtY29sb3I6dmFyKC0tY2FsY2l0ZS1jb2xvci1ib3JkZXItMyl9LnRleHQtY2VudGVyLnNjLWFyY2dpcy1sYXllci12aWV3LWRlZmluaXRpb257dGV4dC1hbGlnbjpjZW50ZXJ9LnNlbGVjdC1maWVsZHMuc2MtYXJjZ2lzLWxheWVyLXZpZXctZGVmaW5pdGlvbnttYXJnaW46MCAwIDVweCAwfVwiO1xuXG5jb25zdCBBcmNnaXNMYXllclZpZXdEZWZpbml0aW9uID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdPdmVyVmlld1JlZnJlc2ggPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0xheWVyVmlld092ZXJWaWV3UmVmcmVzaFwiLCA3KTtcbiAgICAgICAgdGhpcy5hb2lTeW1ib2wgPSB7XG4gICAgICAgICAgICB0eXBlOiBcInNpbXBsZS1maWxsXCIsXG4gICAgICAgICAgICBzdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICAgICAgY29sb3I6IFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIG91dGxpbmU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNpbXBsZS1saW5lXCIsXG4gICAgICAgICAgICAgICAgc3R5bGU6IFwic29saWRcIixcbiAgICAgICAgICAgICAgICBjb2xvcjogWzI1NSwgMCwgMCwgMjU1XSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMlxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvL1xuICAgICAgICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMub25CYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdPdmVyVmlld1JlZnJlc2guZW1pdCgpO1xuICAgICAgICB9O1xuICAgICAgICAvLyAtLS0tLS0tLS0gIEZpbHRlciAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLmdvRmlsdGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMuYW9pQmxvY2tOb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3Blbikge1xuICAgICAgICAgICAgICAgIHRoaXMuYW9pQmxvY2tOb2RlLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQU9JVG9nZ2xlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IGZsb3dTdGF0dXMuRklMVEVSO1xuICAgICAgICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQmFja0ZpbHRlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gZmxvd1N0YXR1cy5ERUZJTklUSU9OO1xuICAgICAgICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMuZmlsdGVyQWN0aW9uTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7IH0sIDIwMCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIC0tLS0tLS0tLSAgQU9JICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMub25Qb2x5Z29uQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGlmICghbm9kZS5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNrZXRjaFZpZXdNb2RlbC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNrZXRjaFZpZXdNb2RlbC5jcmVhdGUoXCJwb2x5Z29uXCIpO1xuICAgICAgICAgICAgICAgIG5vZGUuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY3RhbmdsZUFjdGlvbi5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdMYWJlbC5pbm5lckhUTUwgPSBzdHJpbmdzLmRlZmluZVZpZXcuYW9pUG9seWdvbkRyYXc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25SZWN0YW5nbGVDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKCFub2RlLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tldGNoVmlld01vZGVsLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2tldGNoVmlld01vZGVsLmNyZWF0ZShcInJlY3RhbmdsZVwiKTtcbiAgICAgICAgICAgICAgICBub2RlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2x5Z29uQWN0aW9uLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xhYmVsLmlubmVySFRNTCA9IHN0cmluZ3MuZGVmaW5lVmlldy5hb2lSZWN0YW5nbGVEcmF3O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uRGVsZXRlQU9JQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBkZWZpbml0aW9uTGF5ZXJJZCwgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgICAgICB0aGlzLnNrZXRjaFZpZXdNb2RlbC5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NMYXllci5yZW1vdmVBbGwoKTtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdMYXllclByb3BzID0gZ2V0Vmlld0xheWVyUHJvcHMoZGVmaW5pdGlvbkxheWVySWQsIHByb3BzKTtcbiAgICAgICAgICAgIGlmICh2aWV3TGF5ZXJQcm9wcykge1xuICAgICAgICAgICAgICAgIHZpZXdMYXllclByb3BzLmFvaSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNhbml0aXplVmlld1Byb3BzKHByb3BzKTtcbiAgICAgICAgICAgIGFwcGx5TGF5ZXJBT0kodW5kZWZpbmVkLCBkZWZpbml0aW9uTGF5ZXJJZCwgcHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5kcmF3TGFiZWwuaW5uZXJIVE1MID0gc3RyaW5ncy5kZWZpbmVWaWV3LmFvaVNlbGVjdDtcbiAgICAgICAgICAgIHRoaXMucG9seWdvbkFjdGlvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yZWN0YW5nbGVBY3Rpb24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYW9pQmxvY2tOb2RlLmRlc2NyaXB0aW9uID0gc3RyaW5ncy5kZWZpbmVWaWV3LmFvaVN1YnRleHQ7XG4gICAgICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25HcmFwaGljVXBkYXRlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyB2aWV3LCBkZWZpbml0aW9uTGF5ZXJJZCB9ID0gcHJvcHM7XG4gICAgICAgICAgICB2aWV3LmNsb3NlUG9wdXAoKTtcbiAgICAgICAgICAgIGlmIChldmVudC5zdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2tldGNoR3JhcGhpYyA9IGV2ZW50LmdyYXBoaWNzWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IHNrZXRjaEdyYXBoaWMuZ2VvbWV0cnkuZXh0ZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHB0cyA9IHNrZXRjaEdyYXBoaWMuZ2VvbWV0cnkucmluZ3NbMF07XG4gICAgICAgICAgICAgICAgbGV0IGlzUmVjdGFuZ2xlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHB0cy5sZW5ndGggPT09IDUgJiZcbiAgICAgICAgICAgICAgICAgICAgcHRzLmluZGV4T2YoW2V4dGVudC54bWluLCBleHRlbnQueW1pbl0pID4gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgcHRzLmluZGV4T2YoW2V4dGVudC54bWF4LCBleHRlbnQueW1heF0pID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNSZWN0YW5nbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRWaWV3TGF5ZXJQcm9wcyhkZWZpbml0aW9uTGF5ZXJJZCwge1xuICAgICAgICAgICAgICAgICAgICBhb2k6IHRoaXMucmVjdGFuZ2xlQWN0aW9uLmFjdGl2ZSAmJiBpc1JlY3RhbmdsZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBleHRlbnQudG9KU09OKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2tldGNoR3JhcGhpYy5nZW9tZXRyeS50b0pTT04oKVxuICAgICAgICAgICAgICAgIH0sIHByb3BzKTtcbiAgICAgICAgICAgICAgICBhcHBseUxheWVyQU9JKHNrZXRjaEdyYXBoaWMuZ2VvbWV0cnksIGRlZmluaXRpb25MYXllcklkLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVjdGFuZ2xlQWN0aW9uLmFjdGl2ZSAmJiAhaXNSZWN0YW5nbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlciB1cGRhdGVkIGEgcmVjdGFuZ2xlIHRvIGEgcG9seWdvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyAtLS0tLS0tLS0gIEZpZWxkcyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLnNlbGVjdEZpZWxkcyA9IChmbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgdG90YWxGaWVsZHMsIHJlcXVpcmVkRmllbGROYW1lcyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgdmlldywgZGVmaW5pdGlvbkxheWVySWQgfSA9IHByb3BzO1xuICAgICAgICAgICAgY29uc3Qgdmlld0xheWVyUHJvcHMgPSBnZXRWaWV3TGF5ZXJQcm9wcyhkZWZpbml0aW9uTGF5ZXJJZCwgcHJvcHMpO1xuICAgICAgICAgICAgbGV0IGZpZWxkTmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGlmICh2aWV3TGF5ZXJQcm9wcyA9PT0gbnVsbCB8fCB2aWV3TGF5ZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlld0xheWVyUHJvcHMuZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgZmllbGROYW1lcyA9IHZpZXdMYXllclByb3BzLmZpZWxkcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpZWxkTmFtZXMgPSB0b3RhbEZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChmaWVsZCkgPT4gcmVxdWlyZWRGaWVsZE5hbWVzLmluZGV4T2YoZmllbGQubmFtZSkgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChmaWVsZCkgPT4gZmllbGQubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsb3NlTGF5ZXJWaWV3RGVmaW5pdGlvblBvcG92ZXJzSGFuZGxlcigpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZVdpZHRoID0gdGhpcy5mbG93SXRlbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0ZpZWxkUGlja0xpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYXJjZ2lzLWZpZWxkLXBpY2stbGlzdFwiKTtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5wb3BvdmVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICBvZmZzZXREaXN0YW5jZTogLTEgKiAobm9kZVdpZHRoID8gbm9kZVdpZHRoIC0gNSA6IDIxNSksXG4gICAgICAgICAgICAgICAgb2Zmc2V0U2tpZGRpbmc6IDAsXG4gICAgICAgICAgICAgICAgcG9pbnRlckRpc2FibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBvcG92ZXJXaWR0aDogbm9kZVdpZHRoID8gbm9kZVdpZHRoICsgMzAgOiAyODAsXG4gICAgICAgICAgICAgICAgcmVmRWxlbWVudDogdGhpcy5mbG93SXRlbU5vZGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0ZpZWxkUGlja0xpc3QuZmllbGRzID0gdGhpcy5jcmVhdGVQaWNrTGlzdEZpZWxkcyhmbCk7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0ZpZWxkUGlja0xpc3QubGF5ZXIgPSBmbDtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5tYXBWaWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5zaG93RmllbGRJbmZvID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5zaG93RmllbGROYW1lID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0ZpZWxkUGlja0xpc3Quc2VsZWN0ZWRGaWVsZHMgPSBmaWVsZE5hbWVzO1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzRmllbGRQaWNrTGlzdERpc21pc3NlZFwiLCB0aGlzLmZpZWxkUGlja0xpc3RDaGFuZ2VzKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0KTtcbiAgICAgICAgICAgIHRoaXMuZmxvd0l0ZW1Ob2RlLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5maWVsZFBpY2tMaXN0Q2hhbmdlcyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCByZXF1aXJlZEZpZWxkTmFtZXMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGRlZmluaXRpb25MYXllcklkIH0gPSBwcm9wcztcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkRmllbGRzID0gKF9hID0gZXZlbnQuZGV0YWlsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VsZWN0ZWRGaWVsZHM7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZpZWxkc1BpY2tMaXN0KCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZG1pbkxheWVySW5mbyA9IGdldEFkbWluTGF5ZXJJbmZvKGRlZmluaXRpb25MYXllcklkLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG90YWxGaWVsZHMgPSAoYWRtaW5MYXllckluZm8gPT09IG51bGwgfHwgYWRtaW5MYXllckluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkbWluTGF5ZXJJbmZvLmZpZWxkcykgfHwgZ2V0RkwoZGVmaW5pdGlvbkxheWVySWQsIHByb3BzKS5maWVsZHM7XG4gICAgICAgICAgICAgICAgLy8ga2VlcCBvcmRlciBsaWtlIGluIHNlcnZpY2VcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZEFuZFJlcXVpcmVkRmllbGRzID0gdG90YWxGaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZmllbGQpID0+IHJlcXVpcmVkRmllbGROYW1lcy5pbmRleE9mKGZpZWxkLm5hbWUpID4gLTEgfHwgc2VsZWN0ZWRGaWVsZHMuaW5kZXhPZihmaWVsZC5uYW1lKSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChmaWVsZCkgPT4gZmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkQW5kUmVxdWlyZWRGaWVsZHMubGVuZ3RoIDwgdG90YWxGaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN1YnNldCBvZiBmaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgYWRkVmlld0xheWVyUHJvcHMoZGVmaW5pdGlvbkxheWVySWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkczogc2VsZWN0ZWRBbmRSZXF1aXJlZEZpZWxkc1xuICAgICAgICAgICAgICAgICAgICB9LCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0OyBhbGwgZmllbGRzXG4gICAgICAgICAgICAgICAgICAgIGxldCB2aWV3TGF5ZXJQcm9wcyA9IGdldFZpZXdMYXllclByb3BzKGRlZmluaXRpb25MYXllcklkLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWV3TGF5ZXJQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlld0xheWVyUHJvcHMuZmllbGRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNhbml0aXplVmlld1Byb3BzKHByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgICAgICAgICAgfSAvLyBlbHNlIHVzZXIgaGl0IGNhbmNlbCBvciBjbG9zZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlbW92ZUZpZWxkID0gKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgdG90YWxGaWVsZHMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGRlZmluaXRpb25MYXllcklkIH0gPSBwcm9wcztcbiAgICAgICAgICAgIGxldCB2aWV3TGF5ZXJQcm9wcyA9IGdldFZpZXdMYXllclByb3BzKGRlZmluaXRpb25MYXllcklkLCBwcm9wcyk7XG4gICAgICAgICAgICBpZiAoIXZpZXdMYXllclByb3BzKSB7XG4gICAgICAgICAgICAgICAgdmlld0xheWVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVySWQ6IGRlZmluaXRpb25MYXllcklkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwcm9wcy52aWV3UHJvcHMgPSBwcm9wcy52aWV3UHJvcHMgfHwgW107XG4gICAgICAgICAgICAgICAgcHJvcHMudmlld1Byb3BzLnB1c2godmlld0xheWVyUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2aWV3TGF5ZXJQcm9wcy5maWVsZHMpIHtcbiAgICAgICAgICAgICAgICB2aWV3TGF5ZXJQcm9wcy5maWVsZHMgPSB0b3RhbEZpZWxkcy5tYXAoKGZpZWxkKSA9PiBmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZXdMYXllclByb3BzLmZpZWxkcy5zcGxpY2Uodmlld0xheWVyUHJvcHMuZmllbGRzLmluZGV4T2YoZmllbGROYW1lKSwgMSk7XG4gICAgICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlUmVuZGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBjbG9zZUxheWVyVmlld0RlZmluaXRpb25Qb3BvdmVyc0hhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRmllbGRzUGlja0xpc3QoKTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIExpZmVjeWNsZVxuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgZGVmaW5pdGlvbkxheWVySWQgfSA9IHByb3BzO1xuICAgICAgICB0aGlzLmZsID0gZ2V0RkwoZGVmaW5pdGlvbkxheWVySWQsIHByb3BzKTtcbiAgICAgICAgdGhpcy5hZG1pbkxheWVySW5mbyA9IGdldEFkbWluTGF5ZXJJbmZvKGRlZmluaXRpb25MYXllcklkLCBwcm9wcyk7XG4gICAgICAgIHRoaXMudG90YWxGaWVsZHMgPSAoKF9hID0gdGhpcy5hZG1pbkxheWVySW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpZWxkcykgfHwgZ2V0RkwoZGVmaW5pdGlvbkxheWVySWQsIHByb3BzKS5maWVsZHM7XG4gICAgICAgIHRoaXMucmVxdWlyZWRGaWVsZE5hbWVzID0gZ2V0UmVxdWlyZWRGaWVsZE5hbWVzKHByb3BzKTtcbiAgICB9XG4gICAgYXN5bmMgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aGlzLmZsb3dJdGVtTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7IH0pLCAyMDApO1xuICAgIH1cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVTa2V0Y2hWaWV3TW9kZWwoKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBSZW5kZXIgTWV0aG9kc1xuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcInJlbmRlciB2aWV3LWRlZmluaXRpb25cIiwgcHJvcHNUb1N0cmluZyh0aGlzLnByb3BzKSk7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHN0YXR1cyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBkZWZpbml0aW9uTGF5ZXJJZCwgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGZsID0gZ2V0RkwoZGVmaW5pdGlvbkxheWVySWQsIHByb3BzKTtcbiAgICAgICAgY29uc3QgcnRsID0gZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSA9PT0gXCJydGxcIjtcbiAgICAgICAgcmV0dXJuIChoKEhvc3QsIHsgY2xhc3M6IFwiY2FsY2l0ZS1tYXRjaC1oZWlnaHRcIiB9LCBoKFwiY2FsY2l0ZS1mbG93LWl0ZW1cIiwgeyBoZWFkaW5nOiBzdHJpbmdzLmRlZmluZVZpZXcuZGVmaW5pdGlvbnMsIGRlc2NyaXB0aW9uOiBmbC50aXRsZSwgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICBwYW5lbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbQ1NTX1VUSUxJVFkucnRsXTogcnRsXG4gICAgICAgICAgICB9LCBvbkNhbGNpdGVGbG93SXRlbUJhY2s6IHRoaXMub25CYWNrLCByZWY6IChub2RlKSA9PiAodGhpcy5mbG93SXRlbU5vZGUgPSBub2RlKSB9LCB0aGlzLnJlbmRlckluZm8oKSwgdGhpcy5yZW5kZXJGaWx0ZXIoKSwgdGhpcy5yZW5kZXJBT0koKSwgdGhpcy5yZW5kZXJGaWVsZHMoKSksIHN0YXR1cyA9PT0gZmxvd1N0YXR1cy5GSUxURVIgPyB0aGlzLnJlbmRlckxheWVyRmlsdGVyKCkgOiBudWxsKSk7XG4gICAgfVxuICAgIHJlbmRlckluZm8oKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgY29uZmlnLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgeyBoZWxwQmFzZSwgaGVscE1hcCB9ID0gY29uZmlnO1xuICAgICAgICBpZiAoZ2V0U2luZ2xlT2JqZWN0TG9jYWxTdG9yYWdlKGxvY2FsU3RvcmFnZUtleXMuQVJDR0lTX0NPTVBPTkVOVF9OT1RJRklDQVRJT05TLCBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5cy5MQVlFUl9WSUVXX0RFRklOSVRJT05fRElTTUlTU0VEKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1ub3RpY2VcIiwgeyBjbGFzczogQ1NTJDcubm90aWNlLCBvcGVuOiB0cnVlLCBjbG9zYWJsZTogdHJ1ZSwgc2NhbGU6IFwic1wiLCB3aWR0aDogXCJhdXRvXCIsIG9uQ2FsY2l0ZU5vdGljZUNsb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0U2luZ2xlT2JqZWN0TG9jYWxTdG9yYWdlKGxvY2FsU3RvcmFnZUtleXMuQVJDR0lTX0NPTVBPTkVOVF9OT1RJRklDQVRJT05TLCB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXMuTEFZRVJfVklFV19ERUZJTklUSU9OX0RJU01JU1NFRCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IH0sIGgoXCJkaXZcIiwgeyBzbG90OiBcInRpdGxlXCIgfSwgc3RyaW5ncy5kZWZpbmVWaWV3LmFkZERlZmluaXRpb25zKSwgaChcImRpdlwiLCB7IHNsb3Q6IFwibWVzc2FnZVwiIH0sIHN0cmluZ3MuZGVmaW5lVmlldy5hZGREZWZpbml0aW9uc01zZyksIGgoXCJjYWxjaXRlLWxpbmtcIiwgeyBzbG90OiBcImxpbmtcIiwgdGl0bGU6IHN0cmluZ3MuZGVmaW5lVmlldy5tb3JlQWJvdXRWaWV3cywgdGFyZ2V0OiBcIl9ibGFua1wiLCBocmVmOiBgJHtoZWxwQmFzZX0ke2hlbHBNYXBbXCIxMjAwMDI4MzlcIl19YCB9LCBzdHJpbmdzLmRlZmluZVZpZXcubW9yZUFib3V0Vmlld3MpKSk7XG4gICAgfVxuICAgIHJlbmRlckZpbHRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBkZWZpbml0aW9uTGF5ZXJJZCwgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHZpZXdMYXllclByb3BzID0gZ2V0Vmlld0xheWVyUHJvcHMoZGVmaW5pdGlvbkxheWVySWQsIHByb3BzKTtcbiAgICAgICAgY29uc3QgcnRsID0gZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSA9PT0gXCJydGxcIjtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1ibG9ja1wiLCB7IGhlYWRpbmc6ICh2aWV3TGF5ZXJQcm9wcyA9PT0gbnVsbCB8fCB2aWV3TGF5ZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlld0xheWVyUHJvcHMuZmlsdGVyKSA/IHN0cmluZ3MuZGVmaW5lVmlldy5lZGl0RmlsdGVyIDogc3RyaW5ncy5kZWZpbmVWaWV3LmFkZEZpbHRlciwgY29sbGFwc2libGU6IGZhbHNlLCBjbGFzczogQ1NTJDcuZmlsdGVyQmxvY2ssIHRhYkluZGV4OiAwLCBvbkNsaWNrOiB0aGlzLmdvRmlsdGVyIH0sIGgoXCJjYWxjaXRlLWljb25cIiwgeyBzbG90OiBcImljb25cIiwgaWNvbjogXCJmaWx0ZXJcIiwgc2NhbGU6IFwic1wiIH0pLCBoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyBzbG90OiBcImNvbnRyb2xcIiwgaWNvbjogcnRsID8gXCJjaGV2cm9uLWxlZnRcIiA6IFwiY2hldnJvbi1yaWdodFwiLCBjbGFzczogQ1NTJDcuZmlsdGVyQ2hldnJvbiwgc2NhbGU6IFwic1wiLCB0ZXh0OiAodmlld0xheWVyUHJvcHMgPT09IG51bGwgfHwgdmlld0xheWVyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZXdMYXllclByb3BzLmZpbHRlcikgPyBzdHJpbmdzLmRlZmluZVZpZXcuZWRpdEZpbHRlciA6IHN0cmluZ3MuZGVmaW5lVmlldy5hZGRGaWx0ZXIsIHJlZjogKG5vZGUpID0+ICh0aGlzLmZpbHRlckFjdGlvbk5vZGUgPSBub2RlKSB9KSkpO1xuICAgIH1cbiAgICByZW5kZXJBT0koKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGZsIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGRlZmluaXRpb25MYXllcklkLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKGZsLmlzVGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZXdMYXllclByb3BzID0gZ2V0Vmlld0xheWVyUHJvcHMoZGVmaW5pdGlvbkxheWVySWQsIHByb3BzKTtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1ibG9ja1wiLCB7IGhlYWRpbmc6IHN0cmluZ3MuZGVmaW5lVmlldy5hcmVhT2ZJbnRlcmVzdCwgZGVzY3JpcHRpb246ICEodmlld0xheWVyUHJvcHMgPT09IG51bGwgfHwgdmlld0xheWVyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZXdMYXllclByb3BzLmFvaSkgPyBzdHJpbmdzLmRlZmluZVZpZXcuYW9pU3VidGV4dCA6IHVuZGVmaW5lZCwgY29sbGFwc2libGU6IHRydWUsIG9uQ2FsY2l0ZUJsb2NrT3BlbjogKCkgPT4gdGhpcy5vbkFPSVRvZ2dsZSgpLCBvbkNhbGNpdGVCbG9ja0Nsb3NlOiAoKSA9PiB0aGlzLm9uQU9JVG9nZ2xlKCksIHJlZjogKG5vZGUpID0+ICh0aGlzLmFvaUJsb2NrTm9kZSA9IG5vZGUpIH0sIGgoXCJjYWxjaXRlLWljb25cIiwgeyBzbG90OiBcImljb25cIiwgaWNvbjogXCJwb2x5Z29uXCIsIHNjYWxlOiBcInNcIiB9KSwgdGhpcy5yZW5kZXJBT0lDb250ZW50KCkpKTtcbiAgICB9XG4gICAgcmVuZGVyQU9JQ29udGVudCgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBkZWZpbml0aW9uTGF5ZXJJZCwgbGF5ZXJJZHMsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCB2aWV3TGF5ZXJQcm9wcyA9IGdldFZpZXdMYXllclByb3BzKGRlZmluaXRpb25MYXllcklkLCBwcm9wcyk7XG4gICAgICAgIGNvbnN0IGhhc0FPSSA9ICEhKHZpZXdMYXllclByb3BzID09PSBudWxsIHx8IHZpZXdMYXllclByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWV3TGF5ZXJQcm9wcy5hb2kpO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgbnVsbCwgaChcImNhbGNpdGUtYWN0aW9uLWdyb3VwXCIsIHsgbGF5b3V0OiBcImdyaWRcIiwgY2xhc3M6IENTUyQ3LmFvaUdyb3VwIH0sIGgoXCJjYWxjaXRlLWFjdGlvblwiLCB7IGljb246IFwicG9seWdvblwiLCBhcHBlYXJhbmNlOiBcInNvbGlkXCIsIGFsaWdubWVudDogXCJjZW50ZXJcIiwgYWN0aXZlOiBmYWxzZSwgZGlzYWJsZWQ6IGhhc0FPSSwgc2NhbGU6IFwic1wiLCB0ZXh0OiBzdHJpbmdzLmRlZmluZVZpZXcuYW9pU2tldGNoUG9seWdvbkxhYmVsLCB0aXRsZTogc3RyaW5ncy5kZWZpbmVWaWV3LmFvaVNrZXRjaFBvbHlnb25MYWJlbCwgb25DbGljazogIWhhc0FPSSA/IHRoaXMub25Qb2x5Z29uQ2xpY2sgOiB1bmRlZmluZWQsIHJlZjogKG5vZGUpID0+ICh0aGlzLnBvbHlnb25BY3Rpb24gPSBub2RlKSB9KSwgaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgaWNvbjogXCJyZWN0YW5nbGVcIiwgYXBwZWFyYW5jZTogXCJzb2xpZFwiLCBhbGlnbm1lbnQ6IFwiY2VudGVyXCIsIGFjdGl2ZTogZmFsc2UsIGRpc2FibGVkOiBoYXNBT0ksIHNjYWxlOiBcInNcIiwgdGV4dDogc3RyaW5ncy5kZWZpbmVWaWV3LmFvaVNrZXRjaFJlY3RhbmdsZUxhYmVsLCB0aXRsZTogc3RyaW5ncy5kZWZpbmVWaWV3LmFvaVNrZXRjaFJlY3RhbmdsZUxhYmVsLCBvbkNsaWNrOiAhaGFzQU9JID8gdGhpcy5vblJlY3RhbmdsZUNsaWNrIDogdW5kZWZpbmVkLCByZWY6IChub2RlKSA9PiAodGhpcy5yZWN0YW5nbGVBY3Rpb24gPSBub2RlKSB9KSwgaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgaWNvbjogXCJ0cmFzaFwiLCBhcHBlYXJhbmNlOiBcInNvbGlkXCIsIGFsaWdubWVudDogXCJjZW50ZXJcIiwgc2NhbGU6IFwic1wiLCBkaXNhYmxlZDogIWhhc0FPSSwgdGV4dDogc3RyaW5ncy5kZWZpbmVWaWV3LmFvaURlbGV0ZUxhYmVsLCB0aXRsZTogc3RyaW5ncy5kZWZpbmVWaWV3LmFvaURlbGV0ZUxhYmVsLCBvbkNsaWNrOiBoYXNBT0kgPyB0aGlzLm9uRGVsZXRlQU9JQ2xpY2sgOiB1bmRlZmluZWQgfSkpLCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQ3LnRleHRDZW50ZXIsIHJlZjogKG5vZGUpID0+ICh0aGlzLmRyYXdMYWJlbCA9IG5vZGUpIH0sICFoYXNBT0kgPyBzdHJpbmdzLmRlZmluZVZpZXcuYW9pU2VsZWN0IDogc3RyaW5ncy5kZWZpbmVWaWV3LmFvaVJlc3RhcnQpLCBsYXllcklkcy5sZW5ndGggPiAxID8gKGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IGFwcGVhcmFuY2U6IFwidHJhbnNwYXJlbnRcIiwgd2lkdGg6IFwiZnVsbFwiLCBjbGFzczogQ1NTJDcuYW9pQnV0dG9uLCBvbkNsaWNrOiAoKSA9PiB0aGlzLmFwcGx5QU9JVG9BbGwoKSB9LCBzdHJpbmdzLmRlZmluZVZpZXcuYW9pQXBwbHlBbGwpKSA6IG51bGwpKTtcbiAgICB9XG4gICAgcmVuZGVyRmllbGRzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHRvdGFsRmllbGRzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGRlZmluaXRpb25MYXllcklkLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3Qgdmlld0xheWVyUHJvcHMgPSBnZXRWaWV3TGF5ZXJQcm9wcyhkZWZpbml0aW9uTGF5ZXJJZCwgcHJvcHMpO1xuICAgICAgICBjb25zdCB0b3RhbEZpZWxkQ291bnQgPSB0b3RhbEZpZWxkcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGZpZWxkQ291bnRWaWV3ID0gKChfYSA9IHZpZXdMYXllclByb3BzID09PSBudWxsIHx8IHZpZXdMYXllclByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWV3TGF5ZXJQcm9wcy5maWVsZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHx8IHRvdGFsRmllbGRDb3VudDtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1ibG9ja1wiLCB7IGhlYWRpbmc6IHN0cmluZ3MuZGVmaW5lVmlldy5maWVsZHMsIGRlc2NyaXB0aW9uOiBgJHtmaWVsZENvdW50Vmlld30vJHt0b3RhbEZpZWxkQ291bnR9YCwgY29sbGFwc2libGU6IHRydWUgfSwgaChcImNhbGNpdGUtaWNvblwiLCB7IHNsb3Q6IFwiaWNvblwiLCBpY29uOiBcImZlYXR1cmUtZGV0YWlsc1wiLCBzY2FsZTogXCJzXCIgfSksIHRoaXMucmVuZGVyRmllbGRzQ29udGVudCgpKSk7XG4gICAgfVxuICAgIHJlbmRlckZpZWxkc0NvbnRlbnQoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGZsLCByZXF1aXJlZEZpZWxkTmFtZXMsIHRvdGFsRmllbGRzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGRlZmluaXRpb25MYXllcklkLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3Qgdmlld0xheWVyUHJvcHMgPSBnZXRWaWV3TGF5ZXJQcm9wcyhkZWZpbml0aW9uTGF5ZXJJZCwgcHJvcHMpO1xuICAgICAgICBsZXQgZmllbGRzTGlzdDtcbiAgICAgICAgaWYgKHZpZXdMYXllclByb3BzID09PSBudWxsIHx8IHZpZXdMYXllclByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWV3TGF5ZXJQcm9wcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGZpZWxkc0xpc3QgPSB0b3RhbEZpZWxkcy5maWx0ZXIoKGZpZWxkKSA9PiB2aWV3TGF5ZXJQcm9wcy5maWVsZHMuaW5kZXhPZihmaWVsZC5uYW1lKSA+IC0xIHx8XG4gICAgICAgICAgICAgICAgcmVxdWlyZWRGaWVsZE5hbWVzLmluZGV4T2YoZmllbGQubmFtZSkgPiAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWVsZHNMaXN0ID0gdG90YWxGaWVsZHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzRmllbGRzVG9TZWxlY3QgPSByZXF1aXJlZEZpZWxkTmFtZXMubGVuZ3RoICE9PSB0b3RhbEZpZWxkcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGxpc3RJdGVtcyA9IGZpZWxkc0xpc3QubWFwKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1saXN0LWl0ZW1cIiwgeyBsYWJlbDogZmllbGQuYWxpYXMgfHwgZmllbGQubmFtZSB9LCByZXF1aXJlZEZpZWxkTmFtZXMuaW5kZXhPZihmaWVsZC5uYW1lKSA9PT0gLTEgPyAoaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgaWNvbjogXCJ4XCIsIHNjYWxlOiBcInNcIiwgdGV4dDogc3RyaW5ncy5nZW5lcmFsLnJlbW92ZSwgc2xvdDogXCJhY3Rpb25zLWVuZFwiLCBvbkNsaWNrOiAoKSA9PiB0aGlzLnJlbW92ZUZpZWxkKGZpZWxkLm5hbWUpIH0pKSA6IG51bGwpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCBudWxsLCBoYXNGaWVsZHNUb1NlbGVjdCAmJiAoaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgY2xhc3M6IENTUyQ3LnNlbGVjdEZpZWxkcywgYXBwZWFyYW5jZTogXCJvdXRsaW5lLWZpbGxcIiwgcm91bmQ6IHRydWUsIGxhYmVsOiBzdHJpbmdzLmRlZmluZVZpZXcuc2VsZWN0RmllbGRzLCBzY2FsZTogXCJzXCIsIHdpZHRoOiBcImZ1bGxcIiwgb25DbGljazogKCkgPT4gdGhpcy5zZWxlY3RGaWVsZHMoZmwpLCByZWY6IChub2RlKSA9PiAodGhpcy5idXR0b25Ob2RlID0gbm9kZSkgfSwgc3RyaW5ncy5kZWZpbmVWaWV3LnNlbGVjdEZpZWxkcykpLCBoKFwiY2FsY2l0ZS1saXN0XCIsIG51bGwsIGxpc3RJdGVtcykpKTtcbiAgICB9XG4gICAgcmVuZGVyTGF5ZXJGaWx0ZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGZsIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGRlZmluaXRpb25MYXllcklkIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3Qgdmlld0xheWVyUHJvcHMgPSBnZXRWaWV3TGF5ZXJQcm9wcyhkZWZpbml0aW9uTGF5ZXJJZCwgdGhpcy5wcm9wcyk7XG4gICAgICAgIHJldHVybiAoaChcImFyY2dpcy1maWx0ZXJcIiwgeyBrZXk6IGBmaWx0ZXItJHtkZWZpbml0aW9uTGF5ZXJJZH1gLCB2aWV3OiB2aWV3LCBsYXllcjogZmwsIG1vZGU6IFwibGF5ZXItdmlld1wiLCB2aWV3RmlsdGVyOiB2aWV3TGF5ZXJQcm9wcyA9PT0gbnVsbCB8fCB2aWV3TGF5ZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlld0xheWVyUHJvcHMuZmlsdGVyLCBkaXNtaXNzaWJsZTogZmFsc2UsIGhpZGVMYXllclRpdGxlOiBmYWxzZSwgb25BcmNnaXNGaWx0ZXJQYW5lbEJhY2tDbGljazogdGhpcy5vbkJhY2tGaWx0ZXIsIG9uQXJjZ2lzRmlsdGVyV2hlcmVDaGFuZ2U6IChldmVudCkgPT4gdGhpcy5hcHBseUZpbHRlcihldmVudC5kZXRhaWwpIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgYXBwbHlGaWx0ZXIod2hlcmUpIHtcbiAgICAgICAgLy8gYXBwbHkgZmlsdGVyIGFmdGVyIGFyY2dpcy1maWx0ZXIgY29tcG9uZW50IGNsb3NlZFxuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGRlZmluaXRpb25MYXllcklkIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKHdoZXJlKSB7XG4gICAgICAgICAgICBhZGRWaWV3TGF5ZXJQcm9wcyhkZWZpbml0aW9uTGF5ZXJJZCwge1xuICAgICAgICAgICAgICAgIGZpbHRlcjogd2hlcmVcbiAgICAgICAgICAgIH0sIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQ7IG5vIGZpbHRlclxuICAgICAgICAgICAgY29uc3Qgdmlld0xheWVyUHJvcHMgPSBnZXRWaWV3TGF5ZXJQcm9wcyhkZWZpbml0aW9uTGF5ZXJJZCwgcHJvcHMpO1xuICAgICAgICAgICAgaWYgKHZpZXdMYXllclByb3BzKSB7XG4gICAgICAgICAgICAgICAgdmlld0xheWVyUHJvcHMuZmlsdGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2FuaXRpemVWaWV3UHJvcHMocHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbHRlciBjb21wb25lbnQgZG9lc24ndCByZW1vdmUgZWZmZWN0IG9uIGxheWVyVmlld1xuICAgICAgICAvL2F3YWl0IGFwcGx5TGF5ZXJGaWx0ZXIod2hlcmUsIGRlZmluaXRpb25MYXllcklkLCBwcm9wcyk7XG4gICAgfVxuICAgIGFzeW5jIG9uQU9JVG9nZ2xlKCkge1xuICAgICAgICBpZiAodGhpcy5hb2lCbG9ja05vZGUub3Blbikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLlNrZXRjaFZpZXdNb2RlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW9pQmxvY2tOb2RlLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtTa2V0Y2hWaWV3TW9kZWwsIEdyYXBoaWNzTGF5ZXIsIEdyYXBoaWMsIFBvbHlnb24sIEV4dGVudF0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgICAgICAgICAgICAgICAgIFwiZXNyaS93aWRnZXRzL1NrZXRjaC9Ta2V0Y2hWaWV3TW9kZWxcIixcbiAgICAgICAgICAgICAgICAgICAgXCJlc3JpL2xheWVycy9HcmFwaGljc0xheWVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXNyaS9HcmFwaGljXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXNyaS9nZW9tZXRyeS9Qb2x5Z29uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXNyaS9nZW9tZXRyeS9FeHRlbnRcIlxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIHRoaXMuU2tldGNoVmlld01vZGVsID0gU2tldGNoVmlld01vZGVsO1xuICAgICAgICAgICAgICAgIHRoaXMuR3JhcGhpY3NMYXllciA9IEdyYXBoaWNzTGF5ZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5HcmFwaGljID0gR3JhcGhpYztcbiAgICAgICAgICAgICAgICB0aGlzLlBvbHlnb24gPSBQb2x5Z29uO1xuICAgICAgICAgICAgICAgIHRoaXMuRXh0ZW50ID0gRXh0ZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuYW9pQmxvY2tOb2RlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0dXBTa2V0Y2hWaWV3TW9kZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU2tldGNoVmlld01vZGVsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0dXBTa2V0Y2hWaWV3TW9kZWwoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGFvaVN5bWJvbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsYXllciwgdmlldywgZGVmaW5pdGlvbkxheWVySWQgfSA9IHByb3BzO1xuICAgICAgICB0aGlzLmRlZmF1bHRBdXRvT3BlbkVuYWJsZWQgPSB2aWV3LnBvcHVwRW5hYmxlZDtcbiAgICAgICAgdmlldy5wb3B1cEVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY3NMYXllcikge1xuICAgICAgICAgICAgLy8gZG9uZSB0aGF0IGFscmVhZHlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYXBoaWNzTGF5ZXIgPSBuZXcgdGhpcy5HcmFwaGljc0xheWVyKCk7XG4gICAgICAgIHZpZXcubWFwLmFkZCh0aGlzLmdyYXBoaWNzTGF5ZXIpO1xuICAgICAgICBjb25zdCB2aWV3TGF5ZXJQcm9wcyA9IGdldFZpZXdMYXllclByb3BzKGRlZmluaXRpb25MYXllcklkLCBwcm9wcyk7XG4gICAgICAgIGlmICh2aWV3TGF5ZXJQcm9wcyA9PT0gbnVsbCB8fCB2aWV3TGF5ZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlld0xheWVyUHJvcHMuYW9pKSB7XG4gICAgICAgICAgICAvLyBza2V0Y2ggb25seSB3YW50cyBwb2x5Z29uc1xuICAgICAgICAgICAgY29uc3QgZ2VvbSA9IHZpZXdMYXllclByb3BzLmFvaTtcbiAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZ2VvbS5yaW5nc1xuICAgICAgICAgICAgICAgID8gdGhpcy5Qb2x5Z29uLmZyb21KU09OKGdlb20pXG4gICAgICAgICAgICAgICAgOiBuZXcgdGhpcy5Qb2x5Z29uKHtcbiAgICAgICAgICAgICAgICAgICAgcmluZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtnZW9tLnhtaW4sIGdlb20ueW1pbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbZ2VvbS54bWluLCBnZW9tLnltYXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW2dlb20ueG1heCwgZ2VvbS55bWF4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtnZW9tLnhtYXgsIGdlb20ueW1pbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbZ2VvbS54bWluLCBnZW9tLnltaW5dXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIHNwYXRpYWxSZWZlcmVuY2U6IHZpZXdMYXllclByb3BzLmFvaS5zcGF0aWFsUmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBncmFwaGljID0gbmV3IHRoaXMuR3JhcGhpYyh7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnksXG4gICAgICAgICAgICAgICAgc3ltYm9sOiBhb2lTeW1ib2xcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljc0xheWVyLmFkZChncmFwaGljKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNrZXRjaFZpZXdNb2RlbCA9IG5ldyB0aGlzLlNrZXRjaFZpZXdNb2RlbCh7XG4gICAgICAgICAgICBsYXllcjogdGhpcy5ncmFwaGljc0xheWVyLFxuICAgICAgICAgICAgdmlldyxcbiAgICAgICAgICAgIHBvbHlnb25TeW1ib2w6IGFvaVN5bWJvbCxcbiAgICAgICAgICAgIHVwZGF0ZU9uR3JhcGhpY0NsaWNrOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNrZXRjaFZpZXdNb2RlbC5vbihcImNyZWF0ZVwiLCAoZXZlbnQpID0+IHRoaXMub25HcmFwaGljQ3JlYXRlKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuc2tldGNoVmlld01vZGVsLm9uKFwidXBkYXRlXCIsIHRoaXMub25HcmFwaGljVXBkYXRlKTtcbiAgICAgICAgY29uc3Qgc25hcHBpbmcgPSBsYXllci50eXBlID09PSBcImdyb3VwXCJcbiAgICAgICAgICAgID8gbGF5ZXIubGF5ZXJzLm1hcCgoZkxheWVyKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbGF5ZXI6IGZMYXllciB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogW3sgbGF5ZXIgfV07XG4gICAgICAgIHRoaXMuc2tldGNoVmlld01vZGVsLnNuYXBwaW5nT3B0aW9ucy5mZWF0dXJlU291cmNlcyA9IHNuYXBwaW5nO1xuICAgICAgICB0aGlzLnNrZXRjaFZpZXdNb2RlbC5zbmFwcGluZ09wdGlvbnMuZW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIHJlbW92ZVNrZXRjaFZpZXdNb2RlbCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgZGVmYXVsdEF1dG9PcGVuRW5hYmxlZCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB2aWV3IH0gPSBwcm9wcztcbiAgICAgICAgdGhpcy5ncmFwaGljc0xheWVyICYmIHZpZXcubWFwLnJlbW92ZSh0aGlzLmdyYXBoaWNzTGF5ZXIpO1xuICAgICAgICAoX2EgPSB0aGlzLmdyYXBoaWNzTGF5ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3NMYXllciA9IHVuZGVmaW5lZDtcbiAgICAgICAgKF9iID0gdGhpcy5za2V0Y2hWaWV3TW9kZWwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc2tldGNoVmlld01vZGVsID0gdW5kZWZpbmVkO1xuICAgICAgICB2aWV3LnBvcHVwRW5hYmxlZCA9IGRlZmF1bHRBdXRvT3BlbkVuYWJsZWQ7XG4gICAgfVxuICAgIG9uR3JhcGhpY0NyZWF0ZShldmVudCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGRlZmluaXRpb25MYXllcklkLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKGV2ZW50LnN0YXRlID09PSBcInN0YXJ0XCIgJiYgdGhpcy5wb2x5Z29uQWN0aW9uLmFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5kcmF3TGFiZWwuaW5uZXJIVE1MID0gc3RyaW5ncy5kZWZpbmVWaWV3LmFvaVBvbHlnb25FbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LnN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNrZXRjaEdyYXBoaWMgPSBldmVudC5ncmFwaGljO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW50ID0gc2tldGNoR3JhcGhpYy5nZW9tZXRyeS5leHRlbnQ7XG4gICAgICAgICAgICBhZGRWaWV3TGF5ZXJQcm9wcyhkZWZpbml0aW9uTGF5ZXJJZCwge1xuICAgICAgICAgICAgICAgIGFvaTogIXRoaXMucG9seWdvbkFjdGlvbi5hY3RpdmUgPyBleHRlbnQudG9KU09OKCkgOiBza2V0Y2hHcmFwaGljLmdlb21ldHJ5LnRvSlNPTigpXG4gICAgICAgICAgICB9LCBwcm9wcyk7XG4gICAgICAgICAgICBhcHBseUxheWVyQU9JKHNrZXRjaEdyYXBoaWMuZ2VvbWV0cnksIGRlZmluaXRpb25MYXllcklkLCBwcm9wcyk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY3JlYXRlIGNvbXBsZXRlXCIsIHByb3BzVG9TdHJpbmcocHJvcHMpKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0xhYmVsLmlubmVySFRNTCA9IHN0cmluZ3MuZGVmaW5lVmlldy5hb2lSZXN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5wb2x5Z29uQWN0aW9uLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yZWN0YW5nbGVBY3Rpb24uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBvbHlnb25BY3Rpb24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZWN0YW5nbGVBY3Rpb24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hb2lCbG9ja05vZGUuZGVzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlBT0lUb0FsbCgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBkZWZpbml0aW9uTGF5ZXJJZCwgbGF5ZXIgfSA9IHByb3BzO1xuICAgICAgICBpZiAobGF5ZXIudHlwZSAhPT0gXCJncm91cFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdmlld0xheWVyUHJvcHMgPSBnZXRWaWV3TGF5ZXJQcm9wcyhkZWZpbml0aW9uTGF5ZXJJZCwgcHJvcHMpO1xuICAgICAgICBsYXllci5sYXllcnMubWFwKChmbGF5ZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChmbGF5ZXIubGF5ZXJJZCAhPT0gZGVmaW5pdGlvbkxheWVySWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlld0xheWVyUHJvcHMgPT09IG51bGwgfHwgdmlld0xheWVyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZXdMYXllclByb3BzLmFvaSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRWaWV3TGF5ZXJQcm9wcyhmbGF5ZXIubGF5ZXJJZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW9pOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZpZXdMYXllclByb3BzLmFvaSkpXG4gICAgICAgICAgICAgICAgICAgIH0sIHByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdMYXllclByb3BzMiA9IGdldFZpZXdMYXllclByb3BzKGZsYXllci5sYXllcklkLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWV3TGF5ZXJQcm9wczIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdMYXllclByb3BzMi5hb2kgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2FuaXRpemVWaWV3UHJvcHMocHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmlld0xheWVyUHJvcHMgPT09IG51bGwgfHwgdmlld0xheWVyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZXdMYXllclByb3BzLmFvaSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IHZpZXdMYXllclByb3BzLmFvaS5yaW5nc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLlBvbHlnb24uZnJvbUpTT04odmlld0xheWVyUHJvcHMuYW9pKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLkV4dGVudC5mcm9tSlNPTih2aWV3TGF5ZXJQcm9wcy5hb2kpO1xuICAgICAgICAgICAgICAgICAgICBhcHBseUxheWVyQU9JKGdlb21ldHJ5LCBmbGF5ZXIubGF5ZXJJZCwgcHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlMYXllckFPSSh1bmRlZmluZWQsIGZsYXllci5sYXllcklkLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlUGlja0xpc3RGaWVsZHMoZmwpIHtcbiAgICAgICAgY29uc3QgeyByZXF1aXJlZEZpZWxkTmFtZXMsIHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBhZG1pbkxheWVySW5mbyA9IGdldEFkbWluTGF5ZXJJbmZvKGZsLmxheWVySWQsIHByb3BzKTtcbiAgICAgICAgY29uc3QgdG90YWxGaWVsZHMgPSAoYWRtaW5MYXllckluZm8gPT09IG51bGwgfHwgYWRtaW5MYXllckluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkbWluTGF5ZXJJbmZvLmZpZWxkcykgfHwgZ2V0RkwoZmwubGF5ZXJJZCwgcHJvcHMpLmZpZWxkcztcbiAgICAgICAgcmV0dXJuIHRvdGFsRmllbGRzXG4gICAgICAgICAgICAuZmlsdGVyKChmaWVsZCkgPT4gcmVxdWlyZWRGaWVsZE5hbWVzLmluZGV4T2YoZmllbGQubmFtZSkgPT09IC0xKVxuICAgICAgICAgICAgLm1hcCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogZmllbGQubmFtZSxcbiAgICAgICAgICAgICAgICBhbGlhczogZmllbGQuYWxpYXMgfHwgZmllbGQubmFtZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBmaWVsZC50eXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlRmllbGRzUGlja0xpc3QoKSB7XG4gICAgICAgIHRoaXMuZmxvd0l0ZW1Ob2RlLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmFyY2dpc0ZpZWxkUGlja0xpc3QpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0KTtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdCA9IG51bGw7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbk5vZGUuc2V0Rm9jdXMoKTtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBob3N0RWxlbWVudCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbn07XG5BcmNnaXNMYXllclZpZXdEZWZpbml0aW9uLnN0eWxlID0gYXJjZ2lzTGF5ZXJWaWV3RGVmaW5pdGlvbkNzcztcblxudmFyIGpvaW5GbG93U3RhdHVzO1xuKGZ1bmN0aW9uIChqb2luRmxvd1N0YXR1cykge1xuICAgIGpvaW5GbG93U3RhdHVzW2pvaW5GbG93U3RhdHVzW1wiRVJST1JcIl0gPSAwXSA9IFwiRVJST1JcIjtcbiAgICBqb2luRmxvd1N0YXR1c1tqb2luRmxvd1N0YXR1c1tcIkxPQURJTkdcIl0gPSAxXSA9IFwiTE9BRElOR1wiO1xuICAgIGpvaW5GbG93U3RhdHVzW2pvaW5GbG93U3RhdHVzW1wiVEFSR0VUX1NFTEVDVElPTlwiXSA9IDJdID0gXCJUQVJHRVRfU0VMRUNUSU9OXCI7XG4gICAgam9pbkZsb3dTdGF0dXNbam9pbkZsb3dTdGF0dXNbXCJBRERfU0VMRUNUSU9OXCJdID0gM10gPSBcIkFERF9TRUxFQ1RJT05cIjtcbiAgICBqb2luRmxvd1N0YXR1c1tqb2luRmxvd1N0YXR1c1tcIkJST1dTRV9MQVlFUlwiXSA9IDRdID0gXCJCUk9XU0VfTEFZRVJcIjtcbiAgICBqb2luRmxvd1N0YXR1c1tqb2luRmxvd1N0YXR1c1tcIkNPTkZJR1wiXSA9IDVdID0gXCJDT05GSUdcIjtcbiAgICBqb2luRmxvd1N0YXR1c1tqb2luRmxvd1N0YXR1c1tcIkNSRUFURVwiXSA9IDZdID0gXCJDUkVBVEVcIjtcbn0pKGpvaW5GbG93U3RhdHVzIHx8IChqb2luRmxvd1N0YXR1cyA9IHt9KSk7XG5mdW5jdGlvbiBnZXRGaWVsZEFsaWFzKGxheWVyLCBmaWVsZE5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBmaWVsZHMsIHBvcHVwVGVtcGxhdGUgfSA9IGxheWVyO1xuICAgIGNvbnN0IGZpZWxkSW5mb3MgPSBwb3B1cFRlbXBsYXRlID09PSBudWxsIHx8IHBvcHVwVGVtcGxhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcHVwVGVtcGxhdGUuZmllbGRJbmZvcztcbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGROYW1lID09PSBmaWVsZC5uYW1lKTtcbiAgICByZXR1cm4gKChmaWVsZCAmJiAoKF9hID0gZmllbGRJbmZvcyA9PT0gbnVsbCB8fCBmaWVsZEluZm9zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZEluZm9zLmZpbmQoKGZpZWxkSW5mbykgPT4gZmllbGRJbmZvLmZpZWxkTmFtZSA9PT0gZmllbGQubmFtZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYWJlbCkpIHx8XG4gICAgICAgIChmaWVsZCA9PT0gbnVsbCB8fCBmaWVsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGQuYWxpYXMpIHx8XG4gICAgICAgIGZpZWxkTmFtZSk7XG59XG5mdW5jdGlvbiBnZXRGaWVsZFR5cGUobGF5ZXIsIGZpZWxkTmFtZSkge1xuICAgIGNvbnN0IHsgZmllbGRzIH0gPSBsYXllcjtcbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGROYW1lID09PSBmaWVsZC5uYW1lKTtcbiAgICByZXR1cm4gZmllbGQgPT09IG51bGwgfHwgZmllbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkLnR5cGU7XG59XG5mdW5jdGlvbiBnZXRMYXllclR5cGUobGF5ZXIsIHByb3BzKSB7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICByZXR1cm4gbGF5ZXIuaXNUYWJsZVxuICAgICAgICA/IHN0cmluZ3MuZ2VuZXJhbC50YWJsZVxuICAgICAgICA6IGxheWVyLmdlb21ldHJ5VHlwZSA9PT0gXCJwb2ludFwiIHx8IGxheWVyLmdlb21ldHJ5VHlwZSA9PT0gXCJtdWx0aXBvaW50XCJcbiAgICAgICAgICAgID8gc3RyaW5ncy5qb2luLnBvaW50TGF5ZXJcbiAgICAgICAgICAgIDogbGF5ZXIuZ2VvbWV0cnlUeXBlID09PSBcInBvbHlsaW5lXCJcbiAgICAgICAgICAgICAgICA/IHN0cmluZ3Muam9pbi5wb2x5bGluZUxheWVyXG4gICAgICAgICAgICAgICAgOiBsYXllci5nZW9tZXRyeVR5cGUgPT09IFwicG9seWdvblwiXG4gICAgICAgICAgICAgICAgICAgID8gc3RyaW5ncy5qb2luLnBvbHlnb25MYXllclxuICAgICAgICAgICAgICAgICAgICA6IFwiXCI7XG59XG5mdW5jdGlvbiBoYXNPQkFDKGxheWVyKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAvLyBPbmx5IGlmIG9uZSBvZiBhbGxvd090aGVyc1RvUXVlcnkvYWxsb3dBbm9ueW1vdXNUb1F1ZXJ5IGlzIGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlIGRvIHdlIGJsb2NrIGpvaW4uXG4gICAgLy8gSWYgaXQncyB0cnVlIG9yIG5vdCB0aGVyZSB3ZSBkb24ndCBibG9jayBqb2luXG4gICAgcmV0dXJuIChsYXllci5zb3VyY2VKU09OLm93bmVyc2hpcEJhc2VkQWNjZXNzQ29udHJvbEZvckZlYXR1cmVzICYmXG4gICAgICAgICgoKF9hID0gbGF5ZXIuc291cmNlSlNPTi5vd25lcnNoaXBCYXNlZEFjY2Vzc0NvbnRyb2xGb3JGZWF0dXJlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFsbG93QW5vbnltb3VzVG9RdWVyeSkgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAoKF9iID0gbGF5ZXIuc291cmNlSlNPTi5vd25lcnNoaXBCYXNlZEFjY2Vzc0NvbnRyb2xGb3JGZWF0dXJlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFsbG93T3RoZXJzVG9RdWVyeSkgPT09IGZhbHNlKSk7XG59XG5cbi8qKlxuICogZ2V0IGEgc3VnZ2VzdGVkIHRpdGxlIGZvciB0aGUgam9pbmVkIHZpZXdcbiAqIEBwYXJhbSBwcm9wcyAtIExheWVyVmlld0pvaW5Qcm9wc1xuICovXG5hc3luYyBmdW5jdGlvbiBnZXRTdWdnZXN0ZWRUaXRsZUZvckpvaW4ocHJvcHMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgdGFyZ2V0SXRlbSwgdGFyZ2V0TGF5ZXIsIHN0cmluZ3MsIG1vZHVsZXMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgZXNyaVJlcXVlc3QgfSA9IG1vZHVsZXM7XG4gICAgY29uc3QgcmVsYXRlZFVybCA9IGAke3RhcmdldEl0ZW0uaXRlbVVybH0vcmVsYXRlZEl0ZW1zYDtcbiAgICBjb25zdCByZWxhdGVkQ29udGVudCA9IHtcbiAgICAgICAgcmVsYXRpb25zaGlwVHlwZTogXCJTZXJ2aWNlMlNlcnZpY2VcIixcbiAgICAgICAgZGlyZWN0aW9uOiBcImZvcndhcmRcIlxuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXNyaVJlcXVlc3QocmVsYXRlZFVybCwge1xuICAgICAgICBxdWVyeTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWxhdGVkQ29udGVudCksIHsgZjogXCJqc29uXCIsIHRva2VuOiB0YXJnZXRMYXllci5wb3J0YWxJdGVtLnBvcnRhbC5jcmVkZW50aWFsLnRva2VuIH0pLFxuICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxuICAgICAgICByZXNwb25zZVR5cGU6IFwianNvblwiXG4gICAgfSk7XG4gICAgLy8gY2hlY2sgd2l0aCBzcGFjZXMgYW5kIHVuZGVyc2NvcmVzXG4gICAgY29uc3Qgdmlld0l0ZW1zID0gKChfYiA9IChfYSA9IHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdC5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVsYXRlZEl0ZW1zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnR5cGUgPT09IFwiRmVhdHVyZSBTZXJ2aWNlXCIgJiZcbiAgICAgICAgKGl0ZW0udGl0bGUuaW5kZXhPZih0YXJnZXRJdGVtLnRpdGxlKSA+IC0xIHx8XG4gICAgICAgICAgICBpdGVtLnRpdGxlLmluZGV4T2YodGFyZ2V0SXRlbS50aXRsZS5yZXBsYWNlKC8gL2csIFwiX1wiKSkgPiAtMSB8fFxuICAgICAgICAgICAgaXRlbS50aXRsZS5yZXBsYWNlKC8gL2csIFwiX1wiKS5pbmRleE9mKHRhcmdldEl0ZW0udGl0bGUpID4gLTEpKSkgfHwgW107XG4gICAgcmV0dXJuIChzdHJpbmdzLmpvaW4uam9pbkZlYXR1cmVzVG8ucmVwbGFjZShcIiR7bmFtZX1cIiwgdGFyZ2V0SXRlbS50aXRsZSkgK1xuICAgICAgICBgJHt2aWV3SXRlbXMubGVuZ3RoID8gYCAke3ZpZXdJdGVtcy5sZW5ndGggKyAxfWAgOiBgYH0gJHtzdHJpbmdzLmNyZWF0ZVZpZXcudmlld31gKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBqb2luIGxheWVyIHZpZXdcbiAqIEBwYXJhbSBwcm9wcyAtIExheWVyVmlld0pvaW5Qcm9wc1xuICogQHBhcmFtIG5ld0l0ZW1Qcm9wcyAtIHVzZXIgaW5wdXQgKE5ld0l0ZW1Qcm9wcylcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlSm9pblZpZXcocHJvcHMsIG5ld0l0ZW1Qcm9wcykge1xuICAgIGNvbnN0IHsgdGFyZ2V0SXRlbSwgdGFyZ2V0TGF5ZXIsIHRhcmdldExheWVySWQsIGFkZExheWVyLCBhZGRMYXllcklkIH0gPSBwcm9wcztcbiAgICBjb25zdCBpc1BvcnRhbCA9IHRhcmdldEl0ZW0ucG9ydGFsLmlzUG9ydGFsO1xuICAgIGNvbnN0IHRpbWVTdGFtcCA9IERhdGUubm93KCk7XG4gICAgY29uc3QgdGFyZ2V0RkwgPSAodGFyZ2V0TGF5ZXIudHlwZSA9PT0gXCJncm91cFwiXG4gICAgICAgID8gZ2V0TGF5ZXJzQW5kVGFibGVzKHRhcmdldExheWVyKS5maW5kKChseXIpID0+IGx5ci5sYXllcklkID09PSB0YXJnZXRMYXllcklkKVxuICAgICAgICA6IHRhcmdldExheWVyKTtcbiAgICBjb25zdCBhZGRGTCA9IChhZGRMYXllci50eXBlID09PSBcImdyb3VwXCJcbiAgICAgICAgPyBnZXRMYXllcnNBbmRUYWJsZXMoYWRkTGF5ZXIpLmZpbmQoKGx5cikgPT4gbHlyLmxheWVySWQgPT09IGFkZExheWVySWQpXG4gICAgICAgIDogYWRkTGF5ZXIpO1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGdldEFkbWluU2VydmljZUluZm8ocHJvcHMpO1xuICAgICAgICBpZiAoIWlzUG9ydGFsKSB7XG4gICAgICAgICAgICBhd2FpdCBjcmVhdGVJbmRleGVzKHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVhdGVTZXJ2aWNlUmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVKb2luU2VydmljZShwcm9wcywgbmV3SXRlbVByb3BzKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc1Byb3BzID0geyBuZXdJdGVtUHJvcHMsIGNyZWF0ZVNlcnZpY2VSZXNwb25zZSwgdGltZVN0YW1wLCB0YXJnZXRGTCwgYWRkRkwgfTtcbiAgICAgICAgYXdhaXQgYWRkVG9EZWZpbml0aW9uU3RhdHNUYWJsZShwcm9wcywgcHJvY2Vzc1Byb3BzKTtcbiAgICAgICAgYXdhaXQgYWRkVG9EZWZpbml0aW9uQXR0cmlidXRlSm9pbihwcm9wcywgcHJvY2Vzc1Byb3BzKTtcbiAgICAgICAgYXdhaXQgam9pbkl0ZW1VcGRhdGUocHJvcHMsIHByb2Nlc3NQcm9wcyk7XG4gICAgICAgIHJldHVybiBjcmVhdGVTZXJ2aWNlUmVzcG9uc2UuaXRlbUlkO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcImNyZWF0ZUpvaW5WaWV3IGZhaWxlZFwiKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUpvaW5TZXJ2aWNlKHByb3BzLCBuZXdJdGVtUHJvcHMpIHtcbiAgICBjb25zdCB7IHRhcmdldEl0ZW0sIG1vZHVsZXMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgZXNyaVJlcXVlc3QgfSA9IG1vZHVsZXM7XG4gICAgY29uc3QgeyBmb2xkZXIgfSA9IG5ld0l0ZW1Qcm9wcztcbiAgICBjb25zdCBpc093bmVyRm9sZGVyID0gIWZvbGRlciB8fCAhZm9sZGVyLmlkIHx8IGZvbGRlci5pZCA9PT0gdGFyZ2V0SXRlbS5vd25lcjtcbiAgICBjb25zdCBwb3J0YWwgPSB0YXJnZXRJdGVtLnBvcnRhbDtcbiAgICBjb25zdCBjcmVhdGVTZXJ2aWNlVXJsID0gYCR7cG9ydGFsLnJlc3RVcmx9L2NvbnRlbnQvdXNlcnMvJHt0YXJnZXRJdGVtLm93bmVyfSR7IWlzT3duZXJGb2xkZXIgPyBgLyR7Zm9sZGVyLmlkfWAgOiBcIlwifS9jcmVhdGVTZXJ2aWNlYDtcbiAgICAvLyBub3Qgc3VyZSB3aHkgd2UgbmVlZCB0byBzZW5kIGFsbCB0aGlzIGluLi4uXG4gICAgY29uc3QgY3JlYXRlUGFyYW1zID0ge1xuICAgICAgICBzZXJ2aWNlRGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGhhc1ZlcnNpb25lZERhdGE6IGZhbHNlLFxuICAgICAgICBzdXBwb3J0c0Rpc2Nvbm5lY3RlZEVkaXRpbmc6IGZhbHNlLFxuICAgICAgICBoYXNTdGF0aWNEYXRhOiB0cnVlLFxuICAgICAgICBtYXhSZWNvcmRDb3VudDogMjAwMCxcbiAgICAgICAgc3VwcG9ydGVkUXVlcnlGb3JtYXRzOiBcIkpTT05cIixcbiAgICAgICAgY2FwYWJpbGl0aWVzOiBcIlF1ZXJ5XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBjb3B5cmlnaHRUZXh0OiBcIlwiLFxuICAgICAgICBhbGxvd0dlb21ldHJ5VXBkYXRlczogZmFsc2UsXG4gICAgICAgIC8vIHRoaXMgY2F1c2VzIGlzc3VlcyBpbiByZXN1bHQgbGF5ZXIgd2hlbiB1c2VkIGluIG5ldHdvcmsgdG9vbHMgXCJ1bml0c1wiOlwiZXNyaU1ldGVyc1wiLFxuICAgICAgICBzeW5jRW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGVkaXRvclRyYWNraW5nSW5mbzoge1xuICAgICAgICAgICAgZW5hYmxlRWRpdG9yVHJhY2tpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZW5hYmxlT3duZXJzaGlwQWNjZXNzQ29udHJvbDogZmFsc2UsXG4gICAgICAgICAgICBhbGxvd090aGVyc1RvVXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dPdGhlcnNUb0RlbGV0ZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB4c3NQcmV2ZW50aW9uSW5mbzoge1xuICAgICAgICAgICAgeHNzUHJldmVudGlvbkVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB4c3NQcmV2ZW50aW9uUnVsZTogXCJJbnB1dE9ubHlcIixcbiAgICAgICAgICAgIHhzc0lucHV0UnVsZTogXCJyZWplY3RJbnZhbGlkXCJcbiAgICAgICAgfSxcbiAgICAgICAgdGFibGVzOiBbXSxcbiAgICAgICAgbmFtZTogbmV3SXRlbVByb3BzLnRpdGxlLnJlcGxhY2UoLyAvZywgXCJfXCIpXG4gICAgfTtcbiAgICBpZiAocG9ydGFsLmlzUG9ydGFsKSB7XG4gICAgICAgIGNvbnN0IGRhdGFTb3VyY2VUeXBlID0gYXdhaXQgZ2V0RGF0YVNvdXJjZVR5cGUocHJvcHMpO1xuICAgICAgICBpZiAoZGF0YVNvdXJjZVR5cGUpIHtcbiAgICAgICAgICAgIGNyZWF0ZVBhcmFtcy5vcHRpb25zID0geyBkYXRhU291cmNlVHlwZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjcmVhdGVTZXJ2aWNlQ29udGVudCA9IHtcbiAgICAgICAgY3JlYXRlUGFyYW1ldGVyczogSlNPTi5zdHJpbmdpZnkoY3JlYXRlUGFyYW1zKSxcbiAgICAgICAgb3V0cHV0VHlwZTogXCJmZWF0dXJlU2VydmljZVwiXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVzcmlSZXF1ZXN0KGNyZWF0ZVNlcnZpY2VVcmwsIHtcbiAgICAgICAgICAgIHF1ZXJ5OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNyZWF0ZVNlcnZpY2VDb250ZW50KSwgeyBmOiBcImpzb25cIiwgaXNWaWV3OiB0cnVlLCB0b2tlbjogcG9ydGFsLmNyZWRlbnRpYWwudG9rZW4gfSksXG4gICAgICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiBcImpzb25cIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiY3JlYXRlIHNlcnZpY2UgZmFpbGVkXCIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gYWRkVG9EZWZpbml0aW9uU3RhdHNUYWJsZShwcm9wcywgcHJvY2Vzc1Byb3BzKSB7XG4gICAgY29uc3QgeyBjcmVhdGVTZXJ2aWNlUmVzcG9uc2UsIGFkZEZMLCB0aW1lU3RhbXAgfSA9IHByb2Nlc3NQcm9wcztcbiAgICBjb25zdCB7IGFkZExheWVySWQsIGpvaW5PcGVyYXRpb24sIGF0dHJpYnV0ZVJlbGF0aW9uc2hpcHMgfSA9IHByb3BzO1xuICAgIGlmIChqb2luT3BlcmF0aW9uLnR5cGUgIT09IFwib25lLXRvLW9uZVwiIHx8IGpvaW5PcGVyYXRpb24ubWF0Y2hUeXBlICE9PSBcInN1bW1hcml6ZVwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWRtaW5VcmwgPSBjcmVhdGVTZXJ2aWNlUmVzcG9uc2Uuc2VydmljZXVybC5yZXBsYWNlKFwicmVzdC9zZXJ2aWNlc1wiLCBcInJlc3QvYWRtaW4vc2VydmljZXNcIik7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZUZpZWxkcyA9IGF0dHJpYnV0ZVJlbGF0aW9uc2hpcHMubWFwKChyZWwpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcmVsLmFkZEZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICBhbGlhczogKChfYSA9IGFkZEZMLmZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQubmFtZSA9PT0gcmVsLmFkZEZpZWxkTmFtZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hbGlhcykgfHwgcmVsLmFkZEZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHJlbC5hZGRGaWVsZE5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdW1tYXJpemVGaWVsZHMgPSBbXTtcbiAgICAgICAgam9pbk9wZXJhdGlvbi5zdGF0aXN0aWNzRmllbGRzLmZvckVhY2goKHN0YXRzRmllbGQpID0+IHtcbiAgICAgICAgICAgIHN0YXRzRmllbGQudHlwZXMuZm9yRWFjaCgoc3RhdHNUeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IHN0YXRzVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHN1bW1hcml6ZUZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogYCR7c3RhdHNGaWVsZC5maWVsZE5hbWV9XyR7dHlwZX1gLFxuICAgICAgICAgICAgICAgICAgICBhbGlhczogYCR7c3RhdHNGaWVsZC5maWVsZE5hbWV9XyR7dHlwZX1gLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHN0YXRzRmllbGQuZmllbGROYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdGF0aXN0aWNUeXBlOiB0eXBlID09PSBcIm1lYW5cIiA/IFwiYXZnXCIgOiB0eXBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGpzb24gPSB7XG4gICAgICAgICAgICBsYXllcnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGAke2dldFNvdXJjZVNlcnZpY2VOYW1lKGFkZEZMLnVybCwgcHJvcHMpfV9TdGF0c1RhYmxlYCxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwidGFibGVzdGF0c2pvaW5cIixcbiAgICAgICAgICAgICAgICAgICAgYWRtaW5MYXllckluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdMYXllckRlZmluaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBgJHtnZXRTb3VyY2VTZXJ2aWNlTmFtZShhZGRGTC51cmwsIHByb3BzKX1fJHt0aW1lU3RhbXB9X1N0YXRzVGFibGVgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VTZXJ2aWNlTmFtZTogZ2V0U291cmNlU2VydmljZU5hbWUoYWRkRkwudXJsLCBwcm9wcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUxheWVySWQ6IGFkZExheWVySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUxheWVyRmllbGRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVGaWVsZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJqb2luX2NvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFwiam9pbl9jb3VudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogam9pbk9wZXJhdGlvbi5zdGF0aXN0aWNzRmllbGRzWzBdLmZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aXN0aWNUeXBlOiBcImNvdW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5zdW1tYXJpemVGaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBCeTogYXR0cmlidXRlUmVsYXRpb25zaGlwcy5tYXAoKHJlbCkgPT4gcmVsLmFkZEZpZWxkTmFtZSkuam9pbihcIixcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IGFkZFRvRGVmaW5pdGlvblJlcXVlc3QoYCR7YWRtaW5Vcmx9L2FkZFRvRGVmaW5pdGlvbmAsIGpzb24sIHByb3BzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcImFkZFRvRGVmaW5pdGlvbiBTdGF0c1RhYmxlIGZhaWxlZFwiKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGFkZFRvRGVmaW5pdGlvbkF0dHJpYnV0ZUpvaW4ocHJvcHMsIHByb2Nlc3NQcm9wcykge1xuICAgIGNvbnN0IHsgY3JlYXRlU2VydmljZVJlc3BvbnNlLCBuZXdJdGVtUHJvcHMsIHRhcmdldEZMLCBhZGRGTCwgdGltZVN0YW1wIH0gPSBwcm9jZXNzUHJvcHM7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWRtaW5VcmwgPSBjcmVhdGVTZXJ2aWNlUmVzcG9uc2Uuc2VydmljZXVybC5yZXBsYWNlKFwicmVzdC9zZXJ2aWNlc1wiLCBcInJlc3QvYWRtaW4vc2VydmljZXNcIik7XG4gICAgICAgIGNvbnN0IGpzb24gPSBnZXRBdHRyaWJ1dGVKb2luSlNPTihwcm9wcywgbmV3SXRlbVByb3BzLCB0YXJnZXRGTCwgYWRkRkwsIHRpbWVTdGFtcCk7XG4gICAgICAgIGF3YWl0IGFkZFRvRGVmaW5pdGlvblJlcXVlc3QoYCR7YWRtaW5Vcmx9L2FkZFRvRGVmaW5pdGlvbmAsIGpzb24sIHByb3BzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcImFkZFRvRGVmaW5pdGlvbiBBdHRyaWJ1dGVKb2luIGZhaWxlZFwiKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZUpvaW5KU09OKHByb3BzLCBuZXdJdGVtUHJvcHMsIHRhcmdldEZMLCBhZGRGTCwgdGltZVN0YW1wKSB7XG4gICAgY29uc3QgeyB0YXJnZXRMYXllcklkLCBhZGRMYXllcklkLCBqb2luT3BlcmF0aW9uLCBhdHRyaWJ1dGVSZWxhdGlvbnNoaXBzLCBhZG1pblNlcnZpY2VJbmZvIH0gPSBwcm9wcztcbiAgICBjb25zdCBhdHRyaWJ1dGVGaWVsZHMgPSBhdHRyaWJ1dGVSZWxhdGlvbnNoaXBzLm1hcCgocmVsKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHJlbC5hZGRGaWVsZE5hbWUsXG4gICAgICAgICAgICBhbGlhczogKChfYSA9IGFkZEZMLmZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQubmFtZSA9PT0gcmVsLmFkZEZpZWxkTmFtZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hbGlhcykgfHwgcmVsLmFkZEZpZWxkTmFtZSxcbiAgICAgICAgICAgIHNvdXJjZTogcmVsLmFkZEZpZWxkTmFtZVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGxldCBzdW1tYXJpemVGaWVsZHM7XG4gICAgaWYgKGpvaW5PcGVyYXRpb24udHlwZSA9PT0gXCJvbmUtdG8tb25lXCIgJiYgam9pbk9wZXJhdGlvbi5tYXRjaFR5cGUgPT09IFwic3VtbWFyaXplXCIpIHtcbiAgICAgICAgc3VtbWFyaXplRmllbGRzID0gW107XG4gICAgICAgIGpvaW5PcGVyYXRpb24uc3RhdGlzdGljc0ZpZWxkcy5mb3JFYWNoKChzdGF0c0ZpZWxkKSA9PiB7XG4gICAgICAgICAgICBzdGF0c0ZpZWxkLnR5cGVzLmZvckVhY2goKHN0YXRzVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBzdGF0c1R5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBzdW1tYXJpemVGaWVsZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGAke3N0YXRzRmllbGQuZmllbGROYW1lfV8ke3R5cGV9YCxcbiAgICAgICAgICAgICAgICAgICAgYWxpYXM6IGAke3N0YXRzRmllbGQuZmllbGROYW1lfV8ke3R5cGV9YCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBgJHtzdGF0c0ZpZWxkLmZpZWxkTmFtZX1fJHt0eXBlfWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QganNvbiA9IHt9O1xuICAgIGpzb24ubmFtZSA9IG5ld0l0ZW1Qcm9wcy50aXRsZS5yZXBsYWNlKC8gL2csIFwiX1wiKTtcbiAgICBqc29uLmRpc3BsYXlGaWVsZCA9IFwiXCI7XG4gICAganNvbi5kZXNjcmlwdGlvbiA9IFwiQXR0cmlidXRlSm9pblwiO1xuICAgIGpzb24uYWRtaW5MYXllckluZm8gPSB7XG4gICAgICAgIHZpZXdMYXllckRlZmluaXRpb246IHtcbiAgICAgICAgICAgIHRhYmxlOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogYCR7Z2V0U291cmNlU2VydmljZU5hbWUodGFyZ2V0RkwudXJsLCBwcm9wcyl9XyR7dGltZVN0YW1wfV90YXJnZXRgLFxuICAgICAgICAgICAgICAgIHNvdXJjZVNlcnZpY2VOYW1lOiBnZXRTb3VyY2VTZXJ2aWNlTmFtZSh0YXJnZXRGTC51cmwsIHByb3BzKSxcbiAgICAgICAgICAgICAgICBzb3VyY2VMYXllcklkOiB0YXJnZXRMYXllcklkLFxuICAgICAgICAgICAgICAgIHNvdXJjZUxheWVyRmllbGRzOiB0YXJnZXRGTC5maWVsZHNcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZmllbGQpID0+IGZpZWxkLnR5cGUgIT09IFwib2lkXCIpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmaWVsZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXM6IGZpZWxkLmFsaWFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBmaWVsZC5uYW1lXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcmVsYXRlZFRhYmxlczogW1xuICAgICAgICAgICAgICAgICAgICBqb2luT3BlcmF0aW9uLnR5cGUgPT09IFwib25lLXRvLW9uZVwiICYmIGpvaW5PcGVyYXRpb24ubWF0Y2hUeXBlID09PSBcInN1bW1hcml6ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBgJHtnZXRTb3VyY2VTZXJ2aWNlTmFtZShhZGRGTC51cmwsIHByb3BzKX1fU3RhdHNUYWJsZWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlU2VydmljZU5hbWU6IG5ld0l0ZW1Qcm9wcy50aXRsZS5yZXBsYWNlKC8gL2csIFwiX1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VMYXllcklkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUxheWVyRmllbGRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZUZpZWxkcy5maWx0ZXIoKGF0dHJGaWVsZCkgPT4gIWF0dHJpYnV0ZVJlbGF0aW9uc2hpcHMuc29tZSgocmVsKSA9PiBhdHRyRmllbGQubmFtZSA9PT0gcmVsLmFkZEZpZWxkTmFtZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImpvaW5fY291bnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiBcImpvaW5fY291bnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogXCJqb2luX2NvdW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3VtbWFyaXplRmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBqb2luT3BlcmF0aW9uLmpvaW5UeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEtleUZpZWxkczogYXR0cmlidXRlUmVsYXRpb25zaGlwcy5tYXAoKHJlbCkgPT4gcmVsLnRhcmdldEZpZWxkTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RmllbGRzOiBhdHRyaWJ1dGVSZWxhdGlvbnNoaXBzLm1hcCgocmVsKSA9PiByZWwuYWRkRmllbGROYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogYCR7Z2V0U291cmNlU2VydmljZU5hbWUoYWRkRkwudXJsLCBwcm9wcyl9XyR7dGltZVN0YW1wfV9qb2luYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VTZXJ2aWNlTmFtZTogZ2V0U291cmNlU2VydmljZU5hbWUoYWRkRkwudXJsLCBwcm9wcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTGF5ZXJJZDogYWRkTGF5ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VMYXllckZpZWxkczogYWRkRkwuZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGFkZEZpZWxkKSA9PiBhZGRGaWVsZC50eXBlICE9PSBcIm9pZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKChhZGRGaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1Rha2VuID0gdGFyZ2V0RkwuZmllbGRzLmZpbmQoKHRhcmdldEZpZWxkKSA9PiB0YXJnZXRGaWVsZC5uYW1lID09PSBhZGRGaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGlzVGFrZW4gPyBgJHthZGRGaWVsZC5uYW1lfV8ke3RpbWVTdGFtcH1gIDogYWRkRmllbGQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiBhZGRGaWVsZC5hbGlhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogYWRkRmllbGQubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGpvaW5PcGVyYXRpb24uam9pblR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50S2V5RmllbGRzOiBhdHRyaWJ1dGVSZWxhdGlvbnNoaXBzLm1hcCgocmVsKSA9PiByZWwudGFyZ2V0RmllbGROYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlGaWVsZHM6IGF0dHJpYnV0ZVJlbGF0aW9uc2hpcHMubWFwKChyZWwpID0+IHJlbC5hZGRGaWVsZE5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcEZpbHRlcjogam9pbk9wZXJhdGlvbi50eXBlID09PSBcIm9uZS10by1vbmVcIiAmJiBqb2luT3BlcmF0aW9uLm1hdGNoVHlwZSA9PT0gXCJmaXJzdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBCeUZpZWxkczogYXR0cmlidXRlUmVsYXRpb25zaGlwc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKHJlbCkgPT4gcmVsLmFkZEZpZWxkTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuam9pbihcIixcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlckJ5RmllbGRzOiBgJHtqb2luT3BlcmF0aW9uLnNvcnRCeUZpZWxkTmFtZX0gJHtqb2luT3BlcmF0aW9uLnNvcnRPcmRlcn1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wQ291bnQ6IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxpemVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZW9tZXRyeUZpZWxkOiB0YXJnZXRGTC5pc1RhYmxlXG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIG5hbWU6IGAke2dldFNvdXJjZVNlcnZpY2VOYW1lKHRhcmdldEZMLnVybCwgcHJvcHMpfV8ke3RpbWVTdGFtcH1fdGFyZ2V0LiR7YWRtaW5TZXJ2aWNlSW5mby5sYXllcnMuZmluZCgobHlyKSA9PiBseXIuaWQgPT09IHRhcmdldExheWVySWQpLmFkbWluTGF5ZXJJbmZvLmdlb21ldHJ5RmllbGQubmFtZX1gXG4gICAgICAgICAgICB9XG4gICAgfTtcbiAgICAvKiBub3Qgc3VyZSB3aHkgd2Ugc2VuZCBhbGwgdmlhIGxheWVycy4uLlxuICAgIGxldCBsYXllcnMsIHRhYmxlcztcbiAgICBpZiAodGFyZ2V0RkwuaXNUYWJsZSkge1xuICAgICAgdGFibGVzID0gW2pzb25dO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXllcnMgPSBbanNvbl07XG4gICAgfVxuICBcbiAgICByZXR1cm4ge1xuICAgICAgbGF5ZXJzOiBsYXllcnMsXG4gICAgICB0YWJsZXM6IHRhYmxlc1xuICAgIH07ICovXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGF5ZXJzOiBbanNvbl1cbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gYWRkVG9EZWZpbml0aW9uUmVxdWVzdChhZGRUb0RlZlVybCwganNvbiwgcHJvcHMsIHJldHJ5ID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IG1vZHVsZXMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgZXNyaVJlcXVlc3QsIElkZW50aXR5TWFuYWdlciB9ID0gbW9kdWxlcztcbiAgICAvLyBhZGRUb0RlZlVybCBzYW1lIHNlcnZlciBhcyB0YXJnZXRMYXllclxuICAgIGNvbnN0IGNyZWRlbnRpYWwgPSBJZGVudGl0eU1hbmFnZXIuZmluZENyZWRlbnRpYWwoYWRkVG9EZWZVcmwpO1xuICAgIGNvbnN0IGFkZFRvRGVmQ29udGVudCA9IHtcbiAgICAgICAgYWRkVG9EZWZpbml0aW9uOiBKU09OLnN0cmluZ2lmeShqc29uKVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZXNyaVJlcXVlc3QoYWRkVG9EZWZVcmwsIHtcbiAgICAgICAgICAgIHF1ZXJ5OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFkZFRvRGVmQ29udGVudCksIHsgZjogXCJqc29uXCIsIHRva2VuOiBjcmVkZW50aWFsLnRva2VuIH0pLFxuICAgICAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogXCJqc29uXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKCFyZXRyeSkge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSBpdCdzIGp1c3QgYSBmbHVrZVxuICAgICAgICAgICAgcmV0dXJuIGFkZFRvRGVmaW5pdGlvblJlcXVlc3QoYWRkVG9EZWZVcmwsIGpzb24sIHByb3BzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcImFkZFRvRGVmaW5pdGlvbiByZXF1ZXN0IGZhaWxlZFwiKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNvdXJjZVNlcnZpY2VOYW1lKHVybCwgcHJvcHMpIHtcbiAgICBjb25zdCB7IHRhcmdldEl0ZW0gfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgcG9ydGFsIH0gPSB0YXJnZXRJdGVtO1xuICAgIGNvbnN0IHBvcyA9IHVybC5pbmRleE9mKFwiL3NlcnZpY2VzL1wiKSArIFwiL3NlcnZpY2VzL1wiLmxlbmd0aDtcbiAgICB2YXIgc2VydmljZU5hbWUgPSB1cmwuc3Vic3RyaW5nKHBvcywgdXJsLmluZGV4T2YoXCIvRmVhdHVyZVNlcnZlclwiLCBwb3MpKTtcbiAgICBpZiAocG9ydGFsLmlzUG9ydGFsKSB7XG4gICAgICAgIHNlcnZpY2VOYW1lID0gc2VydmljZU5hbWUucmVwbGFjZShcIkhvc3RlZC9cIiwgXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBzZXJ2aWNlTmFtZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGpvaW5JdGVtVXBkYXRlKHByb3BzLCBwcm9jZXNzUHJvcHMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgY3JlYXRlU2VydmljZVJlc3BvbnNlLCBuZXdJdGVtUHJvcHMgfSA9IHByb2Nlc3NQcm9wcztcbiAgICBjb25zdCB7IHRhcmdldEl0ZW0sIG1vZHVsZXMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgZXNyaVJlcXVlc3QgfSA9IG1vZHVsZXM7XG4gICAgY29uc3QgcG9ydGFsID0gdGFyZ2V0SXRlbS5wb3J0YWw7XG4gICAgY29uc3QgdXBkYXRlVXJsID0gYCR7cG9ydGFsLnJlc3RVcmx9L2NvbnRlbnQvdXNlcnMvJHt0YXJnZXRJdGVtLm93bmVyfS9pdGVtcy8ke2NyZWF0ZVNlcnZpY2VSZXNwb25zZS5pdGVtSWR9L3VwZGF0ZWA7XG4gICAgLy8gbmVlZCB0byBzZW5kIHNvbWUgaW5mbyBhZ2FpblxuICAgIGNvbnN0IHVwZGF0ZUNvbnRlbnQgPSB7XG4gICAgICAgIHRpdGxlOiBuZXdJdGVtUHJvcHMudGl0bGUsXG4gICAgICAgIHRhZ3M6ICgoX2EgPSBuZXdJdGVtUHJvcHMudGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPyBuZXdJdGVtUHJvcHMudGFncy50b1N0cmluZygpIDogdW5kZWZpbmVkLFxuICAgICAgICBzbmlwcGV0OiBuZXdJdGVtUHJvcHMuc3VtbWFyeSxcbiAgICAgICAgY2F0ZWdvcmllczogKF9iID0gbmV3SXRlbVByb3BzLmNhdGVnb3JpZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5qb2luKFwiLFwiKVxuICAgIH07XG4gICAgaWYgKHBvcnRhbC5pc1BvcnRhbCkge1xuICAgICAgICB1cGRhdGVDb250ZW50LnR5cGVLZXl3b3JkcyA9IFwiTXVsdGkgU2VydmljZXMgVmlld1wiO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZXNyaVJlcXVlc3QodXBkYXRlVXJsLCB7XG4gICAgICAgICAgICBxdWVyeTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB1cGRhdGVDb250ZW50KSwgeyBmOiBcImpzb25cIiwgdG9rZW46IHBvcnRhbC5jcmVkZW50aWFsLnRva2VuIH0pLFxuICAgICAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogXCJqc29uXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiaXRlbSB1cGRhdGUgcmVxdWVzdCBmYWlsZWRcIikpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXREYXRhU291cmNlVHlwZShwcm9wcykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBhd2FpdCBnZXRBZG1pblNlcnZpY2VJbmZvKHByb3BzKTtcbiAgICBjb25zdCB7IGFkbWluU2VydmljZUluZm8gfSA9IHByb3BzO1xuICAgIGNvbnN0IGRhdGFTb3VyY2UgPSAoKF9iID0gKF9hID0gYWRtaW5TZXJ2aWNlSW5mbyA9PT0gbnVsbCB8fCBhZG1pblNlcnZpY2VJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZG1pblNlcnZpY2VJbmZvLmFkbWluU2VydmljZUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhYmFzZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRhdGFzb3VyY2UpIHx8IHt9O1xuICAgIGNvbnN0IGRhdGFTb3VyY2VUeXBlID0gKChfYyA9IGRhdGFTb3VyY2UgPT09IG51bGwgfHwgZGF0YVNvdXJjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YVNvdXJjZS5uYW1lKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaW5kZXhPZihcIi9ub3NxbERhdGFiYXNlc1wiKSkgPiAtMVxuICAgICAgICA/IFwic3BhdGlvdGVtcG9yYWxcIlxuICAgICAgICA6ICgoX2QgPSBkYXRhU291cmNlID09PSBudWxsIHx8IGRhdGFTb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGFTb3VyY2UubmFtZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmluZGV4T2YoXCIvZW50ZXJwcmlzZURhdGFiYXNlc1wiKSkgPiAtMVxuICAgICAgICAgICAgPyBcInJlbGF0aW9uYWxcIlxuICAgICAgICAgICAgOiBudWxsO1xuICAgIHJldHVybiBkYXRhU291cmNlVHlwZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFkbWluU2VydmljZUluZm8ocHJvcHMsIG5vQ2FjaGUpIHtcbiAgICBjb25zdCB7IHRhcmdldExheWVyLCBhZG1pblNlcnZpY2VJbmZvLCBtb2R1bGVzIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IElkZW50aXR5TWFuYWdlciwgZXNyaVJlcXVlc3QgfSA9IG1vZHVsZXM7XG4gICAgaWYgKGFkbWluU2VydmljZUluZm8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZXJ2aWNlVXJsID0gdGFyZ2V0TGF5ZXIucG9ydGFsSXRlbS51cmw7XG4gICAgbGV0IGFkbWluVXJsID0gc2VydmljZVVybC5yZXBsYWNlKFwiL3Jlc3Qvc2VydmljZXNcIiwgXCIvcmVzdC9hZG1pbi9zZXJ2aWNlc1wiKTtcbiAgICBpZiAobm9DYWNoZSkge1xuICAgICAgICBhZG1pblVybCArPSBgJHthZG1pblVybC5pbmRleE9mKFwiP1wiKSA+IC0xID8gXCImXCIgOiBcIj9cIn1fdHM9JHtuZXcgRGF0ZSgpLmdldFRpbWUoKX1gO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBJZGVudGl0eU1hbmFnZXIuZ2V0Q3JlZGVudGlhbChhZG1pblVybCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZXNyaVJlcXVlc3QoYWRtaW5VcmwsIHtcbiAgICAgICAgICAgIHF1ZXJ5OiB7IGY6IFwianNvblwiIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHByb3BzLmFkbWluU2VydmljZUluZm8gPSByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcImNvdWxkIG5vdCBnZXQgYWRtaW4gaW5mb1wiKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUluZGV4ZXMocHJvcHMpIHtcbiAgICBjb25zdCB7IHRhcmdldExheWVyLCB0YXJnZXRMYXllcklkLCBhZGRMYXllciwgYWRkTGF5ZXJJZCwgYXR0cmlidXRlUmVsYXRpb25zaGlwcyB9ID0gcHJvcHM7XG4gICAgbGV0IGZsID0gdGFyZ2V0TGF5ZXIudHlwZSA9PT0gXCJncm91cFwiXG4gICAgICAgID8gZ2V0TGF5ZXJzQW5kVGFibGVzKHRhcmdldExheWVyKS5maW5kKChseXIpID0+IGx5ci5sYXllcklkID09PSB0YXJnZXRMYXllcklkKVxuICAgICAgICA6IHRhcmdldExheWVyO1xuICAgIGxldCBmaWVsZE5hbWVzID0gYXR0cmlidXRlUmVsYXRpb25zaGlwcy5tYXAoKHJlbCkgPT4gcmVsLnRhcmdldEZpZWxkTmFtZSk7XG4gICAgYXdhaXQgY3JlYXRlSW5kZXhlc0ZvckxheWVyKGZsLCBmaWVsZE5hbWVzLCBwcm9wcyk7XG4gICAgZmwgPVxuICAgICAgICBhZGRMYXllci50eXBlID09PSBcImdyb3VwXCJcbiAgICAgICAgICAgID8gZ2V0TGF5ZXJzQW5kVGFibGVzKGFkZExheWVyKS5maW5kKChseXIpID0+IGx5ci5sYXllcklkID09PSBhZGRMYXllcklkKVxuICAgICAgICAgICAgOiBhZGRMYXllcjtcbiAgICBmaWVsZE5hbWVzID0gYXR0cmlidXRlUmVsYXRpb25zaGlwcy5tYXAoKHJlbCkgPT4gcmVsLmFkZEZpZWxkTmFtZSk7XG4gICAgYXdhaXQgY3JlYXRlSW5kZXhlc0ZvckxheWVyKGZsLCBmaWVsZE5hbWVzLCBwcm9wcyk7XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVJbmRleGVzRm9yTGF5ZXIoZmwsIGZpZWxkTmFtZXMsIHByb3BzKSB7XG4gICAgY29uc3QganNvbiA9IHtcbiAgICAgICAgaW5kZXhlczogW11cbiAgICB9O1xuICAgIGZsLnNvdXJjZUpTT04uaW5kZXhlcyA9IGZsLnNvdXJjZUpTT04uaW5kZXhlcyB8fCBbXTtcbiAgICBmaWVsZE5hbWVzLmZvckVhY2goKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICBpZiAoIWZsLnNvdXJjZUpTT04uaW5kZXhlcy5zb21lKChpbmRleCkgPT4gaW5kZXguZmllbGRzID09PSBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICAvLyBpbmRleCBkb2Vzbid0IGV4aXN0IHlldFxuICAgICAgICAgICAganNvbi5pbmRleGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IGAke2ZpZWxkTmFtZX1fSW5kZXhgLFxuICAgICAgICAgICAgICAgIGZpZWxkczogZmllbGROYW1lLFxuICAgICAgICAgICAgICAgIGlzVW5pcXVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0FzY2VuZGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYCR7ZmllbGROYW1lfV9JbmRleGBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGpzb24uaW5kZXhlcy5sZW5ndGgpIHtcbiAgICAgICAgYXdhaXQgZXhlY3V0ZUNyZWF0ZUluZGV4ZXMoanNvbiwgZmwsIHByb3BzKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBleGVjdXRlQ3JlYXRlSW5kZXhlcyhqc29uLCBmbCwgcHJvcHMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyB0YXJnZXRJdGVtLCBtb2R1bGVzIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IElkZW50aXR5TWFuYWdlciB9ID0gbW9kdWxlcztcbiAgICBjb25zdCBhZG1pblVybCA9IGZsLnVybC5yZXBsYWNlKFwiL3Jlc3Qvc2VydmljZXNcIiwgXCIvcmVzdC9hZG1pbi9zZXJ2aWNlc1wiKTtcbiAgICBjb25zdCB1cmwgPSBgJHthZG1pblVybH0vJHtmbC5sYXllcklkfS9hZGRUb0RlZmluaXRpb25gO1xuICAgIGNvbnN0IGNyZWRlbnRpYWwgPSBJZGVudGl0eU1hbmFnZXIuZmluZENyZWRlbnRpYWwodXJsKTtcbiAgICBjb25zdCBpc1BvcnRhbCA9IHRhcmdldEl0ZW0ucG9ydGFsLmlzUG9ydGFsO1xuICAgIGNvbnN0IGNvbnRlbnQgPSB7XG4gICAgICAgIGY6IFwianNvblwiLFxuICAgICAgICBhZGRUb0RlZmluaXRpb246IEpTT04uc3RyaW5naWZ5KGpzb24pLFxuICAgICAgICBhc3luYzogIWlzUG9ydGFsLFxuICAgICAgICB0b2tlbjogY3JlZGVudGlhbC50b2tlblxuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9kdWxlcy5lc3JpUmVxdWVzdCh1cmwsIHtcbiAgICAgICAgcXVlcnk6IGNvbnRlbnQsXG4gICAgICAgIG1ldGhvZDogXCJwb3N0XCJcbiAgICB9KTtcbiAgICBpZiAoaXNQb3J0YWwpIHtcbiAgICAgICAgZmwuc291cmNlSlNPTi5pbmRleGVzID0gZmwuc291cmNlSlNPTi5pbmRleGVzIHx8IFtdO1xuICAgICAgICBmbC5zb3VyY2VKU09OLmluZGV4ZXMgPSBmbC5zb3VyY2VKU09OLmluZGV4ZXMuY29uY2F0KGpzb24uaW5kZXhlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgcG9sbEZvclN0YXR1cygoX2EgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXR1c1VSTCwge1xuICAgICAgICAgICAgICAgIGY6IFwianNvblwiLFxuICAgICAgICAgICAgICAgIHRva2VuOiBjcmVkZW50aWFsLnRva2VuXG4gICAgICAgICAgICB9LCBwcm9wcyk7XG4gICAgICAgICAgICBmbC5zb3VyY2VKU09OLmluZGV4ZXMgPSBmbC5zb3VyY2VKU09OLmluZGV4ZXMgfHwgW107XG4gICAgICAgICAgICBmbC5zb3VyY2VKU09OLmluZGV4ZXMgPSBmbC5zb3VyY2VKU09OLmluZGV4ZXMuY29uY2F0KGpzb24uaW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIG5vdCBhIGJpZyBwcm9ibGVtIGlmIGl0IGRpZG4ndCB3b3JrXG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBwb2xsRm9yU3RhdHVzID0gYXN5bmMgKHVybCwgcGFyYW1zLCBwcm9wcykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IG1vZHVsZXMgfSA9IHByb3BzO1xuICAgIGlmICghdXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBvbGxGb3JTdGF0dXM6IG5vIHN0YXR1cyBVUkxcIik7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmdTdGF0dXNlcyA9IFtcInByb2Nlc3NpbmdcIiwgXCJwYXJ0aWFsXCIsIFwiUGVuZGluZ1wiLCBcIkluUHJvZ3Jlc3NcIl07XG4gICAgY29uc3Qgc3VjY2Vzc1N0YXR1c2VzID0gW1wiY29tcGxldGVkXCIsIFwiQ29tcGxldGVkXCJdO1xuICAgIC8vIEtlZXAgcG9sbGluZyBzdGF0dXMgdW50aWwgZWl0aGVyIGNvbXBsZXRlZCBvciBmYWlsZWRcbiAgICB0cnkge1xuICAgICAgICAvLyBEbyBmYWlsdXJlcyByZXBvcnQgYXMgc3VjY2VzcyAoc3RhdHVzIDIwMCk/IE1heSBuZWVkIHRvIG1hbnVhbGx5IHRocm93IGVycm9yIG9uIHN0YXR1cyBjaGVjayBmYWlsdXJlXG4gICAgICAgIGNvbnN0IHN0YXR1c1Jlc3BvbnNlID0gYXdhaXQgbW9kdWxlcy5lc3JpUmVxdWVzdCh1cmwsIHsgcXVlcnk6IHBhcmFtcyB9KTtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gKF9hID0gc3RhdHVzUmVzcG9uc2UgPT09IG51bGwgfHwgc3RhdHVzUmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXR1c1Jlc3BvbnNlLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0dXM7XG4gICAgICAgIGlmIChwZW5kaW5nU3RhdHVzZXMuaW5jbHVkZXMoc3RhdHVzKSkge1xuICAgICAgICAgICAgYXdhaXQgdGltZW91dCg1MDApO1xuICAgICAgICAgICAgcmV0dXJuIHBvbGxGb3JTdGF0dXModXJsLCBwYXJhbXMsIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdWNjZXNzU3RhdHVzZXMuaW5jbHVkZXMoc3RhdHVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXR1c1Jlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgc3RhdHVzUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59O1xuXG5jb25zdCBhcmNnaXNMYXllclZpZXdKb2luQ3NzID0gXCI6aG9zdHtoZWlnaHQ6MTAwJX0ucGFuZWx7aGVpZ2h0OjEwMCV9LmZvb3Rlcnt3aWR0aDoxMDAlfS5lcnJvci1jb250ZW50e21hcmdpbjowLjVyZW19XCI7XG5cbmNvbnN0IEFyY2dpc0xheWVyVmlldyA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Sm9pbkNhbmNlbCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzTGF5ZXJWaWV3Sm9pbkNhbmNlbFwiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdKb2luVGFibGVDbGljayA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzTGF5ZXJWaWV3Sm9pblRhYmxlQ2xpY2tcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Sm9pblN0ZXBDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0xheWVyVmlld0pvaW5TdGVwQ2hhbmdlXCIsIDcpO1xuICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld0pvaW5DcmVhdGVkID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNMYXllclZpZXdKb2luQ3JlYXRlZFwiLCA3KTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBqb2luRmxvd1N0YXR1cy5MT0FESU5HO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvL1xuICAgICAgICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMuZ29DYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld0pvaW5DYW5jZWwuZW1pdCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnZpZXcgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaXRlbUlkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zaG93VGFibGVPcHRpb24gPSBmYWxzZTtcbiAgICB9XG4gICAgYXJjZ2lzTGF5ZXJWaWV3U3RhdHVzSGFuZGxlcihldmVudCkge1xuICAgICAgICBjb25zdCB7IGRldGFpbCB9ID0gZXZlbnQ7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gZGV0YWlsLnN0YXR1cztcbiAgICAgICAgLyogaWYgKGRldGFpbC5sYXllcklkcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgcHJvcHMubGF5ZXJJZHMgPSBbLi4uZGV0YWlsLmxheWVySWRzXTtcbiAgICAgICAgfSAqL1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IGpvaW5GbG93U3RhdHVzLlRBUkdFVF9TRUxFQ1RJT04pIHtcbiAgICAgICAgICAgIC8vcHJvcHMuc291cmNlSXRlbUlkID0gcHJvcHMubGF5ZXJJdGVtLmlkO1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdKb2luU3RlcENoYW5nZS5lbWl0KDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSBqb2luRmxvd1N0YXR1cy5BRERfU0VMRUNUSU9OKSB7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld0pvaW5TdGVwQ2hhbmdlLmVtaXQoMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0dXMgPT09IGpvaW5GbG93U3RhdHVzLkNPTkZJRykge1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdKb2luU3RlcENoYW5nZS5lbWl0KDMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSBqb2luRmxvd1N0YXR1cy5DUkVBVEUpIHtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Sm9pblN0ZXBDaGFuZ2UuZW1pdCg0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3JjZVVwZGF0ZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICB9XG4gICAgYXN5bmMgYXJjZ2lzTGF5ZXJWaWV3Sm9pbkNyZWF0ZURvbmVIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Sm9pbkNyZWF0ZWQuZW1pdChldmVudC5kZXRhaWwpO1xuICAgIH1cbiAgICBhcmNnaXNMYXllclZpZXdKb2luQ3JlYXRlQ2FuY2VsSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdKb2luQ2FuY2VsLmVtaXQoKTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFB1YmxpYyBNZXRob2RzXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLypcbiAgICAgKiBHb3QgdG8gYSBjZXJ0YWluIHN0ZXAuIElmIHN1Y2Nlc3NmdWwgaXQgd2lsbCByZXR1cm4gdHJ1ZS5cbiAgICAgKiBJZiBpdCdzIG5vdCBwb3NzaWJsZSwgYmVjYXVzZSBzb21lIHVzZXIgaW5wdXQgaXMgbWlzc2luZywgdGhlbiBpdCB3aWxsIHJldHVybiBmYWxzZS5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRTdGVwKHN0ZXApIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB0YXJnZXRMYXllcklkLCBhZGRMYXllcklkLCBhdHRyaWJ1dGVSZWxhdGlvbnNoaXBzLCBqb2luT3BlcmF0aW9uIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgYWRkU2VsZWN0aW9uUG9zc2libGUgPSBpc0RlZmluZWQodGFyZ2V0TGF5ZXJJZCk7XG4gICAgICAgIGNvbnN0IGNvbmZpZ1Bvc3NpYmxlID0gaXNEZWZpbmVkKGFkZExheWVySWQpO1xuICAgICAgICBjb25zdCBjcmVhdGVQb3NzaWJsZSA9IChhdHRyaWJ1dGVSZWxhdGlvbnNoaXBzID09PSBudWxsIHx8IGF0dHJpYnV0ZVJlbGF0aW9uc2hpcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF0dHJpYnV0ZVJlbGF0aW9uc2hpcHMuZmluZCgocmVsKSA9PiByZWwudGFyZ2V0RmllbGROYW1lICYmIHJlbC5hZGRGaWVsZE5hbWUpKSAmJlxuICAgICAgICAgICAgam9pbk9wZXJhdGlvbiAmJlxuICAgICAgICAgICAgKChqb2luT3BlcmF0aW9uLm1hdGNoVHlwZSA9PT0gXCJmaXJzdFwiICYmXG4gICAgICAgICAgICAgICAgam9pbk9wZXJhdGlvbi5zb3J0QnlGaWVsZE5hbWUgJiZcbiAgICAgICAgICAgICAgICBqb2luT3BlcmF0aW9uLnNvcnRPcmRlcikgfHxcbiAgICAgICAgICAgICAgICAoam9pbk9wZXJhdGlvbi5tYXRjaFR5cGUgPT09IFwic3VtbWFyaXplXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgKChfYSA9IGpvaW5PcGVyYXRpb24uc3RhdGlzdGljc0ZpZWxkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKChfYiA9IGpvaW5PcGVyYXRpb24uc3RhdGlzdGljc0ZpZWxkcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzBdLmZpZWxkTmFtZSkpKTtcbiAgICAgICAgLy8gY2xvc2UgcG9wb3ZlcnNcbiAgICAgICAgZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yQWxsKFwiLmpzLWFwcC1mbHlvdXRcIikuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gam9pbkZsb3dTdGF0dXMuVEFSR0VUX1NFTEVDVElPTjtcbiAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlc29sdmUodHJ1ZSkpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGlmIChhZGRTZWxlY3Rpb25Qb3NzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IGpvaW5GbG93U3RhdHVzLkFERF9TRUxFQ1RJT047XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlc29sdmUodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnUG9zc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBqb2luRmxvd1N0YXR1cy5DT05GSUc7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlc29sdmUodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBpZiAoY3JlYXRlUG9zc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBqb2luRmxvd1N0YXR1cy5DUkVBVEU7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlc29sdmUodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlc29sdmUoZmFsc2UpKTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIExpZmVjeWNsZVxuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IHsgaXRlbUlkLCB2aWV3LCBzaG93VGFibGVPcHRpb24sIGNvbmZpZyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgW3N0cmluZ3NdID0gYXdhaXQgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyh0aGlzLmhvc3RFbGVtZW50LCBcImFyY2dpcy1sYXllci12aWV3XCIpO1xuICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgICAgICB0aGlzLnByb3BzID0geyBjb25maWcsIHZpZXcsIGl0ZW1JZCwgc2hvd1RhYmxlT3B0aW9uLCBzdHJpbmdzLCBtb2R1bGVzOiB7fSB9O1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFpdGVtSWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJpdGVtSWQgaXMgYSByZXF1aXJlZCBwcm9wZXJ0eS5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IFtQb3J0YWxJdGVtLCBMYXllciwgRXh0ZW50LCBwcm9qZWN0aW9uLCBQb2x5Z29uLCBlc3JpUmVxdWVzdCwgSWRlbnRpdHlNYW5hZ2VyXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcbiAgICAgICAgICAgICAgICBcImVzcmkvcG9ydGFsL1BvcnRhbEl0ZW1cIixcbiAgICAgICAgICAgICAgICBcImVzcmkvbGF5ZXJzL0xheWVyXCIsXG4gICAgICAgICAgICAgICAgXCJlc3JpL2dlb21ldHJ5L0V4dGVudFwiLFxuICAgICAgICAgICAgICAgIFwiZXNyaS9nZW9tZXRyeS9wcm9qZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJlc3JpL2dlb21ldHJ5L1BvbHlnb25cIixcbiAgICAgICAgICAgICAgICBcImVzcmkvcmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIFwiZXNyaS9pZGVudGl0eS9JZGVudGl0eU1hbmFnZXJcIlxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBwcm9wcy5tb2R1bGVzID0ge1xuICAgICAgICAgICAgICAgIFBvcnRhbEl0ZW0sXG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbixcbiAgICAgICAgICAgICAgICBQb2x5Z29uLFxuICAgICAgICAgICAgICAgIEV4dGVudCxcbiAgICAgICAgICAgICAgICBMYXllcixcbiAgICAgICAgICAgICAgICBlc3JpUmVxdWVzdCxcbiAgICAgICAgICAgICAgICBJZGVudGl0eU1hbmFnZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJdGVtID0gbmV3IFBvcnRhbEl0ZW0oe1xuICAgICAgICAgICAgICAgIGlkOiBpdGVtSWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgdGFyZ2V0SXRlbS5sb2FkKCk7XG4gICAgICAgICAgICBwcm9wcy50YXJnZXRJdGVtT3duZXIgPSB0YXJnZXRJdGVtLnBvcnRhbC51c2VyO1xuICAgICAgICAgICAgaWYgKHRhcmdldEl0ZW0ucG9ydGFsLnVzZXIudXNlcm5hbWUgIT09IHRhcmdldEl0ZW0ub3duZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdXNlciBpbmZvIG9mIG93bmVyXG4gICAgICAgICAgICAgICAgYXdhaXQgZXNyaVJlcXVlc3QoYCR7dGFyZ2V0SXRlbS5wb3J0YWwucmVzdFVybH0vY29tbXVuaXR5L3VzZXJzLyR7dGFyZ2V0SXRlbS5vd25lcn1gLCB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7IGY6IFwianNvblwiIH1cbiAgICAgICAgICAgICAgICB9KS50aGVuKCh1c2VyUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyUmVzdWx0ID09PSBudWxsIHx8IHVzZXJSZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXJSZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMudGFyZ2V0SXRlbU93bmVyID0gdXNlclJlc3VsdC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0SXRlbS50eXBlICE9PSBcIkZlYXR1cmUgU2VydmljZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk9ubHkgRmVhdHVyZSBTZXJ2aWNlIGl0ZW1zIGFyZSBhbGxvd2VkLlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IGpvaW5GbG93U3RhdHVzLkVSUk9SO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoKF9hID0gdGFyZ2V0SXRlbS50eXBlS2V5d29yZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmRleE9mKFwiSG9zdGVkIFNlcnZpY2VcIikpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJPbmx5IGhvc3RlZCBGZWF0dXJlIFNlcnZpY2UgaXRlbXMgYXJlIGFsbG93ZWQuXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gam9pbkZsb3dTdGF0dXMuRVJST1I7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldEl0ZW0ucG9ydGFsLnVzZXIudXNlcm5hbWUgIT09IHRhcmdldEl0ZW0ub3duZXIgJiZcbiAgICAgICAgICAgICAgICB0YXJnZXRJdGVtLml0ZW1Db250cm9sICE9PSBcImFkbWluXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiT25seSBvd25lcnMgYW5kIGFkbWlucyBhcmUgYWxsb3dlZC5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBqb2luRmxvd1N0YXR1cy5FUlJPUjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKChfYiA9IHRhcmdldEl0ZW0udHlwZUtleXdvcmRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5kZXhPZihcIlZpZXcgU2VydmljZVwiKSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJWaWV3IGl0ZW1zIGFyZSBub3QgYWxsb3dlZC5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBqb2luRmxvd1N0YXR1cy5FUlJPUjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRhcmdldEl0ZW0gPT09IG51bGwgfHwgdGFyZ2V0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0SXRlbS50eXBlS2V5d29yZHMuaW5kZXhPZihcIklvVEZlYXR1cmVMYXllclwiKSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJWZWxvY2l0eSBpdGVtcyBhcmUgbm90IGFsbG93ZWQuXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gam9pbkZsb3dTdGF0dXMuRVJST1I7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGdjc0V4dGVudCA9IHRhcmdldEl0ZW0uZXh0ZW50O1xuICAgICAgICAgICAgaWYgKCFnY3NFeHRlbnQpIHtcbiAgICAgICAgICAgICAgICBnY3NFeHRlbnQgPSBuZXcgRXh0ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgeG1pbjogLTE4MCxcbiAgICAgICAgICAgICAgICAgICAgeW1pbjogLTkwLFxuICAgICAgICAgICAgICAgICAgICB4bWF4OiAxODAsXG4gICAgICAgICAgICAgICAgICAgIHltYXg6IDkwLFxuICAgICAgICAgICAgICAgICAgICBzcGF0aWFsUmVmZXJlbmNlOiA0MzI2XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlldy5zcGF0aWFsUmVmZXJlbmNlLndraWQgIT09IDQzMjYpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBwcm9qZWN0aW9uLmxvYWQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHRlbnQgPSBwcm9qZWN0aW9uLnByb2plY3QoZ2NzRXh0ZW50LCB2aWV3LnNwYXRpYWxSZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgIHZpZXcuZ29UbyhleHRlbnQuZXhwYW5kKDEuMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmlldy5nb1RvKGdjc0V4dGVudC5leHBhbmQoMS4xKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRMYXllciA9IGF3YWl0IExheWVyLmZyb21Qb3J0YWxJdGVtKHtcbiAgICAgICAgICAgICAgICBwb3J0YWxJdGVtOiB0YXJnZXRJdGVtXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCIqKnRhcmdldExheWVyKipcIiwgdGFyZ2V0TGF5ZXIpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIioqdGFyZ2V0SXRlbSoqXCIsIHRhcmdldEl0ZW0pO1xuICAgICAgICAgICAgaWYgKHRhcmdldExheWVyLnR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgICAgIC8vIGdyb3VwIGxheWVyIGhhcyBubyBsYXllcnMgb3IgdGFibGVzIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgICAgICAgICAvLyBsb2FkQWxsKCkgbG9hZHMgbGF5ZXJzIGFuZCB0YWJsZXMgKGF0IHY0LjIzKVxuICAgICAgICAgICAgICAgIGF3YWl0IHRhcmdldExheWVyLmxvYWRBbGwoKTtcbiAgICAgICAgICAgICAgICBpZiAoKF9jID0gdGFyZ2V0TGF5ZXIubGF5ZXJzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyBhdCBsZWFzdCBvbmUgc3BhdGlhbCBsYXllclxuICAgICAgICAgICAgICAgICAgICB2aWV3Lm1hcC5hZGQodGFyZ2V0TGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHBvcHVwc1xuICAgICAgICAgICAgICAgIChfZCA9IHRhcmdldExheWVyLmxheWVycykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmZvckVhY2goKGx5cikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWx5ci5wb3B1cFRlbXBsYXRlICYmIGx5ci5wb3B1cEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGx5ci5wb3B1cFRlbXBsYXRlID0gbHlyLmNyZWF0ZVBvcHVwVGVtcGxhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGFyZ2V0TGF5ZXIubG9hZCgpO1xuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0TGF5ZXIuaXNUYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3Lm1hcC5hZGQodGFyZ2V0TGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHBvcHVwXG4gICAgICAgICAgICAgICAgdGFyZ2V0TGF5ZXIucG9wdXBUZW1wbGF0ZSA9IHRhcmdldExheWVyLmNyZWF0ZVBvcHVwVGVtcGxhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRJdGVtLnBvcnRhbC5pc1BvcnRhbCkge1xuICAgICAgICAgICAgICAgIC8vIE9CQUMgbm90IHN1cHBvcnRlZCBpbiBFbnRlcnByaXNlXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldExheWVyLnR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdldExheWVyc0FuZFRhYmxlcyh0YXJnZXRMYXllcikuZmluZCgoZmwpID0+ICFoYXNPQkFDKGZsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJMYXllcnMgd2l0aCBPd25lcnNoaXAtQmFzZWQgQWNjZXNzIENvbnRyb2wgYXJlIG5vdCBhbGxvd2VkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNPQkFDKHRhcmdldExheWVyKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTGF5ZXJzIHdpdGggT3duZXJzaGlwLUJhc2VkIEFjY2VzcyBDb250cm9sIGFyZSBub3QgYWxsb3dlZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMudGFyZ2V0SXRlbSA9IHRhcmdldEl0ZW07XG4gICAgICAgICAgICBwcm9wcy50YXJnZXRMYXllciA9IHRhcmdldExheWVyO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBqb2luRmxvd1N0YXR1cy5UQVJHRVRfU0VMRUNUSU9OO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBqb2luRmxvd1N0YXR1cy5FUlJPUjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjb21wb25lbnREaWRMb2FkKCkge1xuICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld0pvaW5TdGVwQ2hhbmdlLmVtaXQoMSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHZpZXcsIHRhcmdldExheWVyLCBhZGRMYXllciB9ID0gcHJvcHM7XG4gICAgICAgIHZpZXcubWFwLnJlbW92ZSh0YXJnZXRMYXllcik7XG4gICAgICAgIHZpZXcubWFwLnJlbW92ZShhZGRMYXllcik7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUmVuZGVyIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJyZW5kZXJcIiwgXCJzdGF0dXM6XCIsIHRoaXMuc3RhdHVzKTtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBzdGF0dXMgPT09IGpvaW5GbG93U3RhdHVzLkVSUk9SID8gdGhpcy5yZW5kZXJFcnJvcigpIDogbnVsbCwgc3RhdHVzID09PSBqb2luRmxvd1N0YXR1cy5MT0FESU5HID8gdGhpcy5yZW5kZXJMb2FkaW5nKCkgOiBudWxsLCBbam9pbkZsb3dTdGF0dXMuVEFSR0VUX1NFTEVDVElPTl0uaW5jbHVkZXMoc3RhdHVzKVxuICAgICAgICAgICAgPyB0aGlzLnJlbmRlclRhcmdldExheWVyU2VsZWN0aW9uKClcbiAgICAgICAgICAgIDogbnVsbCwgW2pvaW5GbG93U3RhdHVzLkFERF9TRUxFQ1RJT04sIGpvaW5GbG93U3RhdHVzLkJST1dTRV9MQVlFUl0uaW5jbHVkZXMoc3RhdHVzKVxuICAgICAgICAgICAgPyB0aGlzLnJlbmRlckFkZExheWVyU2VsZWN0aW9uKClcbiAgICAgICAgICAgIDogbnVsbCwgW2pvaW5GbG93U3RhdHVzLkNPTkZJR10uaW5jbHVkZXMoc3RhdHVzKSA/IHRoaXMucmVuZGVyQ29uZmlnKCkgOiBudWxsLCBzdGF0dXMgPT09IGpvaW5GbG93U3RhdHVzLkNSRUFURSA/IHRoaXMucmVuZGVyQ3JlYXRlSm9pbigpIDogbnVsbCkpO1xuICAgIH1cbiAgICByZW5kZXJFcnJvcigpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB0YXJnZXRJdGVtLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1mbG93LWl0ZW1cIiwgeyBsb2FkaW5nOiBmYWxzZSwgaGVhZGluZzogKHRhcmdldEl0ZW0gPT09IG51bGwgfHwgdGFyZ2V0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0SXRlbS50aXRsZSkgfHwgc3RyaW5ncy5tc2cuZXJyb3IsIGRlc2NyaXB0aW9uOiAodGFyZ2V0SXRlbSA9PT0gbnVsbCB8fCB0YXJnZXRJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXRJdGVtLnRpdGxlKSA/IHN0cmluZ3Muam9pbi50YXJnZXRMYXllciA6IHVuZGVmaW5lZCwgY2xhc3M6IENTUyQ5LnBhbmVsLCByZWY6IChub2RlKSA9PiAodGhpcy5mbG93SXRlbU5vZGUgPSBub2RlKSB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQ5LmVycm9yQ29udGVudCB9LCBoKFwiY2FsY2l0ZS1ub3RpY2VcIiwgeyBzY2FsZTogXCJzXCIsIHdpZHRoOiBcImZ1bGxcIiwgb3BlbjogdHJ1ZSwgaWNvbjogXCJleGNsYW1hdGlvbi1tYXJrLXRyaWFuZ2xlXCIsIGtpbmQ6IFwiZGFuZ2VyXCIgfSwgaChcImRpdlwiLCB7IHNsb3Q6IFwidGl0bGVcIiB9LCBzdHJpbmdzLm1zZy5lcnJvciksIGgoXCJkaXZcIiwgeyBzbG90OiBcIm1lc3NhZ2VcIiB9LCBzdHJpbmdzLm1zZy5pbml0RmFpbGVkKSkpLCBoKFwiZGl2XCIsIHsgc2xvdDogXCJmb290ZXJcIiwgY2xhc3M6IENTUyQ5LmZvb3RlciB9LCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBzbG90OiBcImZvb3RlclwiLCBvbkNsaWNrOiB0aGlzLmdvQ2FuY2VsLCBhcHBlYXJhbmNlOiBcInRyYW5zcGFyZW50XCIsIHdpZHRoOiBcImZ1bGxcIiB9LCBzdHJpbmdzLmdlbmVyYWwuY2FuY2VsKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyTG9hZGluZygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB0YXJnZXRJdGVtLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1mbG93LWl0ZW1cIiwgeyBsb2FkaW5nOiB0cnVlLCBoZWFkaW5nOiB0YXJnZXRJdGVtID09PSBudWxsIHx8IHRhcmdldEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldEl0ZW0udGl0bGUsIGRlc2NyaXB0aW9uOiBzdHJpbmdzLmpvaW4udGFyZ2V0TGF5ZXIsIGNsYXNzOiBDU1MkOS5wYW5lbCwgcmVmOiAobm9kZSkgPT4gKHRoaXMuZmxvd0l0ZW1Ob2RlID0gbm9kZSkgfSkpO1xuICAgIH1cbiAgICByZW5kZXJUYXJnZXRMYXllclNlbGVjdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgc3RhdHVzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGgoXCJhcmNnaXMtbGF5ZXItdmlldy1qb2luLXRhcmdldC1zZWxlY3Rpb25cIiwgeyBrZXk6IGB0YXJnZXQtc2VsZWN0aW9uLSR7c3RhdHVzfWAsIHByb3BzOiBwcm9wcywgc3RhdHVzOiBzdGF0dXMgfSkpO1xuICAgIH1cbiAgICByZW5kZXJBZGRMYXllclNlbGVjdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgc3RhdHVzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGFkZEl0ZW0gfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gKGgoXCJhcmNnaXMtbGF5ZXItdmlldy1qb2luLWFkZC1zZWxlY3Rpb25cIiwgeyBrZXk6IGBhZGQtJHtzdGF0dXN9LSR7YWRkSXRlbSA9PT0gbnVsbCB8fCBhZGRJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZGRJdGVtLmlkfWAsIHByb3BzOiBwcm9wcywgc3RhdHVzOiBzdGF0dXMgfSkpO1xuICAgIH1cbiAgICByZW5kZXJDb25maWcoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHN0YXR1cyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChoKFwiYXJjZ2lzLWxheWVyLXZpZXctam9pbi1jb25maWdcIiwgeyBrZXk6IGBjcmVhdGUtJHtzdGF0dXN9YCwgcHJvcHM6IHByb3BzLCBvbkFyY2dpc0xheWVyVmlld0pvaW5Db25maWdUYWJsZUNsaWNrOiAoZXZlbnQpID0+IHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Sm9pblRhYmxlQ2xpY2suZW1pdChldmVudC5kZXRhaWwpIH0pKTtcbiAgICB9XG4gICAgcmVuZGVyQ3JlYXRlSm9pbigpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgc3RhdHVzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGgoXCJhcmNnaXMtbGF5ZXItdmlldy1qb2luLWNyZWF0ZVwiLCB7IGtleTogYGNyZWF0ZS0ke3N0YXR1c31gLCBwcm9wczogcHJvcHMgfSkpO1xuICAgIH1cbiAgICBnZXQgaG9zdEVsZW1lbnQoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuQXJjZ2lzTGF5ZXJWaWV3LnN0eWxlID0gYXJjZ2lzTGF5ZXJWaWV3Sm9pbkNzcztcblxuY29uc3QgQ1NTJDYgPSB7XG4gICAgZmxvdzogXCJmbG93XCIsXG4gICAgcGFuZWw6IFwicGFuZWxcIixcbiAgICBmb290ZXI6IFwiZm9vdGVyXCIsXG4gICAgaW5mbzogXCJpbmZvXCIsXG4gICAgbGlzdEhlYWRlcjogXCJsaXN0LWhlYWRlclwiLFxuICAgIHRleHQ6IFwidGV4dFwiLFxuICAgIGZvb3RlckJ1dHRvbjogXCJmb290ZXItYnV0dG9uXCIsXG4gICAgYnJvd3NlOiBcImJyb3dzZVwiXG59O1xuXG5jb25zdCBhcmNnaXNMYXllclZpZXdKb2luQWRkU2VsZWN0aW9uQ3NzID0gXCIuZmxvd3toZWlnaHQ6MTAwJX0ucGFuZWx7aGVpZ2h0OjEwMCV9LmZvb3Rlcnt3aWR0aDoxMDAlfS5pbmZve3BvaW50ZXItZXZlbnRzOm5vbmU7cGFkZGluZzoxcmVtIDAuNzVyZW19Lmxpc3QtaGVhZGVye3BvaW50ZXItZXZlbnRzOm5vbmU7cGFkZGluZzoxcmVtIDAuNzVyZW0gMC4zcmVtfS50ZXh0e2ZvbnQtc2l6ZTp2YXIoLS1jYWxjaXRlLWZvbnQtc2l6ZS0tMik7bGluZS1oZWlnaHQ6MS4zNzU7Y29sb3I6dmFyKC0tY2FsY2l0ZS1jb2xvci10ZXh0LTMpO3RyYW5zaXRpb24tZHVyYXRpb246MTUwbXM7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTtwb2ludGVyLWV2ZW50czpub25lO3dvcmQtd3JhcDpicmVhay13b3JkO3dvcmQtYnJlYWs6YnJlYWstd29yZH0uZm9vdGVyLWJ1dHRvbnttYXJnaW46MCAxMHB4IDVweCAxMHB4fS5ub3RpY2V7bWFyZ2luOjhweH0uYnJvd3Nle3dpZHRoOjEwMCV9XCI7XG5cbmNvbnN0IEFyY2dpc0xheWVyVmlld0pvaW5BZGRTZWxlY3Rpb24gPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld0pvaW5TdGF0dXNDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0xheWVyVmlld0pvaW5TdGF0dXNDaGFuZ2VcIiwgNyk7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vXG4gICAgICAgIC8vICBQcml2YXRlIG1ldGhvZHNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdGhpcy5nb0Jyb3dzZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Sm9pblN0YXR1c0NoYW5nZS5lbWl0KHsgc3RhdHVzOiBqb2luRmxvd1N0YXR1cy5CUk9XU0VfTEFZRVIgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ29CYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdKb2luU3RhdHVzQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgICAgICAgIHN0YXR1czogam9pbkZsb3dTdGF0dXMuVEFSR0VUX1NFTEVDVElPTlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ29OZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdKb2luU3RhdHVzQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgICAgICAgIHN0YXR1czogam9pbkZsb3dTdGF0dXMuQ09ORklHXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmxpc3ROb2RlXG4gICAgICAgICAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYWxjaXRlLXBpY2stbGlzdC1pdGVtXCIpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5hZGRMYXllcklkID0gaXRlbS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9wcy5hdHRyaWJ1dGVSZWxhdGlvbnNoaXBzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcHJvcHMuam9pbk9wZXJhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBMaWZlY3ljbGVcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBhZGRJdGVtLCB0YXJnZXRJdGVtLCB0YXJnZXRMYXllciB9ID0gcHJvcHM7XG4gICAgICAgIGlmICghYWRkSXRlbSAmJiB0YXJnZXRMYXllci50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgICAgICAgIHByb3BzLmFkZEl0ZW0gPSB0YXJnZXRJdGVtO1xuICAgICAgICAgICAgcHJvcHMuYWRkTGF5ZXIgPSB0YXJnZXRMYXllcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMuYWRkTGF5ZXIgJiYgcHJvcHMuYWRkTGF5ZXIudHlwZSAhPT0gXCJncm91cFwiICYmICFpc0RlZmluZWQocHJvcHMuYWRkTGF5ZXJJZCkpIHtcbiAgICAgICAgICAgIHByb3BzLmFkZExheWVySWQgPSBwcm9wcy5hZGRMYXllci5sYXllcklkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMuYmFja0J1dHRvbk5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRGb2N1cygpOyB9KTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkUmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHRhcmdldExheWVyLCB0YXJnZXRMYXllcklkLCBhZGRMYXllciwgYWRkTGF5ZXJJZCB9ID0gcHJvcHM7XG4gICAgICAgIGlmICh0YXJnZXRMYXllci50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgICAgICAgIGdldExheWVyc0FuZFRhYmxlcyh0YXJnZXRMYXllcikuZm9yRWFjaCgobHlyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGx5ci5sYXllcklkICE9PSB0YXJnZXRMYXllcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIGx5ci52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZExheWVyICYmIGFkZExheWVyLnR5cGUgPT09IFwiZ3JvdXBcIiAmJiBpc0RlZmluZWQoYWRkTGF5ZXJJZCkpIHtcbiAgICAgICAgICAgIGdldExheWVyc0FuZFRhYmxlcyhhZGRMYXllcikuZm9yRWFjaCgobHlyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldExheWVyLmlkICE9PSBhZGRMYXllci5pZCB8fCB0YXJnZXRMYXllcklkICE9PSBseXIubGF5ZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICBseXIudmlzaWJsZSA9IGx5ci5sYXllcklkID09PSBhZGRMYXllcklkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFkZExheWVyICYmIGFkZExheWVyLnR5cGUgIT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgYWRkTGF5ZXIudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBSZW5kZXIgTWV0aG9kc1xuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgc3RhdHVzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBydGwgPSBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpID09PSBcInJ0bFwiO1xuICAgICAgICByZXR1cm4gKGgoSG9zdCwgeyBjbGFzczogXCJjYWxjaXRlLW1hdGNoLWhlaWdodFwiIH0sIGgoXCJjYWxjaXRlLWZsb3dcIiwgeyBjbGFzczogQ1NTJDYuZmxvdywgZGlyOiBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpIH0sIGgoXCJjYWxjaXRlLWZsb3ctaXRlbVwiLCB7IGRlc2NyaXB0aW9uOiBzdHJpbmdzLmpvaW4uam9pbkxheWVyLCBjbGFzczoge1xuICAgICAgICAgICAgICAgIHBhbmVsOiB0cnVlLFxuICAgICAgICAgICAgICAgIFtDU1NfVVRJTElUWS5ydGxdOiBydGxcbiAgICAgICAgICAgIH0sIHJlZjogKG5vZGUpID0+ICh0aGlzLmZsb3dJdGVtTm9kZSA9IG5vZGUpIH0sIHRoaXMucmVuZGVyRm9vdGVyQnV0dG9ucygpLCB0aGlzLnJlbmRlck9CQUNNc2coKSwgdGhpcy5yZW5kZXJCcm93c2UoKSwgdGhpcy5yZW5kZXJTdWJsYXllcnMoKSksIHN0YXR1cyA9PT0gam9pbkZsb3dTdGF0dXMuQlJPV1NFX0xBWUVSICYmIHRoaXMucmVuZGVyQnJvd3NlTGF5ZXIoKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyRm9vdGVyQnV0dG9ucygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBhZGRJdGVtLCBhZGRMYXllcklkLCBhZGRMYXllciwgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGlzUnRsID0gZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSA9PT0gXCJydGxcIjtcbiAgICAgICAgbGV0IGFkZEZMO1xuICAgICAgICBpZiAoYWRkTGF5ZXIgJiYgYWRkTGF5ZXIudHlwZSA9PT0gXCJncm91cFwiICYmIGlzRGVmaW5lZChhZGRMYXllcklkKSkge1xuICAgICAgICAgICAgZ2V0TGF5ZXJzQW5kVGFibGVzKGFkZExheWVyKS5mb3JFYWNoKChseXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYWRkTGF5ZXJJZCA9PT0gbHlyLmxheWVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkRkwgPSBseXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWRkTGF5ZXIgJiYgYWRkTGF5ZXIudHlwZSAhPT0gXCJncm91cFwiKSB7XG4gICAgICAgICAgICBhZGRGTCA9IGFkZExheWVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHREaXNhYmxlZCA9ICFhZGRMYXllciB8fCAhaXNEZWZpbmVkKGFkZExheWVySWQpIHx8IChhZGRJdGVtLnBvcnRhbC5pc1BvcnRhbCAmJiBoYXNPQkFDKGFkZEZMKSk7XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IHNsb3Q6IFwiZm9vdGVyXCIsIGNsYXNzOiBDU1MkNi5mb290ZXIgfSwgaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgb25DbGljazogdGhpcy5nb0JhY2ssIGFwcGVhcmFuY2U6IFwib3V0bGluZS1maWxsXCIsIHdpZHRoOiBcImhhbGZcIiwgXCJpY29uLXN0YXJ0XCI6IGlzUnRsID8gXCJhcnJvdy1yaWdodFwiIDogXCJhcnJvdy1sZWZ0XCIsIHJlZjogKG5vZGUpID0+ICh0aGlzLmJhY2tCdXR0b25Ob2RlID0gbm9kZSkgfSwgc3RyaW5ncy5nZW5lcmFsLmJhY2spLCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBkaXNhYmxlZDogbmV4dERpc2FibGVkLCBvbkNsaWNrOiAhbmV4dERpc2FibGVkICYmIHRoaXMuZ29OZXh0LCBhcHBlYXJhbmNlOiBcInNvbGlkXCIsIHdpZHRoOiBcImhhbGZcIiwgaWNvbkVuZDogaXNSdGwgPyBcImFycm93LWxlZnRcIiA6IFwiYXJyb3ctcmlnaHRcIiwgcmVmOiAobm9kZSkgPT4gKHRoaXMubmV4dEJ1dHRvbk5vZGUgPSBub2RlKSB9LCBzdHJpbmdzLmdlbmVyYWwubmV4dCkpKTtcbiAgICB9XG4gICAgcmVuZGVyT0JBQ01zZygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBjb25maWcsIGFkZEl0ZW0sIGFkZExheWVySWQsIGFkZExheWVyLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgeyBoZWxwQmFzZSwgaGVscE1hcCB9ID0gY29uZmlnO1xuICAgICAgICBpZiAoIWFkZExheWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhZGRJdGVtLnBvcnRhbC5pc1BvcnRhbCkge1xuICAgICAgICAgICAgLy8gbWVzc2FnZSBvbmx5IGZvciBFbnRlcnByaXNlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFkZEZMO1xuICAgICAgICBpZiAoYWRkTGF5ZXIudHlwZSA9PT0gXCJncm91cFwiICYmIGlzRGVmaW5lZChhZGRMYXllcklkKSkge1xuICAgICAgICAgICAgYWRkRkwgPSBnZXRMYXllcnNBbmRUYWJsZXMoYWRkTGF5ZXIpLmZpbmQoKGx5cikgPT4gYWRkTGF5ZXJJZCA9PT0gbHlyLmxheWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFkZExheWVyLnR5cGUgIT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgYWRkRkwgPSBhZGRMYXllcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc09CQUMoYWRkRkwpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1ub3RpY2VcIiwgeyBrZXk6IGAke2hhc09CQUMoYWRkRkwpfWAsIGNsYXNzOiBcIm5vdGljZVwiLCBvcGVuOiB0cnVlLCBjbG9zYWJsZTogZmFsc2UsIHNjYWxlOiBcInNcIiwgd2lkdGg6IFwiYXV0b1wiLCBraW5kOiBcIndhcm5pbmdcIiwgaWNvbjogXCJleGNsYW1hdGlvbi1tYXJrLXRyaWFuZ2xlXCIgfSwgaChcImRpdlwiLCB7IHNsb3Q6IFwibWVzc2FnZVwiIH0sIHN0cmluZ3Muam9pbi5vYmFjTm90U3VwcG9ydGVkTXNnKSwgaChcImNhbGNpdGUtbGlua1wiLCB7IHNsb3Q6IFwibGlua1wiLCB0aXRsZTogc3RyaW5ncy5qb2luLmxlYXJuTW9yZSwgdGFyZ2V0OiBcIl9ibGFua1wiLCBocmVmOiBgJHtoZWxwQmFzZX0ke2hlbHBNYXBbXCIxMjAwMDQxODRcIl19YCB9LCBzdHJpbmdzLmpvaW4ubGVhcm5Nb3JlKSkpO1xuICAgIH1cbiAgICByZW5kZXJCcm93c2UoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCBudWxsLCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQ2LmluZm8gfSwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkNi50ZXh0IH0sIHN0cmluZ3Muam9pbi5zZWxlY3RBZGRMYXllclBhbmVsRGVzY3JpcHRpb24pKSwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkNi5mb290ZXJCdXR0b24gfSwgaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgaWQ6IFwiYXJjZ2lzLWxheWVyLXZpZXctam9pbi1icm93c2VcIiwgb25DbGljazogdGhpcy5nb0Jyb3dzZSwgYXBwZWFyYW5jZTogXCJvdXRsaW5lLWZpbGxcIiwgd2lkdGg6IFwiZnVsbFwiLCByZWY6IChub2RlKSA9PiAodGhpcy5icm93c2VCdXR0b25Ob2RlID0gbm9kZSkgfSwgc3RyaW5ncy5qb2luLmJyb3dzZUZvckxheWVyKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyQnJvd3NlTGF5ZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoaChcImFyY2dpcy1sYXllci12aWV3LWpvaW4tYnJvd3NlLWxheWVyXCIsIHsgcHJvcHM6IHByb3BzLCBjbGFzczogQ1NTJDYuYnJvd3NlLCBvbkFyY2dpc0xheWVyVmlld0pvaW5TdGF0dXNDaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kZXRhaWwuc3RhdHVzID09PSBqb2luRmxvd1N0YXR1cy5BRERfU0VMRUNUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbid0IG1ha2UgaXQgd29yayB3aXRob3V0IHVzaW5nIGFuIGlkXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IHNlZW1zIHRoZSB3aG9sZSBjb21wb25lbnQgcmVsb2FkcyBmcm9tIHNjcmF0Y2ggYWZ0ZXIgdGhpcyBzdGVwIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhcmNnaXMtbGF5ZXItdmlldy1qb2luLWJyb3dzZVwiKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDQwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB9KSk7XG4gICAgfVxuICAgIHJlbmRlclN1YmxheWVycygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB0YXJnZXRMYXllciwgYWRkSXRlbSwgYWRkTGF5ZXIsIHRhcmdldExheWVySWQsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBpZiAoIWFkZExheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0SXRlbXMgPSBbXTtcbiAgICAgICAgaWYgKGFkZExheWVyLnR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgZ2V0TGF5ZXJzQW5kVGFibGVzKGFkZExheWVyKS5mb3JFYWNoKChseXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0TGF5ZXIuaWQgIT09IGFkZExheWVyLmlkIHx8IHRhcmdldExheWVySWQgIT09IGx5ci5sYXllcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RJdGVtcy51bnNoaWZ0KHRoaXMucmVuZGVyU3VibGF5ZXIobHlyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaXN0SXRlbXMucHVzaCh0aGlzLnJlbmRlclN1YmxheWVyKGFkZExheWVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyID0gc3RyaW5ncy5qb2luLnNlbGVjdEZyb21JdGVtO1xuICAgICAgICByZXR1cm4gKGgoRnJhZ21lbnQsIG51bGwsIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDYubGlzdEhlYWRlciB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQ2LnRleHQgfSwgc3RyLnN1YnN0cmluZygwLCBzdHIuaW5kZXhPZihcIiR7XCIpKSwgaChcImJcIiwgbnVsbCwgYWRkSXRlbS50aXRsZSksIHN0ci5zdWJzdHJpbmcoc3RyLmluZGV4T2YoXCJ9XCIpICsgMSkpKSwgaChcImNhbGNpdGUtcGljay1saXN0XCIsIHsgbXVsdGlwbGU6IGZhbHNlLCBvbkNhbGNpdGVMaXN0Q2hhbmdlOiB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLCByZWY6IChub2RlKSA9PiAodGhpcy5saXN0Tm9kZSA9IG5vZGUpIH0sIGxpc3RJdGVtcykpKTtcbiAgICB9XG4gICAgcmVuZGVyU3VibGF5ZXIobHlyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgYWRkTGF5ZXJJZCB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtcGljay1saXN0LWl0ZW1cIiwgeyBrZXk6IGx5ci5sYXllcklkLCBsYWJlbDogbHlyLnRpdGxlLCB2YWx1ZTogbHlyLmxheWVySWQsIGRlc2NyaXB0aW9uOiBnZXRMYXllclR5cGUobHlyLCBwcm9wcyksIHNlbGVjdGVkOiBhZGRMYXllcklkID09PSBseXIubGF5ZXJJZCB9KSk7XG4gICAgfVxuICAgIGdldCBob3N0RWxlbWVudCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbn07XG5BcmNnaXNMYXllclZpZXdKb2luQWRkU2VsZWN0aW9uLnN0eWxlID0gYXJjZ2lzTGF5ZXJWaWV3Sm9pbkFkZFNlbGVjdGlvbkNzcztcblxuY29uc3QgYXJjZ2lzTGF5ZXJWaWV3Sm9pbkJyb3dzZUxheWVyQ3NzID0gXCIucGFuZWwuc2MtYXJjZ2lzLWxheWVyLXZpZXctam9pbi1icm93c2UtbGF5ZXJ7aGVpZ2h0OjEwMCV9XCI7XG5cbmNvbnN0IEFyY2dpc0xheWVyVmlld0pvaW5Ccm93c2VMYXllciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Sm9pblN0YXR1c0NoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzTGF5ZXJWaWV3Sm9pblN0YXR1c0NoYW5nZVwiLCA3KTtcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gIFByaXZhdGUgbWV0aG9kc1xuICAgICAgICAvL1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLm9uQmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Sm9pblN0YXR1c0NoYW5nZS5lbWl0KHsgc3RhdHVzOiBqb2luRmxvd1N0YXR1cy5BRERfU0VMRUNUSU9OIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdvVXNlTGF5ZXIgPSBhc3luYyAoaXRlbUlkKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgYWRkTGF5ZXIsIHRhcmdldExheWVyLCB2aWV3LCBtb2R1bGVzIH0gPSBwcm9wcztcbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoYWRkTGF5ZXIgJiYgYWRkTGF5ZXIuaWQgIT09IHRhcmdldExheWVyLmlkKSB7XG4gICAgICAgICAgICAgICAgdmlldy5tYXAucmVtb3ZlKGFkZExheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZEl0ZW0gPSBuZXcgbW9kdWxlcy5Qb3J0YWxJdGVtKHtcbiAgICAgICAgICAgICAgICBpZDogaXRlbUlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IGFkZEl0ZW0ubG9hZCgpO1xuICAgICAgICAgICAgY29uc3QgbmV3QWRkTGF5ZXIgPSBhd2FpdCBtb2R1bGVzLkxheWVyLmZyb21Qb3J0YWxJdGVtKHtcbiAgICAgICAgICAgICAgICBwb3J0YWxJdGVtOiBhZGRJdGVtXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChuZXdBZGRMYXllci50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBncm91cCBsYXllciBoYXMgbm8gbGF5ZXJzIG9yIHRhYmxlcyBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gbG9hZEFsbCgpIGxvYWRzIGxheWVycyBhbmQgdGFibGVzIChhdCB2NC4yMylcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXdBZGRMYXllci5sb2FkQWxsKCk7XG4gICAgICAgICAgICAgICAgaWYgKChfYSA9IG5ld0FkZExheWVyLmxheWVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgYXQgbGVhc3Qgb25lIHNwYXRpYWwgbGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5tYXAuYWRkKG5ld0FkZExheWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBwb3B1cHNcbiAgICAgICAgICAgICAgICAoX2IgPSBuZXdBZGRMYXllci5sYXllcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mb3JFYWNoKChseXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFseXIucG9wdXBUZW1wbGF0ZSAmJiBseXIucG9wdXBFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBseXIucG9wdXBUZW1wbGF0ZSA9IGx5ci5jcmVhdGVQb3B1cFRlbXBsYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ld0FkZExheWVyLmxvYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5ld0FkZExheWVyLmlzVGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5tYXAuYWRkKG5ld0FkZExheWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBwb3B1cFxuICAgICAgICAgICAgICAgIG5ld0FkZExheWVyLnBvcHVwVGVtcGxhdGUgPSBuZXdBZGRMYXllci5jcmVhdGVQb3B1cFRlbXBsYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wcy5hZGRJdGVtID0gYWRkSXRlbTtcbiAgICAgICAgICAgIHByb3BzLmFkZExheWVyID0gbmV3QWRkTGF5ZXI7XG4gICAgICAgICAgICBwcm9wcy5hZGRMYXllcklkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcHJvcHMuam9pbk9wZXJhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Sm9pblN0YXR1c0NoYW5nZS5lbWl0KHsgc3RhdHVzOiBqb2luRmxvd1N0YXR1cy5BRERfU0VMRUNUSU9OIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb3BzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wYWdpbmF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVycm9yID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgTGlmZWN5Y2xlXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYXN5bmMgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aGlzLmZsb3dJdGVtTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7IH0pLCAyMDApO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFJlbmRlciBNZXRob2RzXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBsb2FkaW5nLCBob3N0RWxlbWVudCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgcnRsID0gZ2V0RWxlbWVudERpcihob3N0RWxlbWVudCkgPT09IFwicnRsXCI7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCB7IGNsYXNzOiBcImNhbGNpdGUtbWF0Y2gtaGVpZ2h0XCIgfSwgaChcImNhbGNpdGUtZmxvdy1pdGVtXCIsIHsgaGVhZGluZzogc3RyaW5ncy5qb2luLmJyb3dzZUZvckxheWVyVGl0bGUsIGRlc2NyaXB0aW9uOiBzdHJpbmdzLmpvaW4uYnJvd3NlRm9yTGF5ZXJTdWJUaXRsZSwgbG9hZGluZzogbG9hZGluZywgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICBwYW5lbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbQ1NTX1VUSUxJVFkucnRsXTogcnRsXG4gICAgICAgICAgICB9LCBvbkNhbGNpdGVGbG93SXRlbUJhY2s6IHRoaXMub25CYWNrLCByZWY6IChub2RlKSA9PiAodGhpcy5mbG93SXRlbU5vZGUgPSBub2RlKSB9LCB0aGlzLnJlbmRlckl0ZW1Ccm93c2VyKCkpKSk7XG4gICAgfVxuICAgIHJlbmRlckl0ZW1Ccm93c2VyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBwYWdpbmF0aW9uIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHRhcmdldEl0ZW0sIHRhcmdldExheWVyLCBpdGVtSWQsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCB7IHBvcnRhbEl0ZW0gfSA9IHRhcmdldExheWVyO1xuICAgICAgICBjb25zdCB7IHBvcnRhbCB9ID0gcG9ydGFsSXRlbTtcbiAgICAgICAgY29uc3QgdXNlciA9IHBvcnRhbC51c2VyO1xuICAgICAgICBjb25zdCBxdWVyeSA9IGB0eXBlOlwiRmVhdHVyZSBTZXJ2aWNlXCIgdHlwZWtleXdvcmRzOlwiSG9zdGVkIFNlcnZpY2VcIiAtdHlwZWtleXdvcmRzOlwiVmlldyBTZXJ2aWNlXCIgLXR5cGVrZXl3b3JkczpcIlNwYXRpb3RlbXBvcmFsXCIgb3duZXI6XCIke3RhcmdldEl0ZW0ub3duZXJ9XCIgLWlkOiR7aXRlbUlkfWA7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBgJHtnZXRQb3J0YWxCYXNlVXJsKHBvcnRhbCl9L2hvbWUvYDtcbiAgICAgICAgcmV0dXJuIChoKFwiYXJjZ2lzLWl0ZW0tYnJvd3NlclwiLCB7IG9uQXJjZ2lzSXRlbUJyb3dzZXJVcGRhdGU6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHRzLCBudW0sIHN0YXJ0LCB0b3RhbCB9ID0gZS5kZXRhaWw7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcyA9IHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWdpbmF0aW9uID0geyBzdGFydCwgbnVtLCB0b3RhbCB9O1xuICAgICAgICAgICAgfSwgZmlsdGVyOiBxdWVyeSwgcG9ydGFsOiBwb3J0YWwsIHVzZXI6IHVzZXIsIGFwaTogNCwgY29uZmlnOiB7IGJhc2VVcmwgfSwgc2VsZWN0aW9uOiBcIm5vbmVcIiB9LCBoKFwiYXJjZ2lzLWl0ZW0tYnJvd3Nlci10b3AtYmFyXCIsIHsgc2xvdDogXCJ0b3AtYmFyXCIgfSwgaChcImFyY2dpcy1pdGVtLWJyb3dzZXItc2VhcmNoXCIsIHsgc2xvdDogXCJzZWFyY2hcIiwgdGVybTogXCJcIiB9KSksIGgoXCJhcmNnaXMtaXRlbS1icm93c2VyLXNvcnRcIiwgeyBvcHRpb25zOiBbXCJtb2RpZmllZFwiLCBcInRpdGxlXCIsIFwicmVsZXZhbmNlXCJdLCBzbG90OiBcInNvcnRcIiB9KSwgaChcImFyY2dpcy1pdGVtLWJyb3dzZXItY29udGVudFwiLCB7IHNsb3Q6IFwiY29udGVudFwiIH0sICh0aGlzLml0ZW1zIHx8IFtdKS5tYXAoKGl0ZW0pID0+IChoKFwiYXJjZ2lzLWl0ZW0tYnJvd3Nlci1jYXJkXCIsIHsgaXRlbTogaXRlbSwgcG9ydGFsOiBwb3J0YWwsIGJhc2VVcmw6IGJhc2VVcmwsIGtleTogaXRlbS5pZCB9LCBoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyBpZDogYGpvaW4tYWN0aW9uLSR7aXRlbS5pZH1gLCBpY29uOiBcInBsdXMtY2lyY2xlXCIsIHRleHQ6IFwiXCIsIHNjYWxlOiBcInNcIiwgc2xvdDogXCJhY3Rpb25zLWVuZFwiLCBvbkNsaWNrOiB0aGlzLmdvVXNlTGF5ZXIuYmluZCh0aGlzLCBpdGVtLmlkKSB9LCBoKFwiY2FsY2l0ZS10b29sdGlwXCIsIHsgc2xvdDogXCJ0b29sdGlwXCIsIGxhYmVsOiBzdHJpbmdzLmpvaW4uc2VsZWN0LCBvdmVybGF5UG9zaXRpb25pbmc6IFwiZml4ZWRcIiB9LCBzdHJpbmdzLmpvaW4uc2VsZWN0KSkpKSkpLCBoKFwiYXJjZ2lzLWl0ZW0tYnJvd3Nlci1wYWdpbmF0aW9uXCIsIHsgdG90YWw6IHBhZ2luYXRpb24gPT09IG51bGwgfHwgcGFnaW5hdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFnaW5hdGlvbi50b3RhbCwgc3RhcnQ6IHBhZ2luYXRpb24gPT09IG51bGwgfHwgcGFnaW5hdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFnaW5hdGlvbi5zdGFydCwgbnVtOiBwYWdpbmF0aW9uID09PSBudWxsIHx8IHBhZ2luYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhZ2luYXRpb24ubnVtLCBzbG90OiBcInBhZ2luYXRpb25cIiB9KSkpO1xuICAgIH1cbiAgICBnZXQgaG9zdEVsZW1lbnQoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuQXJjZ2lzTGF5ZXJWaWV3Sm9pbkJyb3dzZUxheWVyLnN0eWxlID0gYXJjZ2lzTGF5ZXJWaWV3Sm9pbkJyb3dzZUxheWVyQ3NzO1xuXG5jb25zdCBDU1MkNSA9IHtcbiAgICBmbG93OiBcImZsb3dcIixcbiAgICBwYW5lbDogXCJwYW5lbFwiLFxuICAgIGZvb3RlcjogXCJmb290ZXJcIixcbiAgICBsYXllclNlY3Rpb246IFwibGF5ZXItc2VjdGlvblwiLFxuICAgIHRhcmdldExheWVyOiBcInRhcmdldC1sYXllclwiLFxuICAgIGFkZExheWVyOiBcImFkZC1sYXllclwiLFxuICAgIGxheWVySGVhZGVyOiBcImxheWVyLWhlYWRlclwiLFxuICAgIGxheWVyVGl0bGU6IFwibGF5ZXItdGl0bGVcIixcbiAgICBsYXllckljb246IFwibGF5ZXItaWNvblwiLFxuICAgIGF0dHJpYnV0ZVJlbGF0aW9uc2hpcDogXCJhdHRyaWJ1dGUtcmVsYXRpb25zaGlwXCIsXG4gICAgcmVtb3ZlQXR0cmlidXRlUmVsYXRpb25zaGlwOiBcInJlbW92ZS1hdHRyaWJ1dGUtcmVsYXRpb25zaGlwXCIsXG4gICAgc29ydEJ5U2VjdGlvbjogXCJzb3J0LWJ5LXNlY3Rpb25cIixcbiAgICBqb2luTWF0Y2hUeXBlU2VjdGlvbjogXCJqb2luLW1hdGNoLXR5cGUtc2VjdGlvblwiLFxuICAgIGNoaXA6IFwiY2hpcFwiLFxuICAgIHNlcGFyYXRvcjogXCJzZXBhcmF0b3JcIixcbiAgICBzdGF0c1NlY3Rpb246IFwic3RhdHMtc2VjdGlvblwiLFxuICAgIHN0YXRzRmllbGRIZWFkZXI6IFwic3RhdHMtZmllbGQtaGVhZGVyXCIsXG4gICAgc3RhdHNCdXR0b246IFwic3RhdHMtYnV0dG9uXCIsXG4gICAgc2VsZWN0QWxsOiBcInNlbGVjdC1hbGxcIixcbiAgICBzZWxlY3Q6IFwic2VsZWN0XCJcbn07XG5cbmNvbnN0IGFyY2dpc0xheWVyVmlld0pvaW5Db25maWdDc3MgPSBcIi5mbG93e2hlaWdodDoxMDAlfS5wYW5lbHtoZWlnaHQ6MTAwJX0uZm9vdGVye3dpZHRoOjEwMCV9LmxheWVyLXNlY3Rpb257Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1jYWxjaXRlLWNvbG9yLWJvcmRlci0zKTtiYWNrZ3JvdW5kLWNvbG9yOndoaXRlO21hcmdpbjoxMHB4fS50YXJnZXQtbGF5ZXJ7cGFkZGluZzoxMHB4O2JvcmRlci1ib3R0b206MXB4IHNvbGlkIHZhcigtLWNhbGNpdGUtY29sb3ItYm9yZGVyLTMpO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn0uYWRkLWxheWVye3BhZGRpbmc6MTBweDtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59LmxheWVyLWhlYWRlcntwYWRkaW5nLWJvdHRvbTozcHg7b3ZlcmZsb3ctd3JhcDphbnl3aGVyZX0ubGF5ZXItdGl0bGV7Zm9udC13ZWlnaHQ6Ym9sZDtvdmVyZmxvdy13cmFwOmFueXdoZXJlfS5sYXllci1pY29ue2FsaWduLXNlbGY6Y2VudGVyO2N1cnNvcjpwb2ludGVyfS5hdHRyaWJ1dGUtcmVsYXRpb25zaGlwe2JvcmRlcjoxcHggc29saWQgdmFyKC0tY2FsY2l0ZS1jb2xvci1ib3JkZXItMyk7cGFkZGluZzoxMHB4IDEwcHggMCAxMHB4O21hcmdpbi1ib3R0b206MTBweH0ucmVtb3ZlLWF0dHJpYnV0ZS1yZWxhdGlvbnNoaXB7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpmbGV4LWVuZH0uam9pbi1tYXRjaC10eXBlLXNlY3Rpb257cGFkZGluZzoxMHB4IDB9LmluZm97ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufS5pbmZvLWxhYmVse2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXJ9LmNoaXB7bWFyZ2luLWJvdHRvbTo1cHh9LnNvcnQtYnktc2VjdGlvbntib3JkZXI6MXB4IHNvbGlkIHZhcigtLWNhbGNpdGUtY29sb3ItYm9yZGVyLTMpO3BhZGRpbmc6MTBweCAxMHB4IDAgMTBweDttYXJnaW46MTBweCAwfS5zZXBhcmF0b3J7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgdmFyKC0tY2FsY2l0ZS1jb2xvci1ib3JkZXItMyk7bWFyZ2luOjEwcHggMCAxNXB4IDB9LnN0YXRzLXNlY3Rpb257Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1jYWxjaXRlLWNvbG9yLWJvcmRlci0zKTtwYWRkaW5nOjEwcHggMTBweCAwIDEwcHg7bWFyZ2luLWJvdHRvbToxMHB4fS5zdGF0cy1maWVsZC1oZWFkZXJ7b3ZlcmZsb3ctd3JhcDphbnl3aGVyZTt3aWR0aDoxMDAlfS5zdGF0cy1idXR0b257bWFyZ2luLWJvdHRvbToxMHB4fS5zZWxlY3R7Y3Vyc29yOnBvaW50ZXJ9XCI7XG5cbmNvbnN0IEFyY2dpc0xheWVyVmlld0pvaW5Db25maWcgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld0pvaW5TdGF0dXNDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0xheWVyVmlld0pvaW5TdGF0dXNDaGFuZ2VcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Sm9pbkNvbmZpZ1RhYmxlQ2xpY2sgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0xheWVyVmlld0pvaW5Db25maWdUYWJsZUNsaWNrXCIsIDcpO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvL1xuICAgICAgICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMuZ29CYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdKb2luU3RhdHVzQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgICAgICAgIHN0YXR1czogam9pbkZsb3dTdGF0dXMuQUREX1NFTEVDVElPTlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ29OZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgYXR0cmlidXRlUmVsYXRpb25zaGlwcyB9ID0gcHJvcHM7XG4gICAgICAgICAgICAvLyBjbGVhbiB1cFxuICAgICAgICAgICAgcHJvcHMuYXR0cmlidXRlUmVsYXRpb25zaGlwcyA9IGF0dHJpYnV0ZVJlbGF0aW9uc2hpcHMuZmlsdGVyKChyZWwpID0+IHJlbC50YXJnZXRGaWVsZE5hbWUgJiYgcmVsLmFkZEZpZWxkTmFtZSk7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld0pvaW5TdGF0dXNDaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBqb2luRmxvd1N0YXR1cy5DUkVBVEVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uVGFyZ2V0RmllbGRTZWxlY3QgPSAocmVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCB0YXJnZXRGTCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgICAgICBjb25zdCB7IHRhcmdldEZpZWxkTmFtZSB9ID0gcmVsO1xuICAgICAgICAgICAgY29uc3Qgc2hhcGVGaWVsZHMgPSB0YXJnZXRGTC5maWVsZHMuZmlsdGVyKChmaWVsZCkgPT4gZmllbGQubmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJzaGFwZV9fXCIpKTtcbiAgICAgICAgICAgIHRoaXMub3BlbkZpZWxkUGlja0xpc3Qoe1xuICAgICAgICAgICAgICAgIGxheWVyOiB0YXJnZXRGTCxcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWU6IHRhcmdldEZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICBtdWx0aXBsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaGVhZGluZzogc3RyaW5ncy5qb2luLnRhcmdldEZpZWxkcyxcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIFwic21hbGwtaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICBcImJpZy1pbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNpbmdsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImRvdWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImxvbmdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGF0ZS1vbmx5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidGltZS1vbmx5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidGltZXN0YW1wLW9mZnNldFwiLFxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcImd1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJnbG9iYWwtaWRcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhjbHVkZWRGaWVsZHM6IHNoYXBlRmllbGRzLm1hcCgoZmllbGQpID0+IGZpZWxkLm5hbWUpLFxuICAgICAgICAgICAgICAgIGJ1dHRvbk5vZGU6IHRoaXMudGFyZ2V0RmllbGROb2RlLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAoc2VsZWN0ZWRGaWVsZHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVsLnRhcmdldEZpZWxkTmFtZSA9IHNlbGVjdGVkRmllbGRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkpvaW5GaWVsZFNlbGVjdCA9IChyZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIGFkZEZMIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgICAgIGNvbnN0IHsgYWRkRmllbGROYW1lIH0gPSByZWw7XG4gICAgICAgICAgICBjb25zdCBzaGFwZUZpZWxkcyA9IGFkZEZMLmZpZWxkcy5maWx0ZXIoKGZpZWxkKSA9PiBmaWVsZC5uYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcInNoYXBlX19cIikpO1xuICAgICAgICAgICAgdGhpcy5vcGVuRmllbGRQaWNrTGlzdCh7XG4gICAgICAgICAgICAgICAgbGF5ZXI6IGFkZEZMLFxuICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogYWRkRmllbGROYW1lLFxuICAgICAgICAgICAgICAgIG11bHRpcGxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBoZWFkaW5nOiBzdHJpbmdzLmpvaW4uam9pbkZpZWxkcyxcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIFwic21hbGwtaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICBcImJpZy1pbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNpbmdsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImRvdWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImxvbmdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGF0ZS1vbmx5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidGltZS1vbmx5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidGltZXN0YW1wLW9mZnNldFwiLFxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcImd1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJnbG9iYWwtaWRcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhjbHVkZWRGaWVsZHM6IHNoYXBlRmllbGRzLm1hcCgoZmllbGQpID0+IGZpZWxkLm5hbWUpLFxuICAgICAgICAgICAgICAgIGJ1dHRvbk5vZGU6IHRoaXMuYWRkRmllbGROb2RlLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAoc2VsZWN0ZWRGaWVsZHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVsLmFkZEZpZWxkTmFtZSA9IHNlbGVjdGVkRmllbGRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblNvcnRCeUZpZWxkU2VsZWN0ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgYWRkRkwgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGpvaW5PcGVyYXRpb24sIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICAgICAgY29uc3QgeyBzb3J0QnlGaWVsZE5hbWUgfSA9IGpvaW5PcGVyYXRpb247XG4gICAgICAgICAgICBjb25zdCBzaGFwZUZpZWxkcyA9IGFkZEZMLmZpZWxkcy5maWx0ZXIoKGZpZWxkKSA9PiBmaWVsZC5uYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcInNoYXBlX19cIikpO1xuICAgICAgICAgICAgdGhpcy5vcGVuRmllbGRQaWNrTGlzdCh7XG4gICAgICAgICAgICAgICAgbGF5ZXI6IGFkZEZMLFxuICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogc29ydEJ5RmllbGROYW1lLFxuICAgICAgICAgICAgICAgIG11bHRpcGxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBoZWFkaW5nOiBzdHJpbmdzLmpvaW4uam9pbkZpZWxkcyxcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIFwic21hbGwtaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICBcImJpZy1pbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNpbmdsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImRvdWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImxvbmdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGF0ZS1vbmx5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidGltZS1vbmx5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidGltZXN0YW1wLW9mZnNldFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9pZFwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleGNsdWRlZEZpZWxkczogc2hhcGVGaWVsZHMubWFwKChmaWVsZCkgPT4gZmllbGQubmFtZSksXG4gICAgICAgICAgICAgICAgYnV0dG9uTm9kZTogdGhpcy5zb3J0QnlGaWVsZE5vZGUsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IChzZWxlY3RlZEZpZWxkcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBqb2luT3BlcmF0aW9uLnNvcnRCeUZpZWxkTmFtZSA9IHNlbGVjdGVkRmllbGRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblN0YXRzRmllbGRTZWxlY3QgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBhZGRGTCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgam9pbk9wZXJhdGlvbiwgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXRpc3RpY3NGaWVsZHMgfSA9IGpvaW5PcGVyYXRpb247XG4gICAgICAgICAgICBjb25zdCBzaGFwZUZpZWxkcyA9IGFkZEZMLmZpZWxkcy5maWx0ZXIoKGZpZWxkKSA9PiBmaWVsZC5uYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcInNoYXBlX19cIikpO1xuICAgICAgICAgICAgdGhpcy5vcGVuRmllbGRQaWNrTGlzdCh7XG4gICAgICAgICAgICAgICAgbGF5ZXI6IGFkZEZMLFxuICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogXCJcIixcbiAgICAgICAgICAgICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBoZWFkaW5nOiBzdHJpbmdzLmpvaW4uc2VsZWN0RmllbGRzLFxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJzbWFsbC1pbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYmlnLWludGVnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2luZ2xlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZG91YmxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibG9uZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRlLW9ubHlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0aW1lLW9ubHlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0aW1lc3RhbXAtb2Zmc2V0XCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVkRmllbGRzOiBzdGF0aXN0aWNzRmllbGRzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGZpZWxkKSA9PiBmaWVsZC5maWVsZE5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoc2hhcGVGaWVsZHMubWFwKChmaWVsZCkgPT4gZmllbGQubmFtZSkpLFxuICAgICAgICAgICAgICAgIGJ1dHRvbk5vZGU6IHRoaXMuc3RhdHNCdXR0b25Ob2RlLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAoc2VsZWN0ZWRGaWVsZHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRGaWVsZHMuZm9yRWFjaCgoZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0RhdGUgPSBbXCJkYXRlXCIsIFwiZGF0ZS1vbmx5XCIsIFwidGltZS1vbmx5XCIsIFwidGltZXN0YW1wLW9mZnNldFwiXS5pbmRleE9mKGdldEZpZWxkVHlwZShhZGRGTCwgZmllbGROYW1lKSkgPiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpc3RpY3NGaWVsZHMucHVzaCh7IGZpZWxkTmFtZSwgdHlwZXM6IFtpc0RhdGUgPyBcIk1JTlwiIDogXCJTVU1cIl0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2hvd1RhYmxlT3B0aW9uID0gZmFsc2U7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBMaWZlY3ljbGVcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHRhcmdldExheWVyLCB0YXJnZXRMYXllcklkLCBhZGRMYXllciwgYWRkTGF5ZXJJZCwgYXR0cmlidXRlUmVsYXRpb25zaGlwcywgam9pbk9wZXJhdGlvbiB9ID0gcHJvcHM7XG4gICAgICAgIHRoaXMudGFyZ2V0RkwgPSAodGFyZ2V0TGF5ZXIudHlwZSA9PT0gXCJncm91cFwiXG4gICAgICAgICAgICA/IGdldExheWVyc0FuZFRhYmxlcyh0YXJnZXRMYXllcikuZmluZCgobHlyKSA9PiBseXIubGF5ZXJJZCA9PT0gdGFyZ2V0TGF5ZXJJZClcbiAgICAgICAgICAgIDogdGFyZ2V0TGF5ZXIpO1xuICAgICAgICB0aGlzLmFkZEZMID0gKGFkZExheWVyLnR5cGUgPT09IFwiZ3JvdXBcIlxuICAgICAgICAgICAgPyBnZXRMYXllcnNBbmRUYWJsZXMoYWRkTGF5ZXIpLmZpbmQoKGx5cikgPT4gbHlyLmxheWVySWQgPT09IGFkZExheWVySWQpXG4gICAgICAgICAgICA6IGFkZExheWVyKTtcbiAgICAgICAgaWYgKCEoYXR0cmlidXRlUmVsYXRpb25zaGlwcyA9PT0gbnVsbCB8fCBhdHRyaWJ1dGVSZWxhdGlvbnNoaXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdHRyaWJ1dGVSZWxhdGlvbnNoaXBzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHByb3BzLmF0dHJpYnV0ZVJlbGF0aW9uc2hpcHMgPSBbXTtcbiAgICAgICAgICAgIC8vIGxvb2sgZm9yIHJlbGF0aW9uc2hpcCBmaWVsZHNcbiAgICAgICAgICAgIGNvbnN0IHsgdGFyZ2V0RkwsIGFkZEZMIH0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRhcmdldEZMLnJlbGF0aW9uc2hpcHMgJiYgYWRkRkwucmVsYXRpb25zaGlwcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFJlbHMgPSB0YXJnZXRGTC5yZWxhdGlvbnNoaXBzLmZpbHRlcigocmVsKSA9PiByZWwucmVsYXRlZFRhYmxlSWQgPT09IGFkZExheWVySWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZFJlbHMgPSBhZGRGTC5yZWxhdGlvbnNoaXBzLmZpbHRlcigocmVsKSA9PiByZWwucmVsYXRlZFRhYmxlSWQgPT09IHRhcmdldExheWVySWQpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRSZWxzLmxlbmd0aCAmJiBhZGRSZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRSZWxzLmZvckVhY2goKHRhcmdldFJlbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkUmVsID0gYWRkUmVscy5maW5kKChhZGRSZWwpID0+IHRhcmdldFJlbC5pZCA9PT0gYWRkUmVsLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRSZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5hdHRyaWJ1dGVSZWxhdGlvbnNoaXBzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRGaWVsZE5hbWU6IHRhcmdldFJlbC5rZXlGaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRmllbGROYW1lOiBhZGRSZWwua2V5RmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoKF9hID0gcHJvcHMuYXR0cmlidXRlUmVsYXRpb25zaGlwcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5hdHRyaWJ1dGVSZWxhdGlvbnNoaXBzLnB1c2goe30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgham9pbk9wZXJhdGlvbikge1xuICAgICAgICAgICAgcHJvcHMuam9pbk9wZXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9uZS10by1vbmVcIixcbiAgICAgICAgICAgICAgICBtYXRjaFR5cGU6IFwiZmlyc3RcIixcbiAgICAgICAgICAgICAgICBzb3J0QnlGaWVsZE5hbWU6IHRoaXMuYWRkRkwub2JqZWN0SWRGaWVsZCxcbiAgICAgICAgICAgICAgICBzb3J0T3JkZXI6IFwiQVNDXCIsXG4gICAgICAgICAgICAgICAgam9pblR5cGU6IFwiSU5ORVJcIixcbiAgICAgICAgICAgICAgICBzdGF0aXN0aWNzRmllbGRzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjb21wb25lbnREaWRMb2FkKCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aGlzLmJhY2tCdXR0b25Ob2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Rm9jdXMoKTsgfSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLnJlbW92ZUluZm9Qb3BvdmVyKCk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUmVuZGVyIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHJ0bCA9IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCkgPT09IFwicnRsXCI7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCB7IGNsYXNzOiBcImNhbGNpdGUtbWF0Y2gtaGVpZ2h0XCIgfSwgaChcImNhbGNpdGUtZmxvd1wiLCB7IGNsYXNzOiBDU1MkNS5mbG93LCBkaXI6IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCkgfSwgaChcImNhbGNpdGUtZmxvdy1pdGVtXCIsIHsgaGVhZGluZzogc3RyaW5ncy5qb2luLmNvbmZpZ3VyZUpvaW4sIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcGFuZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgW0NTU19VVElMSVRZLnJ0bF06IHJ0bFxuICAgICAgICAgICAgfSwgcmVmOiAobm9kZSkgPT4gKHRoaXMuZmxvd0l0ZW1Ob2RlID0gbm9kZSkgfSwgdGhpcy5yZW5kZXJGb290ZXJCdXR0b25zKCksIHRoaXMucmVuZGVyQ29udGVudCgpKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyRm9vdGVyQnV0dG9ucygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBhdHRyaWJ1dGVSZWxhdGlvbnNoaXBzLCBqb2luT3BlcmF0aW9uLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgaXNSdGwgPSBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpID09PSBcInJ0bFwiO1xuICAgICAgICBjb25zdCBuZXh0RW5hYmxlZCA9ICEhYXR0cmlidXRlUmVsYXRpb25zaGlwcy5maW5kKChyZWwpID0+IHJlbC50YXJnZXRGaWVsZE5hbWUgJiYgcmVsLmFkZEZpZWxkTmFtZSkgJiZcbiAgICAgICAgICAgIChqb2luT3BlcmF0aW9uLnR5cGUgPT09IFwib25lLXRvLW1hbnlcIiB8fFxuICAgICAgICAgICAgICAgIChqb2luT3BlcmF0aW9uLm1hdGNoVHlwZSA9PT0gXCJmaXJzdFwiICYmXG4gICAgICAgICAgICAgICAgICAgIGpvaW5PcGVyYXRpb24uc29ydEJ5RmllbGROYW1lICYmXG4gICAgICAgICAgICAgICAgICAgIGpvaW5PcGVyYXRpb24uc29ydE9yZGVyKSB8fFxuICAgICAgICAgICAgICAgIChqb2luT3BlcmF0aW9uLm1hdGNoVHlwZSA9PT0gXCJzdW1tYXJpemVcIiAmJlxuICAgICAgICAgICAgICAgICAgICAoKF9hID0gam9pbk9wZXJhdGlvbi5zdGF0aXN0aWNzRmllbGRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAmJlxuICAgICAgICAgICAgICAgICAgICAoKF9iID0gam9pbk9wZXJhdGlvbi5zdGF0aXN0aWNzRmllbGRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF0uZmllbGROYW1lKSkpO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBzbG90OiBcImZvb3RlclwiLCBjbGFzczogQ1NTJDUuZm9vdGVyIH0sIGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IG9uQ2xpY2s6IHRoaXMuZ29CYWNrLCBhcHBlYXJhbmNlOiBcIm91dGxpbmUtZmlsbFwiLCB3aWR0aDogXCJoYWxmXCIsIFwiaWNvbi1zdGFydFwiOiBpc1J0bCA/IFwiYXJyb3ctcmlnaHRcIiA6IFwiYXJyb3ctbGVmdFwiLCByZWY6IChub2RlKSA9PiAodGhpcy5iYWNrQnV0dG9uTm9kZSA9IG5vZGUpIH0sIHN0cmluZ3MuZ2VuZXJhbC5iYWNrKSwgaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgZGlzYWJsZWQ6ICFuZXh0RW5hYmxlZCwgb25DbGljazogbmV4dEVuYWJsZWQgJiYgdGhpcy5nb05leHQsIGFwcGVhcmFuY2U6IFwic29saWRcIiwgd2lkdGg6IFwiaGFsZlwiLCBpY29uRW5kOiBpc1J0bCA/IFwiYXJyb3ctbGVmdFwiIDogXCJhcnJvdy1yaWdodFwiLCByZWY6IChub2RlKSA9PiAodGhpcy5uZXh0QnV0dG9uTm9kZSA9IG5vZGUpIH0sIHN0cmluZ3MuZ2VuZXJhbC5uZXh0KSkpO1xuICAgIH1cbiAgICByZW5kZXJDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gKGgoRnJhZ21lbnQsIG51bGwsIHRoaXMucmVuZGVyTGF5ZXJzKCksIHRoaXMucmVuZGVyQXR0cmlidXRlUmVsYXRpb25zaGlwcygpLCB0aGlzLnJlbmRlckpvaW5PcGVyYXRpb24oKSkpO1xuICAgIH1cbiAgICByZW5kZXJMYXllcnMoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHRhcmdldEZMLCBhZGRGTCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB0YXJnZXRJdGVtLCB0YXJnZXRMYXllciwgdGFyZ2V0TGF5ZXJJZCwgYWRkSXRlbSwgYWRkTGF5ZXIsIGFkZExheWVySWQsIHNob3dUYWJsZU9wdGlvbiwgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHJ0bCA9IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCkgPT09IFwicnRsXCI7XG4gICAgICAgIGNvbnN0IHRhcmdldFRpdGxlID0gdGFyZ2V0TGF5ZXIudHlwZSA9PT0gXCJncm91cFwiXG4gICAgICAgICAgICA/IHJ0bFxuICAgICAgICAgICAgICAgID8gYCR7dGFyZ2V0RkwudGl0bGV9IC8gJHt0YXJnZXRJdGVtLnRpdGxlfWBcbiAgICAgICAgICAgICAgICA6IGAke3RhcmdldEl0ZW0udGl0bGV9IC8gJHt0YXJnZXRGTC50aXRsZX1gXG4gICAgICAgICAgICA6IHRhcmdldExheWVyLnRpdGxlO1xuICAgICAgICBjb25zdCBhZGRUaXRsZSA9IGFkZExheWVyLnR5cGUgPT09IFwiZ3JvdXBcIlxuICAgICAgICAgICAgPyBydGxcbiAgICAgICAgICAgICAgICA/IGAke2FkZEZMLnRpdGxlfSAvICR7YWRkSXRlbS50aXRsZX1gXG4gICAgICAgICAgICAgICAgOiBgJHthZGRJdGVtLnRpdGxlfSAvICR7YWRkRkwudGl0bGV9YFxuICAgICAgICAgICAgOiBhZGRMYXllci50aXRsZTtcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQ1LmxheWVyU2VjdGlvbiB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQ1LnRhcmdldExheWVyIH0sIGgoXCJkaXZcIiwgbnVsbCwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkNS5sYXllckhlYWRlciB9LCBzdHJpbmdzLmpvaW4udGFyZ2V0TGF5ZXIpLCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQ1LmxheWVyVGl0bGUgfSwgdGFyZ2V0VGl0bGUpKSwgc2hvd1RhYmxlT3B0aW9uICYmIChoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyBzY2FsZTogXCJzXCIsIGljb246IFwidGFibGVcIiwgY2xhc3M6IENTUyQ1LmxheWVySWNvbiwgdGV4dDogc3RyaW5ncy5qb2luLnNob3dUYWJsZSwgdGV4dEVuYWJsZWQ6IGZhbHNlLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0TGF5ZXIudHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHRhcmdldExheWVyLnRhYmxlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGx5cikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGx5ci5sYXllcklkID09PSB0YXJnZXRMYXllcklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdKb2luQ29uZmlnVGFibGVDbGljay5lbWl0KGx5cik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAoX2IgPSB0YXJnZXRMYXllci5sYXllcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mb3JFYWNoKChseXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChseXIubGF5ZXJJZCA9PT0gdGFyZ2V0TGF5ZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Sm9pbkNvbmZpZ1RhYmxlQ2xpY2suZW1pdChseXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Sm9pbkNvbmZpZ1RhYmxlQ2xpY2suZW1pdCh0YXJnZXRMYXllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB9KSkpLCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQ1LmFkZExheWVyIH0sIGgoXCJkaXZcIiwgbnVsbCwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkNS5sYXllckhlYWRlciB9LCBzdHJpbmdzLmpvaW4uam9pbkxheWVyKSwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkNS5sYXllclRpdGxlIH0sIGFkZFRpdGxlKSksIHNob3dUYWJsZU9wdGlvbiAmJiAoaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgc2NhbGU6IFwic1wiLCBpY29uOiBcInRhYmxlXCIsIGNsYXNzOiBDU1MkNS5sYXllckljb24sIHRleHQ6IHN0cmluZ3Muam9pbi5zaG93VGFibGUsIHRleHRFbmFibGVkOiBmYWxzZSwgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKGFkZExheWVyLnR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBhZGRMYXllci50YWJsZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChseXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChseXIubGF5ZXJJZCA9PT0gYWRkTGF5ZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Sm9pbkNvbmZpZ1RhYmxlQ2xpY2suZW1pdChseXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gYWRkTGF5ZXIubGF5ZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZm9yRWFjaCgobHlyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobHlyLmxheWVySWQgPT09IGFkZExheWVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld0pvaW5Db25maWdUYWJsZUNsaWNrLmVtaXQobHlyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld0pvaW5Db25maWdUYWJsZUNsaWNrLmVtaXQoYWRkTGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gfSkpKSkpO1xuICAgIH1cbiAgICByZW5kZXJBdHRyaWJ1dGVSZWxhdGlvbnNoaXBzKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGF0dHJpYnV0ZVJlbGF0aW9uc2hpcHMsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWJsb2NrXCIsIHsgaGVhZGluZzogc3RyaW5ncy5qb2luLmF0dHJpYnV0ZUpvaW4sIGRlc2NyaXB0aW9uOiBzdHJpbmdzLmpvaW4uYXR0cmlidXRlSm9pbk1zZywgb3BlbjogdHJ1ZSwgY29sbGFwc2libGU6IHRydWUsIHJlZjogKG5vZGUpID0+ICh0aGlzLmF0dHJCbG9ja05vZGUgPSBub2RlKSB9LCBhdHRyaWJ1dGVSZWxhdGlvbnNoaXBzLm1hcCgocmVsLCBpZHgpID0+IHRoaXMucmVuZGVyQXR0cmlidXRlUmVsYXRpb25zaGlwKHJlbCwgaWR4KSksIGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVSZWxhdGlvbnNoaXBzLnB1c2goe30pO1xuICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICAgICAgfSwgYXBwZWFyYW5jZTogXCJvdXRsaW5lLWZpbGxcIiwgd2lkdGg6IFwiZnVsbFwiLCByZWY6IChub2RlKSA9PiAodGhpcy5maWVsZEJ1dHRvbk5vZGUgPSBub2RlKSB9LCBzdHJpbmdzLmpvaW4uZmllbGRzKSkpO1xuICAgIH1cbiAgICByZW5kZXJBdHRyaWJ1dGVSZWxhdGlvbnNoaXAocmVsLCBpZHgpIHtcbiAgICAgICAgY29uc3QgeyB0YXJnZXRGTCwgYWRkRkwsIHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGF0dHJpYnV0ZVJlbGF0aW9uc2hpcHMsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDUuYXR0cmlidXRlUmVsYXRpb25zaGlwIH0sIGF0dHJpYnV0ZVJlbGF0aW9uc2hpcHMubGVuZ3RoID4gMSAmJiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkNS5yZW1vdmVBdHRyaWJ1dGVSZWxhdGlvbnNoaXAgfSwgaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgc2NhbGU6IFwic1wiLCBpY29uOiBcInRyYXNoXCIsIHRleHQ6IHN0cmluZ3MuZ2VuZXJhbC5yZW1vdmUsIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVSZWxhdGlvbnNoaXBzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICAgICAgfSB9KSkpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBzdHJpbmdzLmpvaW4udGFyZ2V0RmllbGQsIGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IGFwcGVhcmFuY2U6IFwib3V0bGluZS1maWxsXCIsIGtpbmQ6IFwibmV1dHJhbFwiLCB3aWR0aDogXCJmdWxsXCIsIGFsaWdubWVudDogXCJpY29uLWVuZC1zcGFjZS1iZXR3ZWVuXCIsIGljb25FbmQ6IFwiY2hldnJvbi1kb3duXCIsIG9uQ2xpY2s6ICgpID0+IHRoaXMub25UYXJnZXRGaWVsZFNlbGVjdChyZWwpLCByZWY6IChub2RlKSA9PiAodGhpcy50YXJnZXRGaWVsZE5vZGUgPSBub2RlKSB9LCByZWwudGFyZ2V0RmllbGROYW1lXG4gICAgICAgICAgICA/IGdldEZpZWxkQWxpYXModGFyZ2V0RkwsIHJlbC50YXJnZXRGaWVsZE5hbWUpXG4gICAgICAgICAgICA6IHN0cmluZ3Muam9pbi5zZWxlY3RGaWVsZCkpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBzdHJpbmdzLmpvaW4uam9pbkZpZWxkLCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBhcHBlYXJhbmNlOiBcIm91dGxpbmUtZmlsbFwiLCBraW5kOiBcIm5ldXRyYWxcIiwgd2lkdGg6IFwiZnVsbFwiLCBhbGlnbm1lbnQ6IFwiaWNvbi1lbmQtc3BhY2UtYmV0d2VlblwiLCBpY29uRW5kOiBcImNoZXZyb24tZG93blwiLCBvbkNsaWNrOiAoKSA9PiB0aGlzLm9uSm9pbkZpZWxkU2VsZWN0KHJlbCksIHJlZjogKG5vZGUpID0+ICh0aGlzLmFkZEZpZWxkTm9kZSA9IG5vZGUpIH0sIHJlbC5hZGRGaWVsZE5hbWUgPyBnZXRGaWVsZEFsaWFzKGFkZEZMLCByZWwuYWRkRmllbGROYW1lKSA6IHN0cmluZ3Muam9pbi5zZWxlY3RGaWVsZCkpKSk7XG4gICAgfVxuICAgIHJlbmRlckpvaW5PcGVyYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgam9pbk9wZXJhdGlvbiwgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtYmxvY2tcIiwgeyBoZWFkaW5nOiBzdHJpbmdzLmpvaW4uam9pblNldHRpbmdzLCBkZXNjcmlwdGlvbjogc3RyaW5ncy5qb2luLmpvaW5TZXR0aW5nc01zZywgb3BlbjogdHJ1ZSwgY29sbGFwc2libGU6IHRydWUsIHJlZjogKG5vZGUpID0+ICh0aGlzLm9wZXJhdGlvbkJsb2NrTm9kZSA9IG5vZGUpIH0sIHRoaXMucmVuZGVySm9pbk9wZXJhdGlvblR5cGUoKSwgam9pbk9wZXJhdGlvbi50eXBlID09PSBcIm9uZS10by1vbmVcIiAmJiB0aGlzLnJlbmRlck1hdGNoVHlwZSgpLCBqb2luT3BlcmF0aW9uLnR5cGUgPT09IFwib25lLXRvLW9uZVwiICYmXG4gICAgICAgICAgICBqb2luT3BlcmF0aW9uLm1hdGNoVHlwZSA9PT0gXCJmaXJzdFwiICYmXG4gICAgICAgICAgICB0aGlzLnJlbmRlckpvaW5PcGVyYXRpb25Tb3J0QnkoKSwgam9pbk9wZXJhdGlvbi50eXBlID09PSBcIm9uZS10by1vbmVcIiAmJlxuICAgICAgICAgICAgam9pbk9wZXJhdGlvbi5tYXRjaFR5cGUgPT09IFwic3VtbWFyaXplXCIgJiZcbiAgICAgICAgICAgIHRoaXMucmVuZGVySm9pbk9wZXJhdGlvblN0YXRpc3RpY3MoKSwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkNS5zZXBhcmF0b3IgfSksIHRoaXMucmVuZGVySm9pblR5cGUoKSkpO1xuICAgIH1cbiAgICByZW5kZXJKb2luT3BlcmF0aW9uVHlwZSgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBqb2luT3BlcmF0aW9uLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiaW5mb1wiIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogXCJpbmZvLWxhYmVsXCIgfSwgc3RyaW5ncy5qb2luLmpvaW5PcGVyYXRpb24pLCBoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyBjbGFzczogXCJsaW5rLWluZm9cIiwgdGFiaW5kZXg6IFwiMFwiLCBzY2FsZTogXCJzXCIsIGljb246IFwiaW5mb3JtYXRpb25cIiwgb25DbGljazogKGV2ZW50KSA9PiB0aGlzLmhhbmRsZUluZm9DbGljayhldmVudCwgXCJqb2luLW9wZXJhdGlvblwiKSwgdGV4dDogc3RyaW5ncy5qb2luLm1vcmVJbmZvLCByZWY6IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5qb2luT3BlcmF0aW9uSW5mb0ljb25Ob2RlID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiIFwiIHx8ICghdGhpcy5pbmZvUG9wb3Zlck5vZGUgJiYgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUluZm9DbGljayhldmVudCwgXCJqb2luLW9wZXJhdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiIFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IHBhbmVsIGZyb20gc2Nyb2xsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gfSkpLCBoKFwiZGl2XCIsIG51bGwsIGgoXCJjYWxjaXRlLWNoaXBcIiwgeyB2YWx1ZTogXCJvbmUtdG8tb25lXCIsIGFwcGVhcmFuY2U6IGpvaW5PcGVyYXRpb24udHlwZSA9PT0gXCJvbmUtdG8tb25lXCIgPyBcInNvbGlkXCIgOiBcIm91dGxpbmUtZmlsbFwiLCBraW5kOiBcImJyYW5kXCIsIGNsYXNzOiBgJHtDU1MkNS5jaGlwfSAke2pvaW5PcGVyYXRpb24udHlwZSA9PT0gXCJvbmUtdG8tbWFueVwiID8gQ1NTJDUuc2VsZWN0IDogXCJcIn1gLCBvbkNsaWNrOiBqb2luT3BlcmF0aW9uLnR5cGUgPT09IFwib25lLXRvLW1hbnlcIlxuICAgICAgICAgICAgICAgID8gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBqb2luT3BlcmF0aW9uLnR5cGUgPSBcIm9uZS10by1vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkIH0sIHN0cmluZ3Muam9pbi5vbmVUb09uZSksIFwiXFx1MDBBMFwiLCBoKFwiY2FsY2l0ZS1jaGlwXCIsIHsgdmFsdWU6IFwib25lLXRvLW1hbnlcIiwgYXBwZWFyYW5jZTogam9pbk9wZXJhdGlvbi50eXBlID09PSBcIm9uZS10by1tYW55XCIgPyBcInNvbGlkXCIgOiBcIm91dGxpbmUtZmlsbFwiLCBraW5kOiBcImJyYW5kXCIsIGNsYXNzOiBgJHtDU1MkNS5jaGlwfSAke2pvaW5PcGVyYXRpb24udHlwZSA9PT0gXCJvbmUtdG8tb25lXCIgPyBDU1MkNS5zZWxlY3QgOiBcIlwifWAsIG9uQ2xpY2s6IGpvaW5PcGVyYXRpb24udHlwZSA9PT0gXCJvbmUtdG8tb25lXCJcbiAgICAgICAgICAgICAgICA/ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgam9pbk9wZXJhdGlvbi50eXBlID0gXCJvbmUtdG8tbWFueVwiO1xuICAgICAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQgfSwgc3RyaW5ncy5qb2luLm9uZVRvTWFueSkpKSk7XG4gICAgfVxuICAgIHJlbmRlck1hdGNoVHlwZSgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBqb2luT3BlcmF0aW9uLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1yYWRpby1idXR0b24tZ3JvdXBcIiwgeyBuYW1lOiBcIm1hdGNoVHlwZVwiLCBsYXlvdXQ6IFwidmVydGljYWxcIiwgY2xhc3M6IENTUyQ1LmpvaW5NYXRjaFR5cGVTZWN0aW9uIH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgbGF5b3V0OiBcImlubGluZVwiLCBjbGFzczogQ1NTJDUuc2VsZWN0LCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgam9pbk9wZXJhdGlvbi5tYXRjaFR5cGUgPSBcImZpcnN0XCI7XG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgICAgICB9IH0sIGgoXCJjYWxjaXRlLXJhZGlvLWJ1dHRvblwiLCB7IGNoZWNrZWQ6IGpvaW5PcGVyYXRpb24ubWF0Y2hUeXBlID09PSBcImZpcnN0XCIsIHZhbHVlOiBcImZpcnN0XCIsIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBqb2luT3BlcmF0aW9uLm1hdGNoVHlwZSA9IFwiZmlyc3RcIjtcbiAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgIH0gfSksIHN0cmluZ3Muam9pbi5vbmx5Rmlyc3QpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGxheW91dDogXCJpbmxpbmVcIiwgY2xhc3M6IENTUyQ1LnNlbGVjdCwgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGpvaW5PcGVyYXRpb24ubWF0Y2hUeXBlID0gXCJzdW1tYXJpemVcIjtcbiAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgIH0gfSwgaChcImNhbGNpdGUtcmFkaW8tYnV0dG9uXCIsIHsgY2hlY2tlZDogam9pbk9wZXJhdGlvbi5tYXRjaFR5cGUgPT09IFwic3VtbWFyaXplXCIsIHZhbHVlOiBcInN1bW1hcml6ZVwiLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgam9pbk9wZXJhdGlvbi5tYXRjaFR5cGUgPSBcInN1bW1hcml6ZVwiO1xuICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICAgICAgfSB9KSwgc3RyaW5ncy5qb2luLnN1bW1hcml6ZU1hdGNoaW5nKSkpO1xuICAgIH1cbiAgICByZW5kZXJKb2luT3BlcmF0aW9uU29ydEJ5KCkge1xuICAgICAgICBjb25zdCB7IGFkZEZMLCBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBqb2luT3BlcmF0aW9uLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQ1LnNvcnRCeVNlY3Rpb24gfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgc3RyaW5ncy5qb2luLnNvcnRCeSwgaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgYXBwZWFyYW5jZTogXCJvdXRsaW5lLWZpbGxcIiwga2luZDogXCJuZXV0cmFsXCIsIHdpZHRoOiBcImZ1bGxcIiwgYWxpZ25tZW50OiBcImljb24tZW5kLXNwYWNlLWJldHdlZW5cIiwgaWNvbkVuZDogXCJjaGV2cm9uLWRvd25cIiwgb25DbGljazogKCkgPT4gdGhpcy5vblNvcnRCeUZpZWxkU2VsZWN0KCksIHJlZjogKG5vZGUpID0+ICh0aGlzLnNvcnRCeUZpZWxkTm9kZSA9IG5vZGUpIH0sIGdldEZpZWxkQWxpYXMoYWRkRkwsIGpvaW5PcGVyYXRpb24uc29ydEJ5RmllbGROYW1lKSkpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBzdHJpbmdzLmpvaW4uc29ydE9yZGVyLCBoKFwiY2FsY2l0ZS1zZWxlY3RcIiwgeyB3aWR0aDogXCJmdWxsXCIsIG9uQ2FsY2l0ZVNlbGVjdENoYW5nZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0Tm9kZSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICBqb2luT3BlcmF0aW9uLnNvcnRPcmRlciA9IHNlbGVjdE5vZGUudmFsdWU7XG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgICAgICB9LCBsYWJlbDogc3RyaW5ncy5qb2luLnNvcnRPcmRlciB9LCBoKFwiY2FsY2l0ZS1vcHRpb25cIiwgeyBsYWJlbDogc3RyaW5ncy5qb2luLmFzYywgc2VsZWN0ZWQ6IGpvaW5PcGVyYXRpb24uc29ydE9yZGVyID09PSBcIkFTQ1wiLCB2YWx1ZTogXCJBU0NcIiB9LCBzdHJpbmdzLmpvaW4uYXNjKSwgaChcImNhbGNpdGUtb3B0aW9uXCIsIHsgbGFiZWw6IHN0cmluZ3Muam9pbi5kZXNjLCBzZWxlY3RlZDogam9pbk9wZXJhdGlvbi5zb3J0T3JkZXIgPT09IFwiREVTQ1wiLCB2YWx1ZTogXCJERVNDXCIgfSwgc3RyaW5ncy5qb2luLmRlc2MpKSkpKTtcbiAgICB9XG4gICAgcmVuZGVySm9pbk9wZXJhdGlvblN0YXRpc3RpY3MoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgYWRkRkwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgam9pbk9wZXJhdGlvbiwgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHsgc3RhdGlzdGljc0ZpZWxkcyB9ID0gam9pbk9wZXJhdGlvbjtcbiAgICAgICAgY29uc3QgZXhjbHVkZWRGaWVsZHMgPSBzdGF0aXN0aWNzRmllbGRzLm1hcCgoZmllbGQpID0+IGZpZWxkLmZpZWxkTmFtZSk7XG4gICAgICAgIGNvbnN0IGZpZWxkVHlwZXMgPSBbXG4gICAgICAgICAgICBcInNtYWxsLWludGVnZXJcIixcbiAgICAgICAgICAgIFwiYmlnLWludGVnZXJcIixcbiAgICAgICAgICAgIFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgXCJzaW5nbGVcIixcbiAgICAgICAgICAgIFwiZG91YmxlXCIsXG4gICAgICAgICAgICBcImxvbmdcIixcbiAgICAgICAgICAgIFwibnVtYmVyXCIsXG4gICAgICAgICAgICBcImRhdGVcIixcbiAgICAgICAgICAgIFwiZGF0ZS1vbmx5XCIsXG4gICAgICAgICAgICBcInRpbWUtb25seVwiLFxuICAgICAgICAgICAgXCJ0aW1lc3RhbXAtb2Zmc2V0XCJcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgbGF5ZXJGaWVsZHMgPSBhZGRGTC5maWVsZHNcbiAgICAgICAgICAgIC5maWx0ZXIoKGZpZWxkKSA9PiBleGNsdWRlZEZpZWxkcy5pbmRleE9mKGZpZWxkLm5hbWUpID09PSAtMSlcbiAgICAgICAgICAgIC5maWx0ZXIoKGZpZWxkKSA9PiBmaWVsZFR5cGVzLmluZGV4T2YoZmllbGQudHlwZSkgPiAtMSk7XG4gICAgICAgIGNvbnN0IG5vTW9yZUZpZWxkcyA9ICFsYXllckZpZWxkcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiAoaChGcmFnbWVudCwgbnVsbCwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJsXCIgfSwgc3RyaW5ncy5qb2luLmZpZWxkU3RhdHMpLCAoX2EgPSBqb2luT3BlcmF0aW9uLnN0YXRpc3RpY3NGaWVsZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOlxuICAgICAgICAgICAgX2EubWFwKChzdGF0c0ZpZWxkLCBpZHgpID0+IHRoaXMucmVuZGVySm9pbk9wZXJhdGlvblN0YXRpc3RpYyhzdGF0c0ZpZWxkLCBpZHgpKSwgaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgb25DbGljazogIW5vTW9yZUZpZWxkcyAmJiB0aGlzLm9uU3RhdHNGaWVsZFNlbGVjdCwgYXBwZWFyYW5jZTogXCJvdXRsaW5lLWZpbGxcIiwgXCJpY29uLXN0YXJ0XCI6IFwicGx1c1wiLCB3aWR0aDogXCJmdWxsXCIsIGRpc2FibGVkOiBub01vcmVGaWVsZHMsIGNsYXNzOiBDU1MkNS5zdGF0c0J1dHRvbiwgcmVmOiAobm9kZSkgPT4gKHRoaXMuc3RhdHNCdXR0b25Ob2RlID0gbm9kZSkgfSwgc3RyaW5ncy5qb2luLmFkZFN0YXRzKSkpO1xuICAgIH1cbiAgICByZW5kZXJKb2luT3BlcmF0aW9uU3RhdGlzdGljKHN0YXRzRmllbGQsIGlkeCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBhZGRGTCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBqb2luT3BlcmF0aW9uLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgaXNEYXRlID0gW1wiZGF0ZVwiLCBcImRhdGUtb25seVwiLCBcInRpbWUtb25seVwiLCBcInRpbWVzdGFtcC1vZmZzZXRcIl0uaW5kZXhPZihnZXRGaWVsZFR5cGUoYWRkRkwsIHN0YXRzRmllbGQuZmllbGROYW1lKSkgPiAtMTtcbiAgICAgICAgY29uc3QgaGFzQWxsVHlwZXMgPSBpc0RhdGVcbiAgICAgICAgICAgID8gc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiTUlOXCIpID4gLTEgJiYgc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiTUFYXCIpID4gLTFcbiAgICAgICAgICAgIDogc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiU1VNXCIpID4gLTEgJiZcbiAgICAgICAgICAgICAgICBzdGF0c0ZpZWxkLnR5cGVzLmluZGV4T2YoXCJNSU5cIikgPiAtMSAmJlxuICAgICAgICAgICAgICAgIHN0YXRzRmllbGQudHlwZXMuaW5kZXhPZihcIk1BWFwiKSA+IC0xICYmXG4gICAgICAgICAgICAgICAgc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiTUVBTlwiKSA+IC0xICYmXG4gICAgICAgICAgICAgICAgc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiU1REREVWXCIpID4gLTE7XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkNS5zdGF0c1NlY3Rpb24gfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBjbGFzczogQ1NTJDUuc3RhdHNGaWVsZEhlYWRlciwgbGF5b3V0OiBcImlubGluZS1zcGFjZS1iZXR3ZWVuXCIgfSwgZ2V0RmllbGRBbGlhcyhhZGRGTCwgc3RhdHNGaWVsZC5maWVsZE5hbWUpLCBoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyBzY2FsZTogXCJzXCIsIGljb246IFwidHJhc2hcIiwgdGV4dDogc3RyaW5ncy5nZW5lcmFsLnJlbW92ZSwgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGpvaW5PcGVyYXRpb24uc3RhdGlzdGljc0ZpZWxkcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgIH0gfSkpLCBoKFwiZGl2XCIsIG51bGwsICFpc0RhdGUgJiYgKGgoRnJhZ21lbnQsIG51bGwsIGgoXCJjYWxjaXRlLWNoaXBcIiwgeyB2YWx1ZTogXCJTVU1cIiwgYXBwZWFyYW5jZTogc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiU1VNXCIpID4gLTEgPyBcInNvbGlkXCIgOiBcIm91dGxpbmUtZmlsbFwiLCBraW5kOiBcImJyYW5kXCIsIGNsYXNzOiBgJHtDU1MkNS5jaGlwfSAke3N0YXRzRmllbGQudHlwZXMubGVuZ3RoID4gMSB8fCBzdGF0c0ZpZWxkLnR5cGVzLmluZGV4T2YoXCJTVU1cIikgPT09IC0xXG4gICAgICAgICAgICAgICAgPyBDU1MkNS5zZWxlY3RcbiAgICAgICAgICAgICAgICA6IFwiXCJ9YCwgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXRzRmllbGQudHlwZXMuaW5kZXhPZihcIlNVTVwiKSA9PT0gLTFcbiAgICAgICAgICAgICAgICAgICAgPyBzdGF0c0ZpZWxkLnR5cGVzLnB1c2goXCJTVU1cIilcbiAgICAgICAgICAgICAgICAgICAgOiBzdGF0c0ZpZWxkLnR5cGVzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3RhdHNGaWVsZC50eXBlcy5zcGxpY2Uoc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiU1VNXCIpLCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgICAgICB9IH0sIHN0cmluZ3Muam9pbi5zdW0pLCBcIlxcdTAwQTBcIikpLCBoKFwiY2FsY2l0ZS1jaGlwXCIsIHsgdmFsdWU6IFwiTUlOXCIsIGFwcGVhcmFuY2U6IHN0YXRzRmllbGQudHlwZXMuaW5kZXhPZihcIk1JTlwiKSA+IC0xID8gXCJzb2xpZFwiIDogXCJvdXRsaW5lLWZpbGxcIiwga2luZDogXCJicmFuZFwiLCBjbGFzczogYCR7Q1NTJDUuY2hpcH0gJHtzdGF0c0ZpZWxkLnR5cGVzLmxlbmd0aCA+IDEgfHwgc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiTUlOXCIpID09PSAtMVxuICAgICAgICAgICAgICAgID8gQ1NTJDUuc2VsZWN0XG4gICAgICAgICAgICAgICAgOiBcIlwifWAsIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0c0ZpZWxkLnR5cGVzLmluZGV4T2YoXCJNSU5cIikgPT09IC0xXG4gICAgICAgICAgICAgICAgICAgID8gc3RhdHNGaWVsZC50eXBlcy5wdXNoKFwiTUlOXCIpXG4gICAgICAgICAgICAgICAgICAgIDogc3RhdHNGaWVsZC50eXBlcy5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN0YXRzRmllbGQudHlwZXMuc3BsaWNlKHN0YXRzRmllbGQudHlwZXMuaW5kZXhPZihcIk1JTlwiKSwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICAgICAgfSB9LCBzdHJpbmdzLmpvaW4ubWluKSwgXCJcXHUwMEEwXCIsIGgoXCJjYWxjaXRlLWNoaXBcIiwgeyB2YWx1ZTogXCJNQVhcIiwgYXBwZWFyYW5jZTogc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiTUFYXCIpID4gLTEgPyBcInNvbGlkXCIgOiBcIm91dGxpbmUtZmlsbFwiLCBraW5kOiBcImJyYW5kXCIsIGNsYXNzOiBgJHtDU1MkNS5jaGlwfSAke3N0YXRzRmllbGQudHlwZXMubGVuZ3RoID4gMSB8fCBzdGF0c0ZpZWxkLnR5cGVzLmluZGV4T2YoXCJNQVhcIikgPT09IC0xXG4gICAgICAgICAgICAgICAgPyBDU1MkNS5zZWxlY3RcbiAgICAgICAgICAgICAgICA6IFwiXCJ9YCwgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXRzRmllbGQudHlwZXMuaW5kZXhPZihcIk1BWFwiKSA9PT0gLTFcbiAgICAgICAgICAgICAgICAgICAgPyBzdGF0c0ZpZWxkLnR5cGVzLnB1c2goXCJNQVhcIilcbiAgICAgICAgICAgICAgICAgICAgOiBzdGF0c0ZpZWxkLnR5cGVzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3RhdHNGaWVsZC50eXBlcy5zcGxpY2Uoc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiTUFYXCIpLCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgICAgICB9IH0sIHN0cmluZ3Muam9pbi5tYXgpLCAhaXNEYXRlICYmIChoKEZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIiwgaChcImNhbGNpdGUtY2hpcFwiLCB7IHZhbHVlOiBcIk1FQU5cIiwgYXBwZWFyYW5jZTogc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiTUVBTlwiKSA+IC0xID8gXCJzb2xpZFwiIDogXCJvdXRsaW5lLWZpbGxcIiwga2luZDogXCJicmFuZFwiLCBjbGFzczogYCR7Q1NTJDUuY2hpcH0gJHtzdGF0c0ZpZWxkLnR5cGVzLmxlbmd0aCA+IDEgfHwgc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiTUVBTlwiKSA9PT0gLTFcbiAgICAgICAgICAgICAgICA/IENTUyQ1LnNlbGVjdFxuICAgICAgICAgICAgICAgIDogXCJcIn1gLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiTUVBTlwiKSA9PT0gLTFcbiAgICAgICAgICAgICAgICAgICAgPyBzdGF0c0ZpZWxkLnR5cGVzLnB1c2goXCJNRUFOXCIpXG4gICAgICAgICAgICAgICAgICAgIDogc3RhdHNGaWVsZC50eXBlcy5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN0YXRzRmllbGQudHlwZXMuc3BsaWNlKHN0YXRzRmllbGQudHlwZXMuaW5kZXhPZihcIk1FQU5cIiksIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgIH0gfSwgc3RyaW5ncy5qb2luLm1lYW4pLCBcIlxcdTAwQTBcIiwgaChcImNhbGNpdGUtY2hpcFwiLCB7IHZhbHVlOiBcIlNURERFVlwiLCBhcHBlYXJhbmNlOiBzdGF0c0ZpZWxkLnR5cGVzLmluZGV4T2YoXCJTVERERVZcIikgPiAtMSA/IFwic29saWRcIiA6IFwib3V0bGluZS1maWxsXCIsIGtpbmQ6IFwiYnJhbmRcIiwgY2xhc3M6IGAke0NTUyQ1LmNoaXB9ICR7c3RhdHNGaWVsZC50eXBlcy5sZW5ndGggPiAxIHx8IHN0YXRzRmllbGQudHlwZXMuaW5kZXhPZihcIlNURERFVlwiKSA9PT0gLTFcbiAgICAgICAgICAgICAgICA/IENTUyQ1LnNlbGVjdFxuICAgICAgICAgICAgICAgIDogXCJcIn1gLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiU1REREVWXCIpID09PSAtMVxuICAgICAgICAgICAgICAgICAgICA/IHN0YXRzRmllbGQudHlwZXMucHVzaChcIlNURERFVlwiKVxuICAgICAgICAgICAgICAgICAgICA6IHN0YXRzRmllbGQudHlwZXMubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzdGF0c0ZpZWxkLnR5cGVzLnNwbGljZShzdGF0c0ZpZWxkLnR5cGVzLmluZGV4T2YoXCJTVERERVZcIiksIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgIH0gfSwgc3RyaW5ncy5qb2luLnN0ZERldikpKSwgIWhhc0FsbFR5cGVzICYmIChoKEZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIiwgaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgYXBwZWFyYW5jZTogXCJ0cmFuc3BhcmVudFwiLCBsYWJlbDogc3RyaW5ncy5qb2luLnNlbGVjdEFsbCwgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICFpc0RhdGUgJiYgc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiU1VNXCIpID09PSAtMSAmJiBzdGF0c0ZpZWxkLnR5cGVzLnB1c2goXCJTVU1cIik7XG4gICAgICAgICAgICAgICAgc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiTUlOXCIpID09PSAtMSAmJiBzdGF0c0ZpZWxkLnR5cGVzLnB1c2goXCJNSU5cIik7XG4gICAgICAgICAgICAgICAgc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiTUFYXCIpID09PSAtMSAmJiBzdGF0c0ZpZWxkLnR5cGVzLnB1c2goXCJNQVhcIik7XG4gICAgICAgICAgICAgICAgIWlzRGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBzdGF0c0ZpZWxkLnR5cGVzLmluZGV4T2YoXCJNRUFOXCIpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICBzdGF0c0ZpZWxkLnR5cGVzLnB1c2goXCJNRUFOXCIpO1xuICAgICAgICAgICAgICAgICFpc0RhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgc3RhdHNGaWVsZC50eXBlcy5pbmRleE9mKFwiU1REREVWXCIpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICBzdGF0c0ZpZWxkLnR5cGVzLnB1c2goXCJTVERERVZcIik7XG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgICAgICB9IH0sIHN0cmluZ3Muam9pbi5zZWxlY3RBbGwpKSkpKSk7XG4gICAgfVxuICAgIHJlbmRlckpvaW5UeXBlKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGpvaW5PcGVyYXRpb24sIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIGgoXCJkaXZcIiwgeyBjbGFzczogXCJpbmZvXCIgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBcImluZm8tbGFiZWxcIiB9LCBzdHJpbmdzLmpvaW4uam9pblR5cGUpLCBoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyBjbGFzczogXCJsaW5rLWluZm9cIiwgdGFiaW5kZXg6IFwiMFwiLCBzY2FsZTogXCJzXCIsIGljb246IFwiaW5mb3JtYXRpb25cIiwgb25DbGljazogKGV2ZW50KSA9PiB0aGlzLmhhbmRsZUluZm9DbGljayhldmVudCwgXCJqb2luLXR5cGVcIiksIHRleHQ6IHN0cmluZ3Muam9pbi5tb3JlSW5mbywgcmVmOiAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuam9pblR5cGVJbmZvSWNvbk5vZGUgPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCIgXCIgfHwgKCF0aGlzLmluZm9Qb3BvdmVyTm9kZSAmJiBldmVudC5rZXkgPT09IFwiRW50ZXJcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSW5mb0NsaWNrKGV2ZW50LCBcImpvaW4tdHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiIFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IHBhbmVsIGZyb20gc2Nyb2xsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gfSkpLCBoKFwiZGl2XCIsIG51bGwsIGgoXCJjYWxjaXRlLWNoaXBcIiwgeyB2YWx1ZTogXCJpbm5lci1qb2luXCIsIGFwcGVhcmFuY2U6IGpvaW5PcGVyYXRpb24uam9pblR5cGUgPT09IFwiSU5ORVJcIiA/IFwic29saWRcIiA6IFwib3V0bGluZS1maWxsXCIsIGtpbmQ6IFwiYnJhbmRcIiwgY2xhc3M6IGAke0NTUyQ1LmNoaXB9ICR7am9pbk9wZXJhdGlvbi5qb2luVHlwZSA9PT0gXCJMRUZUXCIgPyBDU1MkNS5zZWxlY3QgOiBcIlwifWAsIG9uQ2xpY2s6IGpvaW5PcGVyYXRpb24uam9pblR5cGUgPT09IFwiTEVGVFwiXG4gICAgICAgICAgICAgICAgPyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGpvaW5PcGVyYXRpb24uam9pblR5cGUgPSBcIklOTkVSXCI7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCB9LCBzdHJpbmdzLmpvaW4uaW5uZXJKb2luKSwgXCJcXHUwMEEwXCIsIGgoXCJjYWxjaXRlLWNoaXBcIiwgeyB2YWx1ZTogXCJsZWZ0LWpvaW5cIiwgYXBwZWFyYW5jZTogam9pbk9wZXJhdGlvbi5qb2luVHlwZSA9PT0gXCJMRUZUXCIgPyBcInNvbGlkXCIgOiBcIm91dGxpbmUtZmlsbFwiLCBraW5kOiBcImJyYW5kXCIsIGNsYXNzOiBgJHtDU1MkNS5jaGlwfSAke2pvaW5PcGVyYXRpb24uam9pblR5cGUgPT09IFwiSU5ORVJcIiA/IENTUyQ1LnNlbGVjdCA6IFwiXCJ9YCwgb25DbGljazogam9pbk9wZXJhdGlvbi5qb2luVHlwZSA9PT0gXCJJTk5FUlwiXG4gICAgICAgICAgICAgICAgPyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGpvaW5PcGVyYXRpb24uam9pblR5cGUgPSBcIkxFRlRcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkIH0sIHN0cmluZ3Muam9pbi5sZWZ0Sm9pbikpKSk7XG4gICAgfVxuICAgIG9wZW5GaWVsZFBpY2tMaXN0KHsgbGF5ZXIsIGZpZWxkTmFtZSwgbXVsdGlwbGUsIGhlYWRpbmcsIGZpZWxkVHlwZXMsIGV4Y2x1ZGVkRmllbGRzLCBidXR0b25Ob2RlLCBvbkNoYW5nZSB9KSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGZpZWxkUGlja0xpc3RTb3J0QnksIGZsb3dJdGVtTm9kZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB2aWV3IH0gPSBwcm9wcztcbiAgICAgICAgY29uc3Qgbm9kZVdpZHRoID0gZmxvd0l0ZW1Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHx8IDIxNTtcbiAgICAgICAgdGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFyY2dpcy1maWVsZC1waWNrLWxpc3RcIik7XG4gICAgICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5wb3BvdmVyUHJvcHMgPSB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgb2Zmc2V0RGlzdGFuY2U6IC0xICogKG5vZGVXaWR0aCAtIDIpLFxuICAgICAgICAgICAgb2Zmc2V0U2tpZGRpbmc6IDAsXG4gICAgICAgICAgICBwb2ludGVyRGlzYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBwb3BvdmVyV2lkdGg6IG5vZGVXaWR0aCArIDcsXG4gICAgICAgICAgICByZWZFbGVtZW50OiBmbG93SXRlbU5vZGVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0LmZpZWxkcyA9IHRoaXMuY3JlYXRlUGlja0xpc3RGaWVsZHMobGF5ZXIsIGZpZWxkVHlwZXMsIGV4Y2x1ZGVkRmllbGRzKTtcbiAgICAgICAgdGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0LmxheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5tYXBWaWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0LnNob3dGaWVsZEluZm8gPSB0cnVlO1xuICAgICAgICB0aGlzLmFyY2dpc0ZpZWxkUGlja0xpc3Quc2hvd0ZpZWxkTmFtZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFyY2dpc0ZpZWxkUGlja0xpc3Quc2VsZWN0ZWRGaWVsZHMgPSBmaWVsZE5hbWUgPyBbZmllbGROYW1lXSA6IFtdO1xuICAgICAgICB0aGlzLmFyY2dpc0ZpZWxkUGlja0xpc3Quc29ydEJ5ID0gZmllbGRQaWNrTGlzdFNvcnRCeTtcbiAgICAgICAgdGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0Lm11bHRpcGxlID0gbXVsdGlwbGU7XG4gICAgICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5oZWFkaW5nID0gaGVhZGluZztcbiAgICAgICAgdGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNGaWVsZFBpY2tMaXN0RGlzbWlzc2VkXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZEZpZWxkcyA9IChfYSA9IGV2ZW50LmRldGFpbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbGVjdGVkRmllbGRzO1xuICAgICAgICAgICAgZmxvd0l0ZW1Ob2RlLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0KSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLmFyY2dpc0ZpZWxkUGlja0xpc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbk5vZGUuc2V0Rm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEZpZWxkcyA9PT0gbnVsbCB8fCBzZWxlY3RlZEZpZWxkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWRGaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb25DaGFuZ2Uoc2VsZWN0ZWRGaWVsZHMpO1xuICAgICAgICAgICAgfSAvLyBlbHNlIHVzZXIgaGl0IGNhbmNlbCBvciBjbG9zZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNGaWVsZFBpY2tMaXN0U29ydEJ5Q2hhbmdlXCIsIChldmVudCkgPT4gKHRoaXMuZmllbGRQaWNrTGlzdFNvcnRCeSA9IGV2ZW50LmRldGFpbCkpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdCk7XG4gICAgICAgIGZsb3dJdGVtTm9kZS5kaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIGNyZWF0ZVBpY2tMaXN0RmllbGRzKGxheWVyLCBmaWVsZFR5cGVzLCBleGNsdWRlZEZpZWxkcykge1xuICAgICAgICBjb25zdCB7IGZpZWxkcywgcG9wdXBUZW1wbGF0ZSB9ID0gbGF5ZXI7XG4gICAgICAgIGNvbnN0IGxheWVyRmllbGRzID0gZmllbGRzXG4gICAgICAgICAgICAuZmlsdGVyKChmaWVsZCkgPT4gZXhjbHVkZWRGaWVsZHMuaW5kZXhPZihmaWVsZC5uYW1lKSA9PT0gLTEpXG4gICAgICAgICAgICAuZmlsdGVyKChmaWVsZCkgPT4gZmllbGRUeXBlcy5pbmRleE9mKGZpZWxkLnR5cGUpID4gLTEpO1xuICAgICAgICByZXR1cm4gbGF5ZXJGaWVsZHMubWFwKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogZmllbGQubmFtZSxcbiAgICAgICAgICAgICAgICBhbGlhczogKChfYiA9IChfYSA9IHBvcHVwVGVtcGxhdGUgPT09IG51bGwgfHwgcG9wdXBUZW1wbGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9wdXBUZW1wbGF0ZS5maWVsZEluZm9zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZCgoZmllbGRJbmZvKSA9PiBmaWVsZEluZm8uZmllbGROYW1lID09PSBmaWVsZC5uYW1lKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxhYmVsKSB8fCBmaWVsZC5hbGlhcyxcbiAgICAgICAgICAgICAgICB0eXBlOiBmaWVsZC50eXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlSW5mb0NsaWNrKGV2ZW50LCB0eXBlKSB7XG4gICAgICAgIC8vIGRvbid0IGV4ZWN1dGUgdGhlIGV2ZW50IG9uIHRoZSBlbnRpcmUgdGlsZVxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5yZW1vdmVJbmZvUG9wb3ZlcigpO1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCByZWZFbGVtZW50ID0gdHlwZSA9PT0gXCJqb2luLW9wZXJhdGlvblwiID8gdGhpcy5qb2luT3BlcmF0aW9uSW5mb0ljb25Ob2RlIDogdGhpcy5qb2luVHlwZUluZm9JY29uTm9kZTtcbiAgICAgICAgdGhpcy5pbmZvUG9wb3Zlck5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYXJjZ2lzLWxheWVyLXZpZXctam9pbi1pbmZvLXBvcG92ZXJcIik7XG4gICAgICAgIHRoaXMuaW5mb1BvcG92ZXJOb2RlLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuaW5mb1BvcG92ZXJOb2RlLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmluZm9Qb3BvdmVyTm9kZS5yZWZlcmVuY2VFbGVtZW50ID0gcmVmRWxlbWVudDtcbiAgICAgICAgdGhpcy5pbmZvUG9wb3Zlck5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc0xheWVyVmlld0pvaW5JbmZvUG9wb3ZlckNsb3NlXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUluZm9Qb3BvdmVyKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlZkVsZW1lbnQuc2V0Rm9jdXMoKSwgMjAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5mb1BvcG92ZXJOb2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNMYXllclZpZXdKb2luSW5mb1BvcG92ZXJEaXNjb25uZWN0ZWRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSW5mb1BvcG92ZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5pbmZvUG9wb3Zlck5vZGUpO1xuICAgICAgICB0aGlzLmluZm9Qb3BvdmVyTm9kZS5zZXRPcGVuKHRydWUpO1xuICAgICAgICAvLyBuZWVkIHRvIHdhaXQgdW50aWwgaXQncyBhbGwgdmlzaWJsZVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaW5mb1BvcG92ZXJOb2RlLnNldEZvY3VzKCksIDEwMCk7XG4gICAgfVxuICAgIHJlbW92ZUluZm9Qb3BvdmVyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmluZm9Qb3BvdmVyTm9kZSkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5pbmZvUG9wb3Zlck5vZGUucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKHRoaXMuaW5mb1BvcG92ZXJOb2RlKTtcbiAgICAgICAgICAgIHRoaXMuaW5mb1BvcG92ZXJOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaG9zdEVsZW1lbnQoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuQXJjZ2lzTGF5ZXJWaWV3Sm9pbkNvbmZpZy5zdHlsZSA9IGFyY2dpc0xheWVyVmlld0pvaW5Db25maWdDc3M7XG5cbmNvbnN0IENTUyQ0ID0ge1xuICAgIHBhbmVsOiBcInBhbmVsXCIsXG4gICAgaW5mbzogXCJpbmZvXCIsXG4gICAgZm9vdGVyOiBcImZvb3RlclwiLFxuICAgIGxheWVyU2VjdGlvbjogXCJsYXllci1zZWN0aW9uXCIsXG4gICAgdGFyZ2V0TGF5ZXI6IFwidGFyZ2V0LWxheWVyXCIsXG4gICAgYWRkTGF5ZXI6IFwiYWRkLWxheWVyXCIsXG4gICAgbGF5ZXJIZWFkZXI6IFwibGF5ZXItaGVhZGVyXCIsXG4gICAgbGF5ZXJUaXRsZTogXCJsYXllci10aXRsZVwiXG59O1xuXG5jb25zdCBhcmNnaXNMYXllclZpZXdKb2luQ3JlYXRlQ3NzID0gXCIucGFuZWwuc2MtYXJjZ2lzLWxheWVyLXZpZXctam9pbi1jcmVhdGV7aGVpZ2h0OjEwMCV9LmluZm8uc2MtYXJjZ2lzLWxheWVyLXZpZXctam9pbi1jcmVhdGV7ZGlzcGxheTpncmlkO2dyaWQtdGVtcGxhdGUtY29sdW1uczpyZXBlYXQoMSwgbWlubWF4KDBweCwgMWZyKSk7Z2FwOjAuNXJlbTtwYWRkaW5nOjAgMC43NXJlbX0uZm9vdGVyLnNjLWFyY2dpcy1sYXllci12aWV3LWpvaW4tY3JlYXRle3dpZHRoOjEwMCV9LmxheWVyLXNlY3Rpb24uc2MtYXJjZ2lzLWxheWVyLXZpZXctam9pbi1jcmVhdGV7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1jYWxjaXRlLWNvbG9yLWJvcmRlci0zKTtiYWNrZ3JvdW5kLWNvbG9yOndoaXRlO21hcmdpbjoxMHB4fS50YXJnZXQtbGF5ZXIuc2MtYXJjZ2lzLWxheWVyLXZpZXctam9pbi1jcmVhdGV7cGFkZGluZzoxMHB4O2JvcmRlci1ib3R0b206MXB4IHNvbGlkIHZhcigtLWNhbGNpdGUtY29sb3ItYm9yZGVyLTMpfS5hZGQtbGF5ZXIuc2MtYXJjZ2lzLWxheWVyLXZpZXctam9pbi1jcmVhdGV7cGFkZGluZzoxMHB4fS5sYXllci1oZWFkZXIuc2MtYXJjZ2lzLWxheWVyLXZpZXctam9pbi1jcmVhdGV7cGFkZGluZy1ib3R0b206M3B4fS5sYXllci10aXRsZS5zYy1hcmNnaXMtbGF5ZXItdmlldy1qb2luLWNyZWF0ZXtmb250LXdlaWdodDpib2xkfS5ub3RpY2Uuc2MtYXJjZ2lzLWxheWVyLXZpZXctam9pbi1jcmVhdGV7bWFyZ2luOjhweH1cIjtcblxuY29uc3QgQXJjZ2lzTGF5ZXJWaWV3Sm9pbkNyZWF0ZSA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Sm9pblN0YXR1c0NoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzTGF5ZXJWaWV3Sm9pblN0YXR1c0NoYW5nZVwiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdKb2luQ3JlYXRlRG9uZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzTGF5ZXJWaWV3Sm9pbkNyZWF0ZURvbmVcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Sm9pbkNyZWF0ZUNhbmNlbCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzTGF5ZXJWaWV3Sm9pbkNyZWF0ZUNhbmNlbFwiLCA3KTtcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gIFByaXZhdGUgbWV0aG9kc1xuICAgICAgICAvL1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLmdvQmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIHNhdmUgbGFzdCBzZXR0aW5nc1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgICAgIHByb3BzLnNhdmVkSXRlbVByb3BzID0ge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBpdGVtUHJvcGVydGllc1N0YXRlLnRpdGxlLFxuICAgICAgICAgICAgICAgIHRhZ3M6IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUudGFncyxcbiAgICAgICAgICAgICAgICBzdW1tYXJ5OiBpdGVtUHJvcGVydGllc1N0YXRlLnNuaXBwZXQsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcmllczogaXRlbVByb3BlcnRpZXNTdGF0ZS5jYXRlZ29yaWVzLFxuICAgICAgICAgICAgICAgIGZvbGRlcjogaXRlbVByb3BlcnRpZXNTdGF0ZS5mb2xkZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld0pvaW5TdGF0dXNDaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBqb2luRmxvd1N0YXR1cy5DT05GSUdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdvQ3JlYXRlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgZmxvd0l0ZW1Ob2RlLCBob3N0RWxlbWVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBjcmVhdGUgY2FsbCBmYWlsc1xuICAgICAgICAgICAgcHJvcHMuc2F2ZWRJdGVtUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUudGl0bGUsXG4gICAgICAgICAgICAgICAgdGFnczogaXRlbVByb3BlcnRpZXNTdGF0ZS50YWdzLFxuICAgICAgICAgICAgICAgIHN1bW1hcnk6IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUuc25pcHBldCxcbiAgICAgICAgICAgICAgICBjYXRlZ29yaWVzOiBpdGVtUHJvcGVydGllc1N0YXRlLmNhdGVnb3JpZXMsXG4gICAgICAgICAgICAgICAgZm9sZGVyOiBpdGVtUHJvcGVydGllc1N0YXRlLmZvbGRlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW1Qcm9wcyA9IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogaXRlbVByb3BlcnRpZXNTdGF0ZS50aXRsZSxcbiAgICAgICAgICAgICAgICB0YWdzOiBpdGVtUHJvcGVydGllc1N0YXRlLnRhZ3MsXG4gICAgICAgICAgICAgICAgc3VtbWFyeTogaXRlbVByb3BlcnRpZXNTdGF0ZS5zbmlwcGV0LFxuICAgICAgICAgICAgICAgIGNhdGVnb3JpZXM6IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUuY2F0ZWdvcmllcyxcbiAgICAgICAgICAgICAgICBmb2xkZXI6IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUuZm9sZGVyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3SXRlbUlkID0gYXdhaXQgY3JlYXRlSm9pblZpZXcocHJvcHMsIG5ld0l0ZW1Qcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFyY2dpcy1sYXllci12aWV3LW1zZ1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUuZmxvd0l0ZW1FbGVtZW50ID0gZmxvd0l0ZW1Ob2RlO1xuICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZS5tZXNzYWdlID0gc3RyaW5ncy5tc2cuY3JlYXRlZDtcbiAgICAgICAgICAgICAgICBob3N0RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLm1zZ05vZGUpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRIbmRsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRIbmRsID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZW91dEhuZGwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1zZ05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMubXNnTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld0pvaW5DcmVhdGVEb25lLmVtaXQodGhpcy52aWV3SXRlbUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDcwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3BzLCBmbG93SXRlbU5vZGUgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiY291bGQgbm90IGNyZWF0ZSBqb2luIHZpZXdcIiwgZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFyY2dpcy1sYXllci12aWV3LW1zZ1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUuZmxvd0l0ZW1FbGVtZW50ID0gZmxvd0l0ZW1Ob2RlO1xuICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZS5pc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUubWVzc2FnZSA9IHN0cmluZ3MubXNnLmNyZWF0ZUZhaWxlZDtcbiAgICAgICAgICAgICAgICBob3N0RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLm1zZ05vZGUpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRIbmRsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRIbmRsID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZW91dEhuZGwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1zZ05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMubXNnTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCA3MDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nb0NhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3Sm9pbkNyZWF0ZUNhbmNlbC5lbWl0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRpdGxlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhcmNnaXNMYXllclZpZXdNc2dDbG9zZWRIYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5tc2dOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmhvc3RFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMubXNnTm9kZSk7XG4gICAgICAgICAgICB0aGlzLm1zZ05vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dEhuZGwpO1xuICAgICAgICB0aGlzLnRpbWVvdXRIbmRsID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy52aWV3SXRlbUlkKSB7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld0pvaW5DcmVhdGVEb25lLmVtaXQodGhpcy52aWV3SXRlbUlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgTGlmZWN5Y2xlXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0TGF5ZXIsIHRhcmdldExheWVySWQsIGFkZExheWVyLCBhZGRMYXllcklkIH0gPSBwcm9wcztcbiAgICAgICAgdGhpcy50YXJnZXRGTCA9ICh0YXJnZXRMYXllci50eXBlID09PSBcImdyb3VwXCJcbiAgICAgICAgICAgID8gZ2V0TGF5ZXJzQW5kVGFibGVzKHRhcmdldExheWVyKS5maW5kKChseXIpID0+IGx5ci5sYXllcklkID09PSB0YXJnZXRMYXllcklkKVxuICAgICAgICAgICAgOiB0YXJnZXRMYXllcik7XG4gICAgICAgIHRoaXMuYWRkRkwgPSAoYWRkTGF5ZXIudHlwZSA9PT0gXCJncm91cFwiXG4gICAgICAgICAgICA/IGdldExheWVyc0FuZFRhYmxlcyhhZGRMYXllcikuZmluZCgobHlyKSA9PiBseXIubGF5ZXJJZCA9PT0gYWRkTGF5ZXJJZClcbiAgICAgICAgICAgIDogYWRkTGF5ZXIpO1xuICAgICAgICB0aGlzLnRpdGxlID0gYXdhaXQgZ2V0U3VnZ2VzdGVkVGl0bGVGb3JKb2luKHByb3BzKTtcbiAgICB9XG4gICAgYXN5bmMgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5iYWNrQnV0dG9uTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7IH0pO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFJlbmRlciBNZXRob2RzXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBsb2FkaW5nIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBydGwgPSBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpID09PSBcInJ0bFwiO1xuICAgICAgICByZXR1cm4gKGgoSG9zdCwgeyBjbGFzczogXCJjYWxjaXRlLW1hdGNoLWhlaWdodFwiIH0sIGgoXCJjYWxjaXRlLWZsb3ctaXRlbVwiLCB7IGhlYWRpbmc6IHN0cmluZ3Muam9pbi5jcmVhdGUsIGxvYWRpbmc6IGxvYWRpbmcsIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcGFuZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgW0NTU19VVElMSVRZLnJ0bF06IHJ0bFxuICAgICAgICAgICAgfSwgcmVmOiAobm9kZSkgPT4gKHRoaXMuZmxvd0l0ZW1Ob2RlID0gbm9kZSkgfSwgdGhpcy5yZW5kZXJGb290ZXJCdXR0b25zKCksIHRoaXMucmVuZGVyTm90aWNlKCksIHRoaXMucmVuZGVyTGF5ZXJzKCksIHRoaXMucmVuZGVySW5mbygpKSkpO1xuICAgIH1cbiAgICByZW5kZXJGb290ZXJCdXR0b25zKCkge1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBzbG90OiBcImZvb3RlclwiLCBjbGFzczogQ1NTJDQuZm9vdGVyIH0sIHRoaXMucmVuZGVyQmFjaygpLCB0aGlzLnJlbmRlckNyZWF0ZSgpLCBoKFwiYnJcIiwgbnVsbCksIHRoaXMucmVuZGVyQ2FuY2VsKCkpKTtcbiAgICB9XG4gICAgcmVuZGVyQmFjaygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgaXNSdGwgPSBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpID09PSBcInJ0bFwiO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IG9uQ2xpY2s6IHRoaXMuZ29CYWNrLCBhcHBlYXJhbmNlOiBcIm91dGxpbmUtZmlsbFwiLCB3aWR0aDogXCJoYWxmXCIsIFwiaWNvbi1zdGFydFwiOiBpc1J0bCA/IFwiYXJyb3ctcmlnaHRcIiA6IFwiYXJyb3ctbGVmdFwiLCByZWY6IChub2RlKSA9PiAodGhpcy5iYWNrQnV0dG9uTm9kZSA9IG5vZGUpIH0sIHN0cmluZ3MuZ2VuZXJhbC5iYWNrKSk7XG4gICAgfVxuICAgIHJlbmRlckNyZWF0ZSgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgdGl0bGUsIHRpdGxlRXJyb3IsIHN1bW1hcnlFcnJvciB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgZW5hYmxlZCA9IHRpdGxlICYmICF0aXRsZUVycm9yICYmICFzdW1tYXJ5RXJyb3I7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgZGlzYWJsZWQ6ICFlbmFibGVkLCBvbkNsaWNrOiBlbmFibGVkICYmIHRoaXMuZ29DcmVhdGUsIGFwcGVhcmFuY2U6IFwic29saWRcIiwgd2lkdGg6IFwiaGFsZlwiLCBcImljb24tc3RhcnRcIjogXCJwbHVzLXNxdWFyZVwiLCByZWY6IChub2RlKSA9PiAodGhpcy5jcmVhdGVCdXR0b25Ob2RlID0gbm9kZSkgfSwgc3RyaW5ncy5jcmVhdGVWaWV3LmNyZWF0ZSkpO1xuICAgIH1cbiAgICByZW5kZXJDYW5jZWwoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgb25DbGljazogdGhpcy5nb0NhbmNlbCwgYXBwZWFyYW5jZTogXCJ0cmFuc3BhcmVudFwiLCB3aWR0aDogXCJmdWxsXCIgfSwgc3RyaW5ncy5nZW5lcmFsLmNhbmNlbCkpO1xuICAgIH1cbiAgICByZW5kZXJOb3RpY2UoKSB7XG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJMYXllcnMoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHRhcmdldEZMLCBhZGRGTCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB0YXJnZXRJdGVtLCB0YXJnZXRMYXllciwgYWRkSXRlbSwgYWRkTGF5ZXIsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBydGwgPSBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpID09PSBcInJ0bFwiO1xuICAgICAgICBjb25zdCB0YXJnZXRUaXRsZSA9IHRhcmdldExheWVyLnR5cGUgPT09IFwiZ3JvdXBcIlxuICAgICAgICAgICAgPyBydGxcbiAgICAgICAgICAgICAgICA/IGAke3RhcmdldEZMLnRpdGxlfSAvICR7dGFyZ2V0SXRlbS50aXRsZX1gXG4gICAgICAgICAgICAgICAgOiBgJHt0YXJnZXRJdGVtLnRpdGxlfSAvICR7dGFyZ2V0RkwudGl0bGV9YFxuICAgICAgICAgICAgOiB0YXJnZXRMYXllci50aXRsZTtcbiAgICAgICAgY29uc3QgYWRkVGl0bGUgPSBhZGRMYXllci50eXBlID09PSBcImdyb3VwXCJcbiAgICAgICAgICAgID8gcnRsXG4gICAgICAgICAgICAgICAgPyBgJHthZGRGTC50aXRsZX0gLyAke2FkZEl0ZW0udGl0bGV9YFxuICAgICAgICAgICAgICAgIDogYCR7YWRkSXRlbS50aXRsZX0gLyAke2FkZEZMLnRpdGxlfWBcbiAgICAgICAgICAgIDogYWRkTGF5ZXIudGl0bGU7XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkNC5sYXllclNlY3Rpb24gfSwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkNC50YXJnZXRMYXllciB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQ0LmxheWVySGVhZGVyIH0sIHN0cmluZ3Muam9pbi50YXJnZXRMYXllciksIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDQubGF5ZXJUaXRsZSB9LCB0YXJnZXRUaXRsZSkpLCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQ0LmFkZExheWVyIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDQubGF5ZXJIZWFkZXIgfSwgc3RyaW5ncy5qb2luLmpvaW5MYXllciksIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDQubGF5ZXJUaXRsZSB9LCBhZGRUaXRsZSkpKSk7XG4gICAgfVxuICAgIHJlbmRlckluZm8oKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHRpdGxlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHRhcmdldEl0ZW0sIHRhcmdldEl0ZW1Pd25lciwgc2F2ZWRJdGVtUHJvcHMgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCB7IHBvcnRhbCB9ID0gdGFyZ2V0SXRlbTtcbiAgICAgICAgY29uc3QgdXNlciA9IHBvcnRhbC51c2VyO1xuICAgICAgICBjb25zdCBjb25maWcgPSB7IHBvcnRhbCwgdXNlciwgYXBpOiA0IH07XG4gICAgICAgIGlmIChzYXZlZEl0ZW1Qcm9wcykge1xuICAgICAgICAgICAgaXRlbVByb3BlcnRpZXNTdGF0ZS50aXRsZSA9IHNhdmVkSXRlbVByb3BzLnRpdGxlO1xuICAgICAgICAgICAgaXRlbVByb3BlcnRpZXNTdGF0ZS5mb2xkZXIgPSBzYXZlZEl0ZW1Qcm9wcy5mb2xkZXI7XG4gICAgICAgICAgICBpdGVtUHJvcGVydGllc1N0YXRlLnNuaXBwZXQgPSBzYXZlZEl0ZW1Qcm9wcy5zdW1tYXJ5IHx8IFwiXCI7XG4gICAgICAgICAgICBpdGVtUHJvcGVydGllc1N0YXRlLmNhdGVnb3JpZXMgPSBzYXZlZEl0ZW1Qcm9wcy5jYXRlZ29yaWVzO1xuICAgICAgICAgICAgaXRlbVByb3BlcnRpZXNTdGF0ZS50YWdzID0gc2F2ZWRJdGVtUHJvcHMudGFncztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW1Qcm9wZXJ0aWVzU3RhdGUudGl0bGUgPSB0aXRsZTtcbiAgICAgICAgICAgIGl0ZW1Qcm9wZXJ0aWVzU3RhdGUuZm9sZGVyID1cbiAgICAgICAgICAgICAgICB0YXJnZXRJdGVtLm93bmVyRm9sZGVyICYmXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0YXJnZXRJdGVtLm93bmVyRm9sZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6IHRhcmdldEl0ZW0ub3duZXJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGl0ZW1Qcm9wZXJ0aWVzU3RhdGUuc25pcHBldCA9IHRhcmdldEl0ZW0uc25pcHBldCB8fCBcIlwiO1xuICAgICAgICAgICAgaXRlbVByb3BlcnRpZXNTdGF0ZS5jYXRlZ29yaWVzID0gdGFyZ2V0SXRlbS5jYXRlZ29yaWVzO1xuICAgICAgICAgICAgaXRlbVByb3BlcnRpZXNTdGF0ZS50YWdzID0gdGFyZ2V0SXRlbS50YWdzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkNC5pbmZvIH0sIGgoXCJhcmNnaXMtaXRlbS1wcm9wZXJ0aWVzXCIsIHsgcG9ydGFsOiBwb3J0YWwsIHVzZXI6IHVzZXIsIGFwaTogNCwgY29uZmlnOiBjb25maWcsIHR5cGU6IFwiRmVhdHVyZSBTZXJ2aWNlXCIsIHNjYWxlOiBcInNcIiB9LCBoKFwiYXJjZ2lzLXRpdGxlLWlucHV0XCIsIHsgZW5hYmxlUHVibGlzaGluZzogdHJ1ZSwgb25BcmNnaXNUaXRsZUlucHV0Q2hhbmdlOiBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpdGxlRXJyb3IgPSBhd2FpdCBub2RlLnZhbGlkYXRlVGl0bGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoKCF0aGlzLnRpdGxlRXJyb3IgJiYgdGl0bGVFcnJvcikgfHwgKHRoaXMudGl0bGVFcnJvciAmJiAhdGl0bGVFcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudGl0bGVFcnJvciA9IHRpdGxlRXJyb3I7XG4gICAgICAgICAgICB9IH0pLCBoKFwiYXJjZ2lzLWZvbGRlci1waWNrZXJcIiwgeyB1c2VyOiB0YXJnZXRJdGVtT3duZXIgfSksIGgoXCJhcmNnaXMtY2F0ZWdvcmllcy1waWNrZXJcIiwgbnVsbCksIGgoXCJhcmNnaXMtdGFncy1waWNrZXJcIiwgbnVsbCksIGgoXCJhcmNnaXMtc3VtbWFyeS1pbnB1dFwiLCB7IG9uQXJjZ2lzU3VtbWFyeUlucHV0Q2hhbmdlOiBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1bW1hcnlFcnJvciA9IChhd2FpdCBub2RlLmdldEVycm9yTWVzc2FnZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAoKCF0aGlzLnN1bW1hcnlFcnJvciAmJiBzdW1tYXJ5RXJyb3IpIHx8ICh0aGlzLnN1bW1hcnlFcnJvciAmJiAhc3VtbWFyeUVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdW1tYXJ5RXJyb3IgPSBzdW1tYXJ5RXJyb3I7XG4gICAgICAgICAgICB9IH0pKSkpO1xuICAgIH1cbiAgICBnZXQgaG9zdEVsZW1lbnQoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuQXJjZ2lzTGF5ZXJWaWV3Sm9pbkNyZWF0ZS5zdHlsZSA9IGFyY2dpc0xheWVyVmlld0pvaW5DcmVhdGVDc3M7XG5cbmNvbnN0IENTUyQzID0ge1xuICAgIGZsb3c6IFwiZmxvd1wiLFxuICAgIHBhbmVsOiBcInBhbmVsXCIsXG4gICAgZm9vdGVyOiBcImZvb3RlclwiLFxuICAgIGluZm86IFwiaW5mb1wiLFxuICAgIHRleHQ6IFwidGV4dFwiXG59O1xuXG5jb25zdCBhcmNnaXNMYXllclZpZXdKb2luVGFyZ2V0U2VsZWN0aW9uQ3NzID0gXCIuZmxvd3toZWlnaHQ6MTAwJX0ucGFuZWx7aGVpZ2h0OjEwMCV9LmZvb3Rlcnt3aWR0aDoxMDAlfS5pbmZve3BvaW50ZXItZXZlbnRzOm5vbmU7cGFkZGluZzoxcmVtIDAuNzVyZW19LnRleHR7Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLS0yKTtsaW5lLWhlaWdodDoxLjM3NTtjb2xvcjp2YXIoLS1jYWxjaXRlLWNvbG9yLXRleHQtMyk7dHJhbnNpdGlvbi1kdXJhdGlvbjoxNTBtczt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO3BvaW50ZXItZXZlbnRzOm5vbmV9Lm5vdGljZXttYXJnaW46OHB4fVwiO1xuXG5jb25zdCBBcmNnaXNMYXllclZpZXdKb2luVGFyZ2V0U2VsZWN0aW9uID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdKb2luU3RhdHVzQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNMYXllclZpZXdKb2luU3RhdHVzQ2hhbmdlXCIsIDcpO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvL1xuICAgICAgICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMuZ29OZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdKb2luU3RhdHVzQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgICAgICAgIHN0YXR1czogam9pbkZsb3dTdGF0dXMuQUREX1NFTEVDVElPTlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyB0YXJnZXRMYXllciB9ID0gcHJvcHM7XG4gICAgICAgICAgICB0aGlzLmxpc3ROb2RlXG4gICAgICAgICAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYWxjaXRlLXBpY2stbGlzdC1pdGVtXCIpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy50YXJnZXRMYXllcklkID0gaXRlbS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRMYXllci50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0TGF5ZXJzQW5kVGFibGVzKHRhcmdldExheWVyKS5maW5kKChzdWJMYXllcikgPT4gc3ViTGF5ZXIubGF5ZXJJZCA9PT0gaXRlbS52YWx1ZSkudmlzaWJsZSA9IGl0ZW0uc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRMYXllci52aXNpYmxlID0gaXRlbS5zZWxlY3RlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb3BzLmF0dHJpYnV0ZVJlbGF0aW9uc2hpcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBwcm9wcy5qb2luT3BlcmF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb3BzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIExpZmVjeWNsZVxuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHRhcmdldExheWVyIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKHRhcmdldExheWVyLnR5cGUgIT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgcHJvcHMudGFyZ2V0TGF5ZXJJZCA9IHRhcmdldExheWVyLmxheWVySWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5saXN0Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7IH0pO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFJlbmRlciBNZXRob2RzXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwicmVuZGVyIHRhcmdldC1zZWxlY3Rpb25cIiwgdGhpcy5wcm9wcywgXCJzdGF0dXM6XCIsIHRoaXMuc3RhdHVzKTtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB0YXJnZXRJdGVtLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgcnRsID0gZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSA9PT0gXCJydGxcIjtcbiAgICAgICAgcmV0dXJuIChoKEhvc3QsIHsgY2xhc3M6IFwiY2FsY2l0ZS1tYXRjaC1oZWlnaHRcIiB9LCBoKFwiY2FsY2l0ZS1mbG93XCIsIHsgY2xhc3M6IENTUyQzLmZsb3csIGRpcjogZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSB9LCBoKFwiY2FsY2l0ZS1mbG93LWl0ZW1cIiwgeyBoZWFkaW5nOiB0YXJnZXRJdGVtID09PSBudWxsIHx8IHRhcmdldEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldEl0ZW0udGl0bGUsIGRlc2NyaXB0aW9uOiBzdHJpbmdzLmpvaW4udGFyZ2V0TGF5ZXIsIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcGFuZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgW0NTU19VVElMSVRZLnJ0bF06IHJ0bFxuICAgICAgICAgICAgfSwgcmVmOiAobm9kZSkgPT4gKHRoaXMuZmxvd0l0ZW1Ob2RlID0gbm9kZSkgfSwgdGhpcy5yZW5kZXJGb290ZXJCdXR0b25zKCksIHRoaXMucmVuZGVyT0JBQ01zZygpLCB0aGlzLnJlbmRlckluZm8oKSwgdGhpcy5yZW5kZXJTdWJsYXllcnMoKSkpKSk7XG4gICAgfVxuICAgIHJlbmRlckZvb3RlckJ1dHRvbnMoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0SXRlbSwgdGFyZ2V0TGF5ZXIsIHRhcmdldExheWVySWQsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBpc1J0bCA9IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCkgPT09IFwicnRsXCI7XG4gICAgICAgIGxldCB0YXJnZXRGTDtcbiAgICAgICAgaWYgKHRhcmdldExheWVyLnR5cGUgPT09IFwiZ3JvdXBcIiAmJiBpc0RlZmluZWQodGFyZ2V0TGF5ZXJJZCkpIHtcbiAgICAgICAgICAgIHRhcmdldEZMID0gZ2V0TGF5ZXJzQW5kVGFibGVzKHRhcmdldExheWVyKS5maW5kKChseXIpID0+IHRhcmdldExheWVySWQgPT09IGx5ci5sYXllcklkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YXJnZXRMYXllci50eXBlICE9PSBcImdyb3VwXCIpIHtcbiAgICAgICAgICAgIHRhcmdldEZMID0gdGFyZ2V0TGF5ZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dERpc2FibGVkID0gIWlzRGVmaW5lZCh0YXJnZXRMYXllcklkKSB8fCAodGFyZ2V0SXRlbS5wb3J0YWwuaXNQb3J0YWwgJiYgaGFzT0JBQyh0YXJnZXRGTCkpO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBzbG90OiBcImZvb3RlclwiLCBjbGFzczogQ1NTJDMuZm9vdGVyIH0sIGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IGRpc2FibGVkOiBuZXh0RGlzYWJsZWQsIG9uQ2xpY2s6ICFuZXh0RGlzYWJsZWQgJiYgdGhpcy5nb05leHQsIGFwcGVhcmFuY2U6IFwic29saWRcIiwgd2lkdGg6IFwiZnVsbFwiLCBpY29uRW5kOiBpc1J0bCA/IFwiYXJyb3ctbGVmdFwiIDogXCJhcnJvdy1yaWdodFwiLCByZWY6IChub2RlKSA9PiAodGhpcy5uZXh0QnV0dG9uTm9kZSA9IG5vZGUpIH0sIHN0cmluZ3MuZ2VuZXJhbC5uZXh0KSkpO1xuICAgIH1cbiAgICByZW5kZXJPQkFDTXNnKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGNvbmZpZywgdGFyZ2V0SXRlbSwgdGFyZ2V0TGF5ZXJJZCwgdGFyZ2V0TGF5ZXIsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCB7IGhlbHBCYXNlLCBoZWxwTWFwIH0gPSBjb25maWc7XG4gICAgICAgIGlmICghdGFyZ2V0SXRlbS5wb3J0YWwuaXNQb3J0YWwpIHtcbiAgICAgICAgICAgIC8vIG1lc3NhZ2Ugb25seSBmb3IgRW50ZXJwcmlzZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0YXJnZXRGTDtcbiAgICAgICAgaWYgKHRhcmdldExheWVyLnR5cGUgPT09IFwiZ3JvdXBcIiAmJiBpc0RlZmluZWQodGFyZ2V0TGF5ZXJJZCkpIHtcbiAgICAgICAgICAgIHRhcmdldEZMID0gZ2V0TGF5ZXJzQW5kVGFibGVzKHRhcmdldExheWVyKS5maW5kKChseXIpID0+IHRhcmdldExheWVySWQgPT09IGx5ci5sYXllcklkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YXJnZXRMYXllci50eXBlICE9PSBcImdyb3VwXCIpIHtcbiAgICAgICAgICAgIHRhcmdldEZMID0gdGFyZ2V0TGF5ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBncm91cCBzdWJsYXllciBzZWxlY3RlZCB5ZXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc09CQUModGFyZ2V0RkwpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1ub3RpY2VcIiwgeyBrZXk6IGAke2hhc09CQUModGFyZ2V0RkwpfWAsIGNsYXNzOiBcIm5vdGljZVwiLCBvcGVuOiB0cnVlLCBjbG9zYWJsZTogZmFsc2UsIHNjYWxlOiBcInNcIiwgd2lkdGg6IFwiYXV0b1wiLCBraW5kOiBcIndhcm5pbmdcIiwgaWNvbjogXCJleGNsYW1hdGlvbi1tYXJrLXRyaWFuZ2xlXCIgfSwgaChcImRpdlwiLCB7IHNsb3Q6IFwibWVzc2FnZVwiIH0sIHN0cmluZ3Muam9pbi5vYmFjTm90U3VwcG9ydGVkTXNnKSwgaChcImNhbGNpdGUtbGlua1wiLCB7IHNsb3Q6IFwibGlua1wiLCB0aXRsZTogc3RyaW5ncy5qb2luLmxlYXJuTW9yZSwgdGFyZ2V0OiBcIl9ibGFua1wiLCBocmVmOiBgJHtoZWxwQmFzZX0ke2hlbHBNYXBbXCIxMjAwMDQxODRcIl19YCB9LCBzdHJpbmdzLmpvaW4ubGVhcm5Nb3JlKSkpO1xuICAgIH1cbiAgICByZW5kZXJJbmZvKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDMuaW5mbyB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQzLnRleHQgfSwgc3RyaW5ncy5qb2luLnNlbGVjdFRhcmdldExheWVyUGFuZWxEZXNjcmlwdGlvbikpKTtcbiAgICB9XG4gICAgcmVuZGVyU3VibGF5ZXJzKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHRhcmdldExheWVyIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgbGlzdEl0ZW1zID0gW107XG4gICAgICAgIGlmICh0YXJnZXRMYXllci50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgICAgICAgIChfYSA9IHRhcmdldExheWVyLnRhYmxlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGx5cikgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtcy51bnNoaWZ0KHRoaXMucmVuZGVyU3VibGF5ZXIobHlyKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIChfYiA9IHRhcmdldExheWVyLmxheWVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZvckVhY2goKGx5cikgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtcy51bnNoaWZ0KHRoaXMucmVuZGVyU3VibGF5ZXIobHlyKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RJdGVtcy5wdXNoKHRoaXMucmVuZGVyU3VibGF5ZXIodGFyZ2V0TGF5ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLXBpY2stbGlzdFwiLCB7IG11bHRpcGxlOiBmYWxzZSwgb25DYWxjaXRlTGlzdENoYW5nZTogdGhpcy5vblNlbGVjdGlvbkNoYW5nZSwgcmVmOiAobm9kZSkgPT4gKHRoaXMubGlzdE5vZGUgPSBub2RlKSB9LCBsaXN0SXRlbXMpKTtcbiAgICB9XG4gICAgcmVuZGVyU3VibGF5ZXIobHlyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0TGF5ZXJJZCB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtcGljay1saXN0LWl0ZW1cIiwgeyBrZXk6IGx5ci5sYXllcklkLCBsYWJlbDogbHlyLnRpdGxlLCB2YWx1ZTogbHlyLmxheWVySWQsIGRlc2NyaXB0aW9uOiBnZXRMYXllclR5cGUobHlyLCBwcm9wcyksIHNlbGVjdGVkOiB0YXJnZXRMYXllcklkID09PSBseXIubGF5ZXJJZCB9KSk7XG4gICAgfVxuICAgIGdldCBob3N0RWxlbWVudCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbn07XG5BcmNnaXNMYXllclZpZXdKb2luVGFyZ2V0U2VsZWN0aW9uLnN0eWxlID0gYXJjZ2lzTGF5ZXJWaWV3Sm9pblRhcmdldFNlbGVjdGlvbkNzcztcblxuY29uc3QgQXJjZ2lzTGF5ZXJWaWV3Q3JlYXRlID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdNc2dDbG9zZWQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0xheWVyVmlld01zZ0Nsb3NlZFwiLCA3KTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5mbG93SXRlbUVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaXNFcnJvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzV2FybmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2xvc2VXaXRoT0sgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBMaWZlY3ljbGVcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyBjb21wb25lbnREaWRMb2FkKCkge1xuICAgICAgICBpZiAodGhpcy5mbG93SXRlbUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmxvd0l0ZW1FbGVtZW50LmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aGlzLm9rTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7IH0pO1xuICAgIH1cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxvd0l0ZW1FbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmZsb3dJdGVtRWxlbWVudC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUmVuZGVyIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGhvc3RFbGVtZW50LCBmbG93SXRlbUVsZW1lbnQsIGlzRXJyb3IsIGlzV2FybmluZywgbWVzc2FnZSwgY2xvc2VXaXRoT0sgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGRpciA9IGdldEVsZW1lbnREaXIoaG9zdEVsZW1lbnQpO1xuICAgICAgICBjb25zdCBwYW5lbFdpZHRoID0gTWF0aC5yb3VuZChmbG93SXRlbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpO1xuICAgICAgICByZXR1cm4gKGgoSG9zdCwgeyBjbGFzczogXCJqcy1hcHAtZmx5b3V0XCIgfSwgaChcImNhbGNpdGUtcG9wb3ZlclwiLCB7IGRpcjogZGlyLCBwbGFjZW1lbnQ6IFwidHJhaWxpbmctc3RhcnRcIiwgb3BlbjogdHJ1ZSwgcG9pbnRlckRpc2FibGVkOiB0cnVlLCByZWZlcmVuY2VFbGVtZW50OiBmbG93SXRlbUVsZW1lbnQsIG9mZnNldERpc3RhbmNlOiAtMSAqIChwYW5lbFdpZHRoIC0gMTApLCBvZmZzZXRTa2lkZGluZzogMjAwLCBsYWJlbDogbWVzc2FnZSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICB6SW5kZXg6IFwiMTAwXCIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGAke3BhbmVsV2lkdGggLSAyMH1weGBcbiAgICAgICAgICAgIH0gfSwgaChcImNhbGNpdGUtbm90aWNlXCIsIHsgc2NhbGU6IFwic1wiLCB3aWR0aDogXCJmdWxsXCIsIG9wZW46IHRydWUsIGNsb3NhYmxlOiAhY2xvc2VXaXRoT0ssIGljb246IGlzRXJyb3IgfHwgaXNXYXJuaW5nID8gXCJleGNsYW1hdGlvbi1tYXJrLXRyaWFuZ2xlXCIgOiBcImNoZWNrLWNpcmNsZVwiLCBraW5kOiBpc0Vycm9yID8gXCJkYW5nZXJcIiA6IGlzV2FybmluZyA/IFwid2FybmluZ1wiIDogXCJzdWNjZXNzXCIsIG9uQ2FsY2l0ZU5vdGljZUNsb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdNc2dDbG9zZWQuZW1pdCgpO1xuICAgICAgICAgICAgfSB9LCBoKFwiZGl2XCIsIHsgc2xvdDogXCJ0aXRsZVwiIH0sIGlzRXJyb3IgPyBzdHJpbmdzLm1zZy5lcnJvciA6IGlzV2FybmluZyA/IHN0cmluZ3MubXNnLndhcm5pbmcgOiBzdHJpbmdzLm1zZy5zdWNjZXNzKSwgaChcImRpdlwiLCB7IHNsb3Q6IFwibWVzc2FnZVwiLCByZWY6IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gbXVzdCB1c2UgZGl2IGFuZCByZWYsIG90aGVyd2lzZSA8Yj4gaW5zaWRlIHRoZSBzdHJpbmcgZG9lc24ndCB3b3JrXG4gICAgICAgICAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfSB9KSwgY2xvc2VXaXRoT0sgJiYgKGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IGFwcGVhcmFuY2U6IFwidHJhbnNwYXJlbnRcIiwgc2xvdDogXCJhY3Rpb25zLWVuZFwiLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdNc2dDbG9zZWQuZW1pdCgpO1xuICAgICAgICAgICAgfSwgcmVmOiAobm9kZSkgPT4gKHRoaXMub2tOb2RlID0gbm9kZSkgfSwgc3RyaW5ncy5tc2cub2spKSkpKSk7XG4gICAgfVxuICAgIGdldCBob3N0RWxlbWVudCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbn07XG5cbmNvbnN0IENTUyQyID0ge1xuICAgIGZsb3c6IFwiZmxvd1wiLFxuICAgIHBhbmVsOiBcInBhbmVsXCIsXG4gICAgaW5mbzogXCJpbmZvXCIsXG4gICAgaW5mb0Rlc2NyaXB0aW9uOiBcImluZm8tZGVzY3JpcHRpb25cIixcbiAgICBoYXNEZWZpbml0aW9uSWNvbjogXCJoYXMtZGVmaW5pdGlvbi1pY29uXCIsXG4gICAgZGVmaW5pdGlvbkljb246IFwiZGVmaW5pdGlvbi1pY29uXCIsXG4gICAgZm9vdGVyOiBcImZvb3RlclwiLFxuICAgIGZvb3RlclRvcDogXCJmb290ZXItdG9wXCJcbn07XG5cbmNvbnN0IGFyY2dpc0xheWVyVmlld092ZXJ2aWV3Q3NzID0gXCIuZmxvdy5zYy1hcmNnaXMtbGF5ZXItdmlldy1vdmVydmlld3toZWlnaHQ6MTAwJX0ucGFuZWwuc2MtYXJjZ2lzLWxheWVyLXZpZXctb3ZlcnZpZXd7aGVpZ2h0OjEwMCV9LmluZm8uc2MtYXJjZ2lzLWxheWVyLXZpZXctb3ZlcnZpZXd7ZGlzcGxheTpncmlkO2dyaWQtdGVtcGxhdGUtY29sdW1uczpyZXBlYXQoMSwgbWlubWF4KDBweCwgMWZyKSk7Z2FwOjAuNXJlbTtwb2ludGVyLWV2ZW50czpub25lO3BhZGRpbmc6MXJlbSAwLjc1cmVtfS5pbmZvLWRlc2NyaXB0aW9uLnNjLWFyY2dpcy1sYXllci12aWV3LW92ZXJ2aWV3e2ZvbnQtc2l6ZTp2YXIoLS1jYWxjaXRlLWZvbnQtc2l6ZS0tMik7bGluZS1oZWlnaHQ6MS4zNzU7Y29sb3I6dmFyKC0tY2FsY2l0ZS1jb2xvci10ZXh0LTMpO3RyYW5zaXRpb24tZHVyYXRpb246MTUwbXM7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTtwb2ludGVyLWV2ZW50czpub25lfS5oYXMtZGVmaW5pdGlvbi1pY29uLnNjLWFyY2dpcy1sYXllci12aWV3LW92ZXJ2aWV3e2NvbG9yOnZhcigtLWNhbGNpdGUtY29sb3ItYm9yZGVyLTEpO2N1cnNvcjpwb2ludGVyfS5kZWZpbml0aW9uLWljb24uc2MtYXJjZ2lzLWxheWVyLXZpZXctb3ZlcnZpZXd7Y29sb3I6dmFyKC0tY2FsY2l0ZS1jb2xvci10ZXh0LTIpO2N1cnNvcjpwb2ludGVyfS5mb290ZXIuc2MtYXJjZ2lzLWxheWVyLXZpZXctb3ZlcnZpZXd7d2lkdGg6MTAwJX0uZm9vdGVyLXRvcC5zYy1hcmNnaXMtbGF5ZXItdmlldy1vdmVydmlld3tkaXNwbGF5OmZsZXh9XCI7XG5cbmNvbnN0IEFyY2dpc0xheWVyVmlld092ZXJ2aWV3ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdTdGF0dXNDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0xheWVyVmlld1N0YXR1c0NoYW5nZVwiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdPdmVydmlld1VwZGF0ZWQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0xheWVyVmlld092ZXJ2aWV3VXBkYXRlZFwiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdPdmVydmlld0NhbmNlbCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzTGF5ZXJWaWV3T3ZlcnZpZXdDYW5jZWxcIiwgNyk7XG4gICAgICAgIHRoaXMubGlzdEl0ZW1Ob2RlcyA9IFtdO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvL1xuICAgICAgICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMuZ29CYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdTdGF0dXNDaGFuZ2UuZW1pdCh7IHN0YXR1czogZmxvd1N0YXR1cy5TRUxFQ1RJT04gfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ29OZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdTdGF0dXNDaGFuZ2UuZW1pdCh7IHN0YXR1czogZmxvd1N0YXR1cy5DUkVBVEUgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ29VcGRhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBob3N0RWxlbWVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgICAgICBjb25zdCBzaG93U3VjY2Vzc01zZyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYXJjZ2lzLWxheWVyLXZpZXctbXNnXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZS5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZS5mbG93SXRlbUVsZW1lbnQgPSB0aGlzLmZsb3dJdGVtTm9kZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUubWVzc2FnZSA9IHN0cmluZ3MubXNnLnVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgaG9zdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5tc2dOb2RlKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SG5kbCk7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0SG5kbCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRIbmRsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tc2dOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLm1zZ05vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdPdmVydmlld1VwZGF0ZWQuZW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgNzAwMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgaGFzQW55Q2hhbmdlcyA9IGhhc0NoYW5nZXMocHJvcHMpO1xuICAgICAgICAgICAgaWYgKCFoYXNBbnlDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgc2hvd1N1Y2Nlc3NNc2coKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdmlld1xuICAgICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZVZpZXcodGhpcy5wcm9wcyk7XG4gICAgICAgICAgICAgICAgLy8gbWF4LWFnZSBjYWNoZSBpcyAzMCBzZWM7IG1pZ2h0IG5vdCBnZXQgdGhlIGxhdGVzdFxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0TGF0ZXN0QWRtaW5TZXJ2aWNlSW5mbygpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNDaGFuZ2VzKHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdhaXQgdXAgdG8gMzAgc2VjIHdpdGggaW5jcmVhc2luZyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbWFrZSBvdGhlciBhZG1pblNlcnZpY2VJbmZvIHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgICAgIC8vIHVudGlsIHdlIHJlYWxseSBoYXZlIHRoZSBsYXRlc3RcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdhaXRUaW1lID0gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJ5QWdhaW4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5nZXRMYXRlc3RBZG1pblNlcnZpY2VJbmZvKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0NoYW5nZXModGhpcy5wcm9wcykgfHwgd2FpdFRpbWUgPiAzMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gZ2V0IGxhdGVzdCBzYXZlZCBBT0kgYmVjYXVzZSBpdCByb3VuZHMgY29vcmRpbmF0ZXMgd2hlbiBzYXZpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzLmFkbWluU2VydmljZUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXllcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mb3JFYWNoKGFzeW5jIChsYXllckluZm8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhb2lWYWx1ZSA9IChfZCA9IChfYyA9IChfYiA9IChfYSA9IGxheWVySW5mby5hZG1pbkxheWVySW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZpZXdMYXllckRlZmluaXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50YWJsZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZpbHRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW9pVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFZpZXdMYXllclByb3BzKGxheWVySW5mby5pZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFvaTogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhb2lWYWx1ZS5nZW9tZXRyeSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FpdFRpbWUgKj0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRyeUFnYWluLCB3YWl0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodHJ5QWdhaW4sIHdhaXRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2hvd1N1Y2Nlc3NNc2coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiY291bGQgbm90IGNyZWF0ZSB2aWV3XCIsIGUpO1xuICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhcmNnaXMtbGF5ZXItdmlldy1tc2dcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlLnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlLmZsb3dJdGVtRWxlbWVudCA9IHRoaXMuZmxvd0l0ZW1Ob2RlO1xuICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZS5pc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUubWVzc2FnZSA9IHN0cmluZ3MubXNnLnVwZGF0ZUZhaWxlZDtcbiAgICAgICAgICAgICAgICBob3N0RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLm1zZ05vZGUpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRIbmRsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRIbmRsID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZW91dEhuZGwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1zZ05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMubXNnTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCA3MDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nb0NhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3T3ZlcnZpZXdDYW5jZWwuZW1pdCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb3BzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZVJlbmRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgYXJjZ2lzTGF5ZXJWaWV3T3ZlcnZpZXdSZWZyZXNoSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBmbG93U3RhdHVzLk9WRVJWSUVXO1xuICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgfVxuICAgIGFyY2dpc0xheWVyVmlld01zZ0Nsb3NlZEhhbmRsZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGlmICh0aGlzLm1zZ05vZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1zZ05vZGUubWVzc2FnZSA9PT0gc3RyaW5ncy5tc2cudXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJjZ2lzTGF5ZXJWaWV3T3ZlcnZpZXdVcGRhdGVkLmVtaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5tc2dOb2RlKTtcbiAgICAgICAgICAgIHRoaXMubXNnTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SG5kbCk7XG4gICAgICAgIHRoaXMudGltZW91dEhuZGwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBMaWZlY3ljbGVcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHsgfVxuICAgIGFzeW5jIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMuYmFja0J1dHRvbk5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRGb2N1cygpOyB9KTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBSZW5kZXIgTWV0aG9kc1xuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcInJlbmRlciB2aWV3LW92ZXJ2aWV3XCIsIHByb3BzVG9TdHJpbmcodGhpcy5wcm9wcykpO1xuICAgICAgICBjb25zdCB7IHByb3BzLCBzdGF0dXMsIGxvYWRpbmcgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdmlld0l0ZW0sIGxheWVySXRlbSwgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHJ0bCA9IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCkgPT09IFwicnRsXCI7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCB7IGNsYXNzOiBcImNhbGNpdGUtbWF0Y2gtaGVpZ2h0XCIgfSwgaChcImNhbGNpdGUtZmxvd1wiLCB7IGNsYXNzOiBDU1MkMi5mbG93LCBkaXI6IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCkgfSwgaChcImNhbGNpdGUtZmxvdy1pdGVtXCIsIHsga2V5OiBzdGF0dXMsIGhlYWRpbmc6IHN0cmluZ3MuZ2VuZXJhbC5pbmNsdWRlZExheWVyUGFuZWxUaXRsZSwgZGVzY3JpcHRpb246ICh2aWV3SXRlbSA9PT0gbnVsbCB8fCB2aWV3SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlld0l0ZW0udGl0bGUpIHx8IChsYXllckl0ZW0gPT09IG51bGwgfHwgbGF5ZXJJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllckl0ZW0udGl0bGUpLCBsb2FkaW5nOiBsb2FkaW5nLCBjbGFzczoge1xuICAgICAgICAgICAgICAgIHBhbmVsOiB0cnVlLFxuICAgICAgICAgICAgICAgIFtDU1NfVVRJTElUWS5ydGxdOiBydGxcbiAgICAgICAgICAgIH0sIHJlZjogKG5vZGUpID0+ICh0aGlzLmZsb3dJdGVtTm9kZSA9IG5vZGUpIH0sIHRoaXMucmVuZGVyRm9vdGVyQnV0dG9ucygpLCB0aGlzLnJlbmRlckluZm8oKSwgdGhpcy5yZW5kZXJTdWJsYXllcnMoKSksIFtmbG93U3RhdHVzLkRFRklOSVRJT04sIGZsb3dTdGF0dXMuRklMVEVSXS5pbmNsdWRlcyhzdGF0dXMpXG4gICAgICAgICAgICA/IHRoaXMucmVuZGVyTGF5ZXJEZWZpbml0aW9uKClcbiAgICAgICAgICAgIDogbnVsbCkpKTtcbiAgICB9XG4gICAgcmVuZGVyRm9vdGVyQnV0dG9ucygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB2aWV3SXRlbSB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IHNsb3Q6IFwiZm9vdGVyXCIsIGNsYXNzOiBDU1MkMi5mb290ZXIgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkMi5mb290ZXJUb3AgfSwgdGhpcy5yZW5kZXJCYWNrKCksIHZpZXdJdGVtID8gdGhpcy5yZW5kZXJVcGRhdGUoKSA6IHRoaXMucmVuZGVyTmV4dCgpKSwgdmlld0l0ZW0gPyB0aGlzLnJlbmRlckNhbmNlbCgpIDogbnVsbCkpO1xuICAgIH1cbiAgICByZW5kZXJCYWNrKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBpc1J0bCA9IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCkgPT09IFwicnRsXCI7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgc2xvdDogXCJmb290ZXJcIiwgb25DbGljazogdGhpcy5nb0JhY2ssIGFwcGVhcmFuY2U6IFwib3V0bGluZS1maWxsXCIsIHdpZHRoOiBcImhhbGZcIiwgXCJpY29uLXN0YXJ0XCI6IGlzUnRsID8gXCJhcnJvdy1yaWdodFwiIDogXCJhcnJvdy1sZWZ0XCIsIHJlZjogKG5vZGUpID0+ICh0aGlzLmJhY2tCdXR0b25Ob2RlID0gbm9kZSkgfSwgc3RyaW5ncy5nZW5lcmFsLmJhY2spKTtcbiAgICB9XG4gICAgcmVuZGVyTmV4dCgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgaXNSdGwgPSBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpID09PSBcInJ0bFwiO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IHNsb3Q6IFwiZm9vdGVyXCIsIG9uQ2xpY2s6IHRoaXMuZ29OZXh0LCBhcHBlYXJhbmNlOiBcInNvbGlkXCIsIHdpZHRoOiBcImhhbGZcIiwgaWNvbkVuZDogaXNSdGwgPyBcImFycm93LWxlZnRcIiA6IFwiYXJyb3ctcmlnaHRcIiwgcmVmOiAobm9kZSkgPT4gKHRoaXMubmV4dEJ1dHRvbk5vZGUgPSBub2RlKSB9LCBzdHJpbmdzLmdlbmVyYWwubmV4dCkpO1xuICAgIH1cbiAgICByZW5kZXJVcGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgc2xvdDogXCJmb290ZXJcIiwgb25DbGljazogdGhpcy5nb1VwZGF0ZSwgYXBwZWFyYW5jZTogXCJzb2xpZFwiLCB3aWR0aDogXCJoYWxmXCIsIFwiaWNvbi1zdGFydFwiOiBcInBsdXMtc3F1YXJlXCIsIHJlZjogKG5vZGUpID0+ICh0aGlzLm5leHRCdXR0b25Ob2RlID0gbm9kZSkgfSwgc3RyaW5ncy5nZW5lcmFsLnVwZGF0ZSkpO1xuICAgIH1cbiAgICByZW5kZXJDYW5jZWwoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIsIGxheWVySWRzLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgZW5hYmxlZCA9IChsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXIubG9hZGVkKSAmJiBsYXllcklkcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgZGlzYWJsZWQ6ICFlbmFibGVkLCBvbkNsaWNrOiBlbmFibGVkICYmIHRoaXMuZ29DYW5jZWwsIGFwcGVhcmFuY2U6IFwidHJhbnNwYXJlbnRcIiwgd2lkdGg6IFwiZnVsbFwiIH0sIHN0cmluZ3MuZ2VuZXJhbC5jbG9zZSkpO1xuICAgIH1cbiAgICByZW5kZXJJbmZvKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogXCJpbmZvXCIgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkMi5pbmZvRGVzY3JpcHRpb24gfSwgc3RyaW5ncy5nZW5lcmFsLmluY2x1ZGVkTGF5ZXJQYW5lbERlc2NyaXB0aW9uKSkpO1xuICAgIH1cbiAgICByZW5kZXJTdWJsYXllcnMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIsIGxheWVySWRzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgbGlzdEl0ZW1zID0gW107XG4gICAgICAgIGlmIChsYXllci50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgICAgICAgIChfYSA9IGxheWVyLnRhYmxlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGx5cikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsYXllcklkcy5pbmNsdWRlcyhseXIubGF5ZXJJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdEl0ZW1zLnVuc2hpZnQodGhpcy5yZW5kZXJTdWJsYXllcihseXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIChfYiA9IGxheWVyLmxheWVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZvckVhY2goKGx5cikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsYXllcklkcy5pbmNsdWRlcyhseXIubGF5ZXJJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdEl0ZW1zLnVuc2hpZnQodGhpcy5yZW5kZXJTdWJsYXllcihseXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RJdGVtcy5wdXNoKHRoaXMucmVuZGVyU3VibGF5ZXIobGF5ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxpc3RcIiwgeyByZWY6IChub2RlKSA9PiAodGhpcy5saXN0Tm9kZSA9IG5vZGUpIH0sIGxpc3RJdGVtcykpO1xuICAgIH1cbiAgICByZW5kZXJTdWJsYXllcihmbCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBpc1J0bCA9IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCkgPT09IFwicnRsXCI7XG4gICAgICAgIGNvbnN0IHZpZXdMYXllclByb3BzID0gZ2V0Vmlld0xheWVyUHJvcHMoZmwubGF5ZXJJZCwgcHJvcHMpO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxpc3QtaXRlbVwiLCB7IGtleTogZmwubGF5ZXJJZCwgbGFiZWw6IGZsLnRpdGxlLCBkZXNjcmlwdGlvbjogZmwuaXNUYWJsZSA/IHN0cmluZ3MuZ2VuZXJhbC50YWJsZSA6IHN0cmluZ3MuZ2VuZXJhbC5sYXllciwgb25DbGljazogdGhpcy5nb0RlZmluaXRpb24uYmluZCh0aGlzLCBmbC5sYXllcklkKSwgcmVmOiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdEl0ZW1Ob2Rlc1tmbC5sYXllcklkXSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfSAvLyBub3Qgc3VyZSB3aHkgaXQncyBudWxsIHNvbWV0aW1lc1xuICAgICAgICAgICAgfSB9LCAhIXZpZXdMYXllclByb3BzID8gKGgoXCJjYWxjaXRlLWljb25cIiwgeyBjbGFzczogQ1NTJDIuaGFzRGVmaW5pdGlvbkljb24sIHNsb3Q6IFwiY29udGVudC1lbmRcIiwgaWNvbjogXCJzbGlkZXJzXCIsIHNjYWxlOiBcInNcIiB9KSkgOiBudWxsLCBoKFwiY2FsY2l0ZS1pY29uXCIsIHsgY2xhc3M6IENTUyQyLmRlZmluaXRpb25JY29uLCBzbG90OiBcImNvbnRlbnQtZW5kXCIsIGljb246IGlzUnRsID8gXCJjaGV2cm9uLWxlZnRcIiA6IFwiY2hldnJvbi1yaWdodFwiLCBzY2FsZTogXCJzXCIgfSkpKTtcbiAgICB9XG4gICAgcmVuZGVyTGF5ZXJEZWZpbml0aW9uKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBzdGF0dXMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgZGVmaW5pdGlvbkxheWVySWQgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gKGgoXCJhcmNnaXMtbGF5ZXItdmlldy1kZWZpbml0aW9uXCIsIHsga2V5OiBgZGVmaW5pdGlvbi0ke2RlZmluaXRpb25MYXllcklkfWAsIHByb3BzOiBwcm9wcywgc3RhdHVzOiBzdGF0dXMsIGNsYXNzOiBcImNhbGNpdGUtbWF0Y2gtaGVpZ2h0XCIsIG9uQXJjZ2lzTGF5ZXJWaWV3T3ZlclZpZXdSZWZyZXNoOiAoKSA9PiBzZXRUaW1lb3V0KCgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5saXN0SXRlbU5vZGVzW2RlZmluaXRpb25MYXllcklkXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7IH0sIDIwMCkgfSkpO1xuICAgIH1cbiAgICBnb0RlZmluaXRpb24obGF5ZXJJZCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGZsb3dTdGF0dXMuREVGSU5JVElPTjtcbiAgICAgICAgcHJvcHMuZGVmaW5pdGlvbkxheWVySWQgPSBsYXllcklkO1xuICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgfVxuICAgIGFzeW5jIGdldExhdGVzdEFkbWluU2VydmljZUluZm8oKSB7XG4gICAgICAgIHRoaXMucHJvcHMuYWRtaW5TZXJ2aWNlSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgYXdhaXQgZ2V0QWRtaW5TZXJ2aWNlSW5mbyQxKHRoaXMucHJvcHMsIHRydWUpO1xuICAgICAgICAvKiBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcInVwZGF0ZWQgdmlldyBhZG1pblNlcnZpY2VJbmZvXCIsXG4gICAgICAgICAgdGhpcy5wcm9wcy5hZG1pblNlcnZpY2VJbmZvPy5sYXllcnM/Lm1hcCgobHlyOiBhbnkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGlkOiBseXIuaWQsXG4gICAgICAgICAgICAgIG5hbWU6IGx5ci5uYW1lLFxuICAgICAgICAgICAgICBhZG1pbkxheWVySW5mb19maWx0ZXI6IGx5ci5hZG1pbkxheWVySW5mbz8udmlld0xheWVyRGVmaW5pdGlvbj8udGFibGU/LmZpbHRlcj8udmFsdWUsXG4gICAgICAgICAgICAgIHZpZXdEZWZpbml0aW9uUXVlcnk6IGx5ci52aWV3RGVmaW5pdGlvblF1ZXJ5LFxuICAgICAgICAgICAgICBmaWVsZHM6IGx5ci5maWVsZHMubWFwKChmaWVsZDogYW55KSA9PiBgJHtmaWVsZC5uYW1lfSAoJHtmaWVsZC52aXNpYmxlfSlgKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0aGlzLnByb3BzLmFkbWluU2VydmljZUluZm8/LnRhYmxlcz8ubWFwKChseXI6IGFueSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaWQ6IGx5ci5pZCxcbiAgICAgICAgICAgICAgbmFtZTogbHlyLm5hbWUsXG4gICAgICAgICAgICAgIHZpZXdEZWZpbml0aW9uUXVlcnk6IGx5ci52aWV3RGVmaW5pdGlvblF1ZXJ5LFxuICAgICAgICAgICAgICBmaWVsZHM6IGx5ci5maWVsZHMubWFwKChmaWVsZDogYW55KSA9PiBgJHtmaWVsZC5uYW1lfSAoJHtmaWVsZC52aXNpYmxlfSlgKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KVxuICAgICAgICApOyAqL1xuICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgfVxuICAgIGdldCBob3N0RWxlbWVudCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbn07XG5BcmNnaXNMYXllclZpZXdPdmVydmlldy5zdHlsZSA9IGFyY2dpc0xheWVyVmlld092ZXJ2aWV3Q3NzO1xuXG5jb25zdCBDU1MkMSA9IHtcbiAgICBmbG93OiBcImZsb3dcIixcbiAgICBwYW5lbDogXCJwYW5lbFwiLFxuICAgIGZvb3RlcjogXCJmb290ZXJcIixcbiAgICBpbmZvOiBcImluZm9cIixcbiAgICBpbmZvSGVhZGluZzogXCJpbmZvLWhlYWRpbmdcIixcbiAgICBpbmZvRGVzY3JpcHRpb246IFwiaW5mby1kZXNjcmlwdGlvblwiLFxuICAgIGZpeGVkTGlzdEl0ZW06IFwiZml4ZWQtbGlzdC1pdGVtXCJcbn07XG5cbmNvbnN0IGFyY2dpc0xheWVyVmlld1NlbGVjdGlvbkNzcyA9IFwiLmZsb3cuc2MtYXJjZ2lzLWxheWVyLXZpZXctc2VsZWN0aW9ue2hlaWdodDoxMDAlfS5wYW5lbC5zYy1hcmNnaXMtbGF5ZXItdmlldy1zZWxlY3Rpb257aGVpZ2h0OjEwMCV9LmZvb3Rlci5zYy1hcmNnaXMtbGF5ZXItdmlldy1zZWxlY3Rpb257d2lkdGg6MTAwJX0uaW5mby5zYy1hcmNnaXMtbGF5ZXItdmlldy1zZWxlY3Rpb257ZGlzcGxheTpncmlkO2dyaWQtdGVtcGxhdGUtY29sdW1uczpyZXBlYXQoMSwgbWlubWF4KDBweCwgMWZyKSk7Z2FwOjAuNXJlbTtwb2ludGVyLWV2ZW50czpub25lO3BhZGRpbmc6MXJlbSAwLjc1cmVtfS5pbmZvLWhlYWRpbmcuc2MtYXJjZ2lzLWxheWVyLXZpZXctc2VsZWN0aW9ue2ZvbnQtc2l6ZTp2YXIoLS1jYWxjaXRlLWZvbnQtc2l6ZS0tMSk7bGluZS1oZWlnaHQ6MS4zNzU7Y29sb3I6dmFyKC0tY2FsY2l0ZS1jb2xvci10ZXh0LTIpO3RyYW5zaXRpb24tZHVyYXRpb246MTUwbXM7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTtmb250LXdlaWdodDp2YXIoLS1jYWxjaXRlLWZvbnQtd2VpZ2h0LW1lZGl1bSk7cG9pbnRlci1ldmVudHM6bm9uZX0uaW5mby1kZXNjcmlwdGlvbi5zYy1hcmNnaXMtbGF5ZXItdmlldy1zZWxlY3Rpb257Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLS0yKTtsaW5lLWhlaWdodDoxLjM3NTtjb2xvcjp2YXIoLS1jYWxjaXRlLWNvbG9yLXRleHQtMyk7dHJhbnNpdGlvbi1kdXJhdGlvbjoxNTBtczt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO3BvaW50ZXItZXZlbnRzOm5vbmV9LmZpeGVkLWxpc3QtaXRlbS5zYy1hcmNnaXMtbGF5ZXItdmlldy1zZWxlY3Rpb257bWFyZ2luLWJvdHRvbToxMHB4fVwiO1xuXG5jb25zdCBBcmNnaXNMYXllclZpZXdTZWxlY3Rpb24gPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld1N0YXR1c0NoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzTGF5ZXJWaWV3U3RhdHVzQ2hhbmdlXCIsIDcpO1xuICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld1NlbGVjdGlvbkNhbmNlbCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzTGF5ZXJWaWV3U2VsZWN0aW9uQ2FuY2VsXCIsIDcpO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvL1xuICAgICAgICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMuZ29OZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgbGF5ZXJJZHMgfSA9IHByb3BzO1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdTdGF0dXNDaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBmbG93U3RhdHVzLk9WRVJWSUVXLFxuICAgICAgICAgICAgICAgIGxheWVySWRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nb1N3YXBTb3VyY2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBsYXllcklkcyB9ID0gcHJvcHM7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld1N0YXR1c0NoYW5nZS5lbWl0KHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGZsb3dTdGF0dXMuU1dBUF9TT1VSQ0UsXG4gICAgICAgICAgICAgICAgbGF5ZXJJZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgaG9zdEVsZW1lbnQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGxheWVyLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgICAgIGNvbnN0IGxheWVySWRzID0gW107XG4gICAgICAgICAgICB0aGlzLmxpc3ROb2RlXG4gICAgICAgICAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYWxjaXRlLXBpY2stbGlzdC1pdGVtXCIpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBsYXllcklkcy5wdXNoKGl0ZW0udmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIudHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldExheWVyc0FuZFRhYmxlcyhsYXllcikuZmluZCgoc3ViTGF5ZXIpID0+IHN1YkxheWVyLmxheWVySWQgPT09IGl0ZW0udmFsdWUpLnZpc2libGUgPSBpdGVtLnNlbGVjdGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIudmlzaWJsZSA9IGl0ZW0uc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobGF5ZXJJZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5sYXllcklkcyA9IGxheWVySWRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBsYXllciBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhcmNnaXMtbGF5ZXItdmlldy1tc2dcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlLnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICAgICAgdGhpcy5tc2dOb2RlLmZsb3dJdGVtRWxlbWVudCA9IHRoaXMuZmxvd0l0ZW1Ob2RlO1xuICAgICAgICAgICAgICAgIHRoaXMubXNnTm9kZS5tZXNzYWdlID0gc3RyaW5ncy5tc2cuYXRMZWFzdE9uZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUuaXNXYXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBob3N0RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLm1zZ05vZGUpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRIbmRsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRIbmRsID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZW91dEhuZGwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1zZ05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMubXNnTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1zZ05vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCA3MDAwKTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGF0IGxhc3QgbGlzdCBpdGVtIGFnYWluXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0Tm9kZVxuICAgICAgICAgICAgICAgICAgICAucXVlcnlTZWxlY3RvckFsbChcImNhbGNpdGUtcGljay1saXN0LWl0ZW1cIilcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLmxheWVySWRzLmluZGV4T2YoaXRlbS52YWx1ZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVSZW5kZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgYXJjZ2lzTGF5ZXJWaWV3TXNnQ2xvc2VkSGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMubXNnTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5ob3N0RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLm1zZ05vZGUpO1xuICAgICAgICAgICAgdGhpcy5tc2dOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRIbmRsKTtcbiAgICAgICAgdGhpcy50aW1lb3V0SG5kbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgTGlmZWN5Y2xlXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7IH1cbiAgICBhc3luYyBjb21wb25lbnREaWRMb2FkKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGRlcml2YXRpdmVMYXllcnMgfSA9IHByb3BzO1xuICAgICAgICBpZiAoZGVyaXZhdGl2ZUxheWVycy5oYXNBbnkpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMuc3dhcEJ1dHRvbk5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRGb2N1cygpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMubGlzdE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRGb2N1cygpOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFJlbmRlciBNZXRob2RzXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwicmVuZGVyIHZpZXctc2VsZWN0aW9uXCIsIHByb3BzVG9TdHJpbmcodGhpcy5wcm9wcyksIFwic3RhdHVzOlwiLCB0aGlzLnN0YXR1cyk7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHN0YXR1cyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB2aWV3SXRlbSwgbGF5ZXJJdGVtLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgcnRsID0gZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSA9PT0gXCJydGxcIjtcbiAgICAgICAgcmV0dXJuIChoKEhvc3QsIHsgY2xhc3M6IFwiY2FsY2l0ZS1tYXRjaC1oZWlnaHRcIiB9LCBoKFwiY2FsY2l0ZS1mbG93XCIsIHsgY2xhc3M6IENTUyQxLmZsb3csIGRpcjogZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSB9LCBoKFwiY2FsY2l0ZS1mbG93LWl0ZW1cIiwgeyBoZWFkaW5nOiAodmlld0l0ZW0gPT09IG51bGwgfHwgdmlld0l0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZXdJdGVtLnRpdGxlKSB8fCAobGF5ZXJJdGVtID09PSBudWxsIHx8IGxheWVySXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXJJdGVtLnRpdGxlKSwgZGVzY3JpcHRpb246IHN0cmluZ3MuZ2VuZXJhbC5zb3VyY2VMYXllciwgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICBwYW5lbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbQ1NTX1VUSUxJVFkucnRsXTogcnRsXG4gICAgICAgICAgICB9LCByZWY6IChub2RlKSA9PiAodGhpcy5mbG93SXRlbU5vZGUgPSBub2RlKSB9LCB0aGlzLnJlbmRlckZvb3RlckJ1dHRvbnMoKSwgdGhpcy5yZW5kZXJJbmZvKCksIHRoaXMucmVuZGVyU3VibGF5ZXJzKCkpLCBbZmxvd1N0YXR1cy5TV0FQX1NPVVJDRSwgZmxvd1N0YXR1cy5CUk9XU0VfTEFZRVJdLmluY2x1ZGVzKHN0YXR1cylcbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJTd2FwU291cmNlKClcbiAgICAgICAgICAgIDogbnVsbCkpKTtcbiAgICB9XG4gICAgcmVuZGVyRm9vdGVyQnV0dG9ucygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsYXllciwgbGF5ZXJJZHMsIHZpZXdJdGVtLCBkZXJpdmF0aXZlTGF5ZXJzLCBoYXNSZXBsaWNhcywgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGlzUnRsID0gZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSA9PT0gXCJydGxcIjtcbiAgICAgICAgY29uc3QgaXNWZWxvY2l0eVZpZXcgPSAodmlld0l0ZW0gPT09IG51bGwgfHwgdmlld0l0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZXdJdGVtLnR5cGVLZXl3b3Jkcy5pbmRleE9mKFwiSW9URmVhdHVyZUxheWVyXCIpKSA+IC0xO1xuICAgICAgICBjb25zdCBoYXNTd2FwUmlnaHRzID0gIWlzVmVsb2NpdHlWaWV3ICYmIFtcImFkbWluXCIsIFwidXBkYXRlXCJdLmluZGV4T2Yodmlld0l0ZW0gPT09IG51bGwgfHwgdmlld0l0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZXdJdGVtLml0ZW1Db250cm9sKSA+IC0xO1xuICAgICAgICBjb25zdCBuZXh0RW5hYmxlZCA9IChsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXIubG9hZGVkKSAmJiBsYXllcklkcy5sZW5ndGggJiYgIWRlcml2YXRpdmVMYXllcnMuaGFzQW55O1xuICAgICAgICBpZiAoaGFzU3dhcFJpZ2h0cyAmJiBkZXJpdmF0aXZlTGF5ZXJzLmhhc0FueSkge1xuICAgICAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgc2xvdDogXCJmb290ZXJcIiwgY2xhc3M6IFwiZm9vdGVyXCIgfSwgaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgb25DbGljazogIWhhc1JlcGxpY2FzICYmIHRoaXMuZ29Td2FwU291cmNlLCBkaXNhYmxlZDogaGFzUmVwbGljYXMsIGFwcGVhcmFuY2U6IFwic29saWRcIiwgd2lkdGg6IFwiZnVsbFwiLCBpY29uU3RhcnQ6IFwiYXJyb3ctcmlnaHQtbGVmdFwiLCByZWY6IChub2RlKSA9PiAodGhpcy5zd2FwQnV0dG9uTm9kZSA9IG5vZGUpIH0sIHN0cmluZ3MuZ2VuZXJhbC5zd2FwU291cmNlKSwgaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgb25DbGljazogKCkgPT4gdGhpcy5hcmNnaXNMYXllclZpZXdTZWxlY3Rpb25DYW5jZWwuZW1pdCgpLCBhcHBlYXJhbmNlOiBcInRyYW5zcGFyZW50XCIsIHdpZHRoOiBcImZ1bGxcIiB9LCBzdHJpbmdzLmdlbmVyYWwuY2xvc2UpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBzbG90OiBcImZvb3RlclwiLCBjbGFzczogXCJmb290ZXJcIiB9LCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBkaXNhYmxlZDogIW5leHRFbmFibGVkLCBvbkNsaWNrOiBuZXh0RW5hYmxlZCAmJiB0aGlzLmdvTmV4dCwgYXBwZWFyYW5jZTogXCJzb2xpZFwiLCB3aWR0aDogXCJmdWxsXCIsIGljb25FbmQ6IGlzUnRsID8gXCJhcnJvdy1sZWZ0XCIgOiBcImFycm93LXJpZ2h0XCIsIHJlZjogKG5vZGUpID0+ICh0aGlzLm5leHRCdXR0b25Ob2RlID0gbm9kZSkgfSwgc3RyaW5ncy5nZW5lcmFsLm5leHQpLCBoYXNTd2FwUmlnaHRzICYmIChoKFwiZGl2XCIsIG51bGwsIGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IGRpc2FibGVkOiAhbmV4dEVuYWJsZWQgfHwgaGFzUmVwbGljYXMsIG9uQ2xpY2s6IG5leHRFbmFibGVkICYmICFoYXNSZXBsaWNhcyAmJiB0aGlzLmdvU3dhcFNvdXJjZSwgYXBwZWFyYW5jZTogXCJ0cmFuc3BhcmVudFwiLCB3aWR0aDogXCJmdWxsXCIsIGljb25TdGFydDogXCJhcnJvdy1yaWdodC1sZWZ0XCIsIHJlZjogKG5vZGUpID0+ICh0aGlzLnN3YXBCdXR0b25Ob2RlID0gbm9kZSkgfSwgc3RyaW5ncy5nZW5lcmFsLnN3YXBTb3VyY2UpKSkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJJbmZvKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHZpZXdJdGVtLCBkZXJpdmF0aXZlTGF5ZXJzLCBoYXNSZXBsaWNhcywgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGhhc1N3YXBSaWdodHMgPSBbXCJhZG1pblwiLCBcInVwZGF0ZVwiXS5pbmRleE9mKHZpZXdJdGVtID09PSBudWxsIHx8IHZpZXdJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWV3SXRlbS5pdGVtQ29udHJvbCkgPiAtMTtcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IFwiaW5mb1wiIH0sIGRlcml2YXRpdmVMYXllcnMuaGFzQW55ID8gKGgoXCJjYWxjaXRlLW5vdGljZVwiLCB7IHNjYWxlOiBcInNcIiwgd2lkdGg6IFwiZnVsbFwiLCBvcGVuOiB0cnVlLCBpY29uOiBcImluZm9ybWF0aW9uXCIgfSwgaChcImRpdlwiLCB7IHNsb3Q6IFwibWVzc2FnZVwiIH0sIHN0cmluZ3MuZ2VuZXJhbC5kZXJpdmF0aXZlTGF5ZXJOb3RpY2UpKSkgOiBudWxsLCBoYXNSZXBsaWNhcyAmJiBoYXNTd2FwUmlnaHRzID8gKGgoXCJjYWxjaXRlLW5vdGljZVwiLCB7IHNjYWxlOiBcInNcIiwgd2lkdGg6IFwiZnVsbFwiLCBvcGVuOiB0cnVlLCBpY29uOiBcImluZm9ybWF0aW9uXCIgfSwgaChcImRpdlwiLCB7IHNsb3Q6IFwibWVzc2FnZVwiIH0sIHN0cmluZ3MuZ2VuZXJhbC5zZWxlY3RMYXllclBhbmVsUmVwbGljYU5vdGljZSkpKSA6IG51bGwsICFkZXJpdmF0aXZlTGF5ZXJzLmhhc0FueSA/IChoKFwiZGl2XCIsIG51bGwsIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDEuaW5mb0hlYWRpbmcgfSwgc3RyaW5ncy5nZW5lcmFsLnNlbGVjdExheWVyUGFuZWxUaXRsZSksIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDEuaW5mb0Rlc2NyaXB0aW9uIH0sIHN0cmluZ3MuZ2VuZXJhbC5zZWxlY3RMYXllclBhbmVsRGVzY3JpcHRpb24pKSkgOiBudWxsKSk7XG4gICAgfVxuICAgIHJlbmRlclN1YmxheWVycygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBkZXJpdmF0aXZlTGF5ZXJzIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKGRlcml2YXRpdmVMYXllcnMuaGFzQW55KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJOb25FZGl0YWJsZVN1YmxheWVycygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyRWRpdGFibGVTdWJsYXllcnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJOb25FZGl0YWJsZVN1YmxheWVycygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsYXllciwgbGF5ZXJJZHMsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBsYXllckxpc3RJdGVtcyA9IFtdO1xuICAgICAgICBjb25zdCB0YWJsZUxpc3RJdGVtcyA9IFtdO1xuICAgICAgICBpZiAobGF5ZXIudHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgICAgICAgICAoX2EgPSBsYXllci50YWJsZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChseXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXJJZHMuaW5kZXhPZihseXIubGF5ZXJJZCkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0YWJsZUxpc3RJdGVtcy51bnNoaWZ0KHRoaXMucmVuZGVyTm9uRWRpdGFibGVTdWJsYXllcihseXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIChfYiA9IGxheWVyLmxheWVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZvckVhY2goKGx5cikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsYXllcklkcy5pbmRleE9mKGx5ci5sYXllcklkKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyTGlzdEl0ZW1zLnVuc2hpZnQodGhpcy5yZW5kZXJOb25FZGl0YWJsZVN1YmxheWVyKGx5cikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKGxheWVyLmlzVGFibGUgPyB0YWJsZUxpc3RJdGVtcyA6IGxheWVyTGlzdEl0ZW1zKS5wdXNoKHRoaXMucmVuZGVyTm9uRWRpdGFibGVTdWJsYXllcihsYXllcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkMS5pbmZvIH0sIGxheWVyTGlzdEl0ZW1zLmxlbmd0aCA+IDAgPyAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkMS5pbmZvSGVhZGluZyB9LCBzdHJpbmdzLmdlbmVyYWwubGF5ZXJzKSkgOiBudWxsLCBsYXllckxpc3RJdGVtcy5sZW5ndGggPiAwID8gaChcInVsXCIsIG51bGwsIGxheWVyTGlzdEl0ZW1zKSA6IG51bGwsIHRhYmxlTGlzdEl0ZW1zLmxlbmd0aCA+IDAgPyAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkMS5pbmZvSGVhZGluZyB9LCBzdHJpbmdzLmdlbmVyYWwudGFibGVzKSkgOiBudWxsLCB0YWJsZUxpc3RJdGVtcy5sZW5ndGggPiAwID8gaChcInVsXCIsIG51bGwsIHRhYmxlTGlzdEl0ZW1zKSA6IG51bGwpKTtcbiAgICB9XG4gICAgcmVuZGVyTm9uRWRpdGFibGVTdWJsYXllcihseXIpIHtcbiAgICAgICAgcmV0dXJuIGgoXCJsaVwiLCB7IGNsYXNzOiBDU1MkMS5maXhlZExpc3RJdGVtIH0sIGx5ci50aXRsZSk7XG4gICAgfVxuICAgIHJlbmRlckVkaXRhYmxlU3VibGF5ZXJzKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGxheWVyIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgbGlzdEl0ZW1zID0gW107XG4gICAgICAgIGlmIChsYXllci50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgICAgICAgIChfYSA9IGxheWVyLnRhYmxlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGx5cikgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtcy51bnNoaWZ0KHRoaXMucmVuZGVyRWRpdGFibGVTdWJsYXllcihseXIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKF9iID0gbGF5ZXIubGF5ZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZm9yRWFjaCgobHlyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGlzdEl0ZW1zLnVuc2hpZnQodGhpcy5yZW5kZXJFZGl0YWJsZVN1YmxheWVyKGx5cikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaXN0SXRlbXMucHVzaCh0aGlzLnJlbmRlckVkaXRhYmxlU3VibGF5ZXIobGF5ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLXBpY2stbGlzdFwiLCB7IG11bHRpcGxlOiB0cnVlLCBvbkNhbGNpdGVMaXN0Q2hhbmdlOiB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLCByZWY6IChub2RlKSA9PiAodGhpcy5saXN0Tm9kZSA9IG5vZGUpIH0sIGxpc3RJdGVtcykpO1xuICAgIH1cbiAgICByZW5kZXJFZGl0YWJsZVN1YmxheWVyKGx5cikge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGxheWVySWRzLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1waWNrLWxpc3QtaXRlbVwiLCB7IGtleTogbHlyLmxheWVySWQsIGxhYmVsOiBseXIudGl0bGUsIHZhbHVlOiBseXIubGF5ZXJJZCwgZGVzY3JpcHRpb246IGx5ci5pc1RhYmxlID8gc3RyaW5ncy5nZW5lcmFsLnRhYmxlIDogc3RyaW5ncy5nZW5lcmFsLmxheWVyLCBzZWxlY3RlZDogbGF5ZXJJZHMuaW5kZXhPZihseXIubGF5ZXJJZCkgPiAtMSB9KSk7XG4gICAgfVxuICAgIHJlbmRlclN3YXBTb3VyY2UoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHN0YXR1cyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChoKFwiYXJjZ2lzLWxheWVyLXZpZXctc3dhcC1zb3VyY2VcIiwge1xuICAgICAgICAgICAgLy9rZXk9e2BzZWxlY3Rpb24tJHtzdGF0dXN9YH1cbiAgICAgICAgICAgIHByb3BzOiBwcm9wcywgc3RhdHVzOiBzdGF0dXMsIG9uQXJjZ2lzTGF5ZXJWaWV3U3RhdHVzQ2hhbmdlOiAoKSA9PiBzZXRUaW1lb3V0KCgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5mbG93SXRlbU5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRGb2N1cygpOyB9LCAyMDApXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZ2V0IGhvc3RFbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc0xheWVyVmlld1NlbGVjdGlvbi5zdHlsZSA9IGFyY2dpc0xheWVyVmlld1NlbGVjdGlvbkNzcztcblxuY29uc3QgQ1NTID0ge1xuICAgIHBhbmVsOiBcInBhbmVsXCIsXG4gICAgYnJvd3NlOiBcImJyb3dzZVwiLFxuICAgIGluZm86IFwiaW5mb1wiLFxuICAgIHRleHQ6IFwidGV4dFwiLFxuICAgIGNoZWNrOiBcImNoZWNrXCIsXG4gICAgY2hlY2tUZXh0OiBcImNoZWNrLXRleHRcIixcbiAgICBmb290ZXJCdXR0b246IFwiZm9vdGVyLWJ1dHRvblwiXG59O1xuXG5jb25zdCBhcmNnaXNMYXllclZpZXdTd2FwU291cmNlQ3NzID0gXCIucGFuZWwuc2MtYXJjZ2lzLWxheWVyLXZpZXctc3dhcC1zb3VyY2V7aGVpZ2h0OjEwMCV9LmJyb3dzZS5zYy1hcmNnaXMtbGF5ZXItdmlldy1zd2FwLXNvdXJjZXt3aWR0aDoxMDAlfS5pbmZvLnNjLWFyY2dpcy1sYXllci12aWV3LXN3YXAtc291cmNle21hcmdpbjoxMHB4fS50ZXh0LnNjLWFyY2dpcy1sYXllci12aWV3LXN3YXAtc291cmNle21hcmdpbi1ib3R0b206OHB4fS5jaGVjay5zYy1hcmNnaXMtbGF5ZXItdmlldy1zd2FwLXNvdXJjZXtjb2xvcjpncmVlbn0uY2hlY2stdGV4dC5zYy1hcmNnaXMtbGF5ZXItdmlldy1zd2FwLXNvdXJjZXtmb250LXdlaWdodDpib2xkfS5mb290ZXItYnV0dG9uLnNjLWFyY2dpcy1sYXllci12aWV3LXN3YXAtc291cmNle21hcmdpbjowIDEwcHggNXB4IDEwcHh9XCI7XG5cbmNvbnN0IEFyY2dpc0xheWVyVmlld1N3YXBTb3VyY2UgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld1N0YXR1c0NoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzTGF5ZXJWaWV3U3RhdHVzQ2hhbmdlXCIsIDcpO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvL1xuICAgICAgICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMub25CYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNMYXllclZpZXdTdGF0dXNDaGFuZ2UuZW1pdCh7IHN0YXR1czogZmxvd1N0YXR1cy5TRUxFQ1RJT04gfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ29Ccm93c2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0xheWVyVmlld1N0YXR1c0NoYW5nZS5lbWl0KHsgc3RhdHVzOiBmbG93U3RhdHVzLkJST1dTRV9MQVlFUiB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVSZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBMaWZlY3ljbGVcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyBjb21wb25lbnREaWRMb2FkKCkge1xuICAgICAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbm9yIHdvcmtpbmcgdGhlIHNlY29uZCB0aW1lLi4uXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5mbG93SXRlbU5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRGb2N1cygpOyB9KSwgMjAwKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBSZW5kZXIgTWV0aG9kc1xuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcInJlbmRlciBzd2FwLXNvdXJjZVwiLCBwcm9wc1RvU3RyaW5nKHRoaXMucHJvcHMpLCBcInN0YXR1c1wiLCB0aGlzLnN0YXR1cyk7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHN0YXR1cywgbG9hZGluZyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgcnRsID0gZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSA9PT0gXCJydGxcIjtcbiAgICAgICAgcmV0dXJuIChoKEhvc3QsIHsgY2xhc3M6IFwiY2FsY2l0ZS1tYXRjaC1oZWlnaHRcIiB9LCBoKFwiY2FsY2l0ZS1mbG93LWl0ZW1cIiwgeyBrZXk6IHN0YXR1cywgaGVhZGluZzogc3RyaW5ncy5zd2FwU291cmNlLnRpdGxlLCBkZXNjcmlwdGlvbjogc3RyaW5ncy5zd2FwU291cmNlLnN1YlRpdGxlLCBsb2FkaW5nOiBsb2FkaW5nLCBjbGFzczoge1xuICAgICAgICAgICAgICAgIHBhbmVsOiB0cnVlLFxuICAgICAgICAgICAgICAgIFtDU1NfVVRJTElUWS5ydGxdOiBydGxcbiAgICAgICAgICAgIH0sIG9uQ2FsY2l0ZUZsb3dJdGVtQmFjazogdGhpcy5vbkJhY2ssIHJlZjogKG5vZGUpID0+ICh0aGlzLmZsb3dJdGVtTm9kZSA9IG5vZGUpIH0sIHRoaXMucmVuZGVySW5mbygpLCB0aGlzLnJlbmRlckRlcml2YXRpdmVJbmZvKCksIHRoaXMucmVuZGVyQnJvd3NlKCkpLCBzdGF0dXMgPT09IGZsb3dTdGF0dXMuQlJPV1NFX0xBWUVSICYmIHRoaXMucmVuZGVyQnJvd3NlTGF5ZXIoKSkpO1xuICAgIH1cbiAgICByZW5kZXJJbmZvKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmluZm8gfSwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MudGV4dCB9LCBzdHJpbmdzLnN3YXBTb3VyY2UubXNnMSksIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLnRleHQgfSwgc3RyaW5ncy5zd2FwU291cmNlLm1zZzIpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGxheW91dDogXCJpbmxpbmVcIiB9LCBoKFwiY2FsY2l0ZS1pY29uXCIsIHsgaWNvbjogXCJjaGVja1wiLCBjbGFzczogQ1NTLmNoZWNrIH0pLCBoKFwic3BhblwiLCB7IGNsYXNzOiBDU1MuY2hlY2tUZXh0IH0sIHN0cmluZ3Muc3dhcFNvdXJjZS5yZXF1aXJlbWVudDEpKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBsYXlvdXQ6IFwiaW5saW5lXCIgfSwgaChcImNhbGNpdGUtaWNvblwiLCB7IGljb246IFwiY2hlY2tcIiwgY2xhc3M6IENTUy5jaGVjayB9KSwgaChcInNwYW5cIiwgeyBjbGFzczogQ1NTLmNoZWNrVGV4dCB9LCBzdHJpbmdzLnN3YXBTb3VyY2UucmVxdWlyZW1lbnQyKSksIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgbGF5b3V0OiBcImlubGluZVwiIH0sIGgoXCJjYWxjaXRlLWljb25cIiwgeyBpY29uOiBcImNoZWNrXCIsIGNsYXNzOiBDU1MuY2hlY2sgfSksIGgoXCJzcGFuXCIsIHsgY2xhc3M6IENTUy5jaGVja1RleHQgfSwgc3RyaW5ncy5zd2FwU291cmNlLnJlcXVpcmVtZW50MykpLCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy50ZXh0IH0sIHN0cmluZ3Muc3dhcFNvdXJjZS5tc2czKSkpO1xuICAgIH1cbiAgICByZW5kZXJEZXJpdmF0aXZlSW5mbygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBkZXJpdmF0aXZlTGF5ZXJzLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKCFkZXJpdmF0aXZlTGF5ZXJzLmhhc01TICYmICFkZXJpdmF0aXZlTGF5ZXJzLmhhc1ZUTCAmJiAhZGVyaXZhdGl2ZUxheWVycy5oYXNTY2VuZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5pbmZvIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLnRleHQgfSwgc3RyaW5ncy5zd2FwU291cmNlLmRlcml2YXRpdmVNc2cpKSk7XG4gICAgfVxuICAgIHJlbmRlckJyb3dzZSgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5mb290ZXJCdXR0b24gfSwgaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgaWQ6IFwiYXJjZ2lzLWxheWVyLXZpZXctc3dhcC1zb3VyY2UtYnJvd3NlXCIsIG9uQ2xpY2s6IHRoaXMuZ29Ccm93c2UsIGFwcGVhcmFuY2U6IFwib3V0bGluZS1maWxsXCIsIHdpZHRoOiBcImZ1bGxcIiwgcmVmOiAobm9kZSkgPT4gKHRoaXMuYnJvd3NlQnV0dG9uTm9kZSA9IG5vZGUpIH0sIHN0cmluZ3Muc3dhcFNvdXJjZS5icm93c2VGb3JMYXllcikpKTtcbiAgICB9XG4gICAgcmVuZGVyQnJvd3NlTGF5ZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoaChcImFyY2dpcy1sYXllci12aWV3LWJyb3dzZS1sYXllclwiLCB7IHByb3BzOiBwcm9wcywgY2xhc3M6IENTUy5icm93c2UsIG9uQXJjZ2lzTGF5ZXJWaWV3U3RhdHVzQ2hhbmdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGV0YWlsLnN0YXR1cyA9PT0gZmxvd1N0YXR1cy5TV0FQX1NPVVJDRSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYW4ndCBtYWtlIGl0IHdvcmsgd2l0aG91dCB1c2luZyBhbiBpZFxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBzZWVtcyB0aGUgd2hvbGUgY29tcG9uZW50IHJlbG9hZHMgZnJvbSBzY3JhdGNoIGFmdGVyIHRoaXMgc3RlcCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYXJjZ2lzLWxheWVyLXZpZXctc3dhcC1zb3VyY2UtYnJvd3NlXCIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Rm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgNDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IH0pKTtcbiAgICB9XG4gICAgZ2V0IGhvc3RFbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc0xheWVyVmlld1N3YXBTb3VyY2Uuc3R5bGUgPSBhcmNnaXNMYXllclZpZXdTd2FwU291cmNlQ3NzO1xuXG5leHBvcnQgeyBBcmNnaXNMYXllclZpZXckMSBhcyBhcmNnaXNfbGF5ZXJfdmlldywgQXJjZ2lzTGF5ZXJWaWV3QnJvd3NlTGF5ZXIgYXMgYXJjZ2lzX2xheWVyX3ZpZXdfYnJvd3NlX2xheWVyLCBBcmNnaXNMYXllclZpZXdDcmVhdGUkMSBhcyBhcmNnaXNfbGF5ZXJfdmlld19jcmVhdGUsIEFyY2dpc0xheWVyVmlld0RlZmluaXRpb24gYXMgYXJjZ2lzX2xheWVyX3ZpZXdfZGVmaW5pdGlvbiwgQXJjZ2lzTGF5ZXJWaWV3IGFzIGFyY2dpc19sYXllcl92aWV3X2pvaW4sIEFyY2dpc0xheWVyVmlld0pvaW5BZGRTZWxlY3Rpb24gYXMgYXJjZ2lzX2xheWVyX3ZpZXdfam9pbl9hZGRfc2VsZWN0aW9uLCBBcmNnaXNMYXllclZpZXdKb2luQnJvd3NlTGF5ZXIgYXMgYXJjZ2lzX2xheWVyX3ZpZXdfam9pbl9icm93c2VfbGF5ZXIsIEFyY2dpc0xheWVyVmlld0pvaW5Db25maWcgYXMgYXJjZ2lzX2xheWVyX3ZpZXdfam9pbl9jb25maWcsIEFyY2dpc0xheWVyVmlld0pvaW5DcmVhdGUgYXMgYXJjZ2lzX2xheWVyX3ZpZXdfam9pbl9jcmVhdGUsIEFyY2dpc0xheWVyVmlld0pvaW5UYXJnZXRTZWxlY3Rpb24gYXMgYXJjZ2lzX2xheWVyX3ZpZXdfam9pbl90YXJnZXRfc2VsZWN0aW9uLCBBcmNnaXNMYXllclZpZXdDcmVhdGUgYXMgYXJjZ2lzX2xheWVyX3ZpZXdfbXNnLCBBcmNnaXNMYXllclZpZXdPdmVydmlldyBhcyBhcmNnaXNfbGF5ZXJfdmlld19vdmVydmlldywgQXJjZ2lzTGF5ZXJWaWV3U2VsZWN0aW9uIGFzIGFyY2dpc19sYXllcl92aWV3X3NlbGVjdGlvbiwgQXJjZ2lzTGF5ZXJWaWV3U3dhcFNvdXJjZSBhcyBhcmNnaXNfbGF5ZXJfdmlld19zd2FwX3NvdXJjZSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmNnaXMtbGF5ZXItdmlld18xNC5lbnRyeS5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9ubHkgYWZ0ZXIgaXQgaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgbiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSBmbiAgICAtIGZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSBkZWxheSAtIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICovXG5jb25zdCBkZWJvdW5jZSA9IChmbiwgZGVsYXkpID0+IHtcbiAgICBsZXQgdGltZW91dDtcbiAgICBsZXQgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgZnVuY3Rpb24gZmx1c2goLi4uYXJncykge1xuICAgICAgICBzdGF0dXMgPSBcImZsdXNoZWRcIjtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52b2tlKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhdHVzID0gXCJpbnZva2VkXCI7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbCguLi5hcmdzKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiY2FuY2VsbGVkXCI7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG4gICAgY29uc3QgZGVib3VuY2VkID0gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFwiZmx1c2hlZFwiOlxuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnZva2VkXCI6XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNhbmNlbGxlZFwiOlxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgICBkZWJvdW5jZWQuaW52b2tlID0gaW52b2tlO1xuICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgZGVib3VuY2VkLmdldFN0YXR1cyA9IGdldFN0YXR1cztcbiAgICByZXR1cm4gZGVib3VuY2VkO1xufTtcbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9ubHkgYWZ0ZXIgbiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgdGhyb3R0bGUgPSAoZm4sIGRlbGF5KSA9PiB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTsgLy8gJCYgbWVhbnMgdGhlIHdob2xlIG1hdGNoZWQgc3RyaW5nXG59XG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbi8qKlxuICogU2V0IGEgbWluaW11bSB0aW1lIGZvciBhIHByb21pc2UgdG8gcmVzb2x2ZSAodXNlZnVsIGZvciBwcmV2ZW50aW5nIGZsYXNoIG9mIGxvYWRlcnMpXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1pbkRlbGF5KHByb21pc2UsIG1pbkRlbGF5KSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW3Byb21pc2UsIHRpbWVvdXQobWluRGVsYXkpXSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gaW5saW5lIHNldFRpbWVvdXQgYXMgYW4gYXdhaXQgaW4gYXN5bmMgZnVuY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXQobXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbmNvbnN0IGFycmF5VG9Mb29rdXBNYXAgPSAoZGF0YUFyciwgZ2V0S2V5QW5kSXRlbSkgPT4gT2JqZWN0LmZyb21FbnRyaWVzKChkYXRhQXJyIHx8IFtdKS5tYXAoKGl0ZW0pID0+IHtcbiAgICBjb25zdCB7IGtleSwgZGF0YSB9ID0gZ2V0S2V5QW5kSXRlbShpdGVtKTtcbiAgICByZXR1cm4gW2tleSwgZGF0YV07XG59KSk7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdHdvIGFycmF5cyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50c1xuICogYW5kIHdoZXRoZXIgdGhleSBjb250YWluIHRoZSBzYW1lIGVsZW1lbnRzXG4gKiByZWdhcmRsZXNzIG9mIG9yZGVyXG4gKi9cbmNvbnN0IGFycmF5c0FyZUVxdWl2YWxlbnQgPSAoYXJyMSwgYXJyMikgPT4gYXJyMS5sZW5ndGggPT09IGFycjIubGVuZ3RoICYmIGFycjEucmVkdWNlKChtZW1vLCBzdHIpID0+IG1lbW8gJiYgYXJyMi5pbmRleE9mKHN0cikgPiAtMSwgdHJ1ZSk7XG5mdW5jdGlvbiB1bmlxdWVCeShteUFyciwgZ2V0SXRlbUlkKSB7XG4gICAgY29uc3QgcmVzdWx0QXJyID0gW107XG4gICAgY29uc3QgbG9va3VwTWFwID0ge307XG4gICAgbXlBcnIuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IGdldEl0ZW1JZChpdGVtKTtcbiAgICAgICAgaWYgKGxvb2t1cE1hcFtpZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9va3VwTWFwW2lkXSA9IGl0ZW07XG4gICAgICAgICAgICByZXN1bHRBcnIucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRBcnI7XG59XG5mdW5jdGlvbiB1bmlxdWUobXlBcnIpIHtcbiAgICBjb25zdCBwcmltaXRpdmVzID0geyBib29sZWFuOiB7fSwgbnVtYmVyOiB7fSwgc3RyaW5nOiB7fSB9O1xuICAgIGNvbnN0IG9ianMgPSBbXTtcbiAgICByZXR1cm4gbXlBcnIuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgIGxldCB0eXBlID0gdHlwZW9mIGl0ZW07XG4gICAgICAgIGlmICh0eXBlIGluIHByaW1pdGl2ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVzW3R5cGVdLmhhc093blByb3BlcnR5KGl0ZW0pID8gZmFsc2UgOiAocHJpbWl0aXZlc1t0eXBlXVtpdGVtXSA9IHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9ianMuaW5kZXhPZihpdGVtKSA+PSAwID8gZmFsc2UgOiBvYmpzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IGNodW5rID0gKGFyciwgc2l6ZSkgPT4gWy4uLkFycmF5KE1hdGguY2VpbChhcnIubGVuZ3RoIC8gc2l6ZSkpXS5tYXAoKF8sIGkpID0+IGFyci5zbGljZShzaXplICogaSwgc2l6ZSArIHNpemUgKiBpKSk7XG5cbmV4cG9ydCB7IGFycmF5VG9Mb29rdXBNYXAgYXMgYSwgdW5pcXVlIGFzIGIsIHRocm90dGxlIGFzIGMsIGRlYm91bmNlIGFzIGQsIGVzY2FwZVJlZ0V4cCBhcyBlLCBhcnJheXNBcmVFcXVpdmFsZW50IGFzIGYsIGNodW5rIGFzIGcsIGlzRGVmaW5lZCBhcyBpLCBtaW5EZWxheSBhcyBtLCB0aW1lb3V0IGFzIHQsIHVuaXF1ZUJ5IGFzIHUgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb25hbC00NGRlOGZjZi5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGcgYXMgZ2V0UmVuZGVyaW5nUmVmLCBmIGFzIGZvcmNlVXBkYXRlIH0gZnJvbSAnLi9pbmRleC1lM2JmN2RhNy5qcyc7XG5cbmNvbnN0IGFwcGVuZFRvTWFwID0gKG1hcCwgcHJvcE5hbWUsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgaXRlbXMgPSBtYXAuZ2V0KHByb3BOYW1lKTtcbiAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICAgIG1hcC5zZXQocHJvcE5hbWUsIFt2YWx1ZV0pO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXRlbXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIGl0ZW1zLnB1c2godmFsdWUpO1xuICAgIH1cbn07XG5jb25zdCBkZWJvdW5jZSA9IChmbiwgbXMpID0+IHtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IDA7XG4gICAgICAgICAgICBmbiguLi5hcmdzKTtcbiAgICAgICAgfSwgbXMpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgcG9zc2libGUgZWxlbWVudCBpc0Nvbm5lY3RlZC5cbiAqIFRoZSBwcm9wZXJ0eSBtaWdodCBub3QgYmUgdGhlcmUsIHNvIHdlIGNoZWNrIGZvciBpdC5cbiAqXG4gKiBXZSB3YW50IGl0IHRvIHJldHVybiB0cnVlIGlmIGlzQ29ubmVjdGVkIGlzIG5vdCBhIHByb3BlcnR5LFxuICogb3RoZXJ3aXNlIHdlIHdvdWxkIHJlbW92ZSB0aGVzZSBlbGVtZW50cyBhbmQgd291bGQgbm90IHVwZGF0ZS5cbiAqXG4gKiBCZXR0ZXIgbGVhayBpbiBFZGdlIHRoYW4gdG8gYmUgdXNlbGVzcy5cbiAqL1xuY29uc3QgaXNDb25uZWN0ZWQgPSAobWF5YmVFbGVtZW50KSA9PiAhKCdpc0Nvbm5lY3RlZCcgaW4gbWF5YmVFbGVtZW50KSB8fCBtYXliZUVsZW1lbnQuaXNDb25uZWN0ZWQ7XG5jb25zdCBjbGVhbnVwRWxlbWVudHMgPSBkZWJvdW5jZSgobWFwKSA9PiB7XG4gICAgZm9yIChsZXQga2V5IG9mIG1hcC5rZXlzKCkpIHtcbiAgICAgICAgbWFwLnNldChrZXksIG1hcC5nZXQoa2V5KS5maWx0ZXIoaXNDb25uZWN0ZWQpKTtcbiAgICB9XG59LCAyMDAwKTtcbmNvbnN0IHN0ZW5jaWxTdWJzY3JpcHRpb24gPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnZXRSZW5kZXJpbmdSZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBpbiBhIHN0ZW5jaWwgcHJvamVjdCwgd2UgZG8gbm90aGluZy5cbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVhbGx5IGV4cG9ydGVkIGJ5IEBzdGVuY2lsL2NvcmUuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgZWxtc1RvVXBkYXRlID0gbmV3IE1hcCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3Bvc2U6ICgpID0+IGVsbXNUb1VwZGF0ZS5jbGVhcigpLFxuICAgICAgICBnZXQ6IChwcm9wTmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxtID0gZ2V0UmVuZGVyaW5nUmVmKCk7XG4gICAgICAgICAgICBpZiAoZWxtKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kVG9NYXAoZWxtc1RvVXBkYXRlLCBwcm9wTmFtZSwgZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiAocHJvcE5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZWxtc1RvVXBkYXRlLmdldChwcm9wTmFtZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBlbG1zVG9VcGRhdGUuc2V0KHByb3BOYW1lLCBlbGVtZW50cy5maWx0ZXIoZm9yY2VVcGRhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFudXBFbGVtZW50cyhlbG1zVG9VcGRhdGUpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICAgICAgZWxtc1RvVXBkYXRlLmZvckVhY2goKGVsbXMpID0+IGVsbXMuZm9yRWFjaChmb3JjZVVwZGF0ZSkpO1xuICAgICAgICAgICAgY2xlYW51cEVsZW1lbnRzKGVsbXNUb1VwZGF0ZSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbmNvbnN0IHVud3JhcCA9ICh2YWwpID0+ICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nID8gdmFsKCkgOiB2YWwpO1xuY29uc3QgY3JlYXRlT2JzZXJ2YWJsZU1hcCA9IChkZWZhdWx0U3RhdGUsIHNob3VsZFVwZGF0ZSA9IChhLCBiKSA9PiBhICE9PSBiKSA9PiB7XG4gICAgY29uc3QgdW53cmFwcGVkU3RhdGUgPSB1bndyYXAoZGVmYXVsdFN0YXRlKTtcbiAgICBsZXQgc3RhdGVzID0gbmV3IE1hcChPYmplY3QuZW50cmllcyh1bndyYXBwZWRTdGF0ZSAhPT0gbnVsbCAmJiB1bndyYXBwZWRTdGF0ZSAhPT0gdm9pZCAwID8gdW53cmFwcGVkU3RhdGUgOiB7fSkpO1xuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgICBkaXNwb3NlOiBbXSxcbiAgICAgICAgZ2V0OiBbXSxcbiAgICAgICAgc2V0OiBbXSxcbiAgICAgICAgcmVzZXQ6IFtdLFxuICAgIH07XG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gV2hlbiByZXNldHRpbmcgdGhlIHN0YXRlLCB0aGUgZGVmYXVsdCBzdGF0ZSBtYXkgYmUgYSBmdW5jdGlvbiAtIHVud3JhcCBpdCB0byBpbnZva2UgaXQuXG4gICAgICAgIC8vIG90aGVyd2lzZSwgdGhlIHN0YXRlIHdvbid0IGJlIHByb3Blcmx5IHJlc2V0XG4gICAgICAgIHN0YXRlcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoKF9hID0gdW53cmFwKGRlZmF1bHRTdGF0ZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KSk7XG4gICAgICAgIGhhbmRsZXJzLnJlc2V0LmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICB9O1xuICAgIGNvbnN0IGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICAgIC8vIENhbGwgZmlyc3QgZGlzcG9zZSBhcyByZXNldHRpbmcgdGhlIHN0YXRlIHdvdWxkXG4gICAgICAgIC8vIGNhdXNlIGxlc3MgdXBkYXRlcyA7KVxuICAgICAgICBoYW5kbGVycy5kaXNwb3NlLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldCA9IChwcm9wTmFtZSkgPT4ge1xuICAgICAgICBoYW5kbGVycy5nZXQuZm9yRWFjaCgoY2IpID0+IGNiKHByb3BOYW1lKSk7XG4gICAgICAgIHJldHVybiBzdGF0ZXMuZ2V0KHByb3BOYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldCA9IChwcm9wTmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBzdGF0ZXMuZ2V0KHByb3BOYW1lKTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSh2YWx1ZSwgb2xkVmFsdWUsIHByb3BOYW1lKSkge1xuICAgICAgICAgICAgc3RhdGVzLnNldChwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgaGFuZGxlcnMuc2V0LmZvckVhY2goKGNiKSA9PiBjYihwcm9wTmFtZSwgdmFsdWUsIG9sZFZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHN0YXRlID0gKHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyB7fVxuICAgICAgICA6IG5ldyBQcm94eSh1bndyYXBwZWRTdGF0ZSwge1xuICAgICAgICAgICAgZ2V0KF8sIHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldChwcm9wTmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3duS2V5cyhfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oc3RhdGVzLmtleXMoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhcyhfLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZXMuaGFzKHByb3BOYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQoXywgcHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2V0KHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgY29uc3Qgb24gPSAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBoYW5kbGVyc1tldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KGhhbmRsZXJzW2V2ZW50TmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IG9uQ2hhbmdlID0gKHByb3BOYW1lLCBjYikgPT4ge1xuICAgICAgICBjb25zdCB1blNldCA9IG9uKCdzZXQnLCAoa2V5LCBuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYihuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHVud3JhcCB0aGUgZGVmYXVsdFN0YXRlIGJlY2F1c2UgaXQgbWlnaHQgYmUgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG1pZ2h0IG5vdCBiZSBzZW5kaW5nIHRoZSByaWdodCByZXNldCB2YWx1ZS5cbiAgICAgICAgY29uc3QgdW5SZXNldCA9IG9uKCdyZXNldCcsICgpID0+IGNiKHVud3JhcChkZWZhdWx0U3RhdGUpW3Byb3BOYW1lXSkpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdW5TZXQoKTtcbiAgICAgICAgICAgIHVuUmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHVzZSA9ICguLi5zdWJzY3JpcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuc3VicyA9IHN1YnNjcmlwdGlvbnMucmVkdWNlKCh1bnN1YnMsIHN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5zZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbignc2V0Jywgc3Vic2NyaXB0aW9uLnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5nZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbignZ2V0Jywgc3Vic2NyaXB0aW9uLmdldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5yZXNldCkge1xuICAgICAgICAgICAgICAgIHVuc3Vicy5wdXNoKG9uKCdyZXNldCcsIHN1YnNjcmlwdGlvbi5yZXNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5kaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzLnB1c2gob24oJ2Rpc3Bvc2UnLCBzdWJzY3JpcHRpb24uZGlzcG9zZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuc3VicztcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gKCkgPT4gdW5zdWJzLmZvckVhY2goKHVuc3ViKSA9PiB1bnN1YigpKTtcbiAgICB9O1xuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHN0YXRlcy5nZXQoa2V5KTtcbiAgICAgICAgaGFuZGxlcnMuc2V0LmZvckVhY2goKGNiKSA9PiBjYihrZXksIG9sZFZhbHVlLCBvbGRWYWx1ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGdldCxcbiAgICAgICAgc2V0LFxuICAgICAgICBvbixcbiAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgIHVzZSxcbiAgICAgICAgZGlzcG9zZSxcbiAgICAgICAgcmVzZXQsXG4gICAgICAgIGZvcmNlVXBkYXRlLFxuICAgIH07XG59O1xuY29uc3QgcmVtb3ZlRnJvbUFycmF5ID0gKGFycmF5LCBpdGVtKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBhcnJheS5sZW5ndGgtLTtcbiAgICB9XG59O1xuXG5jb25zdCBjcmVhdGVTdG9yZSA9IChkZWZhdWx0U3RhdGUsIHNob3VsZFVwZGF0ZSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGNyZWF0ZU9ic2VydmFibGVNYXAoZGVmYXVsdFN0YXRlLCBzaG91bGRVcGRhdGUpO1xuICAgIG1hcC51c2Uoc3RlbmNpbFN1YnNjcmlwdGlvbigpKTtcbiAgICByZXR1cm4gbWFwO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlU3RvcmUgYXMgYyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC0wNTk1NmNhYi5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGMgYXMgY3JlYXRlU3RvcmUgfSBmcm9tICcuL2luZGV4LTA1OTU2Y2FiLmpzJztcblxuY29uc3QgaXRlbVByb3BlcnRpZXNTdG9yZSA9IGNyZWF0ZVN0b3JlKHtcbiAgICB0aXRsZTogXCJcIixcbiAgICBzbmlwcGV0OiBcIlwiLFxuICAgIHRhZ3M6IFtdLFxuICAgIGNhdGVnb3JpZXM6IFtdXG59KTtcbmNvbnN0IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUgPSBpdGVtUHJvcGVydGllc1N0b3JlLnN0YXRlO1xuXG5leHBvcnQgeyBpdGVtUHJvcGVydGllc1N0b3JlIGFzIGEsIGl0ZW1Qcm9wZXJ0aWVzU3RhdGUgYXMgaSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVtLXByb3BlcnRpZXMtMTA0OTFiMmUuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG52YXIgbG9jYWxTdG9yYWdlS2V5cztcbihmdW5jdGlvbiAobG9jYWxTdG9yYWdlS2V5cykge1xuICAgIGxvY2FsU3RvcmFnZUtleXNbXCJBUkNHSVNfQ09NUE9ORU5UX05PVElGSUNBVElPTlNcIl0gPSBcImFyY2dpc0NvbXBvbmVudF9ub3RpZmljYXRpb25zXCI7XG59KShsb2NhbFN0b3JhZ2VLZXlzIHx8IChsb2NhbFN0b3JhZ2VLZXlzID0ge30pKTtcbnZhciBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5cztcbihmdW5jdGlvbiAoYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXMpIHtcbiAgICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIkZFQVRVUkVfUkVEVUNUSU9OX1dBUk5JTkdfRElTTUlTU0VEXCJdID0gXCJhcmNnaXNfZmVhdHVyZV9yZWR1Y3Rpb25fd2FybmluZ19kaXNtaXNzZWRcIjtcbiAgICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIlBPUFVQX1dBUk5JTkdfRElTTUlTU0VEXCJdID0gXCJhcmNnaXNfcG9wdXBfd2FybmluZ19kaXNtaXNzZWRcIjtcbiAgICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIklOQ09NUEFUSUJMRV9WRUNUT1JfU1lNQk9MU19ESVNNSVNTRURcIl0gPSBcImFyY2dpc19zeW1ib2xfc3R5bGVyX2luY29tcGF0aWJsZV92ZWN0b3Jfc3ltYm9sc19kaXNtaXNzZWRcIjtcbiAgICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIkVGRkVDVFNfVElQX0RJU01JU1NFRFwiXSA9IFwiYXJjZ2lzX2VmZmVjdHNfdGlwX2Rpc21pc3NlZFwiO1xuICAgIGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzW1wiTEFZRVJfVklFV19ERUZJTklUSU9OX0RJU01JU1NFRFwiXSA9IFwiYXJjZ2lzX2xheWVyX3ZpZXdfZGVmaW5pdGlvbl9kaXNtaXNzZWRcIjtcbiAgICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIkxBWUVSX09WRVJSSURFX1NUQVRVU19USVBfRElTTUlTU0VEXCJdID0gXCJhcmNnaXNfbGF5ZXJfb3ZlcnJpZGVfc3RhdHVzX3RpcF9kaXNtaXNzZWRcIjtcbiAgICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIlNNQVJUX01BUFBJTkdfVElQMV9ESVNNSVNTRURcIl0gPSBcImFyY2dpc19zbWFydF9tYXBwaW5nX3RpcDFfZGlzbWlzc2VkXCI7XG4gICAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJTTUFSVF9NQVBQSU5HX1RJUDJfRElTTUlTU0VEXCJdID0gXCJhcmNnaXNfc21hcnRfbWFwcGluZ190aXAyX2Rpc21pc3NlZFwiO1xuICAgIGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzW1wiTEFZRVJfVklFV19KT0lOX1RJUF9ESVNNSVNTRURcIl0gPSBcImFyY2dpc19sYXllcl92aWV3X2pvaW5fdGlwX2Rpc21pc3NlZFwiO1xuICAgIGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzW1wiTVVMVElESU1FTlNJT05BTF9JTkZPX1RJUF9ESVNNSVNTRURcIl0gPSBcImFyY2dpc19tdWx0aWRpbWVuc2lvbmFsX2luZm9fdGlwX2Rpc21pc3NlZFwiO1xufSkoYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXMgfHwgKGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzID0ge30pKTtcbmNvbnN0IGdldExvY2FsU3RvcmFnZSA9IChsb2NhbFN0b3JhZ2VLZXkpID0+IHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0obG9jYWxTdG9yYWdlS2V5KTtcbn07XG5jb25zdCBzZXRMb2NhbFN0b3JhZ2UgPSAobG9jYWxTdG9yYWdlS2V5LCB2YWx1ZSkgPT4ge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGxvY2FsU3RvcmFnZUtleSwgdmFsdWUpO1xufTtcbmNvbnN0IGdldE9iamVjdExvY2FsU3RvcmFnZSA9IChsb2NhbFN0b3JhZ2VLZXkpID0+IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShnZXRMb2NhbFN0b3JhZ2UobG9jYWxTdG9yYWdlS2V5KSkgfHwge307XG59O1xuY29uc3Qgc2V0U2luZ2xlT2JqZWN0TG9jYWxTdG9yYWdlID0gKGxvY2FsU3RvcmFnZUtleSwga2V5VmFsdWVPYmplY3QpID0+IHtcbiAgICBjb25zdCBzZXRMb2NhbFN0b3JhZ2VWYWwgPSBnZXRPYmplY3RMb2NhbFN0b3JhZ2UobG9jYWxTdG9yYWdlS2V5KTtcbiAgICBzZXRMb2NhbFN0b3JhZ2VWYWxba2V5VmFsdWVPYmplY3Qua2V5XSA9IGtleVZhbHVlT2JqZWN0LnZhbHVlO1xuICAgIHNldExvY2FsU3RvcmFnZShsb2NhbFN0b3JhZ2VLZXksIEpTT04uc3RyaW5naWZ5KHNldExvY2FsU3RvcmFnZVZhbCkpO1xufTtcbmNvbnN0IGdldFNpbmdsZU9iamVjdExvY2FsU3RvcmFnZSA9IChsb2NhbFN0b3JhZ2VLZXksIG9iamVjdEtleSkgPT4ge1xuICAgIGNvbnN0IGdldExvY2FsU3RvcmFnZVZhbCA9IGdldE9iamVjdExvY2FsU3RvcmFnZShsb2NhbFN0b3JhZ2VLZXkpO1xuICAgIGlmIChnZXRMb2NhbFN0b3JhZ2VWYWwgPT09IG51bGwgfHwgZ2V0TG9jYWxTdG9yYWdlVmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXRMb2NhbFN0b3JhZ2VWYWwuaGFzT3duUHJvcGVydHkob2JqZWN0S2V5KSkge1xuICAgICAgICByZXR1cm4gZ2V0TG9jYWxTdG9yYWdlVmFsW29iamVjdEtleV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5cyBhcyBhLCBnZXRTaW5nbGVPYmplY3RMb2NhbFN0b3JhZ2UgYXMgZywgbG9jYWxTdG9yYWdlS2V5cyBhcyBsLCBzZXRTaW5nbGVPYmplY3RMb2NhbFN0b3JhZ2UgYXMgcyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbFN0b3JhZ2UtOWM0ZTdhM2EuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBjIGFzIGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeSB9IGZyb20gJy4vZG9tLTRkMzY3Njc3LmpzJztcbmltcG9ydCB7IGwgYXMgbGFuZ3VhZ2VNYXAgfSBmcm9tICcuL2xhbmd1YWdlVXRpbC1lZjBlNTRiMi5qcyc7XG5pbXBvcnQgeyBhIGFzIGdldEFzc2V0UGF0aCB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuXG4vLyBodHRwczovL21lZGl1bS5jb20vc3RlbmNpbC10cmlja3MvaW1wbGVtZW50aW5nLWludGVybmF0aW9uYWxpc2F0aW9uLWkxOG4td2l0aC1zdGVuY2lsLTVlNjU1OTU1NDExN1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlKGVsZW1lbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBjbG9zZXN0RWxlbWVudCA9IChfYSA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbGVtZW50LCBcIltsYW5nXVwiKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9jID0gKF9iID0gZWxlbWVudC5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAvLyBsYW5ndWFnZSBzZXQgYnkgdGhlIGNhbGxpbmcgYXBwbGljYXRpb24gb3IgYnJvd3Nlci4gZGVmYXVsdHMgdG8gZW5nbGlzaC5cbiAgICBjb25zdCBsYW5nID0gKChjbG9zZXN0RWxlbWVudCA9PT0gbnVsbCB8fCBjbG9zZXN0RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VzdEVsZW1lbnQubGFuZykgfHwgKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlblwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZykpIHtcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFwicnUtUlVcIiBtYXBzIHRvIFwicnVcIiB1c2UgY2FzZVxuICAgICAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcuc2xpY2UoMCwgMikpKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcuc2xpY2UoMCwgMikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZUludGwoZWxlbWVudCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIC8vIGl0J3MgT0sgaWYgd2UgZG9uJ3QgaGF2ZSB0aGUgNCBsZXR0ZXIgbGFuZ3VhZ2UgZmlsZSBmb3IgaXRcbiAgICAvLyA0IGxldHRlciBsYW5ndWFnZSBjb2RlIG5lZWRlZCBmb3IgZm9ybWF0dGluZyBudW1iZXJzXG4gICAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgLy8gbGFuZ3VhZ2Ugc2V0IGJ5IHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uIG9yIGJyb3dzZXIuIGRlZmF1bHRzIHRvIGVuZ2xpc2guXG4gICAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcuc2xpY2UoMCwgMikpKSB7XG4gICAgICAgICAgICAvLyB3ZSBzdXBwb3J0IHRoZSAyIGxldHRlciBjb2RlZCBsYW5ndWFnZVxuICAgICAgICAgICAgLy8gZS5nLiBpdC1DSCB2cyBpdFxuICAgICAgICAgICAgcmV0dXJuIGxhbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJlblwiO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzRm9yQ29tcG9uZW50KGNvbXBvbmVudE5hbWUsIGxvY2FsZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGZldGNoKGdldEFzc2V0UGF0aChgLi4vYXJjZ2lzLWFwcC1hc3NldHMvaTE4bi8ke2NvbXBvbmVudE5hbWV9LmkxOG4uJHtsb2NhbGV9Lmpzb25gKSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lm9rKVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0Lmpzb24oKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH0sICgpID0+IHJlamVjdCgpKTtcbiAgICB9KTtcbn1cbmNvbnN0IHN0cmluZ0NhY2hlID0ge307XG5mdW5jdGlvbiBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgbG9jYWxlKSB7XG4gICAgY29uc3QgaWQgPSBgJHtjb21wb25lbnROYW1lfSR7bG9jYWxlfWA7XG4gICAgaWYgKCFzdHJpbmdDYWNoZVtpZF0pIHtcbiAgICAgICAgc3RyaW5nQ2FjaGVbaWRdID0gZmV0Y2hMb2NhbGVTdHJpbmdzRm9yQ29tcG9uZW50KGNvbXBvbmVudE5hbWUsIGxvY2FsZSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdDYWNoZVtpZF07XG59XG4vKipcbiAqIEdldCBzdHJpbmdzIGFuZCBsYW5ndWFnZSBjb2Rlcy5cbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgMiBsYW5ndWFnZSBjb2Rlcy5cbiAqIFRoZSBmaXJzdCBvbmUgcmV0dXJucyBhIGNvZGUgdGhhdCdzIGFsc28gc3VwcG9ydGVkIGFzIGEgbGFuZ3VhZ2UgZmlsZS5cbiAqIFRoZSBzZWNvbmQgb25lIHJldHVybnMgYSBjb2RlIHdoZXJlIHRoZXJlIGlzIHN1cHBvcnQgZm9yIHRoZSBmaXJzdCAyIGxldHRlcnMgb2YgdGhlIGNvZGUgYXMgcGFydCBvZiBhIGxhbmd1YWdlIGZpbGUsXG4gKiBidXQgd2lsbCByZXR1cm4gdGhlIG9yaWdpbmFsIDQgbGV0dGVyIGNvZGUgZnJvbSB0aGUgcGFnZS5cbiAqIEUuZy4gRm9yIFwiaXQtY2hcIiBpdCB3aWxsIHJldHVybiBcIml0XCIgYXMgdGhlIGZpcnN0IGxhbmd1YWdlIGNvZGUgYW5kIFwiaXQtY2hcIiBhcyB0aGUgc2Vjb25kLlxuICogVGhlIHNlY29uZCBvbmUgaXMgcmVxdWlyZWQgZm9yIGVzcmkuaW50bC5zZXRMb2NhbGUoKSB0byBnZXQgdGhlIGNvcnJlY3QgZm9ybWF0dGluZy5cbiAqXG4gKiBJZiBhIHRhZ05hbWUgaXMgcHJvdmlkZWQgaXQgd2lsbCBvdmVyd2l0ZSB0aGUgZWxlbWVudCdzIHRhZ05hbWVcbiAqXG4gKiAgQHJldHVybiBbIHN0cmluZ3MsIGZpcnN0IGxhbmd1YWdlIGNvZGUsIHNlY29uZCBsYW5ndWFnZSBjb2RlXVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzKGVsZW1lbnQsIHRhZ05hbWUpIHtcbiAgICBjb25zdCBjb21wb25lbnROYW1lID0gdGFnTmFtZSB8fCBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjb21wb25lbnRMYW5ndWFnZSA9IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZShlbGVtZW50KTtcbiAgICBjb25zdCBjb21wb25lbnRMYW5ndWFnZUludGwgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpO1xuICAgIGxldCBzdHJpbmdzO1xuICAgIHRyeSB7XG4gICAgICAgIHN0cmluZ3MgPSBhd2FpdCBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgY29tcG9uZW50TGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYG5vIGxvY2FsZSBmb3IgJHtjb21wb25lbnROYW1lfSAoJHtjb21wb25lbnRMYW5ndWFnZX0pIGxvYWRpbmcgZGVmYXVsdCBsb2NhbGUgZW4uYCk7XG4gICAgICAgIHN0cmluZ3MgPSBhd2FpdCBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgXCJlblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtzdHJpbmdzLCBjb21wb25lbnRMYW5ndWFnZSwgY29tcG9uZW50TGFuZ3VhZ2VJbnRsXTtcbn1cblxuZXhwb3J0IHsgZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlIGFzIGEsIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MgYXMgZyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbGUtMDUwYjZkYjkuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5mdW5jdGlvbiBnZXRQb3J0YWxCYXNlVXJsKHBvcnRhbCkge1xuICAgIGNvbnN0IHsgY3VzdG9tQmFzZVVybCwgcG9ydGFsSG9zdG5hbWUsIHVybEtleSB9ID0gcG9ydGFsO1xuICAgIGNvbnN0IHsgcHJvdG9jb2wgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICBjb25zdCB1cmwgPSB1cmxLZXkgPyBgJHt1cmxLZXl9LiR7Y3VzdG9tQmFzZVVybH1gIDogcG9ydGFsSG9zdG5hbWU7XG4gICAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHt1cmx9YDtcbn1cblxuZXhwb3J0IHsgZ2V0UG9ydGFsQmFzZVVybCBhcyBnIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcnRhbC02NjBiYjQzYS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=