"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-e1f0d3"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-lazy-loading-list.entry.js":
/*!***************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-lazy-loading-list.entry.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_lazy_loading_list: () => (/* binding */ ArcgisLazyLoadingList)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */






const arcgisLazyLoadingListCss = ":host{display:flex;flex-direction:column;overflow:hidden}.pop-menu{display:flex;flex-direction:column;position:absolute;max-height:100%;width:100%;overflow-y:hidden;border:1px solid var(--calcite-color-border-3)}.pop-menu.pop-menu-flyout{top:0px;left:0px;z-index:100}.pop-list{overflow-y:scroll}";

const ArcgisLazyLoadingList = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisLazyLoadingListChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLazyLoadingListChange", 7);
        this.hasSelectedScrolled = false;
        this.suspendObserver = false;
        this.scrollingDown = true;
        // TODO: dom query actual height (48 + 8) to reduce scroll when the list is very short
        this.filterHeight = 56;
        this.itemHeight = 32.5;
        this.itemHeightAdjusted = false;
        this.listChange = async () => {
            const selectedValues = await this.refListNode.getSelectedItems();
            // risk of 2 when filter is used and the pick list is updated frequently
            // this was found during dev, it's probably no longer the case.
            const selectedValue = [...selectedValues.keys()].pop();
            const selectedIndex = this.list.findIndex(({ value }) => value === selectedValue);
            this.arcgisLazyLoadingListChange.emit({
                selectedValue,
                selectedIndex
            });
        };
        this.updateFilter = (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.d)(() => {
            const filteredItems = this.refFilterNode
                .filteredItems;
            if (!filteredItems.length) {
                return;
            }
            const set = new Set(filteredItems.map(({ label }) => label));
            this.suspendObserver = true;
            this.filterList = this.list.filter(({ label }) => set.has(label));
            this.pageRanges = [0, 1];
            this.pageId = 0;
        }, 100);
        this.list = undefined;
        this.popoverProps = undefined;
        this.selectedIndex = 0;
        this.strings = undefined;
        this.showFilter = false;
        this.pageSize = 500;
        this.accumulatePages = true;
        this.position = "auto";
        this.pageBufferSize = 10;
        this.flyOut = false;
        this.listType = "pick-list";
        this.pageId = 0;
        this.filterList = undefined;
    }
    watchSelectedIndex(newValue) {
        this.updatePageId(newValue);
    }
    watchList(newValue) {
        // reset locked "auto" position
        this.listLabels = newValue.map(({ label }) => ({ label }));
        this.lockedMenuPosition = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentWillLoad() {
        this.listLabels = this.list.map(({ label }) => ({ label }));
        const pageIdMax = Math.floor(this.list.length / this.pageSize);
        if (pageIdMax < 2) {
            return;
        }
        this.updatePageId();
        this.setupObserver(pageIdMax);
    }
    componentDidRender() {
        // manipulate dom style at most once when initial item height is not accurate
        // TODO: delay auto menu position lock until item height adjustment
        if (this.flyOut && !this.itemHeightAdjusted && this.refSelectedNode) {
            const itemHeight = this.refSelectedNode.getBoundingClientRect().height;
            if (this.itemHeight !== itemHeight) {
                this.itemHeight = itemHeight;
                const { height, translateX, translateY } = this.getListPosition();
                this.refMenuNode.style.height = `${height}px`;
                this.refMenuNode.style.transform = `translate(${translateX}px, ${translateY}px)`;
            }
            this.itemHeightAdjusted = true;
        }
        requestAnimationFrame(() => {
            // scroll (at most once) selected node into view
            if (!this.hasSelectedScrolled && this.refSelectedNode) {
                this.refSelectedNode.scrollIntoView();
                this.hasSelectedScrolled = true;
            }
            // scroll anchor nodes when needed
            if (this.pendingScroll) {
                this.pendingScroll();
            }
            requestAnimationFrame(() => {
                // start observing after scrolling
                const { observer, refFirstnode, refLastnode } = this;
                if (observer) {
                    this.suspendObserver = false;
                    refFirstnode && observer.observe(refFirstnode);
                    refLastnode && observer.observe(refLastnode);
                }
            });
        });
    }
    disconnectedCallback() {
        var _a;
        (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        var _a, _b;
        this.suspendObserver = true;
        let style;
        if (this.flyOut) {
            const { width, height, translateX, translateY } = this.getListPosition();
            // todo: refine translateY when it's drop-up and the list is short
            style = {
                width: `${width}px`,
                height: `${height}px`,
                transform: this.flyOut && `translate(${translateX}px, ${translateY}px)`
            };
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: this.flyOut && "js-app-flyout" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: this.flyOut ? "pop-menu pop-menu-flyout" : "pop-menu", style: style, ref: (node) => (this.refMenuNode = node) }, this.showFilter && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-filter", { items: this.listLabels, messageOverrides: {
                clear: (_a = this.strings) === null || _a === void 0 ? void 0 : _a.clearFilter,
                label: (_b = this.strings) === null || _b === void 0 ? void 0 : _b.filterLabel
            }, onCalciteFilterChange: this.updateFilter, ref: (node) => (this.refFilterNode = node) }))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pop-list" }, this.renderList()))));
    }
    renderList() {
        const { pageBufferSize } = this;
        const halfPageBufferSize = Math.floor(pageBufferSize / 2);
        const subList = this.getSubList();
        const selectionId = this.getSelectedIndex();
        const selectedItem = this.list[selectionId];
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-pick-list", { dir: (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement), ref: (node) => {
                if (this.refListNode) {
                    this.refListNode.removeEventListener("calciteListChange", this.listChange);
                }
                node.addEventListener("calciteListChange", this.listChange);
                this.refListNode = node;
            }, multiple: false, filterEnabled: false }, subList.map(({ value, label }, i) => (
        // TODO: this could be refactored to take an external render method, similar to renderRow in DGrid
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-pick-list-item", { value: value, label: label, key: label, selected: value === selectedItem.value, ref: !this.hasSelectedScrolled && label === selectedItem.label
                ? (node) => {
                    this.refSelectedNode = node;
                }
                : i === subList.length - halfPageBufferSize
                    ? (node) => {
                        var _a;
                        if (node) {
                            this.refLastnode && ((_a = this.observer) === null || _a === void 0 ? void 0 : _a.unobserve(this.refLastnode));
                            this.refLastnode = node;
                        }
                    }
                    : i === subList.length - pageBufferSize
                        ? (node) => {
                            if (node) {
                                this.refSecondLastnode = node;
                            }
                        }
                        : i === halfPageBufferSize
                            ? (node) => {
                                var _a;
                                if (node) {
                                    this.refFirstnode && ((_a = this.observer) === null || _a === void 0 ? void 0 : _a.unobserve(this.refFirstnode));
                                    this.refFirstnode = node;
                                }
                            }
                            : i === pageBufferSize
                                ? (node) => {
                                    if (node) {
                                        this.refSecondnode = node;
                                    }
                                }
                                : null })))));
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    getSelectedIndex(value = this.selectedIndex) {
        return value >= this.list.length ? 0 : value;
    }
    getListPosition() {
        const { width, left: translateX, top, bottom, containerTop, containerBottom } = this.popoverProps;
        const list = this.filterList || this.list;
        const listHeight = this.itemHeight * list.length + (this.showFilter ? this.filterHeight : 0);
        const clientHeight = containerBottom > bottom ? containerBottom : document.body.clientHeight;
        const spaceBottom = clientHeight - bottom;
        const spaceTop = top - containerTop;
        // autoPosition is only initialized once per list, so it doesn't flip when filterList changes
        if (!this.lockedMenuPosition) {
            if (this.position === "auto") {
                // allow a third of the list to be scrolled, or goden ratio
                this.lockedMenuPosition =
                    listHeight * 1.5 <= spaceBottom || spaceTop / (spaceTop + spaceBottom) < 0.618
                        ? "down"
                        : "up";
            }
            else {
                this.lockedMenuPosition = this.position === "down" ? "down" : "up";
            }
        }
        const isDropdown = this.lockedMenuPosition === "down";
        const height = isDropdown
            ? Math.min(listHeight, spaceBottom - 2)
            : Math.min(listHeight, spaceTop - 2);
        const translateY = isDropdown ? bottom : Math.max(containerTop, top - height);
        return { width, height, translateX, translateY };
    }
    getSubList() {
        const useAccumulatedPageId = !!(this.accumulatePages && this.pageRanges);
        const firstId = useAccumulatedPageId ? Math.min(this.pageRanges[0], this.pageId) : this.pageId;
        const lastId = useAccumulatedPageId
            ? Math.max(this.pageRanges[1], this.pageId + 1)
            : this.pageId + 1;
        const list = this.filterList || this.list;
        const { pageBufferSize } = this;
        // TODO: we could handle a async fetch-ed list here
        const subList = list.slice(firstId === 0 ? 0 : firstId * this.pageSize - pageBufferSize, lastId * this.pageSize + pageBufferSize);
        if (this.accumulatePages) {
            this.pageRanges = [firstId, lastId];
        }
        return subList;
    }
    setupObserver(pageIdMax) {
        // observe anchor nodes to determine whether lazy loading is needed
        this.observer = new IntersectionObserver((entries, _observer) => {
            if (this.suspendObserver) {
                return;
            }
            entries = entries.filter(({ isIntersecting }) => isIntersecting);
            let pageUpdated = false;
            // when only one node is intersecting, increase or decrease page id
            if (entries.length === 1) {
                const entry = entries[0];
                // scrolling downwards to make last item visible
                if (this.refLastnode && entry.target.label === this.refLastnode.label) {
                    if (this.pageId < pageIdMax) {
                        this.pageId++;
                        pageUpdated = true;
                        this.scrollingDown = true;
                        if (!this.accumulatePages) {
                            // hide refFirst node since it will appear and can't be detected by observer
                            this.pendingScroll = () => { var _a; return this.pageId > 0 && ((_a = this.refSecondnode) === null || _a === void 0 ? void 0 : _a.scrollIntoView(true)); };
                        }
                    }
                }
                else if (this.pageId > 0) {
                    // scrolling upwards to avoid stuck scroll position by make first item in the old page visible
                    this.pageId--;
                    if (this.accumulatePages) {
                        const node = entry.target;
                        this.pendingScroll = () => {
                            node.scrollIntoView();
                            this.pendingScroll = null;
                        };
                    }
                    else {
                        this.pendingScroll = () => {
                            var _a;
                            // bottom position instead of default center position to avoid bottom node to appear
                            (_a = this.refSecondLastnode) === null || _a === void 0 ? void 0 : _a.scrollIntoView(false);
                            this.pendingScroll = null;
                        };
                    }
                    pageUpdated = true;
                    this.scrollingDown = false;
                }
            }
            else if (entries.length === 2) {
                // both anchor nodes are visible (short page)
                if (this.pageId === pageIdMax) {
                    this.pageId--;
                    if (this.accumulatePages) {
                        const node = this.refLastnode;
                        this.pendingScroll = () => {
                            // default is center position
                            node.scrollIntoView();
                            this.pendingScroll = null;
                        };
                    }
                    pageUpdated = true;
                    this.scrollingDown = false;
                }
            }
            if (pageUpdated) {
                _observer.unobserve(this.refLastnode);
                _observer.unobserve(this.refFirstnode);
            }
        });
    }
    updatePageId(selectedIndex = this.selectedIndex) {
        selectedIndex = this.getSelectedIndex(selectedIndex);
        const pageId = Math.floor(selectedIndex / this.pageSize);
        if (pageId !== this.pageId) {
            this.pageId = pageId;
        }
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
    static get watchers() { return {
        "selectedIndex": ["watchSelectedIndex"],
        "list": ["watchList"]
    }; }
};
ArcgisLazyLoadingList.style = arcgisLazyLoadingListCss;



//# sourceMappingURL=arcgis-lazy-loading-list.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
    let timeout;
    let status = "idle";
    function flush(...args) {
        status = "flushed";
        return debounced(...args);
    }
    function invoke(...args) {
        status = "invoked";
        return debounced(...args);
    }
    function cancel(...args) {
        status = "cancelled";
        return debounced(...args);
    }
    function getStatus() {
        return status;
    }
    const debounced = (...args) => new Promise((resolve) => {
        switch (status) {
            case "flushed":
                status = "idle";
                if (timeout) {
                    clearTimeout(timeout);
                    resolve(fn(...args));
                }
                else {
                    resolve(null);
                }
                break;
            case "invoked":
                clearTimeout(timeout);
                status = "idle";
                resolve(fn(...args));
                break;
            case "cancelled":
                clearTimeout(timeout);
                status = "idle";
                resolve(null);
                break;
            default:
                if (timeout) {
                    clearTimeout(timeout);
                }
                status = "pending";
                timeout = setTimeout(() => {
                    status = "idle";
                    return resolve(fn(...args));
                }, delay);
                break;
        }
    });
    debounced.flush = flush;
    debounced.invoke = invoke;
    debounced.cancel = cancel;
    debounced.getStatus = getStatus;
    return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
    let timeout;
    return (...args) => new Promise((resolve) => {
        if (timeout) {
            return;
        }
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            timeout = undefined;
            resolve(fn(...args));
        }, delay);
    });
};
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
    await Promise.all([promise, timeout(minDelay)]);
    return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
    const { key, data } = getKeyAndItem(item);
    return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
    const resultArr = [];
    const lookupMap = {};
    myArr.forEach((item) => {
        const id = getItemId(item);
        if (lookupMap[id] == null) {
            lookupMap[id] = item;
            resultArr.push(item);
        }
    });
    return resultArr;
}
function unique(myArr) {
    const primitives = { boolean: {}, number: {}, string: {} };
    const objs = [];
    return myArr.filter((item) => {
        let type = typeof item;
        if (type in primitives) {
            return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
        }
        else {
            return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
    });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));



//# sourceMappingURL=functional-44de8fcf.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS_UTILITY),
/* harmony export */   a: () => (/* binding */ formatDate),
/* harmony export */   b: () => (/* binding */ formatPlural),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   l: () => (/* binding */ languageMap)
/* harmony export */ });
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



const languageMap = new Map([
    ["ar", "ar"],
    ["bg", "bg"],
    ["bs", "bs"],
    ["ca", "ca"],
    ["cs", "cs"],
    ["da", "da"],
    ["de", "de"],
    ["el", "el"],
    ["en", "en"],
    ["es", "es"],
    ["et", "et"],
    ["fi", "fi"],
    ["fr", "fr"],
    ["he", "he"],
    ["hr", "hr"],
    ["hu", "hu"],
    ["id", "id"],
    ["it", "it"],
    ["ja", "ja"],
    ["ko", "ko"],
    ["lt", "lt"],
    ["lv", "lv"],
    ["nb", "nb"],
    ["nl", "nl"],
    ["pl", "pl"],
    ["pt-br", "pt-BR"],
    ["pt-pt", "pt-PT"],
    ["ro", "ro"],
    ["ru", "ru"],
    ["sk", "sk"],
    ["sl", "sl"],
    ["sr", "sr"],
    ["sv", "sv"],
    ["th", "th"],
    ["tr", "tr"],
    ["uk", "uk"],
    ["vi", "vi"],
    ["zh-cn", "zh-CN"],
    ["zh-hk", "zh-HK"],
    ["zh-tw", "zh-TW"]
]);
// rtl
function getElementDir(el) {
    return getElementProp(el, "dir", "ltr");
}
function getElementProp(el, prop, value) {
    const closestWithProp = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, `[${prop}]`);
    return closestWithProp ? closestWithProp.getAttribute(prop) : value;
}
// css
const CSS_UTILITY = {
    rtl: "arcgis--rtl"
};
async function formatNumber(number, options) {
    const { api, type, places } = options || {};
    if (api === 4) {
        const [intl] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/intl"]);
        const numberFormatIntlOptions = intl.convertNumberFormatToIntlOptions({
            places,
            style: type,
            digitSeparator: true
        });
        return intl.formatNumber(number, Object.assign(Object.assign({}, numberFormatIntlOptions), { style: type }));
    }
    const [dojoNumber] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["dojo/number"]);
    return dojoNumber.format(number, {
        type,
        places,
        pattern: options === null || options === void 0 ? void 0 : options.pattern
    });
}
const cache = {};
function formatDate(date) {
    const lang = document.documentElement.lang;
    const dayShortMonthYear = {
        year: "numeric",
        month: "short",
        day: "numeric"
    };
    if (!cache[lang]) {
        cache[lang] = new Intl.DateTimeFormat(document.documentElement.lang, dayShortMonthYear);
    }
    return cache[lang].format(date);
}
function formatPlural(lang, stringObj, number) {
    const singles = ["id", "ja", "ko", "th", "vi", "zh-cn", "zh-hk", "zh-tw"];
    const likeEnglish = [
        "en",
        "ca",
        "da",
        "de",
        "el",
        "es",
        "et",
        "fi",
        "hi",
        "hu",
        "it",
        "nb",
        "nl",
        "pt-pt",
        "sv",
        "tr"
    ];
    const locale = lang !== null && lang !== void 0 ? lang : "en";
    // if the number is one, or it is a "simple" language, return the 1 string
    if (number === 1 || singles.includes(locale)) {
        return stringObj.single.replace("${number}", "1");
    }
    // if the number is not 1 and the language uses the same pluralization strategy as english,
    // return the multiple string
    if (number !== 1 && likeEnglish.includes(locale)) {
        return stringObj.multiple.replace("${number}", `${number}`);
    }
    // if none of the above worked, return the "unknown" string
    return stringObj.unknown.replace("${number}", `${number}`);
}



//# sourceMappingURL=languageUtil-ef0e54b2.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLWUxZjBkMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RztBQUNwRDtBQUNPO0FBQzdCO0FBQ1I7O0FBRTNCLHdDQUF3QyxhQUFhLHNCQUFzQixnQkFBZ0IsVUFBVSxhQUFhLHNCQUFzQixrQkFBa0IsZ0JBQWdCLFdBQVcsa0JBQWtCLCtDQUErQywwQkFBMEIsUUFBUSxTQUFTLFlBQVksVUFBVSxrQkFBa0I7O0FBRXpVO0FBQ0E7QUFDQSxRQUFRLHFEQUFnQjtBQUN4QiwyQ0FBMkMscURBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNEJBQTRCLDBEQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTyxRQUFRLE9BQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPLFFBQVEsT0FBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlDQUFpQztBQUN6RCxtREFBbUQsT0FBTztBQUMxRCxnRUFBZ0UsV0FBVyxNQUFNLFdBQVc7QUFD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aUMsU0FBUyxLQUFLO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQSw2QkFBNkIsMkRBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUVBQXVFLDhCQUE4QixhQUFhO0FBQ2xIO0FBQ0EsK0JBQStCLDJEQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTyxNQUFNLE9BQU87QUFDakU7QUFDQTtBQUNBLHdDQUF3QyxPQUFPLE1BQU0sT0FBTztBQUM1RDs7QUFFeUg7O0FBRXpIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vYXJjZ2lzLWxhenktbG9hZGluZy1saXN0LmVudHJ5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBjIGFzIGNyZWF0ZUV2ZW50LCBoLCBIIGFzIEhvc3QsIGQgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuaW1wb3J0IHsgZCBhcyBkZWJvdW5jZSB9IGZyb20gJy4vZnVuY3Rpb25hbC00NGRlOGZjZi5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldEVsZW1lbnREaXIgfSBmcm9tICcuL2xhbmd1YWdlVXRpbC1lZjBlNTRiMi5qcyc7XG5pbXBvcnQgJy4vbG9hZE1vZHVsZXMtYjRhYzEyNDcuanMnO1xuaW1wb3J0ICcuL2RvbS00ZDM2NzY3Ny5qcyc7XG5cbmNvbnN0IGFyY2dpc0xhenlMb2FkaW5nTGlzdENzcyA9IFwiOmhvc3R7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtvdmVyZmxvdzpoaWRkZW59LnBvcC1tZW51e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47cG9zaXRpb246YWJzb2x1dGU7bWF4LWhlaWdodDoxMDAlO3dpZHRoOjEwMCU7b3ZlcmZsb3cteTpoaWRkZW47Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1jYWxjaXRlLWNvbG9yLWJvcmRlci0zKX0ucG9wLW1lbnUucG9wLW1lbnUtZmx5b3V0e3RvcDowcHg7bGVmdDowcHg7ei1pbmRleDoxMDB9LnBvcC1saXN0e292ZXJmbG93LXk6c2Nyb2xsfVwiO1xuXG5jb25zdCBBcmNnaXNMYXp5TG9hZGluZ0xpc3QgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFyY2dpc0xhenlMb2FkaW5nTGlzdENoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzTGF6eUxvYWRpbmdMaXN0Q2hhbmdlXCIsIDcpO1xuICAgICAgICB0aGlzLmhhc1NlbGVjdGVkU2Nyb2xsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdXNwZW5kT2JzZXJ2ZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY3JvbGxpbmdEb3duID0gdHJ1ZTtcbiAgICAgICAgLy8gVE9ETzogZG9tIHF1ZXJ5IGFjdHVhbCBoZWlnaHQgKDQ4ICsgOCkgdG8gcmVkdWNlIHNjcm9sbCB3aGVuIHRoZSBsaXN0IGlzIHZlcnkgc2hvcnRcbiAgICAgICAgdGhpcy5maWx0ZXJIZWlnaHQgPSA1NjtcbiAgICAgICAgdGhpcy5pdGVtSGVpZ2h0ID0gMzIuNTtcbiAgICAgICAgdGhpcy5pdGVtSGVpZ2h0QWRqdXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saXN0Q2hhbmdlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYWx1ZXMgPSBhd2FpdCB0aGlzLnJlZkxpc3ROb2RlLmdldFNlbGVjdGVkSXRlbXMoKTtcbiAgICAgICAgICAgIC8vIHJpc2sgb2YgMiB3aGVuIGZpbHRlciBpcyB1c2VkIGFuZCB0aGUgcGljayBsaXN0IGlzIHVwZGF0ZWQgZnJlcXVlbnRseVxuICAgICAgICAgICAgLy8gdGhpcyB3YXMgZm91bmQgZHVyaW5nIGRldiwgaXQncyBwcm9iYWJseSBubyBsb25nZXIgdGhlIGNhc2UuXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFZhbHVlID0gWy4uLnNlbGVjdGVkVmFsdWVzLmtleXMoKV0ucG9wKCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gdGhpcy5saXN0LmZpbmRJbmRleCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSA9PT0gc2VsZWN0ZWRWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0xhenlMb2FkaW5nTGlzdENoYW5nZS5lbWl0KHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFZhbHVlLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUZpbHRlciA9IGRlYm91bmNlKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkSXRlbXMgPSB0aGlzLnJlZkZpbHRlck5vZGVcbiAgICAgICAgICAgICAgICAuZmlsdGVyZWRJdGVtcztcbiAgICAgICAgICAgIGlmICghZmlsdGVyZWRJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXQgPSBuZXcgU2V0KGZpbHRlcmVkSXRlbXMubWFwKCh7IGxhYmVsIH0pID0+IGxhYmVsKSk7XG4gICAgICAgICAgICB0aGlzLnN1c3BlbmRPYnNlcnZlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckxpc3QgPSB0aGlzLmxpc3QuZmlsdGVyKCh7IGxhYmVsIH0pID0+IHNldC5oYXMobGFiZWwpKTtcbiAgICAgICAgICAgIHRoaXMucGFnZVJhbmdlcyA9IFswLCAxXTtcbiAgICAgICAgICAgIHRoaXMucGFnZUlkID0gMDtcbiAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgdGhpcy5saXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBvcG92ZXJQcm9wcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNob3dGaWx0ZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IDUwMDtcbiAgICAgICAgdGhpcy5hY2N1bXVsYXRlUGFnZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gXCJhdXRvXCI7XG4gICAgICAgIHRoaXMucGFnZUJ1ZmZlclNpemUgPSAxMDtcbiAgICAgICAgdGhpcy5mbHlPdXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saXN0VHlwZSA9IFwicGljay1saXN0XCI7XG4gICAgICAgIHRoaXMucGFnZUlkID0gMDtcbiAgICAgICAgdGhpcy5maWx0ZXJMaXN0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB3YXRjaFNlbGVjdGVkSW5kZXgobmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYWdlSWQobmV3VmFsdWUpO1xuICAgIH1cbiAgICB3YXRjaExpc3QobmV3VmFsdWUpIHtcbiAgICAgICAgLy8gcmVzZXQgbG9ja2VkIFwiYXV0b1wiIHBvc2l0aW9uXG4gICAgICAgIHRoaXMubGlzdExhYmVscyA9IG5ld1ZhbHVlLm1hcCgoeyBsYWJlbCB9KSA9PiAoeyBsYWJlbCB9KSk7XG4gICAgICAgIHRoaXMubG9ja2VkTWVudVBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgTGlmZWN5Y2xlXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgICAgIHRoaXMubGlzdExhYmVscyA9IHRoaXMubGlzdC5tYXAoKHsgbGFiZWwgfSkgPT4gKHsgbGFiZWwgfSkpO1xuICAgICAgICBjb25zdCBwYWdlSWRNYXggPSBNYXRoLmZsb29yKHRoaXMubGlzdC5sZW5ndGggLyB0aGlzLnBhZ2VTaXplKTtcbiAgICAgICAgaWYgKHBhZ2VJZE1heCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVBhZ2VJZCgpO1xuICAgICAgICB0aGlzLnNldHVwT2JzZXJ2ZXIocGFnZUlkTWF4KTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkUmVuZGVyKCkge1xuICAgICAgICAvLyBtYW5pcHVsYXRlIGRvbSBzdHlsZSBhdCBtb3N0IG9uY2Ugd2hlbiBpbml0aWFsIGl0ZW0gaGVpZ2h0IGlzIG5vdCBhY2N1cmF0ZVxuICAgICAgICAvLyBUT0RPOiBkZWxheSBhdXRvIG1lbnUgcG9zaXRpb24gbG9jayB1bnRpbCBpdGVtIGhlaWdodCBhZGp1c3RtZW50XG4gICAgICAgIGlmICh0aGlzLmZseU91dCAmJiAhdGhpcy5pdGVtSGVpZ2h0QWRqdXN0ZWQgJiYgdGhpcy5yZWZTZWxlY3RlZE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1IZWlnaHQgPSB0aGlzLnJlZlNlbGVjdGVkTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pdGVtSGVpZ2h0ICE9PSBpdGVtSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtSGVpZ2h0ID0gaXRlbUhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGhlaWdodCwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSB9ID0gdGhpcy5nZXRMaXN0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZk1lbnVOb2RlLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZNZW51Tm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7dHJhbnNsYXRlWH1weCwgJHt0cmFuc2xhdGVZfXB4KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLml0ZW1IZWlnaHRBZGp1c3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIC8vIHNjcm9sbCAoYXQgbW9zdCBvbmNlKSBzZWxlY3RlZCBub2RlIGludG8gdmlld1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1NlbGVjdGVkU2Nyb2xsZWQgJiYgdGhpcy5yZWZTZWxlY3RlZE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZlNlbGVjdGVkTm9kZS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzU2VsZWN0ZWRTY3JvbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzY3JvbGwgYW5jaG9yIG5vZGVzIHdoZW4gbmVlZGVkXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nU2Nyb2xsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IG9ic2VydmluZyBhZnRlciBzY3JvbGxpbmdcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9ic2VydmVyLCByZWZGaXJzdG5vZGUsIHJlZkxhc3Rub2RlIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1c3BlbmRPYnNlcnZlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZWZGaXJzdG5vZGUgJiYgb2JzZXJ2ZXIub2JzZXJ2ZShyZWZGaXJzdG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICByZWZMYXN0bm9kZSAmJiBvYnNlcnZlci5vYnNlcnZlKHJlZkxhc3Rub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMub2JzZXJ2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUmVuZGVyIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuc3VzcGVuZE9ic2VydmVyID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN0eWxlO1xuICAgICAgICBpZiAodGhpcy5mbHlPdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSB9ID0gdGhpcy5nZXRMaXN0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIC8vIHRvZG86IHJlZmluZSB0cmFuc2xhdGVZIHdoZW4gaXQncyBkcm9wLXVwIGFuZCB0aGUgbGlzdCBpcyBzaG9ydFxuICAgICAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGAke3dpZHRofXB4YCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGAke2hlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLmZseU91dCAmJiBgdHJhbnNsYXRlKCR7dHJhbnNsYXRlWH1weCwgJHt0cmFuc2xhdGVZfXB4KWBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChoKEhvc3QsIHsgY2xhc3M6IHRoaXMuZmx5T3V0ICYmIFwianMtYXBwLWZseW91dFwiIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogdGhpcy5mbHlPdXQgPyBcInBvcC1tZW51IHBvcC1tZW51LWZseW91dFwiIDogXCJwb3AtbWVudVwiLCBzdHlsZTogc3R5bGUsIHJlZjogKG5vZGUpID0+ICh0aGlzLnJlZk1lbnVOb2RlID0gbm9kZSkgfSwgdGhpcy5zaG93RmlsdGVyICYmIChoKFwiZGl2XCIsIG51bGwsIGgoXCJjYWxjaXRlLWZpbHRlclwiLCB7IGl0ZW1zOiB0aGlzLmxpc3RMYWJlbHMsIG1lc3NhZ2VPdmVycmlkZXM6IHtcbiAgICAgICAgICAgICAgICBjbGVhcjogKF9hID0gdGhpcy5zdHJpbmdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xlYXJGaWx0ZXIsXG4gICAgICAgICAgICAgICAgbGFiZWw6IChfYiA9IHRoaXMuc3RyaW5ncykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZpbHRlckxhYmVsXG4gICAgICAgICAgICB9LCBvbkNhbGNpdGVGaWx0ZXJDaGFuZ2U6IHRoaXMudXBkYXRlRmlsdGVyLCByZWY6IChub2RlKSA9PiAodGhpcy5yZWZGaWx0ZXJOb2RlID0gbm9kZSkgfSkpKSwgaChcImRpdlwiLCB7IGNsYXNzOiBcInBvcC1saXN0XCIgfSwgdGhpcy5yZW5kZXJMaXN0KCkpKSkpO1xuICAgIH1cbiAgICByZW5kZXJMaXN0KCkge1xuICAgICAgICBjb25zdCB7IHBhZ2VCdWZmZXJTaXplIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBoYWxmUGFnZUJ1ZmZlclNpemUgPSBNYXRoLmZsb29yKHBhZ2VCdWZmZXJTaXplIC8gMik7XG4gICAgICAgIGNvbnN0IHN1Ykxpc3QgPSB0aGlzLmdldFN1Ykxpc3QoKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uSWQgPSB0aGlzLmdldFNlbGVjdGVkSW5kZXgoKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRJdGVtID0gdGhpcy5saXN0W3NlbGVjdGlvbklkXTtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1waWNrLWxpc3RcIiwgeyBkaXI6IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCksIHJlZjogKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWZMaXN0Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZkxpc3ROb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYWxjaXRlTGlzdENoYW5nZVwiLCB0aGlzLmxpc3RDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjYWxjaXRlTGlzdENoYW5nZVwiLCB0aGlzLmxpc3RDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmTGlzdE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgfSwgbXVsdGlwbGU6IGZhbHNlLCBmaWx0ZXJFbmFibGVkOiBmYWxzZSB9LCBzdWJMaXN0Lm1hcCgoeyB2YWx1ZSwgbGFiZWwgfSwgaSkgPT4gKFxuICAgICAgICAvLyBUT0RPOiB0aGlzIGNvdWxkIGJlIHJlZmFjdG9yZWQgdG8gdGFrZSBhbiBleHRlcm5hbCByZW5kZXIgbWV0aG9kLCBzaW1pbGFyIHRvIHJlbmRlclJvdyBpbiBER3JpZFxuICAgICAgICBoKFwiY2FsY2l0ZS1waWNrLWxpc3QtaXRlbVwiLCB7IHZhbHVlOiB2YWx1ZSwgbGFiZWw6IGxhYmVsLCBrZXk6IGxhYmVsLCBzZWxlY3RlZDogdmFsdWUgPT09IHNlbGVjdGVkSXRlbS52YWx1ZSwgcmVmOiAhdGhpcy5oYXNTZWxlY3RlZFNjcm9sbGVkICYmIGxhYmVsID09PSBzZWxlY3RlZEl0ZW0ubGFiZWxcbiAgICAgICAgICAgICAgICA/IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmU2VsZWN0ZWROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiBpID09PSBzdWJMaXN0Lmxlbmd0aCAtIGhhbGZQYWdlQnVmZmVyU2l6ZVxuICAgICAgICAgICAgICAgICAgICA/IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVmTGFzdG5vZGUgJiYgKChfYSA9IHRoaXMub2JzZXJ2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bm9ic2VydmUodGhpcy5yZWZMYXN0bm9kZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVmTGFzdG5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogaSA9PT0gc3ViTGlzdC5sZW5ndGggLSBwYWdlQnVmZmVyU2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVmU2Vjb25kTGFzdG5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogaSA9PT0gaGFsZlBhZ2VCdWZmZXJTaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZkZpcnN0bm9kZSAmJiAoKF9hID0gdGhpcy5vYnNlcnZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVub2JzZXJ2ZSh0aGlzLnJlZkZpcnN0bm9kZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZGaXJzdG5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaSA9PT0gcGFnZUJ1ZmZlclNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZlNlY29uZG5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCB9KSkpKSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUHJpdmF0ZSBNZXRob2RzXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZ2V0U2VsZWN0ZWRJbmRleCh2YWx1ZSA9IHRoaXMuc2VsZWN0ZWRJbmRleCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPj0gdGhpcy5saXN0Lmxlbmd0aCA/IDAgOiB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0TGlzdFBvc2l0aW9uKCkge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBsZWZ0OiB0cmFuc2xhdGVYLCB0b3AsIGJvdHRvbSwgY29udGFpbmVyVG9wLCBjb250YWluZXJCb3R0b20gfSA9IHRoaXMucG9wb3ZlclByb3BzO1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy5maWx0ZXJMaXN0IHx8IHRoaXMubGlzdDtcbiAgICAgICAgY29uc3QgbGlzdEhlaWdodCA9IHRoaXMuaXRlbUhlaWdodCAqIGxpc3QubGVuZ3RoICsgKHRoaXMuc2hvd0ZpbHRlciA/IHRoaXMuZmlsdGVySGVpZ2h0IDogMCk7XG4gICAgICAgIGNvbnN0IGNsaWVudEhlaWdodCA9IGNvbnRhaW5lckJvdHRvbSA+IGJvdHRvbSA/IGNvbnRhaW5lckJvdHRvbSA6IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0O1xuICAgICAgICBjb25zdCBzcGFjZUJvdHRvbSA9IGNsaWVudEhlaWdodCAtIGJvdHRvbTtcbiAgICAgICAgY29uc3Qgc3BhY2VUb3AgPSB0b3AgLSBjb250YWluZXJUb3A7XG4gICAgICAgIC8vIGF1dG9Qb3NpdGlvbiBpcyBvbmx5IGluaXRpYWxpemVkIG9uY2UgcGVyIGxpc3QsIHNvIGl0IGRvZXNuJ3QgZmxpcCB3aGVuIGZpbHRlckxpc3QgY2hhbmdlc1xuICAgICAgICBpZiAoIXRoaXMubG9ja2VkTWVudVBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyBhIHRoaXJkIG9mIHRoZSBsaXN0IHRvIGJlIHNjcm9sbGVkLCBvciBnb2RlbiByYXRpb1xuICAgICAgICAgICAgICAgIHRoaXMubG9ja2VkTWVudVBvc2l0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgbGlzdEhlaWdodCAqIDEuNSA8PSBzcGFjZUJvdHRvbSB8fCBzcGFjZVRvcCAvIChzcGFjZVRvcCArIHNwYWNlQm90dG9tKSA8IDAuNjE4XG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiZG93blwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwidXBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9ja2VkTWVudVBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiA9PT0gXCJkb3duXCIgPyBcImRvd25cIiA6IFwidXBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0Ryb3Bkb3duID0gdGhpcy5sb2NrZWRNZW51UG9zaXRpb24gPT09IFwiZG93blwiO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBpc0Ryb3Bkb3duXG4gICAgICAgICAgICA/IE1hdGgubWluKGxpc3RIZWlnaHQsIHNwYWNlQm90dG9tIC0gMilcbiAgICAgICAgICAgIDogTWF0aC5taW4obGlzdEhlaWdodCwgc3BhY2VUb3AgLSAyKTtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlWSA9IGlzRHJvcGRvd24gPyBib3R0b20gOiBNYXRoLm1heChjb250YWluZXJUb3AsIHRvcCAtIGhlaWdodCk7XG4gICAgICAgIHJldHVybiB7IHdpZHRoLCBoZWlnaHQsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVkgfTtcbiAgICB9XG4gICAgZ2V0U3ViTGlzdCgpIHtcbiAgICAgICAgY29uc3QgdXNlQWNjdW11bGF0ZWRQYWdlSWQgPSAhISh0aGlzLmFjY3VtdWxhdGVQYWdlcyAmJiB0aGlzLnBhZ2VSYW5nZXMpO1xuICAgICAgICBjb25zdCBmaXJzdElkID0gdXNlQWNjdW11bGF0ZWRQYWdlSWQgPyBNYXRoLm1pbih0aGlzLnBhZ2VSYW5nZXNbMF0sIHRoaXMucGFnZUlkKSA6IHRoaXMucGFnZUlkO1xuICAgICAgICBjb25zdCBsYXN0SWQgPSB1c2VBY2N1bXVsYXRlZFBhZ2VJZFxuICAgICAgICAgICAgPyBNYXRoLm1heCh0aGlzLnBhZ2VSYW5nZXNbMV0sIHRoaXMucGFnZUlkICsgMSlcbiAgICAgICAgICAgIDogdGhpcy5wYWdlSWQgKyAxO1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy5maWx0ZXJMaXN0IHx8IHRoaXMubGlzdDtcbiAgICAgICAgY29uc3QgeyBwYWdlQnVmZmVyU2l6ZSB9ID0gdGhpcztcbiAgICAgICAgLy8gVE9ETzogd2UgY291bGQgaGFuZGxlIGEgYXN5bmMgZmV0Y2gtZWQgbGlzdCBoZXJlXG4gICAgICAgIGNvbnN0IHN1Ykxpc3QgPSBsaXN0LnNsaWNlKGZpcnN0SWQgPT09IDAgPyAwIDogZmlyc3RJZCAqIHRoaXMucGFnZVNpemUgLSBwYWdlQnVmZmVyU2l6ZSwgbGFzdElkICogdGhpcy5wYWdlU2l6ZSArIHBhZ2VCdWZmZXJTaXplKTtcbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZVBhZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2VSYW5nZXMgPSBbZmlyc3RJZCwgbGFzdElkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ViTGlzdDtcbiAgICB9XG4gICAgc2V0dXBPYnNlcnZlcihwYWdlSWRNYXgpIHtcbiAgICAgICAgLy8gb2JzZXJ2ZSBhbmNob3Igbm9kZXMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgbGF6eSBsb2FkaW5nIGlzIG5lZWRlZFxuICAgICAgICB0aGlzLm9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzLCBfb2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1c3BlbmRPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJpZXMgPSBlbnRyaWVzLmZpbHRlcigoeyBpc0ludGVyc2VjdGluZyB9KSA9PiBpc0ludGVyc2VjdGluZyk7XG4gICAgICAgICAgICBsZXQgcGFnZVVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHdoZW4gb25seSBvbmUgbm9kZSBpcyBpbnRlcnNlY3RpbmcsIGluY3JlYXNlIG9yIGRlY3JlYXNlIHBhZ2UgaWRcbiAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICAgICAgICAgICAgICAvLyBzY3JvbGxpbmcgZG93bndhcmRzIHRvIG1ha2UgbGFzdCBpdGVtIHZpc2libGVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWZMYXN0bm9kZSAmJiBlbnRyeS50YXJnZXQubGFiZWwgPT09IHRoaXMucmVmTGFzdG5vZGUubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFnZUlkIDwgcGFnZUlkTWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhZ2VJZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxpbmdEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hY2N1bXVsYXRlUGFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoaWRlIHJlZkZpcnN0IG5vZGUgc2luY2UgaXQgd2lsbCBhcHBlYXIgYW5kIGNhbid0IGJlIGRldGVjdGVkIGJ5IG9ic2VydmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nU2Nyb2xsID0gKCkgPT4geyB2YXIgX2E7IHJldHVybiB0aGlzLnBhZ2VJZCA+IDAgJiYgKChfYSA9IHRoaXMucmVmU2Vjb25kbm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNjcm9sbEludG9WaWV3KHRydWUpKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBhZ2VJZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2Nyb2xsaW5nIHVwd2FyZHMgdG8gYXZvaWQgc3R1Y2sgc2Nyb2xsIHBvc2l0aW9uIGJ5IG1ha2UgZmlyc3QgaXRlbSBpbiB0aGUgb2xkIHBhZ2UgdmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhZ2VJZC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hY2N1bXVsYXRlUGFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBlbnRyeS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdTY3JvbGwgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1Njcm9sbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBib3R0b20gcG9zaXRpb24gaW5zdGVhZCBvZiBkZWZhdWx0IGNlbnRlciBwb3NpdGlvbiB0byBhdm9pZCBib3R0b20gbm9kZSB0byBhcHBlYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnJlZlNlY29uZExhc3Rub2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2Nyb2xsSW50b1ZpZXcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1Njcm9sbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxpbmdEb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW50cmllcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBib3RoIGFuY2hvciBub2RlcyBhcmUgdmlzaWJsZSAoc2hvcnQgcGFnZSlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYWdlSWQgPT09IHBhZ2VJZE1heCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhZ2VJZC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hY2N1bXVsYXRlUGFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnJlZkxhc3Rub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgaXMgY2VudGVyIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1Njcm9sbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxpbmdEb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2VVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgX29ic2VydmVyLnVub2JzZXJ2ZSh0aGlzLnJlZkxhc3Rub2RlKTtcbiAgICAgICAgICAgICAgICBfb2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMucmVmRmlyc3Rub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZVBhZ2VJZChzZWxlY3RlZEluZGV4ID0gdGhpcy5zZWxlY3RlZEluZGV4KSB7XG4gICAgICAgIHNlbGVjdGVkSW5kZXggPSB0aGlzLmdldFNlbGVjdGVkSW5kZXgoc2VsZWN0ZWRJbmRleCk7XG4gICAgICAgIGNvbnN0IHBhZ2VJZCA9IE1hdGguZmxvb3Ioc2VsZWN0ZWRJbmRleCAvIHRoaXMucGFnZVNpemUpO1xuICAgICAgICBpZiAocGFnZUlkICE9PSB0aGlzLnBhZ2VJZCkge1xuICAgICAgICAgICAgdGhpcy5wYWdlSWQgPSBwYWdlSWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhvc3RFbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxuICAgIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgICAgIFwic2VsZWN0ZWRJbmRleFwiOiBbXCJ3YXRjaFNlbGVjdGVkSW5kZXhcIl0sXG4gICAgICAgIFwibGlzdFwiOiBbXCJ3YXRjaExpc3RcIl1cbiAgICB9OyB9XG59O1xuQXJjZ2lzTGF6eUxvYWRpbmdMaXN0LnN0eWxlID0gYXJjZ2lzTGF6eUxvYWRpbmdMaXN0Q3NzO1xuXG5leHBvcnQgeyBBcmNnaXNMYXp5TG9hZGluZ0xpc3QgYXMgYXJjZ2lzX2xhenlfbG9hZGluZ19saXN0IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyY2dpcy1sYXp5LWxvYWRpbmctbGlzdC5lbnRyeS5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9ubHkgYWZ0ZXIgaXQgaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgbiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSBmbiAgICAtIGZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSBkZWxheSAtIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICovXG5jb25zdCBkZWJvdW5jZSA9IChmbiwgZGVsYXkpID0+IHtcbiAgICBsZXQgdGltZW91dDtcbiAgICBsZXQgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgZnVuY3Rpb24gZmx1c2goLi4uYXJncykge1xuICAgICAgICBzdGF0dXMgPSBcImZsdXNoZWRcIjtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52b2tlKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhdHVzID0gXCJpbnZva2VkXCI7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbCguLi5hcmdzKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiY2FuY2VsbGVkXCI7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG4gICAgY29uc3QgZGVib3VuY2VkID0gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFwiZmx1c2hlZFwiOlxuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnZva2VkXCI6XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNhbmNlbGxlZFwiOlxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgICBkZWJvdW5jZWQuaW52b2tlID0gaW52b2tlO1xuICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgZGVib3VuY2VkLmdldFN0YXR1cyA9IGdldFN0YXR1cztcbiAgICByZXR1cm4gZGVib3VuY2VkO1xufTtcbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9ubHkgYWZ0ZXIgbiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgdGhyb3R0bGUgPSAoZm4sIGRlbGF5KSA9PiB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTsgLy8gJCYgbWVhbnMgdGhlIHdob2xlIG1hdGNoZWQgc3RyaW5nXG59XG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbi8qKlxuICogU2V0IGEgbWluaW11bSB0aW1lIGZvciBhIHByb21pc2UgdG8gcmVzb2x2ZSAodXNlZnVsIGZvciBwcmV2ZW50aW5nIGZsYXNoIG9mIGxvYWRlcnMpXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1pbkRlbGF5KHByb21pc2UsIG1pbkRlbGF5KSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW3Byb21pc2UsIHRpbWVvdXQobWluRGVsYXkpXSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gaW5saW5lIHNldFRpbWVvdXQgYXMgYW4gYXdhaXQgaW4gYXN5bmMgZnVuY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXQobXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbmNvbnN0IGFycmF5VG9Mb29rdXBNYXAgPSAoZGF0YUFyciwgZ2V0S2V5QW5kSXRlbSkgPT4gT2JqZWN0LmZyb21FbnRyaWVzKChkYXRhQXJyIHx8IFtdKS5tYXAoKGl0ZW0pID0+IHtcbiAgICBjb25zdCB7IGtleSwgZGF0YSB9ID0gZ2V0S2V5QW5kSXRlbShpdGVtKTtcbiAgICByZXR1cm4gW2tleSwgZGF0YV07XG59KSk7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdHdvIGFycmF5cyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50c1xuICogYW5kIHdoZXRoZXIgdGhleSBjb250YWluIHRoZSBzYW1lIGVsZW1lbnRzXG4gKiByZWdhcmRsZXNzIG9mIG9yZGVyXG4gKi9cbmNvbnN0IGFycmF5c0FyZUVxdWl2YWxlbnQgPSAoYXJyMSwgYXJyMikgPT4gYXJyMS5sZW5ndGggPT09IGFycjIubGVuZ3RoICYmIGFycjEucmVkdWNlKChtZW1vLCBzdHIpID0+IG1lbW8gJiYgYXJyMi5pbmRleE9mKHN0cikgPiAtMSwgdHJ1ZSk7XG5mdW5jdGlvbiB1bmlxdWVCeShteUFyciwgZ2V0SXRlbUlkKSB7XG4gICAgY29uc3QgcmVzdWx0QXJyID0gW107XG4gICAgY29uc3QgbG9va3VwTWFwID0ge307XG4gICAgbXlBcnIuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IGdldEl0ZW1JZChpdGVtKTtcbiAgICAgICAgaWYgKGxvb2t1cE1hcFtpZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9va3VwTWFwW2lkXSA9IGl0ZW07XG4gICAgICAgICAgICByZXN1bHRBcnIucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRBcnI7XG59XG5mdW5jdGlvbiB1bmlxdWUobXlBcnIpIHtcbiAgICBjb25zdCBwcmltaXRpdmVzID0geyBib29sZWFuOiB7fSwgbnVtYmVyOiB7fSwgc3RyaW5nOiB7fSB9O1xuICAgIGNvbnN0IG9ianMgPSBbXTtcbiAgICByZXR1cm4gbXlBcnIuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgIGxldCB0eXBlID0gdHlwZW9mIGl0ZW07XG4gICAgICAgIGlmICh0eXBlIGluIHByaW1pdGl2ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVzW3R5cGVdLmhhc093blByb3BlcnR5KGl0ZW0pID8gZmFsc2UgOiAocHJpbWl0aXZlc1t0eXBlXVtpdGVtXSA9IHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9ianMuaW5kZXhPZihpdGVtKSA+PSAwID8gZmFsc2UgOiBvYmpzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IGNodW5rID0gKGFyciwgc2l6ZSkgPT4gWy4uLkFycmF5KE1hdGguY2VpbChhcnIubGVuZ3RoIC8gc2l6ZSkpXS5tYXAoKF8sIGkpID0+IGFyci5zbGljZShzaXplICogaSwgc2l6ZSArIHNpemUgKiBpKSk7XG5cbmV4cG9ydCB7IGFycmF5VG9Mb29rdXBNYXAgYXMgYSwgdW5pcXVlIGFzIGIsIHRocm90dGxlIGFzIGMsIGRlYm91bmNlIGFzIGQsIGVzY2FwZVJlZ0V4cCBhcyBlLCBhcnJheXNBcmVFcXVpdmFsZW50IGFzIGYsIGNodW5rIGFzIGcsIGlzRGVmaW5lZCBhcyBpLCBtaW5EZWxheSBhcyBtLCB0aW1lb3V0IGFzIHQsIHVuaXF1ZUJ5IGFzIHUgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb25hbC00NGRlOGZjZi5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGwgYXMgbG9hZE1vZHVsZXMgfSBmcm9tICcuL2xvYWRNb2R1bGVzLWI0YWMxMjQ3LmpzJztcbmltcG9ydCB7IGMgYXMgY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5IH0gZnJvbSAnLi9kb20tNGQzNjc2NzcuanMnO1xuXG5jb25zdCBsYW5ndWFnZU1hcCA9IG5ldyBNYXAoW1xuICAgIFtcImFyXCIsIFwiYXJcIl0sXG4gICAgW1wiYmdcIiwgXCJiZ1wiXSxcbiAgICBbXCJic1wiLCBcImJzXCJdLFxuICAgIFtcImNhXCIsIFwiY2FcIl0sXG4gICAgW1wiY3NcIiwgXCJjc1wiXSxcbiAgICBbXCJkYVwiLCBcImRhXCJdLFxuICAgIFtcImRlXCIsIFwiZGVcIl0sXG4gICAgW1wiZWxcIiwgXCJlbFwiXSxcbiAgICBbXCJlblwiLCBcImVuXCJdLFxuICAgIFtcImVzXCIsIFwiZXNcIl0sXG4gICAgW1wiZXRcIiwgXCJldFwiXSxcbiAgICBbXCJmaVwiLCBcImZpXCJdLFxuICAgIFtcImZyXCIsIFwiZnJcIl0sXG4gICAgW1wiaGVcIiwgXCJoZVwiXSxcbiAgICBbXCJoclwiLCBcImhyXCJdLFxuICAgIFtcImh1XCIsIFwiaHVcIl0sXG4gICAgW1wiaWRcIiwgXCJpZFwiXSxcbiAgICBbXCJpdFwiLCBcIml0XCJdLFxuICAgIFtcImphXCIsIFwiamFcIl0sXG4gICAgW1wia29cIiwgXCJrb1wiXSxcbiAgICBbXCJsdFwiLCBcImx0XCJdLFxuICAgIFtcImx2XCIsIFwibHZcIl0sXG4gICAgW1wibmJcIiwgXCJuYlwiXSxcbiAgICBbXCJubFwiLCBcIm5sXCJdLFxuICAgIFtcInBsXCIsIFwicGxcIl0sXG4gICAgW1wicHQtYnJcIiwgXCJwdC1CUlwiXSxcbiAgICBbXCJwdC1wdFwiLCBcInB0LVBUXCJdLFxuICAgIFtcInJvXCIsIFwicm9cIl0sXG4gICAgW1wicnVcIiwgXCJydVwiXSxcbiAgICBbXCJza1wiLCBcInNrXCJdLFxuICAgIFtcInNsXCIsIFwic2xcIl0sXG4gICAgW1wic3JcIiwgXCJzclwiXSxcbiAgICBbXCJzdlwiLCBcInN2XCJdLFxuICAgIFtcInRoXCIsIFwidGhcIl0sXG4gICAgW1widHJcIiwgXCJ0clwiXSxcbiAgICBbXCJ1a1wiLCBcInVrXCJdLFxuICAgIFtcInZpXCIsIFwidmlcIl0sXG4gICAgW1wiemgtY25cIiwgXCJ6aC1DTlwiXSxcbiAgICBbXCJ6aC1oa1wiLCBcInpoLUhLXCJdLFxuICAgIFtcInpoLXR3XCIsIFwiemgtVFdcIl1cbl0pO1xuLy8gcnRsXG5mdW5jdGlvbiBnZXRFbGVtZW50RGlyKGVsKSB7XG4gICAgcmV0dXJuIGdldEVsZW1lbnRQcm9wKGVsLCBcImRpclwiLCBcImx0clwiKTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRQcm9wKGVsLCBwcm9wLCB2YWx1ZSkge1xuICAgIGNvbnN0IGNsb3Nlc3RXaXRoUHJvcCA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbCwgYFske3Byb3B9XWApO1xuICAgIHJldHVybiBjbG9zZXN0V2l0aFByb3AgPyBjbG9zZXN0V2l0aFByb3AuZ2V0QXR0cmlidXRlKHByb3ApIDogdmFsdWU7XG59XG4vLyBjc3NcbmNvbnN0IENTU19VVElMSVRZID0ge1xuICAgIHJ0bDogXCJhcmNnaXMtLXJ0bFwiXG59O1xuYXN5bmMgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bWJlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXBpLCB0eXBlLCBwbGFjZXMgfSA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKGFwaSA9PT0gNCkge1xuICAgICAgICBjb25zdCBbaW50bF0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2ludGxcIl0pO1xuICAgICAgICBjb25zdCBudW1iZXJGb3JtYXRJbnRsT3B0aW9ucyA9IGludGwuY29udmVydE51bWJlckZvcm1hdFRvSW50bE9wdGlvbnMoe1xuICAgICAgICAgICAgcGxhY2VzLFxuICAgICAgICAgICAgc3R5bGU6IHR5cGUsXG4gICAgICAgICAgICBkaWdpdFNlcGFyYXRvcjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGludGwuZm9ybWF0TnVtYmVyKG51bWJlciwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBudW1iZXJGb3JtYXRJbnRsT3B0aW9ucyksIHsgc3R5bGU6IHR5cGUgfSkpO1xuICAgIH1cbiAgICBjb25zdCBbZG9qb051bWJlcl0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJkb2pvL251bWJlclwiXSk7XG4gICAgcmV0dXJuIGRvam9OdW1iZXIuZm9ybWF0KG51bWJlciwge1xuICAgICAgICB0eXBlLFxuICAgICAgICBwbGFjZXMsXG4gICAgICAgIHBhdHRlcm46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXR0ZXJuXG4gICAgfSk7XG59XG5jb25zdCBjYWNoZSA9IHt9O1xuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gICAgY29uc3QgbGFuZyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nO1xuICAgIGNvbnN0IGRheVNob3J0TW9udGhZZWFyID0ge1xuICAgICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgICAgbW9udGg6IFwic2hvcnRcIixcbiAgICAgICAgZGF5OiBcIm51bWVyaWNcIlxuICAgIH07XG4gICAgaWYgKCFjYWNoZVtsYW5nXSkge1xuICAgICAgICBjYWNoZVtsYW5nXSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nLCBkYXlTaG9ydE1vbnRoWWVhcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZVtsYW5nXS5mb3JtYXQoZGF0ZSk7XG59XG5mdW5jdGlvbiBmb3JtYXRQbHVyYWwobGFuZywgc3RyaW5nT2JqLCBudW1iZXIpIHtcbiAgICBjb25zdCBzaW5nbGVzID0gW1wiaWRcIiwgXCJqYVwiLCBcImtvXCIsIFwidGhcIiwgXCJ2aVwiLCBcInpoLWNuXCIsIFwiemgtaGtcIiwgXCJ6aC10d1wiXTtcbiAgICBjb25zdCBsaWtlRW5nbGlzaCA9IFtcbiAgICAgICAgXCJlblwiLFxuICAgICAgICBcImNhXCIsXG4gICAgICAgIFwiZGFcIixcbiAgICAgICAgXCJkZVwiLFxuICAgICAgICBcImVsXCIsXG4gICAgICAgIFwiZXNcIixcbiAgICAgICAgXCJldFwiLFxuICAgICAgICBcImZpXCIsXG4gICAgICAgIFwiaGlcIixcbiAgICAgICAgXCJodVwiLFxuICAgICAgICBcIml0XCIsXG4gICAgICAgIFwibmJcIixcbiAgICAgICAgXCJubFwiLFxuICAgICAgICBcInB0LXB0XCIsXG4gICAgICAgIFwic3ZcIixcbiAgICAgICAgXCJ0clwiXG4gICAgXTtcbiAgICBjb25zdCBsb2NhbGUgPSBsYW5nICE9PSBudWxsICYmIGxhbmcgIT09IHZvaWQgMCA/IGxhbmcgOiBcImVuXCI7XG4gICAgLy8gaWYgdGhlIG51bWJlciBpcyBvbmUsIG9yIGl0IGlzIGEgXCJzaW1wbGVcIiBsYW5ndWFnZSwgcmV0dXJuIHRoZSAxIHN0cmluZ1xuICAgIGlmIChudW1iZXIgPT09IDEgfHwgc2luZ2xlcy5pbmNsdWRlcyhsb2NhbGUpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdPYmouc2luZ2xlLnJlcGxhY2UoXCIke251bWJlcn1cIiwgXCIxXCIpO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgbnVtYmVyIGlzIG5vdCAxIGFuZCB0aGUgbGFuZ3VhZ2UgdXNlcyB0aGUgc2FtZSBwbHVyYWxpemF0aW9uIHN0cmF0ZWd5IGFzIGVuZ2xpc2gsXG4gICAgLy8gcmV0dXJuIHRoZSBtdWx0aXBsZSBzdHJpbmdcbiAgICBpZiAobnVtYmVyICE9PSAxICYmIGxpa2VFbmdsaXNoLmluY2x1ZGVzKGxvY2FsZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ09iai5tdWx0aXBsZS5yZXBsYWNlKFwiJHtudW1iZXJ9XCIsIGAke251bWJlcn1gKTtcbiAgICB9XG4gICAgLy8gaWYgbm9uZSBvZiB0aGUgYWJvdmUgd29ya2VkLCByZXR1cm4gdGhlIFwidW5rbm93blwiIHN0cmluZ1xuICAgIHJldHVybiBzdHJpbmdPYmoudW5rbm93bi5yZXBsYWNlKFwiJHtudW1iZXJ9XCIsIGAke251bWJlcn1gKTtcbn1cblxuZXhwb3J0IHsgQ1NTX1VUSUxJVFkgYXMgQywgZm9ybWF0RGF0ZSBhcyBhLCBmb3JtYXRQbHVyYWwgYXMgYiwgZm9ybWF0TnVtYmVyIGFzIGYsIGdldEVsZW1lbnREaXIgYXMgZywgbGFuZ3VhZ2VNYXAgYXMgbCB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9