"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_functi-2677af"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
    let timeout;
    let status = "idle";
    function flush(...args) {
        status = "flushed";
        return debounced(...args);
    }
    function invoke(...args) {
        status = "invoked";
        return debounced(...args);
    }
    function cancel(...args) {
        status = "cancelled";
        return debounced(...args);
    }
    function getStatus() {
        return status;
    }
    const debounced = (...args) => new Promise((resolve) => {
        switch (status) {
            case "flushed":
                status = "idle";
                if (timeout) {
                    clearTimeout(timeout);
                    resolve(fn(...args));
                }
                else {
                    resolve(null);
                }
                break;
            case "invoked":
                clearTimeout(timeout);
                status = "idle";
                resolve(fn(...args));
                break;
            case "cancelled":
                clearTimeout(timeout);
                status = "idle";
                resolve(null);
                break;
            default:
                if (timeout) {
                    clearTimeout(timeout);
                }
                status = "pending";
                timeout = setTimeout(() => {
                    status = "idle";
                    return resolve(fn(...args));
                }, delay);
                break;
        }
    });
    debounced.flush = flush;
    debounced.invoke = invoke;
    debounced.cancel = cancel;
    debounced.getStatus = getStatus;
    return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
    let timeout;
    return (...args) => new Promise((resolve) => {
        if (timeout) {
            return;
        }
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            timeout = undefined;
            resolve(fn(...args));
        }, delay);
    });
};
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
    await Promise.all([promise, timeout(minDelay)]);
    return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
    const { key, data } = getKeyAndItem(item);
    return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
    const resultArr = [];
    const lookupMap = {};
    myArr.forEach((item) => {
        const id = getItemId(item);
        if (lookupMap[id] == null) {
            lookupMap[id] = item;
            resultArr.push(item);
        }
    });
    return resultArr;
}
function unique(myArr) {
    const primitives = { boolean: {}, number: {}, string: {} };
    const objs = [];
    return myArr.filter((item) => {
        let type = typeof item;
        if (type in primitives) {
            return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
        }
        else {
            return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
    });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));



//# sourceMappingURL=functional-44de8fcf.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
    var _a, _b, _c;
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        // "ru-RU" maps to "ru" use case
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
        }
        else {
            return "en";
        }
    }
}
function getComponentClosestLanguageIntl(element) {
    var _a, _b, _c;
    // it's OK if we don't have the 4 letter language file for it
    // 4 letter language code needed for formatting numbers
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            // we support the 2 letter coded language
            // e.g. it-CH vs it
            return lang;
        }
        else {
            return "en";
        }
    }
}
function fetchLocaleStringsForComponent(componentName, locale) {
    return new Promise((resolve, reject) => {
        fetch((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
            if (result.ok)
                resolve(result.json());
            else
                reject();
        }, () => reject());
    });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
    const id = `${componentName}${locale}`;
    if (!stringCache[id]) {
        stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
    }
    return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
    const componentName = tagName || element.tagName.toLowerCase();
    const componentLanguage = getComponentClosestLanguage(element);
    const componentLanguageIntl = getComponentClosestLanguageIntl(element);
    let strings;
    try {
        strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
    }
    catch (e) {
        console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
        strings = await fetchLocaleStringsFromCache(componentName, "en");
    }
    return [strings, componentLanguage, componentLanguageIntl];
}



//# sourceMappingURL=locale-050b6db9.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/previewPopup-2acb9488.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/previewPopup-2acb9488.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ generateMasterFieldInfo),
/* harmony export */   p: () => (/* binding */ previewPopup)
/* harmony export */ });
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




async function generatefieldInfo(layer, popupTemplate) {
    return new Promise((resolve, reject) => {
        (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/popup/FieldInfo"]).then(async ([FieldInfo]) => {
            var _a, _b, _c;
            const masterFieldInfo = [];
            // map original fieldinfo
            const fieldInfoMap = new Map((_a = popupTemplate === null || popupTemplate === void 0 ? void 0 : popupTemplate.fieldInfos) === null || _a === void 0 ? void 0 : _a.map((fieldInfo) => [
                fieldInfo.fieldName,
                fieldInfo
            ]));
            // map fields from service
            const layerFieldsMap = 
            /* getServiceType(layer) !== serviceTypeEnum.imageryTile ? */ await (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.d)(layer); /* : null */
            // loop over popup fieldinfo first to maintain field order, than add new fields
            if (layerFieldsMap === null || layerFieldsMap === void 0 ? void 0 : layerFieldsMap.size) {
                fieldInfoMap.forEach((fieldInfo) => {
                    if (layerFieldsMap.has(fieldInfo.fieldName)) {
                        masterFieldInfo.push(fieldInfo);
                        // wont use layerFields anymore, so remove them here
                        layerFieldsMap.delete(fieldInfo.fieldName);
                    }
                });
                // remaining fields are new fields in the service
                layerFieldsMap.forEach((field) => {
                    if (["geometry"].indexOf(field.type) === -1) {
                        const tempFieldInfo = new FieldInfo();
                        tempFieldInfo.fieldName = field.name;
                        tempFieldInfo.label = field.alias;
                        tempFieldInfo.visible = false;
                        masterFieldInfo.push(tempFieldInfo);
                    }
                });
                layerFieldsMap.clear();
            }
            // expressions
            if (popupTemplate === null || popupTemplate === void 0 ? void 0 : popupTemplate.expressionInfos) {
                (_b = popupTemplate.expressionInfos) === null || _b === void 0 ? void 0 : _b.forEach((expression) => {
                    const expressionNameWithPrefix = `${_commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_1__.f.expression}${expression.name}`;
                    if (fieldInfoMap.has(expressionNameWithPrefix)) {
                        masterFieldInfo.push(fieldInfoMap.get(expressionNameWithPrefix));
                    }
                    else {
                        const tempFieldInfo = new FieldInfo();
                        tempFieldInfo.fieldName = expressionNameWithPrefix;
                        tempFieldInfo.visible = false;
                        masterFieldInfo.push(tempFieldInfo);
                    }
                });
            }
            // relationships: todo
            (_c = popupTemplate === null || popupTemplate === void 0 ? void 0 : popupTemplate.fieldInfos) === null || _c === void 0 ? void 0 : _c.forEach((field) => {
                // raster fields get returned via generateLayerFieldsMap now
                if (field.fieldName.indexOf(_commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_1__.f.relationship) !== -1 /*||
                field.fieldName.indexOf(fieldInfoPrefixEnum.raster) !== -1 */) {
                    masterFieldInfo.push(field);
                }
            });
            resolve(masterFieldInfo);
        }, (error) => {
            reject(error);
        });
    });
}
const generateMasterFieldInfo = (layer, popupTemplate) => generatefieldInfo(layer, popupTemplate);

const previewPopup = async (mapView, layer, previewPopupController) => {
    var _a, _b;
    mapView.closePopup();
    let singleFeature = null;
    const serviceType = (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.c)(layer);
    // if scene layer, check for associated FS, else do regular preview popup
    if (serviceType === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_1__.s.scene && !(layer === null || layer === void 0 ? void 0 : layer.associatedLayer)) {
        // to do
        // singleFeature = await getSingleSceneFeatureToDisplay(mapView, layer as __esri.SceneLayer, previewPopupController);
        return;
    }
    else {
        singleFeature = await getSingleFeatureToDisplay(mapView, layer, previewPopupController, serviceType);
    }
    if (singleFeature) {
        if ("dockEnabled" in mapView.popup) {
            mapView.popup.dockEnabled = true;
        }
        mapView.openPopup({
            features: [singleFeature],
            location: ((_b = (_a = singleFeature.geometry) === null || _a === void 0 ? void 0 : _a.extent) === null || _b === void 0 ? void 0 : _b.center) || singleFeature.geometry
        });
        return singleFeature;
    }
};
const getSingleFeatureToDisplay = async (mapView, layer, previewPopupController, serviceType) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    try {
        let currentLayer = null;
        let popupFeature;
        if (serviceType === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_1__.s.ogcFeature) {
            currentLayer = (await mapView.whenLayerView(layer));
            // wait for features to load, else layerview queries dont return anything
            const [reactiveUtils] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/core/reactiveUtils"]);
            await reactiveUtils.whenOnce(() => !currentLayer.updating);
        }
        else if (serviceType === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_1__.s.stream) {
            currentLayer = (await mapView.whenLayerView(layer));
            // wait for features to load, else layerview queries dont return anything
            const [reactiveUtils] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/core/reactiveUtils"]);
            await reactiveUtils.whenOnce(() => !currentLayer.updating);
        }
        else {
            currentLayer = layer;
        }
        // imagery tile layer cannot use query operation
        if (serviceType === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_1__.s.imageryTile) {
            const layerView = mapView.allLayerViews.find((view) => view.layer.id === layer.id);
            const features = await layerView.fetchPopupFeatures(layer.fullExtent.center);
            return features === null || features === void 0 ? void 0 : features[0];
        }
        // if sublayer supports identity, return the 1st feature for popup preview.
        if (serviceType === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_1__.s.mapImage &&
            layer.layer.version >= 10.5 &&
            !((_b = (_a = layer.layer.capabilities) === null || _a === void 0 ? void 0 : _a.operations) === null || _b === void 0 ? void 0 : _b.supportsQuery) &&
            ((_d = (_c = layer.layer.capabilities) === null || _c === void 0 ? void 0 : _c.operations) === null || _d === void 0 ? void 0 : _d.supportsIdentify)) {
            const currFeature = await (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.f)(layer, mapView);
            // attaching source layer is needed for popup to display
            if (currFeature) {
                currFeature.sourceLayer = layer;
            }
            return currFeature;
        }
        const isTable = "isTable" in layer && layer.isTable;
        // query center
        const centerQueryParams = currentLayer.createQuery();
        if (!isTable) {
            centerQueryParams.geometry = mapView.center;
            centerQueryParams.distance = mapView.resolution;
        }
        centerQueryParams.outFields = ["*"];
        const featureSetCenter = await currentLayer.queryFeatures(centerQueryParams, {
            signal: previewPopupController.signal
        });
        if (((_e = featureSetCenter === null || featureSetCenter === void 0 ? void 0 : featureSetCenter.features) === null || _e === void 0 ? void 0 : _e.length) === 0) {
            // feature by extent
            const extentQueryParams = currentLayer.createQuery();
            extentQueryParams.geometry = mapView.extent;
            extentQueryParams.outFields = ["*"];
            const featureSetExtent = await currentLayer.queryFeatures(extentQueryParams, {
                signal: previewPopupController.signal
            });
            if (((_f = featureSetExtent === null || featureSetExtent === void 0 ? void 0 : featureSetExtent.features) === null || _f === void 0 ? void 0 : _f.length) > 0) {
                // get closest to center
                popupFeature = await getClosestToCenter(featureSetExtent, mapView, layer);
            }
            else {
                // get any feature
                const singleFeatureQueryParams = currentLayer.createQuery();
                singleFeatureQueryParams.where =
                    currentLayer.definitionExpression || "1=1";
                singleFeatureQueryParams.outFields = ["*"];
                if (((_h = (_g = layer.sourceJSON) === null || _g === void 0 ? void 0 : _g.advancedQueryCapabilities) === null || _h === void 0 ? void 0 : _h.supportsPagination) ||
                    serviceType === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_1__.s.ogcFeature) {
                    singleFeatureQueryParams.start = 0;
                    singleFeatureQueryParams.num = 1;
                }
                singleFeatureQueryParams.outSpatialReference = mapView.spatialReference;
                popupFeature = (_k = (_j = (await currentLayer.queryFeatures(singleFeatureQueryParams, { signal: previewPopupController.signal }))) === null || _j === void 0 ? void 0 : _j.features) === null || _k === void 0 ? void 0 : _k[0];
            }
        }
        else {
            popupFeature = (_l = featureSetCenter === null || featureSetCenter === void 0 ? void 0 : featureSetCenter.features) === null || _l === void 0 ? void 0 : _l[0];
        }
        if (popupFeature && serviceType === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_1__.s.imagery) {
            popupFeature = await getSingleFeatureToDisplayForImagery(layer, popupFeature);
        }
        return popupFeature;
    }
    catch (error) {
        // abort error
        console.log(error);
    }
};
const getSingleFeatureToDisplayForImagery = async (layer, defaultGraphic) => {
    var _a;
    const query = layer.createQuery();
    // in api, "*" is a special keyword for query only. pseudo raster fields must be appended explicitly.
    // this could be revisited, e.g. introduce an additional option.
    query.outFields = ["*"].concat(layer.rasterFields.map((field) => field.name).filter((name) => name.startsWith("Raster.")));
    query.geometry = defaultGraphic.geometry;
    query.outSpatialReference = defaultGraphic.geometry.spatialReference;
    const features = await layer.queryVisibleRasters(query, {
        returnTopmostRaster: true,
        returnDomainValues: true
    });
    return (_a = features === null || features === void 0 ? void 0 : features[0]) !== null && _a !== void 0 ? _a : defaultGraphic;
};
const getClosestToCenter = async (featureSet, mapView, layer) => {
    const geometryType = await (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.h)(layer);
    // point based on point distance
    if (geometryType === "point") {
        let featureAndDistance = null;
        for (let x = 0; x < featureSet.features.length; x++) {
            const pointDistance = featureSet.features[x].geometry.distance(mapView.center);
            if (x === 0 || (featureAndDistance === null || featureAndDistance === void 0 ? void 0 : featureAndDistance[1]) > pointDistance) {
                featureAndDistance = [featureSet.features[x], pointDistance];
            }
        }
        return featureAndDistance[0];
    }
    // polyline with grate
    else if (geometryType === "polyline") {
        let featureAndDistance = null;
        const [geometryEngine] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/geometry/geometryEngine"]);
        for (let x = 0; x < featureSet.features.length; x++) {
            const lineDistance = geometryEngine.nearestVertex(featureSet.features[x].geometry, mapView.center).distance;
            if (x === 0 || (featureAndDistance === null || featureAndDistance === void 0 ? void 0 : featureAndDistance[1]) > lineDistance) {
                featureAndDistance = [featureSet.features[x], lineDistance];
            }
        }
        return featureAndDistance[0];
    }
    // polygon based on centroid distance
    else if (geometryType === "polygon" || (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.c)(layer) === "imagery") {
        let featureAndDistance = null;
        for (let x = 0; x < featureSet.features.length; x++) {
            const centroidDistance = featureSet.features[x].geometry.centroid.distance(mapView.center);
            if (x === 0 || (featureAndDistance === null || featureAndDistance === void 0 ? void 0 : featureAndDistance[1]) > centroidDistance) {
                featureAndDistance = [featureSet.features[x], centroidDistance];
            }
        }
        return featureAndDistance[0];
    }
    // table, any other use case, send the 1st one
    else {
        return featureSet.features[0];
    }
};
// const getSingleSceneFeatureToDisplay = async (
//   mapView: __esri.MapView,
//   layer: __esri.SceneLayer,
//   previewPopupController: AbortController
// ): Promise<__esri.Graphic> => {
//   try {
//     const layerView = await mapView.whenLayerView(layer);
//     const query = layer.createQuery();
//     query.start = 0;
//     query.num = 1;
//     query.outFields = ["*"];
//     const tempResult = await layerView.queryFeatures(query, { signal: previewPopupController.signal });
//     return tempResult.features?.[0];
//   } catch (error) {
//     // abort error
//     return null;
//   }
// };



//# sourceMappingURL=previewPopup-2acb9488.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fZnVuY3RpLTI2NzdhZi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVpTTs7QUFFak07Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUMyRTtBQUNiO0FBQ047O0FBRXhEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtREFBaUM7QUFDbEU7QUFDQTtBQUNBLFFBQVEsd0RBQVc7QUFDbkIsZUFBZSx3REFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFXO0FBQ3ZCLG1CQUFtQix3REFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtREFBaUM7QUFDbEU7QUFDQTtBQUNBLFFBQVEsd0RBQVc7QUFDbkIsZUFBZSx3REFBVztBQUMxQjtBQUNBO0FBQ0EsWUFBWSx3REFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxREFBWSw4QkFBOEIsY0FBYyxRQUFRLE9BQU87QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjLEVBQUUsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZSxHQUFHLGtCQUFrQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEU7O0FBRTVFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkQ7QUFDOEI7QUFDK0Q7O0FBRTFKO0FBQ0E7QUFDQSxRQUFRLDJEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRiwrREFBc0IsU0FBUztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHVEQUFtQixZQUFZLEVBQUUsZ0JBQWdCO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx1REFBbUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtEQUFjO0FBQ3RDO0FBQ0Esd0JBQXdCLHVEQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1REFBZTtBQUMzQztBQUNBO0FBQ0EsMENBQTBDLDJEQUFXO0FBQ3JEO0FBQ0E7QUFDQSxpQ0FBaUMsdURBQWU7QUFDaEQ7QUFDQTtBQUNBLDBDQUEwQywyREFBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdURBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1REFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsK0RBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdURBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsdUNBQXVDO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdURBQWU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0RBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQVc7QUFDbEQsd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLCtEQUFjO0FBQ3pEO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHVDQUF1QztBQUN4RztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFMkQ7O0FBRTNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vZnVuY3Rpb25hbC00NGRlOGZjZi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9sb2NhbGUtMDUwYjZkYjkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vcHJldmlld1BvcHVwLTJhY2I5NDg4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb25seSBhZnRlciBpdCBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciBuIG1pbGxpc2Vjb25kc1xuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IGRlYm91bmNlID0gKGZuLCBkZWxheSkgPT4ge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIGxldCBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICBmdW5jdGlvbiBmbHVzaCguLi5hcmdzKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiZmx1c2hlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZva2UoLi4uYXJncykge1xuICAgICAgICBzdGF0dXMgPSBcImludm9rZWRcIjtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuY2VsKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhdHVzID0gXCJjYW5jZWxsZWRcIjtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbiAgICBjb25zdCBkZWJvdW5jZWQgPSAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmbHVzaGVkXCI6XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImludm9rZWRcIjpcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2FuY2VsbGVkXCI6XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICAgIGRlYm91bmNlZC5pbnZva2UgPSBpbnZva2U7XG4gICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgICBkZWJvdW5jZWQuZ2V0U3RhdHVzID0gZ2V0U3RhdHVzO1xuICAgIHJldHVybiBkZWJvdW5jZWQ7XG59O1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb25seSBhZnRlciBuIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWRcbiAqIEBwYXJhbSBmbiAgICAtIGZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSBkZWxheSAtIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICovXG5jb25zdCB0aHJvdHRsZSA9IChmbiwgZGVsYXkpID0+IHtcbiAgICBsZXQgdGltZW91dDtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgdGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpOyAvLyAkJiBtZWFucyB0aGUgd2hvbGUgbWF0Y2hlZCBzdHJpbmdcbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xufVxuLyoqXG4gKiBTZXQgYSBtaW5pbXVtIHRpbWUgZm9yIGEgcHJvbWlzZSB0byByZXNvbHZlICh1c2VmdWwgZm9yIHByZXZlbnRpbmcgZmxhc2ggb2YgbG9hZGVycylcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWluRGVsYXkocHJvbWlzZSwgbWluRGVsYXkpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbcHJvbWlzZSwgdGltZW91dChtaW5EZWxheSldKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byBpbmxpbmUgc2V0VGltZW91dCBhcyBhbiBhd2FpdCBpbiBhc3luYyBmdW5jdGlvbnNcbiAqL1xuZnVuY3Rpb24gdGltZW91dChtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuY29uc3QgYXJyYXlUb0xvb2t1cE1hcCA9IChkYXRhQXJyLCBnZXRLZXlBbmRJdGVtKSA9PiBPYmplY3QuZnJvbUVudHJpZXMoKGRhdGFBcnIgfHwgW10pLm1hcCgoaXRlbSkgPT4ge1xuICAgIGNvbnN0IHsga2V5LCBkYXRhIH0gPSBnZXRLZXlBbmRJdGVtKGl0ZW0pO1xuICAgIHJldHVybiBba2V5LCBkYXRhXTtcbn0pKTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0d28gYXJyYXlzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzXG4gKiBhbmQgd2hldGhlciB0aGV5IGNvbnRhaW4gdGhlIHNhbWUgZWxlbWVudHNcbiAqIHJlZ2FyZGxlc3Mgb2Ygb3JkZXJcbiAqL1xuY29uc3QgYXJyYXlzQXJlRXF1aXZhbGVudCA9IChhcnIxLCBhcnIyKSA9PiBhcnIxLmxlbmd0aCA9PT0gYXJyMi5sZW5ndGggJiYgYXJyMS5yZWR1Y2UoKG1lbW8sIHN0cikgPT4gbWVtbyAmJiBhcnIyLmluZGV4T2Yoc3RyKSA+IC0xLCB0cnVlKTtcbmZ1bmN0aW9uIHVuaXF1ZUJ5KG15QXJyLCBnZXRJdGVtSWQpIHtcbiAgICBjb25zdCByZXN1bHRBcnIgPSBbXTtcbiAgICBjb25zdCBsb29rdXBNYXAgPSB7fTtcbiAgICBteUFyci5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gZ2V0SXRlbUlkKGl0ZW0pO1xuICAgICAgICBpZiAobG9va3VwTWFwW2lkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb29rdXBNYXBbaWRdID0gaXRlbTtcbiAgICAgICAgICAgIHJlc3VsdEFyci5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdEFycjtcbn1cbmZ1bmN0aW9uIHVuaXF1ZShteUFycikge1xuICAgIGNvbnN0IHByaW1pdGl2ZXMgPSB7IGJvb2xlYW46IHt9LCBudW1iZXI6IHt9LCBzdHJpbmc6IHt9IH07XG4gICAgY29uc3Qgb2JqcyA9IFtdO1xuICAgIHJldHVybiBteUFyci5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlb2YgaXRlbTtcbiAgICAgICAgaWYgKHR5cGUgaW4gcHJpbWl0aXZlcykge1xuICAgICAgICAgICAgcmV0dXJuIHByaW1pdGl2ZXNbdHlwZV0uaGFzT3duUHJvcGVydHkoaXRlbSkgPyBmYWxzZSA6IChwcmltaXRpdmVzW3R5cGVdW2l0ZW1dID0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2Jqcy5pbmRleE9mKGl0ZW0pID49IDAgPyBmYWxzZSA6IG9ianMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgY2h1bmsgPSAoYXJyLCBzaXplKSA9PiBbLi4uQXJyYXkoTWF0aC5jZWlsKGFyci5sZW5ndGggLyBzaXplKSldLm1hcCgoXywgaSkgPT4gYXJyLnNsaWNlKHNpemUgKiBpLCBzaXplICsgc2l6ZSAqIGkpKTtcblxuZXhwb3J0IHsgYXJyYXlUb0xvb2t1cE1hcCBhcyBhLCB1bmlxdWUgYXMgYiwgdGhyb3R0bGUgYXMgYywgZGVib3VuY2UgYXMgZCwgZXNjYXBlUmVnRXhwIGFzIGUsIGFycmF5c0FyZUVxdWl2YWxlbnQgYXMgZiwgY2h1bmsgYXMgZywgaXNEZWZpbmVkIGFzIGksIG1pbkRlbGF5IGFzIG0sIHRpbWVvdXQgYXMgdCwgdW5pcXVlQnkgYXMgdSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdW5jdGlvbmFsLTQ0ZGU4ZmNmLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgfSBmcm9tICcuL2RvbS00ZDM2NzY3Ny5qcyc7XG5pbXBvcnQgeyBsIGFzIGxhbmd1YWdlTWFwIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMnO1xuaW1wb3J0IHsgYSBhcyBnZXRBc3NldFBhdGggfSBmcm9tICcuL2luZGV4LWUzYmY3ZGE3LmpzJztcblxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL3N0ZW5jaWwtdHJpY2tzL2ltcGxlbWVudGluZy1pbnRlcm5hdGlvbmFsaXNhdGlvbi1pMThuLXdpdGgtc3RlbmNpbC01ZTY1NTk1NTQxMTdcbmZ1bmN0aW9uIGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZShlbGVtZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgLy8gbGFuZ3VhZ2Ugc2V0IGJ5IHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uIG9yIGJyb3dzZXIuIGRlZmF1bHRzIHRvIGVuZ2xpc2guXG4gICAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBcInJ1LVJVXCIgbWFwcyB0byBcInJ1XCIgdXNlIGNhc2VcbiAgICAgICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nLnNsaWNlKDAsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcImVuXCI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAvLyBpdCdzIE9LIGlmIHdlIGRvbid0IGhhdmUgdGhlIDQgbGV0dGVyIGxhbmd1YWdlIGZpbGUgZm9yIGl0XG4gICAgLy8gNCBsZXR0ZXIgbGFuZ3VhZ2UgY29kZSBuZWVkZWQgZm9yIGZvcm1hdHRpbmcgbnVtYmVyc1xuICAgIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICAgIGNvbnN0IGxhbmcgPSAoKGNsb3Nlc3RFbGVtZW50ID09PSBudWxsIHx8IGNsb3Nlc3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXN0RWxlbWVudC5sYW5nKSB8fCAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgICAgICAgLy8gd2Ugc3VwcG9ydCB0aGUgMiBsZXR0ZXIgY29kZWQgbGFuZ3VhZ2VcbiAgICAgICAgICAgIC8vIGUuZy4gaXQtQ0ggdnMgaXRcbiAgICAgICAgICAgIHJldHVybiBsYW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmZXRjaChnZXRBc3NldFBhdGgoYC4uL2FyY2dpcy1hcHAtYXNzZXRzL2kxOG4vJHtjb21wb25lbnROYW1lfS5pMThuLiR7bG9jYWxlfS5qc29uYCkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5vaylcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdC5qc29uKCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9LCAoKSA9PiByZWplY3QoKSk7XG4gICAgfSk7XG59XG5jb25zdCBzdHJpbmdDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGxvY2FsZSkge1xuICAgIGNvbnN0IGlkID0gYCR7Y29tcG9uZW50TmFtZX0ke2xvY2FsZX1gO1xuICAgIGlmICghc3RyaW5nQ2FjaGVbaWRdKSB7XG4gICAgICAgIHN0cmluZ0NhY2hlW2lkXSA9IGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nQ2FjaGVbaWRdO1xufVxuLyoqXG4gKiBHZXQgc3RyaW5ncyBhbmQgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIDIgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGUgZmlyc3Qgb25lIHJldHVybnMgYSBjb2RlIHRoYXQncyBhbHNvIHN1cHBvcnRlZCBhcyBhIGxhbmd1YWdlIGZpbGUuXG4gKiBUaGUgc2Vjb25kIG9uZSByZXR1cm5zIGEgY29kZSB3aGVyZSB0aGVyZSBpcyBzdXBwb3J0IGZvciB0aGUgZmlyc3QgMiBsZXR0ZXJzIG9mIHRoZSBjb2RlIGFzIHBhcnQgb2YgYSBsYW5ndWFnZSBmaWxlLFxuICogYnV0IHdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCA0IGxldHRlciBjb2RlIGZyb20gdGhlIHBhZ2UuXG4gKiBFLmcuIEZvciBcIml0LWNoXCIgaXQgd2lsbCByZXR1cm4gXCJpdFwiIGFzIHRoZSBmaXJzdCBsYW5ndWFnZSBjb2RlIGFuZCBcIml0LWNoXCIgYXMgdGhlIHNlY29uZC5cbiAqIFRoZSBzZWNvbmQgb25lIGlzIHJlcXVpcmVkIGZvciBlc3JpLmludGwuc2V0TG9jYWxlKCkgdG8gZ2V0IHRoZSBjb3JyZWN0IGZvcm1hdHRpbmcuXG4gKlxuICogSWYgYSB0YWdOYW1lIGlzIHByb3ZpZGVkIGl0IHdpbGwgb3ZlcndpdGUgdGhlIGVsZW1lbnQncyB0YWdOYW1lXG4gKlxuICogIEByZXR1cm4gWyBzdHJpbmdzLCBmaXJzdCBsYW5ndWFnZSBjb2RlLCBzZWNvbmQgbGFuZ3VhZ2UgY29kZV1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyhlbGVtZW50LCB0YWdOYW1lKSB7XG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IHRhZ05hbWUgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2UgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCk7XG4gICAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2VJbnRsID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KTtcbiAgICBsZXQgc3RyaW5ncztcbiAgICB0cnkge1xuICAgICAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudExhbmd1YWdlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBubyBsb2NhbGUgZm9yICR7Y29tcG9uZW50TmFtZX0gKCR7Y29tcG9uZW50TGFuZ3VhZ2V9KSBsb2FkaW5nIGRlZmF1bHQgbG9jYWxlIGVuLmApO1xuICAgICAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIFwiZW5cIik7XG4gICAgfVxuICAgIHJldHVybiBbc3RyaW5ncywgY29tcG9uZW50TGFuZ3VhZ2UsIGNvbXBvbmVudExhbmd1YWdlSW50bF07XG59XG5cbmV4cG9ydCB7IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZSBhcyBhLCBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIGFzIGcgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxlLTA1MGI2ZGI5LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgbCBhcyBsb2FkTW9kdWxlcyB9IGZyb20gJy4vbG9hZE1vZHVsZXMtYjRhYzEyNDcuanMnO1xuaW1wb3J0IHsgZiBhcyBmaWVsZEluZm9QcmVmaXhFbnVtLCBzIGFzIHNlcnZpY2VUeXBlRW51bSB9IGZyb20gJy4vY29tbW9uRW51bXMtZmNmMTM2NjEuanMnO1xuaW1wb3J0IHsgZCBhcyBnZW5lcmF0ZUxheWVyRmllbGRzTWFwLCBjIGFzIGdldFNlcnZpY2VUeXBlLCBmIGFzIGlkZW50aWZ5T25NYXBJbWFnZUxheWVyLCBoIGFzIGdldExheWVyR2VvbWV0cnlUeXBlIH0gZnJvbSAnLi9jb21tb25GdW5jdGlvbnMtYjA4MzBlOWUuanMnO1xuXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZWZpZWxkSW5mbyhsYXllciwgcG9wdXBUZW1wbGF0ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxvYWRNb2R1bGVzKFtcImVzcmkvcG9wdXAvRmllbGRJbmZvXCJdKS50aGVuKGFzeW5jIChbRmllbGRJbmZvXSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBtYXN0ZXJGaWVsZEluZm8gPSBbXTtcbiAgICAgICAgICAgIC8vIG1hcCBvcmlnaW5hbCBmaWVsZGluZm9cbiAgICAgICAgICAgIGNvbnN0IGZpZWxkSW5mb01hcCA9IG5ldyBNYXAoKF9hID0gcG9wdXBUZW1wbGF0ZSA9PT0gbnVsbCB8fCBwb3B1cFRlbXBsYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb3B1cFRlbXBsYXRlLmZpZWxkSW5mb3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGZpZWxkSW5mbykgPT4gW1xuICAgICAgICAgICAgICAgIGZpZWxkSW5mby5maWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgZmllbGRJbmZvXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICAvLyBtYXAgZmllbGRzIGZyb20gc2VydmljZVxuICAgICAgICAgICAgY29uc3QgbGF5ZXJGaWVsZHNNYXAgPSBcbiAgICAgICAgICAgIC8qIGdldFNlcnZpY2VUeXBlKGxheWVyKSAhPT0gc2VydmljZVR5cGVFbnVtLmltYWdlcnlUaWxlID8gKi8gYXdhaXQgZ2VuZXJhdGVMYXllckZpZWxkc01hcChsYXllcik7IC8qIDogbnVsbCAqL1xuICAgICAgICAgICAgLy8gbG9vcCBvdmVyIHBvcHVwIGZpZWxkaW5mbyBmaXJzdCB0byBtYWludGFpbiBmaWVsZCBvcmRlciwgdGhhbiBhZGQgbmV3IGZpZWxkc1xuICAgICAgICAgICAgaWYgKGxheWVyRmllbGRzTWFwID09PSBudWxsIHx8IGxheWVyRmllbGRzTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllckZpZWxkc01hcC5zaXplKSB7XG4gICAgICAgICAgICAgICAgZmllbGRJbmZvTWFwLmZvckVhY2goKGZpZWxkSW5mbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXJGaWVsZHNNYXAuaGFzKGZpZWxkSW5mby5maWVsZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXN0ZXJGaWVsZEluZm8ucHVzaChmaWVsZEluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd29udCB1c2UgbGF5ZXJGaWVsZHMgYW55bW9yZSwgc28gcmVtb3ZlIHRoZW0gaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJGaWVsZHNNYXAuZGVsZXRlKGZpZWxkSW5mby5maWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gcmVtYWluaW5nIGZpZWxkcyBhcmUgbmV3IGZpZWxkcyBpbiB0aGUgc2VydmljZVxuICAgICAgICAgICAgICAgIGxheWVyRmllbGRzTWFwLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChbXCJnZW9tZXRyeVwiXS5pbmRleE9mKGZpZWxkLnR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcEZpZWxkSW5mbyA9IG5ldyBGaWVsZEluZm8oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBGaWVsZEluZm8uZmllbGROYW1lID0gZmllbGQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBGaWVsZEluZm8ubGFiZWwgPSBmaWVsZC5hbGlhcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBGaWVsZEluZm8udmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzdGVyRmllbGRJbmZvLnB1c2godGVtcEZpZWxkSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsYXllckZpZWxkc01hcC5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXhwcmVzc2lvbnNcbiAgICAgICAgICAgIGlmIChwb3B1cFRlbXBsYXRlID09PSBudWxsIHx8IHBvcHVwVGVtcGxhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcHVwVGVtcGxhdGUuZXhwcmVzc2lvbkluZm9zKSB7XG4gICAgICAgICAgICAgICAgKF9iID0gcG9wdXBUZW1wbGF0ZS5leHByZXNzaW9uSW5mb3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mb3JFYWNoKChleHByZXNzaW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25OYW1lV2l0aFByZWZpeCA9IGAke2ZpZWxkSW5mb1ByZWZpeEVudW0uZXhwcmVzc2lvbn0ke2V4cHJlc3Npb24ubmFtZX1gO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRJbmZvTWFwLmhhcyhleHByZXNzaW9uTmFtZVdpdGhQcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXN0ZXJGaWVsZEluZm8ucHVzaChmaWVsZEluZm9NYXAuZ2V0KGV4cHJlc3Npb25OYW1lV2l0aFByZWZpeCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcEZpZWxkSW5mbyA9IG5ldyBGaWVsZEluZm8oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBGaWVsZEluZm8uZmllbGROYW1lID0gZXhwcmVzc2lvbk5hbWVXaXRoUHJlZml4O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEZpZWxkSW5mby52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXN0ZXJGaWVsZEluZm8ucHVzaCh0ZW1wRmllbGRJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVsYXRpb25zaGlwczogdG9kb1xuICAgICAgICAgICAgKF9jID0gcG9wdXBUZW1wbGF0ZSA9PT0gbnVsbCB8fCBwb3B1cFRlbXBsYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb3B1cFRlbXBsYXRlLmZpZWxkSW5mb3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHJhc3RlciBmaWVsZHMgZ2V0IHJldHVybmVkIHZpYSBnZW5lcmF0ZUxheWVyRmllbGRzTWFwIG5vd1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5maWVsZE5hbWUuaW5kZXhPZihmaWVsZEluZm9QcmVmaXhFbnVtLnJlbGF0aW9uc2hpcCkgIT09IC0xIC8qfHxcbiAgICAgICAgICAgICAgICBmaWVsZC5maWVsZE5hbWUuaW5kZXhPZihmaWVsZEluZm9QcmVmaXhFbnVtLnJhc3RlcikgIT09IC0xICovKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hc3RlckZpZWxkSW5mby5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc29sdmUobWFzdGVyRmllbGRJbmZvKTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmNvbnN0IGdlbmVyYXRlTWFzdGVyRmllbGRJbmZvID0gKGxheWVyLCBwb3B1cFRlbXBsYXRlKSA9PiBnZW5lcmF0ZWZpZWxkSW5mbyhsYXllciwgcG9wdXBUZW1wbGF0ZSk7XG5cbmNvbnN0IHByZXZpZXdQb3B1cCA9IGFzeW5jIChtYXBWaWV3LCBsYXllciwgcHJldmlld1BvcHVwQ29udHJvbGxlcikgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgbWFwVmlldy5jbG9zZVBvcHVwKCk7XG4gICAgbGV0IHNpbmdsZUZlYXR1cmUgPSBudWxsO1xuICAgIGNvbnN0IHNlcnZpY2VUeXBlID0gZ2V0U2VydmljZVR5cGUobGF5ZXIpO1xuICAgIC8vIGlmIHNjZW5lIGxheWVyLCBjaGVjayBmb3IgYXNzb2NpYXRlZCBGUywgZWxzZSBkbyByZWd1bGFyIHByZXZpZXcgcG9wdXBcbiAgICBpZiAoc2VydmljZVR5cGUgPT09IHNlcnZpY2VUeXBlRW51bS5zY2VuZSAmJiAhKGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllci5hc3NvY2lhdGVkTGF5ZXIpKSB7XG4gICAgICAgIC8vIHRvIGRvXG4gICAgICAgIC8vIHNpbmdsZUZlYXR1cmUgPSBhd2FpdCBnZXRTaW5nbGVTY2VuZUZlYXR1cmVUb0Rpc3BsYXkobWFwVmlldywgbGF5ZXIgYXMgX19lc3JpLlNjZW5lTGF5ZXIsIHByZXZpZXdQb3B1cENvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzaW5nbGVGZWF0dXJlID0gYXdhaXQgZ2V0U2luZ2xlRmVhdHVyZVRvRGlzcGxheShtYXBWaWV3LCBsYXllciwgcHJldmlld1BvcHVwQ29udHJvbGxlciwgc2VydmljZVR5cGUpO1xuICAgIH1cbiAgICBpZiAoc2luZ2xlRmVhdHVyZSkge1xuICAgICAgICBpZiAoXCJkb2NrRW5hYmxlZFwiIGluIG1hcFZpZXcucG9wdXApIHtcbiAgICAgICAgICAgIG1hcFZpZXcucG9wdXAuZG9ja0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG1hcFZpZXcub3BlblBvcHVwKHtcbiAgICAgICAgICAgIGZlYXR1cmVzOiBbc2luZ2xlRmVhdHVyZV0sXG4gICAgICAgICAgICBsb2NhdGlvbjogKChfYiA9IChfYSA9IHNpbmdsZUZlYXR1cmUuZ2VvbWV0cnkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5leHRlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jZW50ZXIpIHx8IHNpbmdsZUZlYXR1cmUuZ2VvbWV0cnlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzaW5nbGVGZWF0dXJlO1xuICAgIH1cbn07XG5jb25zdCBnZXRTaW5nbGVGZWF0dXJlVG9EaXNwbGF5ID0gYXN5bmMgKG1hcFZpZXcsIGxheWVyLCBwcmV2aWV3UG9wdXBDb250cm9sbGVyLCBzZXJ2aWNlVHlwZSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2w7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IGN1cnJlbnRMYXllciA9IG51bGw7XG4gICAgICAgIGxldCBwb3B1cEZlYXR1cmU7XG4gICAgICAgIGlmIChzZXJ2aWNlVHlwZSA9PT0gc2VydmljZVR5cGVFbnVtLm9nY0ZlYXR1cmUpIHtcbiAgICAgICAgICAgIGN1cnJlbnRMYXllciA9IChhd2FpdCBtYXBWaWV3LndoZW5MYXllclZpZXcobGF5ZXIpKTtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIGZlYXR1cmVzIHRvIGxvYWQsIGVsc2UgbGF5ZXJ2aWV3IHF1ZXJpZXMgZG9udCByZXR1cm4gYW55dGhpbmdcbiAgICAgICAgICAgIGNvbnN0IFtyZWFjdGl2ZVV0aWxzXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvY29yZS9yZWFjdGl2ZVV0aWxzXCJdKTtcbiAgICAgICAgICAgIGF3YWl0IHJlYWN0aXZlVXRpbHMud2hlbk9uY2UoKCkgPT4gIWN1cnJlbnRMYXllci51cGRhdGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VydmljZVR5cGUgPT09IHNlcnZpY2VUeXBlRW51bS5zdHJlYW0pIHtcbiAgICAgICAgICAgIGN1cnJlbnRMYXllciA9IChhd2FpdCBtYXBWaWV3LndoZW5MYXllclZpZXcobGF5ZXIpKTtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIGZlYXR1cmVzIHRvIGxvYWQsIGVsc2UgbGF5ZXJ2aWV3IHF1ZXJpZXMgZG9udCByZXR1cm4gYW55dGhpbmdcbiAgICAgICAgICAgIGNvbnN0IFtyZWFjdGl2ZVV0aWxzXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvY29yZS9yZWFjdGl2ZVV0aWxzXCJdKTtcbiAgICAgICAgICAgIGF3YWl0IHJlYWN0aXZlVXRpbHMud2hlbk9uY2UoKCkgPT4gIWN1cnJlbnRMYXllci51cGRhdGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50TGF5ZXIgPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbWFnZXJ5IHRpbGUgbGF5ZXIgY2Fubm90IHVzZSBxdWVyeSBvcGVyYXRpb25cbiAgICAgICAgaWYgKHNlcnZpY2VUeXBlID09PSBzZXJ2aWNlVHlwZUVudW0uaW1hZ2VyeVRpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxheWVyVmlldyA9IG1hcFZpZXcuYWxsTGF5ZXJWaWV3cy5maW5kKCh2aWV3KSA9PiB2aWV3LmxheWVyLmlkID09PSBsYXllci5pZCk7XG4gICAgICAgICAgICBjb25zdCBmZWF0dXJlcyA9IGF3YWl0IGxheWVyVmlldy5mZXRjaFBvcHVwRmVhdHVyZXMobGF5ZXIuZnVsbEV4dGVudC5jZW50ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVzID09PSBudWxsIHx8IGZlYXR1cmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWF0dXJlc1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBzdWJsYXllciBzdXBwb3J0cyBpZGVudGl0eSwgcmV0dXJuIHRoZSAxc3QgZmVhdHVyZSBmb3IgcG9wdXAgcHJldmlldy5cbiAgICAgICAgaWYgKHNlcnZpY2VUeXBlID09PSBzZXJ2aWNlVHlwZUVudW0ubWFwSW1hZ2UgJiZcbiAgICAgICAgICAgIGxheWVyLmxheWVyLnZlcnNpb24gPj0gMTAuNSAmJlxuICAgICAgICAgICAgISgoX2IgPSAoX2EgPSBsYXllci5sYXllci5jYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVyYXRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3VwcG9ydHNRdWVyeSkgJiZcbiAgICAgICAgICAgICgoX2QgPSAoX2MgPSBsYXllci5sYXllci5jYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5vcGVyYXRpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc3VwcG9ydHNJZGVudGlmeSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJGZWF0dXJlID0gYXdhaXQgaWRlbnRpZnlPbk1hcEltYWdlTGF5ZXIobGF5ZXIsIG1hcFZpZXcpO1xuICAgICAgICAgICAgLy8gYXR0YWNoaW5nIHNvdXJjZSBsYXllciBpcyBuZWVkZWQgZm9yIHBvcHVwIHRvIGRpc3BsYXlcbiAgICAgICAgICAgIGlmIChjdXJyRmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIGN1cnJGZWF0dXJlLnNvdXJjZUxheWVyID0gbGF5ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VyckZlYXR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNUYWJsZSA9IFwiaXNUYWJsZVwiIGluIGxheWVyICYmIGxheWVyLmlzVGFibGU7XG4gICAgICAgIC8vIHF1ZXJ5IGNlbnRlclxuICAgICAgICBjb25zdCBjZW50ZXJRdWVyeVBhcmFtcyA9IGN1cnJlbnRMYXllci5jcmVhdGVRdWVyeSgpO1xuICAgICAgICBpZiAoIWlzVGFibGUpIHtcbiAgICAgICAgICAgIGNlbnRlclF1ZXJ5UGFyYW1zLmdlb21ldHJ5ID0gbWFwVmlldy5jZW50ZXI7XG4gICAgICAgICAgICBjZW50ZXJRdWVyeVBhcmFtcy5kaXN0YW5jZSA9IG1hcFZpZXcucmVzb2x1dGlvbjtcbiAgICAgICAgfVxuICAgICAgICBjZW50ZXJRdWVyeVBhcmFtcy5vdXRGaWVsZHMgPSBbXCIqXCJdO1xuICAgICAgICBjb25zdCBmZWF0dXJlU2V0Q2VudGVyID0gYXdhaXQgY3VycmVudExheWVyLnF1ZXJ5RmVhdHVyZXMoY2VudGVyUXVlcnlQYXJhbXMsIHtcbiAgICAgICAgICAgIHNpZ25hbDogcHJldmlld1BvcHVwQ29udHJvbGxlci5zaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICgoKF9lID0gZmVhdHVyZVNldENlbnRlciA9PT0gbnVsbCB8fCBmZWF0dXJlU2V0Q2VudGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWF0dXJlU2V0Q2VudGVyLmZlYXR1cmVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gZmVhdHVyZSBieSBleHRlbnRcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudFF1ZXJ5UGFyYW1zID0gY3VycmVudExheWVyLmNyZWF0ZVF1ZXJ5KCk7XG4gICAgICAgICAgICBleHRlbnRRdWVyeVBhcmFtcy5nZW9tZXRyeSA9IG1hcFZpZXcuZXh0ZW50O1xuICAgICAgICAgICAgZXh0ZW50UXVlcnlQYXJhbXMub3V0RmllbGRzID0gW1wiKlwiXTtcbiAgICAgICAgICAgIGNvbnN0IGZlYXR1cmVTZXRFeHRlbnQgPSBhd2FpdCBjdXJyZW50TGF5ZXIucXVlcnlGZWF0dXJlcyhleHRlbnRRdWVyeVBhcmFtcywge1xuICAgICAgICAgICAgICAgIHNpZ25hbDogcHJldmlld1BvcHVwQ29udHJvbGxlci5zaWduYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCgoX2YgPSBmZWF0dXJlU2V0RXh0ZW50ID09PSBudWxsIHx8IGZlYXR1cmVTZXRFeHRlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZlYXR1cmVTZXRFeHRlbnQuZmVhdHVyZXMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5sZW5ndGgpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGdldCBjbG9zZXN0IHRvIGNlbnRlclxuICAgICAgICAgICAgICAgIHBvcHVwRmVhdHVyZSA9IGF3YWl0IGdldENsb3Nlc3RUb0NlbnRlcihmZWF0dXJlU2V0RXh0ZW50LCBtYXBWaWV3LCBsYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgYW55IGZlYXR1cmVcbiAgICAgICAgICAgICAgICBjb25zdCBzaW5nbGVGZWF0dXJlUXVlcnlQYXJhbXMgPSBjdXJyZW50TGF5ZXIuY3JlYXRlUXVlcnkoKTtcbiAgICAgICAgICAgICAgICBzaW5nbGVGZWF0dXJlUXVlcnlQYXJhbXMud2hlcmUgPVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIuZGVmaW5pdGlvbkV4cHJlc3Npb24gfHwgXCIxPTFcIjtcbiAgICAgICAgICAgICAgICBzaW5nbGVGZWF0dXJlUXVlcnlQYXJhbXMub3V0RmllbGRzID0gW1wiKlwiXTtcbiAgICAgICAgICAgICAgICBpZiAoKChfaCA9IChfZyA9IGxheWVyLnNvdXJjZUpTT04pID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5hZHZhbmNlZFF1ZXJ5Q2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guc3VwcG9ydHNQYWdpbmF0aW9uKSB8fFxuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlVHlwZSA9PT0gc2VydmljZVR5cGVFbnVtLm9nY0ZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlRmVhdHVyZVF1ZXJ5UGFyYW1zLnN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlRmVhdHVyZVF1ZXJ5UGFyYW1zLm51bSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpbmdsZUZlYXR1cmVRdWVyeVBhcmFtcy5vdXRTcGF0aWFsUmVmZXJlbmNlID0gbWFwVmlldy5zcGF0aWFsUmVmZXJlbmNlO1xuICAgICAgICAgICAgICAgIHBvcHVwRmVhdHVyZSA9IChfayA9IChfaiA9IChhd2FpdCBjdXJyZW50TGF5ZXIucXVlcnlGZWF0dXJlcyhzaW5nbGVGZWF0dXJlUXVlcnlQYXJhbXMsIHsgc2lnbmFsOiBwcmV2aWV3UG9wdXBDb250cm9sbGVyLnNpZ25hbCB9KSkpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5mZWF0dXJlcykgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9wdXBGZWF0dXJlID0gKF9sID0gZmVhdHVyZVNldENlbnRlciA9PT0gbnVsbCB8fCBmZWF0dXJlU2V0Q2VudGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWF0dXJlU2V0Q2VudGVyLmZlYXR1cmVzKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2xbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcHVwRmVhdHVyZSAmJiBzZXJ2aWNlVHlwZSA9PT0gc2VydmljZVR5cGVFbnVtLmltYWdlcnkpIHtcbiAgICAgICAgICAgIHBvcHVwRmVhdHVyZSA9IGF3YWl0IGdldFNpbmdsZUZlYXR1cmVUb0Rpc3BsYXlGb3JJbWFnZXJ5KGxheWVyLCBwb3B1cEZlYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3B1cEZlYXR1cmU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBhYm9ydCBlcnJvclxuICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgfVxufTtcbmNvbnN0IGdldFNpbmdsZUZlYXR1cmVUb0Rpc3BsYXlGb3JJbWFnZXJ5ID0gYXN5bmMgKGxheWVyLCBkZWZhdWx0R3JhcGhpYykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBxdWVyeSA9IGxheWVyLmNyZWF0ZVF1ZXJ5KCk7XG4gICAgLy8gaW4gYXBpLCBcIipcIiBpcyBhIHNwZWNpYWwga2V5d29yZCBmb3IgcXVlcnkgb25seS4gcHNldWRvIHJhc3RlciBmaWVsZHMgbXVzdCBiZSBhcHBlbmRlZCBleHBsaWNpdGx5LlxuICAgIC8vIHRoaXMgY291bGQgYmUgcmV2aXNpdGVkLCBlLmcuIGludHJvZHVjZSBhbiBhZGRpdGlvbmFsIG9wdGlvbi5cbiAgICBxdWVyeS5vdXRGaWVsZHMgPSBbXCIqXCJdLmNvbmNhdChsYXllci5yYXN0ZXJGaWVsZHMubWFwKChmaWVsZCkgPT4gZmllbGQubmFtZSkuZmlsdGVyKChuYW1lKSA9PiBuYW1lLnN0YXJ0c1dpdGgoXCJSYXN0ZXIuXCIpKSk7XG4gICAgcXVlcnkuZ2VvbWV0cnkgPSBkZWZhdWx0R3JhcGhpYy5nZW9tZXRyeTtcbiAgICBxdWVyeS5vdXRTcGF0aWFsUmVmZXJlbmNlID0gZGVmYXVsdEdyYXBoaWMuZ2VvbWV0cnkuc3BhdGlhbFJlZmVyZW5jZTtcbiAgICBjb25zdCBmZWF0dXJlcyA9IGF3YWl0IGxheWVyLnF1ZXJ5VmlzaWJsZVJhc3RlcnMocXVlcnksIHtcbiAgICAgICAgcmV0dXJuVG9wbW9zdFJhc3RlcjogdHJ1ZSxcbiAgICAgICAgcmV0dXJuRG9tYWluVmFsdWVzOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIChfYSA9IGZlYXR1cmVzID09PSBudWxsIHx8IGZlYXR1cmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWF0dXJlc1swXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVmYXVsdEdyYXBoaWM7XG59O1xuY29uc3QgZ2V0Q2xvc2VzdFRvQ2VudGVyID0gYXN5bmMgKGZlYXR1cmVTZXQsIG1hcFZpZXcsIGxheWVyKSA9PiB7XG4gICAgY29uc3QgZ2VvbWV0cnlUeXBlID0gYXdhaXQgZ2V0TGF5ZXJHZW9tZXRyeVR5cGUobGF5ZXIpO1xuICAgIC8vIHBvaW50IGJhc2VkIG9uIHBvaW50IGRpc3RhbmNlXG4gICAgaWYgKGdlb21ldHJ5VHlwZSA9PT0gXCJwb2ludFwiKSB7XG4gICAgICAgIGxldCBmZWF0dXJlQW5kRGlzdGFuY2UgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGZlYXR1cmVTZXQuZmVhdHVyZXMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50RGlzdGFuY2UgPSBmZWF0dXJlU2V0LmZlYXR1cmVzW3hdLmdlb21ldHJ5LmRpc3RhbmNlKG1hcFZpZXcuY2VudGVyKTtcbiAgICAgICAgICAgIGlmICh4ID09PSAwIHx8IChmZWF0dXJlQW5kRGlzdGFuY2UgPT09IG51bGwgfHwgZmVhdHVyZUFuZERpc3RhbmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWF0dXJlQW5kRGlzdGFuY2VbMV0pID4gcG9pbnREaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVBbmREaXN0YW5jZSA9IFtmZWF0dXJlU2V0LmZlYXR1cmVzW3hdLCBwb2ludERpc3RhbmNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmVhdHVyZUFuZERpc3RhbmNlWzBdO1xuICAgIH1cbiAgICAvLyBwb2x5bGluZSB3aXRoIGdyYXRlXG4gICAgZWxzZSBpZiAoZ2VvbWV0cnlUeXBlID09PSBcInBvbHlsaW5lXCIpIHtcbiAgICAgICAgbGV0IGZlYXR1cmVBbmREaXN0YW5jZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IFtnZW9tZXRyeUVuZ2luZV0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2dlb21ldHJ5L2dlb21ldHJ5RW5naW5lXCJdKTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBmZWF0dXJlU2V0LmZlYXR1cmVzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lRGlzdGFuY2UgPSBnZW9tZXRyeUVuZ2luZS5uZWFyZXN0VmVydGV4KGZlYXR1cmVTZXQuZmVhdHVyZXNbeF0uZ2VvbWV0cnksIG1hcFZpZXcuY2VudGVyKS5kaXN0YW5jZTtcbiAgICAgICAgICAgIGlmICh4ID09PSAwIHx8IChmZWF0dXJlQW5kRGlzdGFuY2UgPT09IG51bGwgfHwgZmVhdHVyZUFuZERpc3RhbmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWF0dXJlQW5kRGlzdGFuY2VbMV0pID4gbGluZURpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZUFuZERpc3RhbmNlID0gW2ZlYXR1cmVTZXQuZmVhdHVyZXNbeF0sIGxpbmVEaXN0YW5jZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZlYXR1cmVBbmREaXN0YW5jZVswXTtcbiAgICB9XG4gICAgLy8gcG9seWdvbiBiYXNlZCBvbiBjZW50cm9pZCBkaXN0YW5jZVxuICAgIGVsc2UgaWYgKGdlb21ldHJ5VHlwZSA9PT0gXCJwb2x5Z29uXCIgfHwgZ2V0U2VydmljZVR5cGUobGF5ZXIpID09PSBcImltYWdlcnlcIikge1xuICAgICAgICBsZXQgZmVhdHVyZUFuZERpc3RhbmNlID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBmZWF0dXJlU2V0LmZlYXR1cmVzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICBjb25zdCBjZW50cm9pZERpc3RhbmNlID0gZmVhdHVyZVNldC5mZWF0dXJlc1t4XS5nZW9tZXRyeS5jZW50cm9pZC5kaXN0YW5jZShtYXBWaWV3LmNlbnRlcik7XG4gICAgICAgICAgICBpZiAoeCA9PT0gMCB8fCAoZmVhdHVyZUFuZERpc3RhbmNlID09PSBudWxsIHx8IGZlYXR1cmVBbmREaXN0YW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmVhdHVyZUFuZERpc3RhbmNlWzFdKSA+IGNlbnRyb2lkRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlQW5kRGlzdGFuY2UgPSBbZmVhdHVyZVNldC5mZWF0dXJlc1t4XSwgY2VudHJvaWREaXN0YW5jZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZlYXR1cmVBbmREaXN0YW5jZVswXTtcbiAgICB9XG4gICAgLy8gdGFibGUsIGFueSBvdGhlciB1c2UgY2FzZSwgc2VuZCB0aGUgMXN0IG9uZVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmVhdHVyZVNldC5mZWF0dXJlc1swXTtcbiAgICB9XG59O1xuLy8gY29uc3QgZ2V0U2luZ2xlU2NlbmVGZWF0dXJlVG9EaXNwbGF5ID0gYXN5bmMgKFxuLy8gICBtYXBWaWV3OiBfX2VzcmkuTWFwVmlldyxcbi8vICAgbGF5ZXI6IF9fZXNyaS5TY2VuZUxheWVyLFxuLy8gICBwcmV2aWV3UG9wdXBDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXJcbi8vICk6IFByb21pc2U8X19lc3JpLkdyYXBoaWM+ID0+IHtcbi8vICAgdHJ5IHtcbi8vICAgICBjb25zdCBsYXllclZpZXcgPSBhd2FpdCBtYXBWaWV3LndoZW5MYXllclZpZXcobGF5ZXIpO1xuLy8gICAgIGNvbnN0IHF1ZXJ5ID0gbGF5ZXIuY3JlYXRlUXVlcnkoKTtcbi8vICAgICBxdWVyeS5zdGFydCA9IDA7XG4vLyAgICAgcXVlcnkubnVtID0gMTtcbi8vICAgICBxdWVyeS5vdXRGaWVsZHMgPSBbXCIqXCJdO1xuLy8gICAgIGNvbnN0IHRlbXBSZXN1bHQgPSBhd2FpdCBsYXllclZpZXcucXVlcnlGZWF0dXJlcyhxdWVyeSwgeyBzaWduYWw6IHByZXZpZXdQb3B1cENvbnRyb2xsZXIuc2lnbmFsIH0pO1xuLy8gICAgIHJldHVybiB0ZW1wUmVzdWx0LmZlYXR1cmVzPy5bMF07XG4vLyAgIH0gY2F0Y2ggKGVycm9yKSB7XG4vLyAgICAgLy8gYWJvcnQgZXJyb3Jcbi8vICAgICByZXR1cm4gbnVsbDtcbi8vICAgfVxuLy8gfTtcblxuZXhwb3J0IHsgZ2VuZXJhdGVNYXN0ZXJGaWVsZEluZm8gYXMgZywgcHJldmlld1BvcHVwIGFzIHAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJldmlld1BvcHVwLTJhY2I5NDg4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==