"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_loadin-02c488"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loading-69139907.js":
/*!*************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loading-69139907.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   r: () => (/* binding */ requestWrapper)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
let _loadingTimer;
let _requestCancelled;
function startLoading(node) {
    node.loading = true;
    _requestCancelled = false;
    if (_loadingTimer) {
        clearTimeout(_loadingTimer);
    }
    _loadingTimer = setTimeout(() => {
        // took too long
        endLoading(node);
        _requestCancelled = true;
    }, 60000);
}
function endLoading(node) {
    node.loading = false;
}
function requestWrapper(request, node) {
    startLoading(node);
    return request
        .then((result) => {
        endLoading(node);
        if (!_requestCancelled) {
            return Promise.resolve(result);
        }
        else {
            return Promise.reject(new Error("timeout"));
        }
    })
        .catch((error) => {
        endLoading(node);
        return Promise.reject(error);
    });
}



//# sourceMappingURL=loading-69139907.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-class-breaks-50c446bd.js":
/*!*************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-class-breaks-50c446bd.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ createVectorFieldRenderer),
/* harmony export */   b: () => (/* binding */ createClassBreaksRendererFromExisting),
/* harmony export */   c: () => (/* binding */ createClassBreaksRenderer),
/* harmony export */   d: () => (/* binding */ createVectorFieldRendererFromExisting),
/* harmony export */   g: () => (/* binding */ getRasterClassBreaksFields)
/* harmony export */ });
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/* harmony import */ var _raster_symbolStyler_9b32ef48_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./raster-symbolStyler-9b32ef48.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-symbolStyler-9b32ef48.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */





/**
 * creates a Vector Field renderer with default settings
 * @param options: options
 */
function createVectorFieldRenderer() {
    const { layer: smLayer, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    const rasterFunction = layer.type === "imagery" ? layer.rasterFunction : undefined;
    return modules.RasterVectorFieldCreator.createRenderer({ layer, rasterFunction }).then((result) => {
        layer.effect = undefined;
        layer.renderer = result.renderer;
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}
/**
 * Creates a Vector Field renderer with some settings from the current renderer
 * @param options: options
 */
function createVectorFieldRendererFromExisting(options) {
    const { layer: smLayer, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    const renderer = layer.renderer;
    const rasterFunction = layer.type === "imagery" ? layer.rasterFunction : undefined;
    options = options || {};
    return modules.RasterVectorFieldCreator.createRenderer({
        layer,
        rasterFunction,
        style: options.style || renderer.style
    }).then((result) => {
        // save old tile size
        result.renderer.symbolTileSize = renderer.symbolTileSize;
        // save old size variable variable
        const sizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size");
        result.renderer.visualVariables = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.n)(result.renderer, "size") || [];
        result.renderer.visualVariables.push(sizeVisVar);
        // save old symbol direction
        result.renderer.flowRepresentation = renderer.flowRepresentation;
        // save old input unit
        result.renderer.inputUnit = renderer.inputUnit;
        // save old output unit
        result.renderer.outputUnit = renderer.outputUnit;
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}

/**
 * creates a Class Breaks renderer with default settings
 */
function createClassBreaksRenderer() {
    const { layer: smLayer, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    const rasterFunction = layer.type === "imagery" ? layer.rasterFunction : undefined;
    const colorRamp = (0,_raster_symbolStyler_9b32ef48_js__WEBPACK_IMPORTED_MODULE_3__.c)([
        [245, 245, 0],
        [255, 0, 0]
    ].map((color) => new modules.esriColor(color)));
    return modules.RasterClassBreaksCreator.createRenderer({
        layer,
        rasterFunction,
        colorRamp
    }).then((result) => {
        result.renderer.classBreakInfos.forEach((classBreakInfo) => (classBreakInfo.symbol.outline.width = 0));
        return Promise.resolve(result);
    });
}
function createClassBreaksRendererFromExisting(options) {
    const { layer: smLayer, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    const renderer = layer.renderer;
    const rasterFunction = layer.type === "imagery" ? layer.rasterFunction : undefined;
    return modules.RasterClassBreaksCreator.createRenderer({
        layer,
        rasterFunction,
        field: options.field || renderer.field,
        classificationMethod: options.classificationMethod || renderer.authoringInfo.classificationMethod,
        numClasses: options.numClasses || renderer.classBreakInfos.length,
        colorRamp: renderer.authoringInfo.colorRamp,
        definedInterval: options.definedInterval
    }).then((result) => {
        result.renderer.classBreakInfos.forEach((classBreakInfo) => (classBreakInfo.symbol.outline.width = 0));
        return Promise.resolve(result);
    });
}
function getRasterClassBreaksFields() {
    var _a;
    const { layer: smLayer, modules, strings } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    let fields;
    const { rasterInfo } = layer;
    const rasterAttributeTableFields = (_a = rasterInfo === null || rasterInfo === void 0 ? void 0 : rasterInfo.attributeTable) === null || _a === void 0 ? void 0 : _a.fields;
    if (rasterAttributeTableFields) {
        fields = rasterAttributeTableFields.filter((field) => field.type !== "oid" && field.type !== "string");
    }
    else {
        fields = [new modules.Field({ name: "value", alias: strings.panels.classBreaks.value })];
    }
    return fields;
}



//# sourceMappingURL=raster-class-breaks-50c446bd.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-flow-761a3470.js":
/*!*****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-flow-761a3470.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ createFlowRendererFromExisting),
/* harmony export */   c: () => (/* binding */ createFlowRenderer),
/* harmony export */   f: () => (/* binding */ findFlowScheme)
/* harmony export */ });
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




/**
 * creates a Flow renderer with default settings
 * @param options: options
 */
function createFlowRenderer(options) {
    const { layer: smLayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    options = options || {};
    return modules.RasterFlowCreator.createRenderer({
        layer,
        view: mapView,
        theme: options.flowTheme || "flow-line",
        includeColorVariable: options.includeColorVariable,
        legendOptions: options.legendOptions,
        flowRepresentation: options.flowRepresentation,
        flowScheme: options.flowScheme || findFlowScheme()
    }).then((result) => {
        if (result.layerEffect && result.layerEffect.indexOf("drop-shadow") === -1) {
            layer.effect = result.layerEffect;
        }
        result.renderer.color = result.renderer.color && (options.color || result.renderer.color);
        layer.renderer = result.renderer;
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}
/**
 * Creates a Flow renderer with some settings from the current renderer
 * @param options: options
 */
function createFlowRendererFromExisting(options) {
    var _a;
    const { layer: smLayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    options = options || {};
    const renderer = layer.renderer;
    const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "color");
    const authoringInfo = renderer.authoringInfo;
    const theme = options.flowTheme || (authoringInfo === null || authoringInfo === void 0 ? void 0 : authoringInfo.flowTheme) || "flow-line";
    return modules.RasterFlowCreator.createRenderer({
        layer,
        view: mapView,
        theme,
        includeColorVariable: (_a = options.includeColorVariable) !== null && _a !== void 0 ? _a : !!colorVisVar,
        legendOptions: options.legendOptions || (colorVisVar === null || colorVisVar === void 0 ? void 0 : colorVisVar.legendOptions),
        flowRepresentation: options.flowRepresentation || renderer.flowRepresentation,
        // flowScheme: theme === "flow-line" ? options.flowScheme || findFlowScheme() : undefined /* bug */
        flowScheme: options.flowScheme
    }).then((result) => {
        // keep old slider min/max
        const colorAuthVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.p)(renderer, "color");
        const newColorAuthVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.p)(result.renderer, "color");
        if ((colorAuthVisVar === null || colorAuthVisVar === void 0 ? void 0 : colorAuthVisVar.minSliderValue) && (colorAuthVisVar === null || colorAuthVisVar === void 0 ? void 0 : colorAuthVisVar.maxSliderValue) && newColorAuthVisVar) {
            newColorAuthVisVar.minSliderValue = colorAuthVisVar.minSliderValue;
            newColorAuthVisVar.maxSliderValue = colorAuthVisVar.maxSliderValue;
        }
        // keep old stops
        const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(layer.renderer, "color");
        const newColorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(result.renderer, "color");
        if (colorVisVar && newColorVisVar) {
            colorVisVar.stops.forEach((stop, idx) => {
                newColorVisVar.stops[idx].value = stop.value;
            });
        }
        // keep old single color
        result.renderer.color = result.renderer.color && (options.color || renderer.color || result.renderer.color);
        // keep old stop colors
        const scheme = options.flowScheme || findFlowScheme();
        if (scheme && colorVisVar && newColorVisVar) {
            colorVisVar.stops.forEach((stop, idx) => {
                newColorVisVar.stops[idx].color = new modules.esriColor(stop.color.toJSON());
            });
        }
        if (theme === authoringInfo.flowTheme) {
            result.renderer.flowSpeed = renderer.flowSpeed;
            result.renderer.density = renderer.density;
            result.renderer.trailLength = renderer.trailLength;
            result.renderer.trailWidth = renderer.trailWidth;
            result.renderer.trailCap = renderer.trailCap;
        }
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}
function findFlowScheme() {
    const { layer: smLayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    const renderer = layer.renderer;
    const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "color");
    if (!colorVisVar) {
        return null;
    }
    const colors = colorVisVar.stops.map((stop) => {
        return stop.color;
    });
    const schemes = modules.flowSchemes.getSchemes({
        basemap: mapView.map.basemap || "topo"
    });
    const allSchemes = [schemes.primaryScheme].concat(schemes.secondarySchemes);
    const matchingSchemes = [];
    allSchemes.forEach((scheme) => {
        let hasNoMatch = colors.some((color, idx) => {
            return !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a4)(scheme.colors[idx], color);
        });
        if (!hasNoMatch) {
            matchingSchemes.push(scheme);
        }
        else {
            // try flipped ramp
            scheme.colors = scheme.colors.reverse();
            hasNoMatch = colors.some((color, idx) => {
                return !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a4)(scheme.colors[idx], color);
            });
            if (!hasNoMatch) {
                matchingSchemes.push(scheme);
            }
        }
    });
    return matchingSchemes.length ? matchingSchemes[0] : null;
}



//# sourceMappingURL=raster-flow-761a3470.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fbG9hZGluLTAyYzQ4OC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFK0I7O0FBRS9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tIO0FBQy9FO0FBQ0E7QUFDc0M7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQixFQUFFLCtEQUFpQjtBQUN6RDtBQUNBO0FBQ0EsNkRBQTZELHVCQUF1QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEIsRUFBRSwrREFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUVBQVM7QUFDcEMsMENBQTBDLG1FQUFnQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEIsRUFBRSwrREFBaUI7QUFDekQ7QUFDQTtBQUNBLHNCQUFzQixtRUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQixFQUFFLCtEQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUMsRUFBRSwrREFBaUI7QUFDbEU7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHdEQUF3RDtBQUM5RjtBQUNBO0FBQ0E7O0FBRW1NOztBQUVuTTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNrSTtBQUMvRjtBQUNBOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUMsRUFBRSwrREFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUMsRUFBRSwrREFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1FQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQ0FBZ0MsbUVBQWE7QUFDN0MsbUNBQW1DLG1FQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUVBQVM7QUFDckMsK0JBQStCLG1FQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUMsRUFBRSwrREFBaUI7QUFDbEU7QUFDQTtBQUNBLHdCQUF3QixtRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0VBQVc7QUFDL0IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9FQUFXO0FBQ25DLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUU2Rjs7QUFFN0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9sb2FkaW5nLTY5MTM5OTA3LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL3Jhc3Rlci1jbGFzcy1icmVha3MtNTBjNDQ2YmQuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vcmFzdGVyLWZsb3ctNzYxYTM0NzAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5sZXQgX2xvYWRpbmdUaW1lcjtcbmxldCBfcmVxdWVzdENhbmNlbGxlZDtcbmZ1bmN0aW9uIHN0YXJ0TG9hZGluZyhub2RlKSB7XG4gICAgbm9kZS5sb2FkaW5nID0gdHJ1ZTtcbiAgICBfcmVxdWVzdENhbmNlbGxlZCA9IGZhbHNlO1xuICAgIGlmIChfbG9hZGluZ1RpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChfbG9hZGluZ1RpbWVyKTtcbiAgICB9XG4gICAgX2xvYWRpbmdUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyB0b29rIHRvbyBsb25nXG4gICAgICAgIGVuZExvYWRpbmcobm9kZSk7XG4gICAgICAgIF9yZXF1ZXN0Q2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9LCA2MDAwMCk7XG59XG5mdW5jdGlvbiBlbmRMb2FkaW5nKG5vZGUpIHtcbiAgICBub2RlLmxvYWRpbmcgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlcXVlc3RXcmFwcGVyKHJlcXVlc3QsIG5vZGUpIHtcbiAgICBzdGFydExvYWRpbmcobm9kZSk7XG4gICAgcmV0dXJuIHJlcXVlc3RcbiAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBlbmRMb2FkaW5nKG5vZGUpO1xuICAgICAgICBpZiAoIV9yZXF1ZXN0Q2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidGltZW91dFwiKSk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIGVuZExvYWRpbmcobm9kZSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IHJlcXVlc3RXcmFwcGVyIGFzIHIgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZGluZy02OTEzOTkwNy5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGEgYXMgZ2V0VmlzVmFyLCBuIGFzIGdldFZpc1ZhcnNFeGNlcHQsIHMgYXMgc21hcnRNYXBwaW5nU3RhdGUgfSBmcm9tICcuL3Jhc3Rlci11bmlxdWUtdmFsdWUtMDk3NmVjN2YuanMnO1xuaW1wb3J0ICcuL2xvYWRNb2R1bGVzLWI0YWMxMjQ3LmpzJztcbmltcG9ydCAnLi9jb21tb25FbnVtcy1mY2YxMzY2MS5qcyc7XG5pbXBvcnQgeyBjIGFzIGNyZWF0ZUNvbG9yUmFtcCB9IGZyb20gJy4vcmFzdGVyLXN5bWJvbFN0eWxlci05YjMyZWY0OC5qcyc7XG5cbi8qKlxuICogY3JlYXRlcyBhIFZlY3RvciBGaWVsZCByZW5kZXJlciB3aXRoIGRlZmF1bHQgc2V0dGluZ3NcbiAqIEBwYXJhbSBvcHRpb25zOiBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVZlY3RvckZpZWxkUmVuZGVyZXIoKSB7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIGNvbnN0IHJhc3RlckZ1bmN0aW9uID0gbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5XCIgPyBsYXllci5yYXN0ZXJGdW5jdGlvbiA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbW9kdWxlcy5SYXN0ZXJWZWN0b3JGaWVsZENyZWF0b3IuY3JlYXRlUmVuZGVyZXIoeyBsYXllciwgcmFzdGVyRnVuY3Rpb24gfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGxheWVyLmVmZmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGF5ZXIucmVuZGVyZXIgPSByZXN1bHQucmVuZGVyZXI7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9LCAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBWZWN0b3IgRmllbGQgcmVuZGVyZXIgd2l0aCBzb21lIHNldHRpbmdzIGZyb20gdGhlIGN1cnJlbnQgcmVuZGVyZXJcbiAqIEBwYXJhbSBvcHRpb25zOiBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVZlY3RvckZpZWxkUmVuZGVyZXJGcm9tRXhpc3Rpbmcob3B0aW9ucykge1xuICAgIGNvbnN0IHsgbGF5ZXI6IHNtTGF5ZXIsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IGxheWVyID0gc21MYXllcjtcbiAgICBjb25zdCByZW5kZXJlciA9IGxheWVyLnJlbmRlcmVyO1xuICAgIGNvbnN0IHJhc3RlckZ1bmN0aW9uID0gbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5XCIgPyBsYXllci5yYXN0ZXJGdW5jdGlvbiA6IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gbW9kdWxlcy5SYXN0ZXJWZWN0b3JGaWVsZENyZWF0b3IuY3JlYXRlUmVuZGVyZXIoe1xuICAgICAgICBsYXllcixcbiAgICAgICAgcmFzdGVyRnVuY3Rpb24sXG4gICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlIHx8IHJlbmRlcmVyLnN0eWxlXG4gICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIC8vIHNhdmUgb2xkIHRpbGUgc2l6ZVxuICAgICAgICByZXN1bHQucmVuZGVyZXIuc3ltYm9sVGlsZVNpemUgPSByZW5kZXJlci5zeW1ib2xUaWxlU2l6ZTtcbiAgICAgICAgLy8gc2F2ZSBvbGQgc2l6ZSB2YXJpYWJsZSB2YXJpYWJsZVxuICAgICAgICBjb25zdCBzaXplVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcInNpemVcIik7XG4gICAgICAgIHJlc3VsdC5yZW5kZXJlci52aXN1YWxWYXJpYWJsZXMgPSBnZXRWaXNWYXJzRXhjZXB0KHJlc3VsdC5yZW5kZXJlciwgXCJzaXplXCIpIHx8IFtdO1xuICAgICAgICByZXN1bHQucmVuZGVyZXIudmlzdWFsVmFyaWFibGVzLnB1c2goc2l6ZVZpc1Zhcik7XG4gICAgICAgIC8vIHNhdmUgb2xkIHN5bWJvbCBkaXJlY3Rpb25cbiAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmZsb3dSZXByZXNlbnRhdGlvbiA9IHJlbmRlcmVyLmZsb3dSZXByZXNlbnRhdGlvbjtcbiAgICAgICAgLy8gc2F2ZSBvbGQgaW5wdXQgdW5pdFxuICAgICAgICByZXN1bHQucmVuZGVyZXIuaW5wdXRVbml0ID0gcmVuZGVyZXIuaW5wdXRVbml0O1xuICAgICAgICAvLyBzYXZlIG9sZCBvdXRwdXQgdW5pdFxuICAgICAgICByZXN1bHQucmVuZGVyZXIub3V0cHV0VW5pdCA9IHJlbmRlcmVyLm91dHB1dFVuaXQ7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9LCAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKSk7XG59XG5cbi8qKlxuICogY3JlYXRlcyBhIENsYXNzIEJyZWFrcyByZW5kZXJlciB3aXRoIGRlZmF1bHQgc2V0dGluZ3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2xhc3NCcmVha3NSZW5kZXJlcigpIHtcbiAgICBjb25zdCB7IGxheWVyOiBzbUxheWVyLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCBsYXllciA9IHNtTGF5ZXI7XG4gICAgY29uc3QgcmFzdGVyRnVuY3Rpb24gPSBsYXllci50eXBlID09PSBcImltYWdlcnlcIiA/IGxheWVyLnJhc3RlckZ1bmN0aW9uIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGNvbG9yUmFtcCA9IGNyZWF0ZUNvbG9yUmFtcChbXG4gICAgICAgIFsyNDUsIDI0NSwgMF0sXG4gICAgICAgIFsyNTUsIDAsIDBdXG4gICAgXS5tYXAoKGNvbG9yKSA9PiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoY29sb3IpKSk7XG4gICAgcmV0dXJuIG1vZHVsZXMuUmFzdGVyQ2xhc3NCcmVha3NDcmVhdG9yLmNyZWF0ZVJlbmRlcmVyKHtcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIHJhc3RlckZ1bmN0aW9uLFxuICAgICAgICBjb2xvclJhbXBcbiAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcy5mb3JFYWNoKChjbGFzc0JyZWFrSW5mbykgPT4gKGNsYXNzQnJlYWtJbmZvLnN5bWJvbC5vdXRsaW5lLndpZHRoID0gMCkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDbGFzc0JyZWFrc1JlbmRlcmVyRnJvbUV4aXN0aW5nKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGxheWVyOiBzbUxheWVyLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCBsYXllciA9IHNtTGF5ZXI7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBsYXllci5yZW5kZXJlcjtcbiAgICBjb25zdCByYXN0ZXJGdW5jdGlvbiA9IGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeVwiID8gbGF5ZXIucmFzdGVyRnVuY3Rpb24gOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG1vZHVsZXMuUmFzdGVyQ2xhc3NCcmVha3NDcmVhdG9yLmNyZWF0ZVJlbmRlcmVyKHtcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIHJhc3RlckZ1bmN0aW9uLFxuICAgICAgICBmaWVsZDogb3B0aW9ucy5maWVsZCB8fCByZW5kZXJlci5maWVsZCxcbiAgICAgICAgY2xhc3NpZmljYXRpb25NZXRob2Q6IG9wdGlvbnMuY2xhc3NpZmljYXRpb25NZXRob2QgfHwgcmVuZGVyZXIuYXV0aG9yaW5nSW5mby5jbGFzc2lmaWNhdGlvbk1ldGhvZCxcbiAgICAgICAgbnVtQ2xhc3Nlczogb3B0aW9ucy5udW1DbGFzc2VzIHx8IHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcy5sZW5ndGgsXG4gICAgICAgIGNvbG9yUmFtcDogcmVuZGVyZXIuYXV0aG9yaW5nSW5mby5jb2xvclJhbXAsXG4gICAgICAgIGRlZmluZWRJbnRlcnZhbDogb3B0aW9ucy5kZWZpbmVkSW50ZXJ2YWxcbiAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcy5mb3JFYWNoKChjbGFzc0JyZWFrSW5mbykgPT4gKGNsYXNzQnJlYWtJbmZvLnN5bWJvbC5vdXRsaW5lLndpZHRoID0gMCkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRSYXN0ZXJDbGFzc0JyZWFrc0ZpZWxkcygpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbW9kdWxlcywgc3RyaW5ncyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIGxldCBmaWVsZHM7XG4gICAgY29uc3QgeyByYXN0ZXJJbmZvIH0gPSBsYXllcjtcbiAgICBjb25zdCByYXN0ZXJBdHRyaWJ1dGVUYWJsZUZpZWxkcyA9IChfYSA9IHJhc3RlckluZm8gPT09IG51bGwgfHwgcmFzdGVySW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFzdGVySW5mby5hdHRyaWJ1dGVUYWJsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpZWxkcztcbiAgICBpZiAocmFzdGVyQXR0cmlidXRlVGFibGVGaWVsZHMpIHtcbiAgICAgICAgZmllbGRzID0gcmFzdGVyQXR0cmlidXRlVGFibGVGaWVsZHMuZmlsdGVyKChmaWVsZCkgPT4gZmllbGQudHlwZSAhPT0gXCJvaWRcIiAmJiBmaWVsZC50eXBlICE9PSBcInN0cmluZ1wiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZpZWxkcyA9IFtuZXcgbW9kdWxlcy5GaWVsZCh7IG5hbWU6IFwidmFsdWVcIiwgYWxpYXM6IHN0cmluZ3MucGFuZWxzLmNsYXNzQnJlYWtzLnZhbHVlIH0pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbn1cblxuZXhwb3J0IHsgY3JlYXRlVmVjdG9yRmllbGRSZW5kZXJlciBhcyBhLCBjcmVhdGVDbGFzc0JyZWFrc1JlbmRlcmVyRnJvbUV4aXN0aW5nIGFzIGIsIGNyZWF0ZUNsYXNzQnJlYWtzUmVuZGVyZXIgYXMgYywgY3JlYXRlVmVjdG9yRmllbGRSZW5kZXJlckZyb21FeGlzdGluZyBhcyBkLCBnZXRSYXN0ZXJDbGFzc0JyZWFrc0ZpZWxkcyBhcyBnIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhc3Rlci1jbGFzcy1icmVha3MtNTBjNDQ2YmQuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBwIGFzIGdldEF1dGhWaXNWYXIsIGEgYXMgZ2V0VmlzVmFyLCBzIGFzIHNtYXJ0TWFwcGluZ1N0YXRlLCBhNCBhcyBpc1NhbWVDb2xvciB9IGZyb20gJy4vcmFzdGVyLXVuaXF1ZS12YWx1ZS0wOTc2ZWM3Zi5qcyc7XG5pbXBvcnQgJy4vbG9hZE1vZHVsZXMtYjRhYzEyNDcuanMnO1xuaW1wb3J0ICcuL2NvbW1vbkVudW1zLWZjZjEzNjYxLmpzJztcblxuLyoqXG4gKiBjcmVhdGVzIGEgRmxvdyByZW5kZXJlciB3aXRoIGRlZmF1bHQgc2V0dGluZ3NcbiAqIEBwYXJhbSBvcHRpb25zOiBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZsb3dSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbWFwVmlldywgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBtb2R1bGVzLlJhc3RlckZsb3dDcmVhdG9yLmNyZWF0ZVJlbmRlcmVyKHtcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIHZpZXc6IG1hcFZpZXcsXG4gICAgICAgIHRoZW1lOiBvcHRpb25zLmZsb3dUaGVtZSB8fCBcImZsb3ctbGluZVwiLFxuICAgICAgICBpbmNsdWRlQ29sb3JWYXJpYWJsZTogb3B0aW9ucy5pbmNsdWRlQ29sb3JWYXJpYWJsZSxcbiAgICAgICAgbGVnZW5kT3B0aW9uczogb3B0aW9ucy5sZWdlbmRPcHRpb25zLFxuICAgICAgICBmbG93UmVwcmVzZW50YXRpb246IG9wdGlvbnMuZmxvd1JlcHJlc2VudGF0aW9uLFxuICAgICAgICBmbG93U2NoZW1lOiBvcHRpb25zLmZsb3dTY2hlbWUgfHwgZmluZEZsb3dTY2hlbWUoKVxuICAgIH0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAocmVzdWx0LmxheWVyRWZmZWN0ICYmIHJlc3VsdC5sYXllckVmZmVjdC5pbmRleE9mKFwiZHJvcC1zaGFkb3dcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBsYXllci5lZmZlY3QgPSByZXN1bHQubGF5ZXJFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmNvbG9yID0gcmVzdWx0LnJlbmRlcmVyLmNvbG9yICYmIChvcHRpb25zLmNvbG9yIHx8IHJlc3VsdC5yZW5kZXJlci5jb2xvcik7XG4gICAgICAgIGxheWVyLnJlbmRlcmVyID0gcmVzdWx0LnJlbmRlcmVyO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfSwgKGVycm9yKSA9PiBQcm9taXNlLnJlamVjdChlcnJvcikpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgRmxvdyByZW5kZXJlciB3aXRoIHNvbWUgc2V0dGluZ3MgZnJvbSB0aGUgY3VycmVudCByZW5kZXJlclxuICogQHBhcmFtIG9wdGlvbnM6IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmxvd1JlbmRlcmVyRnJvbUV4aXN0aW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbWFwVmlldywgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbGF5ZXIucmVuZGVyZXI7XG4gICAgY29uc3QgY29sb3JWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgY29uc3QgYXV0aG9yaW5nSW5mbyA9IHJlbmRlcmVyLmF1dGhvcmluZ0luZm87XG4gICAgY29uc3QgdGhlbWUgPSBvcHRpb25zLmZsb3dUaGVtZSB8fCAoYXV0aG9yaW5nSW5mbyA9PT0gbnVsbCB8fCBhdXRob3JpbmdJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdXRob3JpbmdJbmZvLmZsb3dUaGVtZSkgfHwgXCJmbG93LWxpbmVcIjtcbiAgICByZXR1cm4gbW9kdWxlcy5SYXN0ZXJGbG93Q3JlYXRvci5jcmVhdGVSZW5kZXJlcih7XG4gICAgICAgIGxheWVyLFxuICAgICAgICB2aWV3OiBtYXBWaWV3LFxuICAgICAgICB0aGVtZSxcbiAgICAgICAgaW5jbHVkZUNvbG9yVmFyaWFibGU6IChfYSA9IG9wdGlvbnMuaW5jbHVkZUNvbG9yVmFyaWFibGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICEhY29sb3JWaXNWYXIsXG4gICAgICAgIGxlZ2VuZE9wdGlvbnM6IG9wdGlvbnMubGVnZW5kT3B0aW9ucyB8fCAoY29sb3JWaXNWYXIgPT09IG51bGwgfHwgY29sb3JWaXNWYXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbG9yVmlzVmFyLmxlZ2VuZE9wdGlvbnMpLFxuICAgICAgICBmbG93UmVwcmVzZW50YXRpb246IG9wdGlvbnMuZmxvd1JlcHJlc2VudGF0aW9uIHx8IHJlbmRlcmVyLmZsb3dSZXByZXNlbnRhdGlvbixcbiAgICAgICAgLy8gZmxvd1NjaGVtZTogdGhlbWUgPT09IFwiZmxvdy1saW5lXCIgPyBvcHRpb25zLmZsb3dTY2hlbWUgfHwgZmluZEZsb3dTY2hlbWUoKSA6IHVuZGVmaW5lZCAvKiBidWcgKi9cbiAgICAgICAgZmxvd1NjaGVtZTogb3B0aW9ucy5mbG93U2NoZW1lXG4gICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIC8vIGtlZXAgb2xkIHNsaWRlciBtaW4vbWF4XG4gICAgICAgIGNvbnN0IGNvbG9yQXV0aFZpc1ZhciA9IGdldEF1dGhWaXNWYXIocmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgICAgIGNvbnN0IG5ld0NvbG9yQXV0aFZpc1ZhciA9IGdldEF1dGhWaXNWYXIocmVzdWx0LnJlbmRlcmVyLCBcImNvbG9yXCIpO1xuICAgICAgICBpZiAoKGNvbG9yQXV0aFZpc1ZhciA9PT0gbnVsbCB8fCBjb2xvckF1dGhWaXNWYXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbG9yQXV0aFZpc1Zhci5taW5TbGlkZXJWYWx1ZSkgJiYgKGNvbG9yQXV0aFZpc1ZhciA9PT0gbnVsbCB8fCBjb2xvckF1dGhWaXNWYXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbG9yQXV0aFZpc1Zhci5tYXhTbGlkZXJWYWx1ZSkgJiYgbmV3Q29sb3JBdXRoVmlzVmFyKSB7XG4gICAgICAgICAgICBuZXdDb2xvckF1dGhWaXNWYXIubWluU2xpZGVyVmFsdWUgPSBjb2xvckF1dGhWaXNWYXIubWluU2xpZGVyVmFsdWU7XG4gICAgICAgICAgICBuZXdDb2xvckF1dGhWaXNWYXIubWF4U2xpZGVyVmFsdWUgPSBjb2xvckF1dGhWaXNWYXIubWF4U2xpZGVyVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8ga2VlcCBvbGQgc3RvcHNcbiAgICAgICAgY29uc3QgY29sb3JWaXNWYXIgPSBnZXRWaXNWYXIobGF5ZXIucmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgICAgIGNvbnN0IG5ld0NvbG9yVmlzVmFyID0gZ2V0VmlzVmFyKHJlc3VsdC5yZW5kZXJlciwgXCJjb2xvclwiKTtcbiAgICAgICAgaWYgKGNvbG9yVmlzVmFyICYmIG5ld0NvbG9yVmlzVmFyKSB7XG4gICAgICAgICAgICBjb2xvclZpc1Zhci5zdG9wcy5mb3JFYWNoKChzdG9wLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBuZXdDb2xvclZpc1Zhci5zdG9wc1tpZHhdLnZhbHVlID0gc3RvcC52YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtlZXAgb2xkIHNpbmdsZSBjb2xvclxuICAgICAgICByZXN1bHQucmVuZGVyZXIuY29sb3IgPSByZXN1bHQucmVuZGVyZXIuY29sb3IgJiYgKG9wdGlvbnMuY29sb3IgfHwgcmVuZGVyZXIuY29sb3IgfHwgcmVzdWx0LnJlbmRlcmVyLmNvbG9yKTtcbiAgICAgICAgLy8ga2VlcCBvbGQgc3RvcCBjb2xvcnNcbiAgICAgICAgY29uc3Qgc2NoZW1lID0gb3B0aW9ucy5mbG93U2NoZW1lIHx8IGZpbmRGbG93U2NoZW1lKCk7XG4gICAgICAgIGlmIChzY2hlbWUgJiYgY29sb3JWaXNWYXIgJiYgbmV3Q29sb3JWaXNWYXIpIHtcbiAgICAgICAgICAgIGNvbG9yVmlzVmFyLnN0b3BzLmZvckVhY2goKHN0b3AsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIG5ld0NvbG9yVmlzVmFyLnN0b3BzW2lkeF0uY29sb3IgPSBuZXcgbW9kdWxlcy5lc3JpQ29sb3Ioc3RvcC5jb2xvci50b0pTT04oKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhlbWUgPT09IGF1dGhvcmluZ0luZm8uZmxvd1RoZW1lKSB7XG4gICAgICAgICAgICByZXN1bHQucmVuZGVyZXIuZmxvd1NwZWVkID0gcmVuZGVyZXIuZmxvd1NwZWVkO1xuICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmRlbnNpdHkgPSByZW5kZXJlci5kZW5zaXR5O1xuICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLnRyYWlsTGVuZ3RoID0gcmVuZGVyZXIudHJhaWxMZW5ndGg7XG4gICAgICAgICAgICByZXN1bHQucmVuZGVyZXIudHJhaWxXaWR0aCA9IHJlbmRlcmVyLnRyYWlsV2lkdGg7XG4gICAgICAgICAgICByZXN1bHQucmVuZGVyZXIudHJhaWxDYXAgPSByZW5kZXJlci50cmFpbENhcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfSwgKGVycm9yKSA9PiBQcm9taXNlLnJlamVjdChlcnJvcikpO1xufVxuZnVuY3Rpb24gZmluZEZsb3dTY2hlbWUoKSB7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbWFwVmlldywgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbGF5ZXIucmVuZGVyZXI7XG4gICAgY29uc3QgY29sb3JWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgaWYgKCFjb2xvclZpc1Zhcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY29sb3JzID0gY29sb3JWaXNWYXIuc3RvcHMubWFwKChzdG9wKSA9PiB7XG4gICAgICAgIHJldHVybiBzdG9wLmNvbG9yO1xuICAgIH0pO1xuICAgIGNvbnN0IHNjaGVtZXMgPSBtb2R1bGVzLmZsb3dTY2hlbWVzLmdldFNjaGVtZXMoe1xuICAgICAgICBiYXNlbWFwOiBtYXBWaWV3Lm1hcC5iYXNlbWFwIHx8IFwidG9wb1wiXG4gICAgfSk7XG4gICAgY29uc3QgYWxsU2NoZW1lcyA9IFtzY2hlbWVzLnByaW1hcnlTY2hlbWVdLmNvbmNhdChzY2hlbWVzLnNlY29uZGFyeVNjaGVtZXMpO1xuICAgIGNvbnN0IG1hdGNoaW5nU2NoZW1lcyA9IFtdO1xuICAgIGFsbFNjaGVtZXMuZm9yRWFjaCgoc2NoZW1lKSA9PiB7XG4gICAgICAgIGxldCBoYXNOb01hdGNoID0gY29sb3JzLnNvbWUoKGNvbG9yLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhaXNTYW1lQ29sb3Ioc2NoZW1lLmNvbG9yc1tpZHhdLCBjb2xvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWhhc05vTWF0Y2gpIHtcbiAgICAgICAgICAgIG1hdGNoaW5nU2NoZW1lcy5wdXNoKHNjaGVtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0cnkgZmxpcHBlZCByYW1wXG4gICAgICAgICAgICBzY2hlbWUuY29sb3JzID0gc2NoZW1lLmNvbG9ycy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBoYXNOb01hdGNoID0gY29sb3JzLnNvbWUoKGNvbG9yLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWlzU2FtZUNvbG9yKHNjaGVtZS5jb2xvcnNbaWR4XSwgY29sb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWhhc05vTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGluZ1NjaGVtZXMucHVzaChzY2hlbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hdGNoaW5nU2NoZW1lcy5sZW5ndGggPyBtYXRjaGluZ1NjaGVtZXNbMF0gOiBudWxsO1xufVxuXG5leHBvcnQgeyBjcmVhdGVGbG93UmVuZGVyZXJGcm9tRXhpc3RpbmcgYXMgYSwgY3JlYXRlRmxvd1JlbmRlcmVyIGFzIGMsIGZpbmRGbG93U2NoZW1lIGFzIGYgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFzdGVyLWZsb3ctNzYxYTM0NzAuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9