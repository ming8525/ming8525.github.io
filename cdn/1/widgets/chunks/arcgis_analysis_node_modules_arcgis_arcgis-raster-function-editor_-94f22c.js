"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-94f22c"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.pt-BR-13a658bd.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.pt-BR-13a658bd.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addRaster: () => (/* binding */ addRaster),
/* harmony export */   addScalar: () => (/* binding */ addScalar),
/* harmony export */   breadcrumb: () => (/* binding */ breadcrumb),
/* harmony export */   breadcrumbEditor: () => (/* binding */ breadcrumbEditor),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   category: () => (/* binding */ category),
/* harmony export */   categoryNames: () => (/* binding */ categoryNames),
/* harmony export */   close: () => (/* binding */ close),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultModelName: () => (/* binding */ defaultModelName),
/* harmony export */   definitionQuery: () => (/* binding */ definitionQuery),
/* harmony export */   description: () => (/* binding */ description),
/* harmony export */   deselectFunction: () => (/* binding */ deselectFunction),
/* harmony export */   details: () => (/* binding */ details),
/* harmony export */   dialogTitle: () => (/* binding */ dialogTitle),
/* harmony export */   dontSave: () => (/* binding */ dontSave),
/* harmony export */   enterFURL: () => (/* binding */ enterFURL),
/* harmony export */   enterURL: () => (/* binding */ enterURL),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   errorTitle: () => (/* binding */ errorTitle),
/* harmony export */   everyone: () => (/* binding */ everyone),
/* harmony export */   f32PixelType: () => (/* binding */ f32PixelType),
/* harmony export */   f64PixelType: () => (/* binding */ f64PixelType),
/* harmony export */   failedToLoadLayer: () => (/* binding */ failedToLoadLayer),
/* harmony export */   folder: () => (/* binding */ folder),
/* harmony export */   general: () => (/* binding */ general),
/* harmony export */   groupFieldName: () => (/* binding */ groupFieldName),
/* harmony export */   groupItemsBy: () => (/* binding */ groupItemsBy),
/* harmony export */   groups: () => (/* binding */ groups),
/* harmony export */   invalidRFTMessage: () => (/* binding */ invalidRFTMessage),
/* harmony export */   isDataset: () => (/* binding */ isDataset),
/* harmony export */   isPublic: () => (/* binding */ isPublic),
/* harmony export */   item: () => (/* binding */ item),
/* harmony export */   itemGroup: () => (/* binding */ itemGroup),
/* harmony export */   loadingLayer: () => (/* binding */ loadingLayer),
/* harmony export */   matchVariables: () => (/* binding */ matchVariables),
/* harmony export */   mosaic: () => (/* binding */ mosaic),
/* harmony export */   multidimensionalRules: () => (/* binding */ multidimensionalRules),
/* harmony export */   name: () => (/* binding */ name),
/* harmony export */   noTagErrorMsg: () => (/* binding */ noTagErrorMsg),
/* harmony export */   noTitleErrorMsg: () => (/* binding */ noTitleErrorMsg),
/* harmony export */   noTitleTagErrorMsg: () => (/* binding */ noTitleTagErrorMsg),
/* harmony export */   ok: () => (/* binding */ ok),
/* harmony export */   organization: () => (/* binding */ organization),
/* harmony export */   outputPixelType: () => (/* binding */ outputPixelType),
/* harmony export */   owner: () => (/* binding */ owner),
/* harmony export */   parameter: () => (/* binding */ parameter),
/* harmony export */   parameters: () => (/* binding */ parameters),
/* harmony export */   properties: () => (/* binding */ properties),
/* harmony export */   raster: () => (/* binding */ raster),
/* harmony export */   rasterFunctionEditor: () => (/* binding */ rasterFunctionEditor),
/* harmony export */   rasterFunctions: () => (/* binding */ rasterFunctions),
/* harmony export */   rfxLicenseInfo: () => (/* binding */ rfxLicenseInfo),
/* harmony export */   s16PixelType: () => (/* binding */ s16PixelType),
/* harmony export */   s32PixelType: () => (/* binding */ s32PixelType),
/* harmony export */   s8PixelType: () => (/* binding */ s8PixelType),
/* harmony export */   save: () => (/* binding */ save),
/* harmony export */   saveAs: () => (/* binding */ saveAs),
/* harmony export */   saveUtils: () => (/* binding */ saveUtils),
/* harmony export */   savingMessage: () => (/* binding */ savingMessage),
/* harmony export */   scalar: () => (/* binding */ scalar),
/* harmony export */   search: () => (/* binding */ search),
/* harmony export */   selectFeature: () => (/* binding */ selectFeature),
/* harmony export */   selectFunction: () => (/* binding */ selectFunction),
/* harmony export */   selectRaster: () => (/* binding */ selectRaster),
/* harmony export */   serviceURL: () => (/* binding */ serviceURL),
/* harmony export */   setGroupSharing: () => (/* binding */ setGroupSharing),
/* harmony export */   setSharingLevel: () => (/* binding */ setSharingLevel),
/* harmony export */   share: () => (/* binding */ share),
/* harmony export */   shareWith: () => (/* binding */ shareWith),
/* harmony export */   success: () => (/* binding */ success),
/* harmony export */   tagFieldName: () => (/* binding */ tagFieldName),
/* harmony export */   tags: () => (/* binding */ tags),
/* harmony export */   title: () => (/* binding */ title),
/* harmony export */   toolDetailsEditor: () => (/* binding */ toolDetailsEditor),
/* harmony export */   toolEditor: () => (/* binding */ toolEditor),
/* harmony export */   toolModeler: () => (/* binding */ toolModeler),
/* harmony export */   tryAgain: () => (/* binding */ tryAgain),
/* harmony export */   type: () => (/* binding */ type),
/* harmony export */   u16PixelType: () => (/* binding */ u16PixelType),
/* harmony export */   u32PixelType: () => (/* binding */ u32PixelType),
/* harmony export */   u8PixelType: () => (/* binding */ u8PixelType),
/* harmony export */   unionDimensions: () => (/* binding */ unionDimensions),
/* harmony export */   unknownPixelType: () => (/* binding */ unknownPixelType),
/* harmony export */   unsavedTitle: () => (/* binding */ unsavedTitle),
/* harmony export */   unsavedWarningExisting: () => (/* binding */ unsavedWarningExisting),
/* harmony export */   unsavedWarningNew: () => (/* binding */ unsavedWarningNew),
/* harmony export */   userStartDirection: () => (/* binding */ userStartDirection),
/* harmony export */   variables: () => (/* binding */ variables),
/* harmony export */   viewerModeMessage: () => (/* binding */ viewerModeMessage),
/* harmony export */   viewerModeTitle: () => (/* binding */ viewerModeTitle),
/* harmony export */   warning: () => (/* binding */ warning)
/* harmony export */ });
const ok = "OK";
const cancel = "Cancelar";
const enterURL = "Inserir URL do Serviço de Imagem";
const serviceURL = "URL de Serviço";
const selectRaster = "Selecionar Raster";
const failedToLoadLayer = "Falha ao carregar Camada";
const loadingLayer = "Carregando camada";
const selectFeature = "Selecionar Camada de Feição";
const enterFURL = "Inserir URL de Serviço da Feição";
const addRaster = "Adiciona Variável de Raster";
const addScalar = "Adicionar Constante";
const raster = "Raster";
const scalar = "Escalar";
const defaultModelName = "Modelo de Função do Raster";
const general = "Geral";
const parameters = "Parâmetros";
const variables = "Variáveis";
const name = "Nome";
const description = "Descrição";
const parameter = "Parâmetro";
const isPublic = "É Público";
const isDataset = "IsDataset";
const unknownPixelType = "Desconhecido";
const outputPixelType = "Tipo de Pixel de Saída";
const u8PixelType = "8 Bit Indefinido";
const s8PixelType = "8 Bit Definido";
const u16PixelType = "16 Bit Indefinido";
const s16PixelType = "16 Bit Definido";
const u32PixelType = "32 Bit Não Atribuído";
const s32PixelType = "32 Bit Atribuído";
const f32PixelType = "32 Bit Flutuante";
const f64PixelType = "64 Bit Duplo";
const properties = "Propriedades";
const multidimensionalRules = "Regras Multidimensionais";
const matchVariables = "Variável Correspondentes";
const unionDimensions = "Unir Dimensões";
const rasterFunctionEditor = {
	invalidRFTMessage: "O Modelo de Função do Raster não é válido.",
	rfxArgsEditor: {
		outputRaster: "OutputRaster",
		raster: "Raster",
		unsupportedDataTypeWarning: "Os seguintes parâmetros não são exibidos, pois atualmente não são suportados.",
		unsupportedFunction: "Contém funções raster atualmente não suportadas."
	},
	rfxRasterInput: {
		selectLayer: "Selecionar Camada",
		browseLayers: "Procurar Camadas",
		rfxVariable: "RasterFunctionVariable"
	},
	rfxBandCombinationEditor: {
		methodLabel: "Método",
		bandLabel: "Banda",
		combinationLabel: "Combinação"
	},
	rfxRemapGrid: {
		minimum: "Mínimo",
		maximum: "Máximo",
		output: "Saída",
		noData: "NoData",
		remapValuesLabel: "Remapear Valores"
	},
	rfxNamedRasterEditor: {
		rasterVariables: "Variáveis do Raster",
		deleteSelectedVars: "Remover variáveis selecionadas"
	},
	rfxClippingGeometry: {
		clippingLayer: "Recortando Camada",
		clippingRaster: "Recortando Raster",
		clippingGeometry: "Recortando Geometria",
		customExtent: "Personalizar extensão",
		outputExtent: "Extensão de Saída",
		currentExtent: "Extensão do Mapa Atual",
		drawLabel: "Desenhar"
	},
	rfxCustomExtent: {
		top: "Superior",
		right: "Direita",
		bottom: "Inferior",
		left: "Esquerda"
	},
	rfxRasterArrayEditor: {
		moveUp: "Mover para Cima",
		moveDown: "Mover para Baixo",
		remove: "Remover"
	},
	rfxStatisticsGrid: {
		stdDev: "Desvio Padrão",
		min: "Mín",
		max: "Máx",
		mean: "Média"
	},
	rfxWeightedSumTableEditor: {
		weightedSumTable: "Tabela de Soma Ponderada",
		id: "ID",
		layer: "Camada",
		field: "Campo",
		weight: "Peso",
		value: "Valor",
		selectLayer: "Selecionar Camada"
	},
	rfxWeightedOverlayTableEditor: {
		weightedOverlayTable: "Tabela de Sobreposição Ponderada",
		id: "ID",
		layer: "Camada",
		field: "Campo",
		influence: "Influência",
		sumOfInfluence: "Soma de Influência",
		value: "Valor",
		remapTable: "Tabela de Remapeamento",
		scale: "Escala",
		scales: "Escalas",
		selectRaster: "Selecionar Raster"
	},
	rfxFeatureSelect: {
		addFeatureLayer: "Procurar por uma camada de feição",
		addPointLayer: "Procurar por uma camada de ponto"
	},
	rfxFieldSelect: {
		value: "Valor",
		count: "Contagem"
	},
	rfxAttributeTable: {
		tableType: "Tipo de Tabela",
		manual: "Manual",
		external: "Externo",
		minVal: "Valor Mínimo",
		maxVal: "Valor Máximo",
		baseClassName: "Nome de Base de Classe",
		colorScheme: "Esquema de Cores",
		defaultClassName: "Label_",
		generateTable: "Gerar Tabela",
		browseTable: "Procurar Tabela",
		value: "Valor",
		classname: "ClassName",
		color: "Cor"
	},
	rfxFieldNumberSwitchable: {
		number: "Numérico",
		field: "Campo",
		string: "Texto",
		linearUnit: "Unidade Linear"
	},
	rfxPropertySet: {
		name: "Nome",
		value: "Valor"
	},
	rfxConversionGrid: {
		size: "Tamanho"
	},
	rfxTransposeBit: {
		bitPattern: "Padrão Bit",
		outputBit: "Bit de Saída",
		inputBit: "Bit de Entrada"
	},
	rfxSpatialReference: {
		placeHolder: "Refinar por Palavra-Chave",
		coordinateSystem: "Sistema de Coordenadas",
		gcs: "Sistema de Coordenadas Geográficas",
		pcs: "Sistema de Coordenadas Planas",
		vcs: "Sistema de Coordenadas Verticais"
	}
};
const rfxLicenseInfo = "Este modelo de função raster pode ser utilizado para processar sua imagem utilizando o ArcGIS Image Server.";
const rasterFunctions = {
	rfx: {
		aCosHName: "ACosH",
		aCosHSnip: "Calcule o co-seno hiperbólico inverso de células em um raster.",
		aCosHDesc: "A função calcula o co-seno hiperbólico inverso dos pixels em um raster.",
		aCosName: "ACos",
		aCosSnip: "Calcula o co-seno inverso dos pixels em um raster.",
		aCosDesc: "Esta função de raster calcula o co-seno inverso das células em um raster. Em matemática, todas as funções trigonométricas têm uma faixa definida de valores de entrada válidos, chamada de domínio. Os valores de saída de cada função também têm uma faixa definida. Para esta ferramenta, o domínio é [-1, 1], e o intervalo é [0, pi].",
		aSinHName: "ASenH",
		aSinHSnip: "Calcula o seno hiperbólico inverso de células em um raster.",
		aSinHDesc: "A função calcula o seno hiperbólico inverso dos pixels em um raster.",
		aSinName: "ASen",
		aSinSnip: "Calcula o seno inverso de células em um raster.",
		aSinDesc: "A função calcula o seno inverso dos pixels em um raster.",
		aTan2Name: "ATan2",
		aTan2Snip: "Calcula a tangente inversa (baseado em x,y) de células em um raster.",
		aTan2Desc: "A função calcula a tangente inversa (baseado em x,y) dos pixels em um raster.",
		aTanHName: "ATanH",
		aTanHSnip: "Calcula a tangente hiperbólica inversa de células em um raster.",
		aTanHDesc: "A função calcula a tangente hiperbólica inversa dos pixels em um raster.",
		aTanName: "ATan",
		aTanSnip: "Calcula a tangente inversa de células em um raster.",
		aTanDesc: "A função calcula a tangente inversa dos pixels em um raster.",
		absName: "Abs",
		absSnip: "Calcule o valor absoluto das células em um raster.",
		absDesc: "A função Abs calcula o valor absoluto dos pixels em um raster.",
		reflectanceName: "Reflectância Aparente",
		reflectanceSnip: "Converte imagem bruta em valores do Topo da Atmosfera levando em conta as características do sensor, a posição do sol e o tempo de aquisição.",
		reflectanceDesc: "Esta função de raster que ajusta os valores do número digital de brilho da imagem (DN) para alguns sensores de satélite. Os ajustes são baseados na elevação do Sol, na data de aquisição e nas propriedades do sensor para definir o ganho e a polarização para cada banda. Esta função é utilizada para ajustar os valores de reflectância ou brilho de algumas imagens de satélite com base na iluminação da cena e nas configurações de ganho do sensor. As imagens são ajustadas para uma condição de iluminação teoricamente comum, portanto, deve haver menor variação entre cenas de diferentes datas e diferentes sensores. Isto pode ser útil para classificação de imagem, balanceamento de cores e mosaico. Esta função pode ser utilizada somente com imagens específicas. Os sensores aplicáveis são Landsat MSS, Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, GeoEye-1, RapidEye, DMCii, WorldView-1, WorldView-2, SPOT 6 e Pleiades.<div><br/>A função executa duas correções. O primeiro é baseado nas configurações de ganho. Os valores de brilho originais são recriados a partir dos valores da imagem ao reverter as equações de ganho. A segunda correção tem a ver com as diferenças de ângulo e brilho do Sol. Os valores de brilho originais são ajustados para uma condição de iluminação comum normalizando cenas capturadas em condições de iluminação variável. Em geral, enquanto o tipo de dados da imagem de saída for o mesmo que o tipo de dados da imagem de entrada, os valores de saída serão inferiores aos valores de entrada e serão cortados no intervalo de dados válido.</div>",
		argStatisticsName: "ArgStatistics",
		argStatisticsSnip: "Calcula a estatística de cenário incluindo Arg Máx, Arg Mín, Arg Média e Duração.",
		argStatisticsDesc: "A função computa estatística de argumento. Há quatro métodos na função ArgStatistics: ArgMax, ArgMin, ArgMedian e Duration.",
		arithmeticName: "Aritmético",
		arithmeticSnip: "Executa uma operação aritmética entre dois rasters ou um raster e um escalar.",
		arithmeticDesc: "A função Aritmética executa uma operação aritmética entre dois rasters ou um raster e um escalar, e vice versa.",
		aspectSlopeName: "Aspecto-Declividade",
		aspectSlopeSnip: "Cria um raster que exibe simultaneamente o aspecto (direção) e a declividade (inclinação) de uma superfície contínua, conforme representado em um modelo de elevação digital.",
		aspectSlopeDesc: "A função Aspecto de Declividade cria uma camada raster que exibe simultaneamente o aspecto e declive de uma superfície. O aspecto identifica a direção de declividade da taxa máxima de alteração no valor de cada pixel para seus vizinhos. O aspecto pode ser visto como a direção de declividade. Os valores do raster de saída serão a direção de bússola do aspecto, representados por uma tonalidade (cor). A declividade representa a taxa de alteração de elevação de cada pixel do modelo de elevação digital (DEM). A declividade representa a parte íngreme da superfície e é simbolizada em três classes que são mostradas utilizando saturação de cor (brilho).<div><br/>Os valores de pixel no raster de declividade-aspecto de saída refletem uma combinação de aspecto e declividade. Pixels com valores abaixo de 20 são considerados planos e são mostrados em cinzas. Os valores de declividade-aspecto de 21 e acima de serão exibidos com saturações variadas como seguem: 21 a 30 —Saturação de declividade baixa, 31 para 40—Saturação de declividade moderada, 41 e acima—Saturação de declividade alta</div>",
		aspectName: "Aspecto",
		aspectSnip: "Mostra qual é a direção de um pixel, onde 0 é devido ao norte e ao ângulo aumentando no sentido horário para 360.",
		aspectDesc: "A função Aspecto identifica a direção de declividade da taxa máxima de alteração no valor de cada célula para seus vizinhos. O aspecto pode ser visto como a direção de declividade. Os valores do raster de saída serão a direção de bússola do aspecto.<div><br/>A entrada desta função é Raster de Entrada. A função Aspecto é normalmente aplicada a um modelo digital de elevação (DEM). Por padrão, o aspecto aparece como uma imagem em escala de cinza. Você pode adicionar a função Mapa de Cores para especificar um esquema de cores em particular ou permitir que a pessoa que visualiza o mosaico modifique a simbologia com seu próprio esquema de cores.</div>",
		tableName: "Tabela de Atributos",
		tableSnip: "Utilize uma tabela para nomear e simbolizar os valores em um conjunto de dados. As colunas da tabela são delimitadas por vírgula: PixelValue, AttributeName, RedValue, GreenValue, BlueValu.",
		tableDesc: "A função Tabela de Atributo permite a você definir uma tabela de atributos para simbolizar um conjunto de dados de mosaico de única banda ou conjunto de dados raster. <div><br/>Isto é útil quando desejar apresentar a imagem que sofreu uma classificação para uso do solo, tais como, terra de floresta, zonas úmidas, área de colheita e urbana. Adicionalmente, se sua tabela contiver campos nomeados vermelho, verde e azul, os valores dentro destes campos serão utilizados como um mapa de cores ao renderizar a imagem.</div>",
		bandArithmeticName: "Aritmética de Bandas",
		bandArithmeticSnip: "Calcula índices utilizando fórmulas pré definidas ou uma expressão definida pelo usuário.",
		bandArithmeticDesc: "A função Aritmética da Banda executa uma operação aritmética nas bandas de um conjunto de dados raster. Você pode escolher algoritmos pré-definidos ou inserir sua própria fórmula de linha única. Os operadores suportados são -,+,/,*, e unário -.",
		thresholdName: "Limite Binário",
		thresholdSnip: "Organiza dados contínuos no primeiro plano e segundo plano minimizando a covariância entre as duas classes.",
		thresholdDesc: "Quando um conjunto de dados raster tiver uma distribuição bimodal, esta função cria um novo raster que divide os dados em duas classes distintas. Ele cria uma classe de valor baixo exibido com pixels pretos e uma classe de valor alto exibida com pixels brancos.",
		bitwiseAndName: "E Bitwise",
		bitwiseAndSnip: "Executa a operação Bitwise E em valores binários de dois rasters de entrada.",
		bitwiseAndDesc: "Bitwise E executa uma operação Bitwise E em valores binários de dois rasters de entrada.",
		bitwiseLeftShiftName: "Mudança à Esquerda de Bitwise",
		bitwiseLeftShiftSnip: "Executa a operação Mudança à Esquerda de Bitwise em valores binários de dois rasters de entrada.",
		bitwiseLeftShiftDesc: "A ferramenta Mudança à Esquerda de Bitwise executa uma operação Mudança à Esquerda de Bitwise nos valores binários de dois dados rasters de entrada.",
		bitwiseNotName: "Não Bitwise",
		bitwiseNotSnip: "Executa uma operação Bitwise Não (complemento) nos valores binários de dois rasters de entrada.",
		bitwiseNotDesc: "A função executa uma operação Bitwise Não (complemento) no valor binário de um raster de entrada.",
		bitwiseOrName: "Ou Bitwise",
		bitwiseOrSnip: "Executa uma operação Bitwise Ou em valores binários de dois rasters de entrada.",
		bitwiseOrDesc: "A função executa uma operação Bitwise Ou em valores binários de dois rasters de entrada. ",
		bitwiseRightShiftName: "Deslocar à Direita do Bitwise",
		bitwiseRightShiftSnip: "Executa a operação Deslocar à Direita do Bitwise em valores binários de dois rasters de entrada.",
		bitwiseRightShiftDesc: "A função executa uma operação Deslocar à Direita do Bitwise em valores binários de dois rasters de entrada.",
		bitwiseXorName: "XOu Bitwise",
		bitwiseXorSnip: "Executa a operação Ou Bitwise eXclusivo em valores binários de dois rasters de entrada.",
		bitwiseXorDesc: "A função executa uma operação Bitwise eXclusivo em valores binários de dois rasters de entrada.",
		booleanAndName: "E Booleano",
		booleanAndSnip: "Executa a operação E Booleano em valores da célula de dois rasters de entrada. Se ambos os valores de entrada forem verdadeiros (não zero), o valor de saída será 1. Se uma ou ambas entradas forem falsas (zero), o valor de saída será 0.",
		booleanAndDesc: "A função executa uma operação Booleano E em valores de pixel de dois rasters de entrada. Se ambos os valores de entrada forem verdadeiros (não zero), o valor de saída será 1. Se um ou ambos os valores de entrada forem falsos (zero), o valor de saída será 0. ",
		booleanNotName: "Não Booleano",
		booleanNotSnip: "Executa uma operação Não Booleano (complemento) nos valores de células do raster de entrada. Se os valores de entrada forem verdadeiros (não zero), o valor de saída será 0. Se os valores de entrada forem falsos (zero), o valor de saída será 1.",
		booleanNotDesc: "A função executa uma operação Não Booleano (complemento) nos valores de pixel do raster de entrada. Se os valores de entrada forem verdadeiros (não zero), o valor de saída será 0. Se os valores de entrada forem falsos (zero), o valor de saída será 1.",
		booleanOrName: "Ou Booleano",
		booleanOrSnip: "Executa a operação Ou Booleano em valores da célula de dois rasters de entrada. Se um ou ambos valores de entrada forem verdadeiros (não zero), o valor de saída será 1. Se ambos os valores de entrada forem falsos (zero), a saída será 0.",
		booleanOrDesc: "A função executa uma operação Bitwise Ou em valores de células de dois rasters de entrada. Se um ou ambos os valores de entrada forem verdadeiros (não zero), o valor de saída será 1. Se ambos os valores de entrada forem falsos (zero), o valor de saída será 0.",
		booleanXorName: "XOu Boolean",
		booleanXorSnip: "Executa a operação Booleano eXclusive Ou em valores da célula de dois rasters de entrada. Se um valor de entrada for verdadeiro (não zero) e o outro valor for falso (zero), o valor de saída será 1. Se ambos os valores de entrada forem verdadeiros ou ambos forem falsos, o valor de saída será 0.",
		booleanXorDesc: "A função executa uma operação Booleano eXclusivo Ou nos valores de células de dois rasters de entrada. Se um valor de entrada for verdadeiro (não zero) e o outro valor for falso (zero), o valor de saída será 1. Se ambos os valores de entrada forem verdadeiros ou ambos forem falsos, o valor de saída será 0.",
		bufferedRasterName: "Buffer",
		bufferedRasterSnip: "Gera o buffer do último bloco de pixel acessado.",
		bufferedRasterDesc: "A função Com Buffer é utilizada para otimizar o desempenho de cadeias de funções complexas. Ela armazena a saída na memória de parte da cadeia de função que vem antes dela. <div><br/>Insira esta função no Editor de Função onde deseja armazenar a saída.</div>",
		rasterCalculatorName: "Calculadora",
		rasterCalculatorSnip: "Computa um raster a partir de um raster baseado em uma expressão matemática.",
		rasterCalculatorDesc: "A função Calculadora permite a você criar e executar expressões, e incorporar estas em cadeias de função.",
		cellStatisticsName: "Estatísticas da Célula",
		cellStatisticsSnip: "Calcula uma estatística por célula de vários rasters. As estatísticas disponíveis são Maioria, Máximo, Média, Mediana, Mínimo, Minoria, Percentil, Intervalo, Desvio Padrão, Soma e Variedade.",
		cellStatisticsDesc: "Esta é uma função que calcula estatísticas de múltiplos rasters, em uma base de pixel por pixel. As estatísticas disponíveis são maioria, máximo, média, mediana, mínimo, minoria, intervalo, desvio padrão, soma e variedade.",
		classifyName: "Classificar",
		classifySnip: "Atribui cada pixel a uma classe. Incorpora dados subordinados, tal como, uma imagem segmentada.",
		classifyDesc: "Esta função de raster classifica um conjunto de dados raster baseado em um arquivo de Definição do Classificador da Esri (.ecd) e entradas do conjunto de dados raster. O arquivo .ecd utilizado na função Classificar contém todas as informações para um conjunto de dados específico e classificador, e é gerado pelas ferramentas de treinamento de classificação, tal como, as ferramentas Treinar Máquina Vetorial de Suporte ou Treinar Árvores Aleatórias .",
		clipName: "Recortar",
		clipSnip: "Configura a extensão de um raster utilizando coordenadas ou outro conjunto de dados.",
		clipDesc: "Esta função recorta um raster utilizando uma forma retangular de acordo com as extensões definidas ou recortará um raster para a forma de uma classe de feição de polígono de entrada. A forma que define o recorte pode recortar a extensão do raster ou recortar uma área dentro do raster.",
		colorspaceConversionName: "Conversão do Modelo de Cores",
		colorspaceConversionSnip: "Converte um raster de RGB para HSV e vice versa.",
		colorspaceConversionDesc: "A função Conversão do Modelo de Cores converte o modelo de cores de uma imagem a partir da tonalidade, saturação e valor (HSV) de cor de espaço para vermelho, verde e azul (RGB) ou vice-versa.<div><br/>Esta função pode ser utilizada em um conjunto de dados de mosaico.</div>",
		colormapToRGBName: "Mapa de Cores para RGB",
		colormapToRGBSnip: "Converte um raster de banda única com um mapa de cores, para um raster de três bandas (vermelho, verde e azul).",
		colormapToRGBDesc: "Esta função converte um raster de banda única com um mapa de cores, para um raster de três bandas (vermelho, verde e azul).<div><br/>Esta função é útil quando você precisar criar um raster de três bandas de um raster de banda única com um mapa de cores associado. Os valores no mapa de cores serão utilizados para criar cada banda vermelha, verde e azul. Esta função pode ser utilizada em um conjunto de dados de mosaico.</div>",
		colormapName: "Mapa de Cores",
		colormapSnip: "Altera os valores de pixel para exibir os dados do raster como uma imagem em vermelho, azul, verde (RGB) ou escala de cinza, baseado em um mapa de cores ou uma rampa de cores.",
		colormapDesc: "A função Mapa de cores é um tipo de renderizador de dados raster. Ela transforma os valores de pixel para exibir os dados raster como uma imagem de escala em cinza ou RGB com base em um esquema de cor ou cores específicas em um arquivo de mapa de cores. Você pode utilizar um mapa de cores para representar dados analisados, como uma imagem classificada ou ao exibir um mapa topográfico (ou um índice de imagem escaneada de cor).<div><br/>Os mapas de cores contém um conjunto de valores que são associados com cores utilizadas para exibir um raster de banda única constantemente com as mesmas cores. Cada valor de pixel é associado com uma cor, definido como um conjunto de valores RGB. Os mapas de cores são capazes de suportar qualquer profundidade de bit exceto o ponto flutuante. Eles também suportam valores positivos e negativos e podem conter valores mapeados de cores ausentes. Ao exibir um conjunto de dados com um mapa de cores contendo valores ausentes, os pixels com estes valores ausentes não serão exibidos.</div>",
		complexName: "Complexo",
		complexSnip: "Extrai a magnitude de números complexos.",
		complexDesc: "Esta função computa a magnitude de valores complexos.<div><br/>Esta função é normalmente utilizada com imagens RADAR que tem um tipo de dados complexos. Ela pode ser utilizada em um conjunto de dados de mosaico.</div>",
		compositeBandName: "Bandas Compostas",
		compositeBandSnip: "Combina múltiplos conjunto de dados em um raster de múltiplas bandas.",
		compositeBandDesc: "A função Bandas Compostas permite a você combinar várias imagens para formar uma imagem de múltiplas bandas.",
		conName: "Con",
		conSnip: "Executa uma operação condicional Se, Então, Outro. Quando um operador Con é utilizado, normalmente são necessárias duas ou mais funções locais encadeadas, onde uma função declara os critérios e a segunda função é o operador Con que utiliza os critérios e dita quais devem ser as saídas verdadeiras e falsas.",
		conDesc: "A função Con configura os pixels do raster de saída baseado em uma avaliação se\\outro de cada pixel de entrada. Ela retorna valores de pixel do Raster Verdadeiro se a avaliação condicional for verdadeira (1) ou retorna os valores de pixel a partir do Raster Falso se a avaliação condicional for falsa (0). Estes critérios são especificados pela saída de uma função matemática lógica, que será o Raster de entrada.",
		constantName: "Constante",
		constantSnip: "Cria um raster virtual com um único valor de pixel.",
		constantDesc: "Esta função cria um raster virtual com um valor de pixel único que pode ser utilizado em modelos de função de raster e para processar um conjunto de dados do mosaico.<div><br/>O valor da constante é utilizado para cada valor de pixel no raster.</div>",
		contourName: "Curva de Nível",
		contourSnip: "Cria linhas da curva de nível.",
		contourDesc: "A função Curva de Nível gera linhas de contorno juntando pontos com a mesma elevação a partir de um conjunto de dados raster de elevação. As curvas de nível são isolinhas criadas como rasters para visualização. Os recursos chaves seguintes tornam esta função poderosa: as curvas de nível são geradas de forma rápida e dinâmica em conjunto de dados grandes, como Elevação Mundial; as curvas de nível pode ser suavizadas para fornecer uma aparência cartográfica mais agradável enquanto mantém a exatidão das curvas de nível; controle dinâmico sobre o intervalo das curvas de nível é fornecido; as opções de saída incluem linhas de curvas de nível, curvas de nível de índice e curvas de nível preenchidas.<div><br/>A criação de uma camada de curva de nível como um produto raster é valiosa para uma ampla gama de aplicações, já que as curvas de nível podem ser sobrepostas em um mapa e fornecer informações sobre o terreno sem obscurecer os dados subjacentes. Elas são úteis em aplicações como engenharia, agricultura e gerenciamento de água.</div>",
		contrastBrightnessName: "Contraste e Brilho",
		contrastBrightnessSnip: "Ajusta o contraste e brilho de um raster.",
		contrastBrightnessDesc: "A função Contraste E Brilho melhora a aparência de dados raster modificando o brilho ou contraste dentro da imagem. O brilho aumenta a claridade global da imagem—por exemplo, tornando cores escuras mais claras e cores claras mais branca—enquanto o contraste ajusta a diferença entre as cores mais escuras e mais claras.<div><br/>A utilização desta função altera os valores de pixel; portanto, esta função deve ser utilizada quando desejar realçar a aparência dos dados e não se você pretender utilizar os dados como parte de uma análise que exigiria os valores de pixels brutos. Esta função é útil ao publicar os dados como um serviço de imagem que pode ser utilizado em aplicativos sem a habilidade de alterar o contraste e brilho da imagem ou assegurar que ela seja exibida utilizando suas configurações preferidas.</div>",
		convolutionName: "Convolução",
		convolutionSnip: "Aplica um filtro para nitidez, sombreado, detectar bordas, suavização ou um efeito gradiente através de um raster.",
		convolutionDesc: "A função Convolução executa um filtro nos valores de pixel em uma imagem, que pode ser utilizado para clarear uma imagem, escurecer uma imagem, detectar bordas dentro de uma imagem ou outras otimizações baseadas em kernel. Os filtros são utilizados para melhorar a qualidade da imagem raster eliminando dados espúrios ou melhorando feições nos dados. Estes filtros de convolução são aplicados um kernel de mudança, sobreposição (janela ou vizinhança), como 3 por 3. Os filtros de convolução funcionam com o cálculo do valor de pixel baseado nos pesos de seus vizinhos.",
		corridorName: "Corredor",
		corridorSnip: "Calcula a soma de custos acumulativos para dois rasters acumulativos de entrada.",
		corridorDesc: "A função de Corredor calcula a soma de custos acumulativos para dois rasters de custo acumulativo de entrada. Enquanto dois rasters podem ser utilizados para a entrada, para obter um resultado significante eles devem ser rasters de saída de custo acumulativo inalterado. A ordem das duas entradas é irrelevante.",
		cosHName: "CosH",
		cosHSnip: "Calcula o co-seno hiperbólico de células em um raster.",
		cosHDesc: "A função calcula o co-seno hiperbólico dos pixels em um raster.",
		cosName: "Cos",
		cosSnip: "Calcula o co-seno de uma célula em um raster.",
		cosDesc: "A função calcula o co-seno dos pixels em um raster.",
		costAllocationName: "Alocação de Custo",
		costAllocationSnip: "Calcula, para cada célula, sua origem de menor custo baseada no menor custo acumulativo sobre uma superfície de custo.",
		costAllocationDesc: "A função Alocação de Custo calcula para cada célula sua fonte de menor custo baseada no menor custo acumulativo sobre uma superfície de custo.",
		costBackLinkName: "Vínculo Anterior de Custo",
		costBackLinkSnip: "Define o vizinho que será a próxima célula no menor caminho de custo acumulativo até a fonte de menor custo.",
		costBackLinkDesc: "A função Vínculo Anterior de Custo define o vizinho que está próximo da célula no caminho de menor custo acumulativo até a fonte de menor custo.<div><br/>O backlink do raster contém valores de zero a oito, que define a direção ou identifica a próxima célula vizinha (célula bem sucedida) ao longo do caminho de custo menos acumulativo de uma célula para alcançar sua origem de menor custo. Se o caminho for passar no vizinho direito, a célula será atribuída ao valor 1, 2 para célula diagonal direita inferior e continuando à direita. O valor 0 é reservado para células de origem.</div>",
		costDistanceName: "Distância de Custo",
		costDistanceSnip: "Calcula a distância de menor custo acumulativo para cada célula de ou para a origem de menor custo sobre uma superfície de custo.",
		costDistanceDesc: "A função Distância de Custo calcula a distância de menor custo acumulativo para cada célula de ou até a fonte de menor custo sobre uma superfície de custo.",
		costPathName: "Caminho de Custo",
		costPathSnip: "Calcula o caminho de menor custo da origem até o destino.",
		costPathDesc: "A função Caminho de Custo global calcula o caminho de menor custo a partir de uma origem até um destino.<div><br/>Esta função produz um raster de saída que registra o caminho menor custo ou caminhos de localizações selecionadas para a célula de origem mais próxima definida dentro da superfície de custo acumulativo, em termos de distância de custo.</div>",
		curvatureName: "Curvatura",
		curvatureSnip: "Calcula a curvatura de uma superfície de raster, opcionalmente inclui perfil e curvatura plana.",
		curvatureDesc: "A função Curvatura exibe a forma ou curvatura de declividade. Uma parte da superfície pode ser côncava ou convexa; você pode dizer isto olhando o valor da curvatura. A curvatura é definida calculando a segunda derivada da superfície.<div><br/>A saída da função Curvatura pode ser utilizada para descrever as características físicas de uma bacia de drenagem em um esforço para entender os processos de erosão e escoamento. O valor da curvatura pode ser utilizado para encontrar padrões de erosão do solo, como também, a distribuição de água na terra. A curvatura do perfil afeta a aceleração e desaceleração do fluxo e, portanto, influencia a erosão e a deposição. A curvatura da forma plana influencia a convergência e divergência do fluxo.</div>",
		divideName: "Dividir",
		divideSnip: "Divide os valores de dois rasters em uma base de célula por célula.",
		divideDesc: "A função Dividir divide os valores de dois rasters em uma base de pixel a pixel.",
		elevationVoidFillName: "Preenchimento de Elevação Nula",
		elevationVoidFillSnip: "Cria pixels onde tiver vazios em seus dados de elevação.",
		elevationVoidFillDesc: "A função Preenchimento de Elevação Nula é utilizada para criar pixels onde tiver vazios em sua elevação.<div><br/>Os vazios ocorrem quando não há pontos coletados dentro da área representada por um pixel no raster resultante. Os vazios são frequentemente causados por corpos d'água, seleção do tipo de classe ou exclusão. O preenchimento do vazio é mais comumente utilizado ao gerar uma superfície.</div>",
		equalToName: "Igual A",
		equalToSnip: "Executa uma operação não-igual-a Relacional em duas entradas em uma base célula a célula. Retorna 1 para células onde o primeiro raster é igual ao segundo dado raster e 0 para células onde não é.",
		equalToDesc: "A função executa uma operação igual-a em dois raster em uma base pixel a pixel. Retorna um valor de 1 de pixels onde o primeiro raster é igual ao segundo raster e um valor de 0 para pixels onde eles não são iguais.",
		eucAllocationName: "Alocação Euclidiana",
		eucAllocationSnip: "Calcula a origem mais próxima para cada célula baseada na distância Euclidiana.",
		eucAllocationDesc: "A função Alocação Euclidiana calcula, para cada célula, a origem mais próxima com base na distância Euclidiana.",
		eucDirectionName: "Direção Euclidiana",
		eucDirectionSnip: "Calcula, para cada célula, a direção, em graus, da origem mais próxima.",
		eucDirectionDesc: "A função Direção Euclidiana calcula, para cada célula, a direção em graus até a origem mais próxima. <div><br/>A direção é calculada a partir de cada centro da célula para o centro da célula de origem que está mais próximo dela. A faixa de valores é de 0 graus a 360 graus, com 0 reservado para as células de origem. Devido ao leste (direita) é 90 e os valores aumentam à direita (180 é sul, 270 é oeste e 360 é norte).</div>",
		eucDistanceName: "Distância Euclidiana",
		eucDistanceSnip: "Calcula, para cada célula, a distância Euclidiana para a origem mais próxima.",
		eucDistanceDesc: "A função Distância Euclidiana calcula, para cada célula, a distância Euclidiana até a origem mais próxima.",
		exp10Name: "Exp10",
		exp10Snip: "Calcula a base de exponencial 10 das células em um raster.",
		exp10Desc: "A função Exp 10 calcula a base 10 exponencial dos pixels em um raster.",
		exp2Name: "Exp2",
		exp2Snip: "Calcula a base de exponencial 2 das células em um raster.",
		exp2Desc: "A função calcula a base 2 exponencial dos pixels em um raster.",
		expName: "Exp",
		expSnip: "Calcule a base e exponencial das células em um raster.",
		expDesc: "Esta função calcula a base e exponencial dos pixels em um raster.",
		extractBandName: "Extrair Faixas",
		extractBandSnip: "Especifica com quais bandas trabalhar ao utilizar conjuntos de dados de múltiplas bandas.",
		extractBandDesc: " A função extrair Bandas permite a você extrair uma ou mais bandas de um raster ou pode reordenar as bandas em um conjunto de dados raster de múltiplas bandas.<div><br/>Você pode utilizar a função Extrair Bandas antes de outras funções, como Aritmética, para controlar quais bandas são utilizadas como entrada na próxima função.</div>",
		fillName: "Preenchimento",
		fillSnip: "Preenche as depressões na superfície do raster para remover pequenas imperfeições nos dados.",
		fillDesc: "A função Preencher global localiza e preenche depressões e cumes em um raster de superfície de elevação para remover imperfeições pequenas nos dados. A função preencherá um processo iterativo até que todas as depressões sejam preenchidas dentro do Limite Z especificado.<div><br/>Quando uma superfície de elevação for criada com ferramentas de Mapeamento de Ortofotos ou por outros meios, há frequentemente pequenos erros significantes no formulário de depressões e cumes nos dados. Em fotogrametria, depressões e cumes são frequentemente chamado de buracos e picos. devido ao fato dos dados de superfície serem frequentemente utilizados em modelagem, como modelagem hidrológica, é importante corrigir estes erros de depressões e cumes até certo ponto consistente com os dados circundantes.</div>",
		floatName: "Real",
		floatSnip: "Converte cada valor de célula de um raster em uma representação de ponto flutuante.",
		floatDesc: "A função Flutuante converte cada valor de pixel de um raster em uma representação de ponto flutuante.",
		flowAccumulationName: "Acumulação de Fluxo",
		flowAccumulationSnip: "Cria um raster de fluxo acumulado em cada célula. Um fator de peso pode opcionalmente ser aplicado.",
		flowAccumulationDesc: "A função Acumulação de Fluxo global cria um raster de fluxo acumulado em cada pixel, como determinado pelo acúmulo do peso de todos os pixels que fluem em cada pixel de declividade. Se nenhum peso de raster for fornecido, um peso de 1 é aplicado a cada pixel e o valor dos pixels no raster de saída for o número de pixels que fluem em cada pixel.<div><br/>Os pixels de saída com uma acumulação de fluxo alta são áreas de fluxos concentrados e podem ser utilizados para identificar canais de rios. Os pixels de saída com uma acumulação de fluxo de zero são locais topográficos altos e podem ser utilizados para identificar cumes.</div>",
		flowDirectionName: "Direção do Fluxo",
		flowDirectionSnip: "Cria um raster da direção de fluxo de cada célula até o vizinho de maior declividade.",
		flowDirectionDesc: "Uma das chaves para derivar características hidrológicas de uma superfície é a habilidade de determinar a direção de fluxo de cada pixel no raster. A função de raster Direção de Fluxo utiliza uma superfície como entrada e cria um raster de direção de fluxo a partir de cada pixel para seu vizinho de declividade mais íngreme. A função Direção de Fluxo suporta três métodos de modelagem de fluxo: o D8 (oito direções), Direção de Fluxo Múltiplo (MFD), e D-Infinity (DINF). ",
		flowDistanceName: "Distância do Fluxo",
		flowDistanceSnip: "Calcula, para cada célula, a distância vertical ou horizontal mínima de declividade para células em um fluxo ou rio no qual fluem.",
		flowDistanceDesc: "Para cada pixel, a função irá calcular a distância mínima vertical ou horizontal de declividade para pixels em um fluxo ou rio em eles fluem. Se um raster de direção de fluxo opcional for fornecido, a direção de declividade será limitada para os definidos pelo raster de direção de fluxo de entrada. A saída é um raster de distância de fluxo.",
		focalName: "Estatística Focal",
		focalSnip: "Calcula a estatística focal para cada pixel de uma imagem baseado em uma vizinhança focal definida.",
		focalDesc: "A função Estatísticas Focal calcula a estatística focal de cada pixel a partir de uma imagem baseado em uma vizinhança focal definida.",
		geometricName: "Geométrico",
		geometricSnip: "Aumenta a precisão posicional de um conjunto de dados ao representar a elevação.",
		geometricDesc: "A função Geométrica produz uma imagem ortorretificada baseado em uma definição de sensor e um modelo de terreno. Aumenta a precisão posicional de um conjunto de dados ao representar a elevação.",
		grayscaleName: "Escala de cinza",
		grayscaleSnip: "Converte uma imagem de banda múltipla em uma imagem de escala de cinza de única banda.",
		grayscaleDesc: "Esta função converte uma imagem de múltiplas bandas em uma imagem de escala de cinza de única banda.<div><br/>Esta função se aplica em pesos especificados para cada banda de entrada e normaliza a imagem de saída. Os pesos estão frequentemente aplicados devido algumas bandas terem importância de variável dependendo do aplicativo. Por exemplo, a banda azul frequentemente contém mais ruído que outras bandas.</div>",
		greaterThanEqualName: "Maior que Igual",
		greaterThanEqualSnip: "Executa uma operação maior-que-igual-a Relacional em duas entradas em uma base célula a célula. Retorna 1 para células onde um raster é maior que ou igual ao segundo raster e 0 se não for maior.",
		greaterThanEqualDesc: "A função executa uma operação maior-que-ou-igual-a Relacional em duas entradas em uma base pixel a pixel. Retorna um valor de 1 para pixels onde o primeiro raster é maior que o segundo raster e um valor de 0 para pixels onde o primeiro raster não é maior ou igual ao segundo raster.",
		greaterThanName: "Maior Que",
		greaterThanSnip: "Executa uma operação maior-que Relacional em duas entradas em uma base célula a célula. Retorna 1 para células em que o primeiro dado raster é maior que o segundo e 0 para células em não é.",
		greaterThanDesc: "A função executa uma operação maior-que Relacional em duas entradas em uma base pixel a pixel. Retorna um valor de 1 para pixels onde o primeiro raster é maior que o segundo raster e um valor de 0 para pixels onde o primeiro raster não é maior que o segundo raster.",
		heatIndexName: "Índice de Aquecimento",
		heatIndexSnip: "Combina temperatura do ambiente e umidade relativa à umidade para retornar uma temperatura aparente.",
		heatIndexDesc: "Esta função calcula a temperatura aparente baseado na temperatura ambiente e umidade relativa. A temperatura aparente é frequentemente descrita como quão quente ele é para o corpo humano.<div><br/>Este índice pode ser útil para calcular os perigos relacionados para problemas médicos como cãibras musculares, desidratação, exaustão de calor ou insolação mais séria em dias quentes e úmidos. Quando a umidade relativa estiver alta, ela se torna mais difícil para o suor do corpo evaporar, deixando indivíduos sem um caminho natural efetivo para se refrescar. Mapas de aquecimento ou avisos são frequentemente um produto de reclassificação do resultado de índice de aquecimento em classes, onde quanto maior o valor de índice, mais provável dele se tornar um alerta ao invés de apenas um aviso.</div>",
		hillshadeName: "Relevo Sombreado",
		hillshadeSnip: "Cria uma representação 3D da superfície, levando em conta a posição relativa do sol para sombreamento da imagem.",
		hillshadeDesc: "A função Relevo Sombreado produz uma representação 3D da superfície do terreno em escala de cinza, levando em conta a posição relativa do Sol para sombreamento da imagem. <div><br/>O Relevo Sombreado é uma técnica para visualizar o terreno determinado por uma fonte de luz, e a declividade e aspecto da superfície de elevação. É um método qualitativo para visualizar topografia e não fornece valores de elevação absolutos. </div>",
		intName: "Int",
		intSnip: "Converte cada valor da célula de um raster para um número inteiro utilizando a função Truncar.",
		intDesc: "A função Int converte cada valor da pixel de um raster para um número inteiro por truncamento.",
		interpolateIrregularDataName: "Interpolar Dados Irregulares",
		interpolateIrregularDataSnip: "Interpola de nuvens de ponto ou grades irregulares.",
		interpolateIrregularDataDesc: "Alguns conjuntos de dados netCDF ou HDF armazenam sua localização geográfica como conjuntos irregularmente espaçados de pixels ou dados de pontos. Ao adicionar estes conjunto de dados para um conjunto de dados do mosaico, a função irregular interpolar dados utiliza a irregularmente dos dados da grade e os reamostra de forma que cada pixel seja de tamanho uniforme e seja quadrado.<div><br/>Ao adicionar variáveis de netCDF ou HDF a um conjunto de dados de mosaico, ela verificará automaticamente se os dados estão dispostos regularmente. Caso contrário, a função Interpolar Dados Irregulares pode ser utilizada para converter os dados irregulares em um raster de grade regular. Você pode alterar o método de interpolação e o tamanho da célula utilizados na função Interpolar Dados Irregulares do raster. Para dados raster de espaçamento regular, nenhuma interpolação será aplicada e os dados serão lidos como estão.</div>",
		isNullName: "Nulo",
		isNullSnip: "Determina quais valores dos rasters de entrada são de NoData em uma base de célula a célula. Retorna um valor de 1 se os valores de entrada for NoData e 0 para células que não forem.",
		isNullDesc: "A função É Nulo determina quais valores do raster de entrada são NoData em uma base de pixel e pixel. Retorna um valor de 1 se o valor de entrada for NoData e o valor de 0 para pixels que não são NoData.",
		kernelDensityName: "Densidade de Kernel",
		kernelDensitySnip: "Calcula uma área de magnitude por unidade a partir das feições de polilinha ou linha utilizando uma função de Kernel para ajustar uma superfície suavemente coberta para cada polilinha ou ponto.",
		kernelDensityDesc: "Esta função calcula uma área de unidade por magnitude a partir de feições de ponto ou de polilinha utilizando uma função de kernel para ajustar uma superfície suavemente coberta para cada ponto ou polilinha.",
		keyMetadataName: "Principais Metadados",
		keyMetadataSnip: "Substitui ou insere metadados-chaves de um raster em uma cadeia de função.",
		keyMetadataDesc: "Esta função permite que você insira ou substitua metadados chaves de uma raster.<div><br/>As informações nos metadados chave é utilizado para ajudar o aplicativo com algum processamento e renderização, incluindo fornecer algumas informações úteis como o nome do sensor, nomes de bandas ou cobertura de nuvem associado com a imagem.</div>",
		shortestPathName: "Caminhos de Menor Custo",
		shortestPathSnip: "Executa uma análise da distância de custo utilizando entradas de origem e destino, que são utilizadas para determinar o caminho de menor custo de uma origem até um destino.",
		shortestPathDesc: "A função Caminho de Menor Custo global calcula o caminho de menor custo a partir de uma origem até um destino. A distância de menor custo acumulativo é calculado para cada pixel sobre uma superfície de custo, para a origem mais próxima. Esta função produz um raster de saída que registra o caminho menor custo ou caminhos de localizações selecionadas para os pixels de origem mais próximos definidos dentro da superfície de custo acumulativo, em termos de distância de custo.<div><br/>Cada caminho de menor custo é atribuído um valor quando encontrou no processo de escaneamento. O pixel final no Raster de Origem de um caminho de custo recebe um valor de 1. O primeiro caminho recebe um valor de 3, o segundo 4 e assim por diante. Quando caminhos múltiplos se juntam e seguem a distância restante de volta para uma origem na mesma rota, o segmento onde os dois caminhos viajam juntos é atribuído um valor de 2. A porção juntada do caminho não pode ser atribuído ao valor de um dos caminhos, já que a porção juntada pertence a ambas as rotas.</div>",
		lessThanEqualName: "Menor que Igual",
		lessThanEqualSnip: "Executa uma operação menor-que-ou-igual-a Relacional em duas entradas em uma base célula a célula. Retorna 1 para células onde o primeiro raster for menor ou igual ao segundo raster e 0 onde não for maior.",
		lessThanEqualDesc: "A função executa uma operação menor-que-ou-igual-a Relacional em duas entradas em uma base pixel a pixel. Retorna um valor de 1 para pixels onde o primeiro raster é menor ou igual ao segundo raster e um valor de 0 onde ele não é menor ou igual ao segundo raster.",
		lessThanName: "Menor Que",
		lessThanSnip: "Executa uma operação menor-que Relacional em duas entradas em uma base célula a célula. Retorna 1 para células onde o primeiro raster é menor que o segundo raster e 0 se não for.",
		lessThanDesc: "A função executa uma operação menor-que Relacional em duas entradas em uma base pixel a pixel. Retorna um valor de 1 para pixels onde o primeiro raster é menor que o segundo raster e um valor de 0 se ele não for menor que o segundo raster.",
		lnName: "Ln",
		lnSnip: "Calcula o logaritmo natural (base e) de células em um raster.",
		lnDesc: "A função Ln calcula o logaritmo natural (base e) de cada pixel em um raster.",
		log10Name: "Log10",
		log10Snip: "Calcula a base de logaritmo 10 das células em um raster.",
		log10Desc: "A função Log10 calcula a base de logaritmo 10 de cada pixel em um raster.",
		log2Name: "Log2",
		log2Snip: "Calcula a base de logaritmo 2 das células em um raster.",
		log2Desc: "A função Log2 calcula a base de logaritmo 2 de cada pixel em um raster.",
		lookupName: "Pesquisar",
		lookupSnip: "Cria um novo raster pesquisando valores encontrados em outro campo na tabela do raster de entrada.",
		lookupDesc: "A função cria um novo raster pesquisando valores encontrados em outro campo na tabela do raster de entrada",
		mlClassifyName: "Classificação ML",
		mlClassifySnip: "Classifica a imagem utilizando uma abordagem por pixel. Os pixels misturados são atribuídos para a feição com a porcentagem mais alta neste pixel.",
		mlClassifyDesc: "A função Classificação ML permite a você executar uma classificação supervisionada utilizando o algoritmo de classificação de máxima probabilidade, em um conjunto de dados raster ou conjunto de dados do mosaico. Esta função exige um arquivo de assinatura de classificação.",
		maskName: "Máscara",
		maskSnip: "Configura os valores que você não deseja exibir.",
		maskDesc: "Esta função de raster define os valores que você não deseja para exibir em seu raster. Com a utilização da função Mascarar, você especificará um ou mais valores NoData ou uma faixa de valores de pixels válidas. ",
		minusName: "Subtrair",
		minusSnip: "Subtrai o valor do segundo raster de entrada do valor do primeiro raster de entrada em uma base de célula por célula.",
		minusDesc: "A função Menos subtrai o valor do segundo raster de entrada do valor do primeiro raster de entrada em uma base de pixel a pixel.",
		modName: "Mod",
		modSnip: "Encontra o remanescente (módulo) do primeiro raster quando dividido pelo segundo raster em uma base de célula por célula.",
		modDesc: "A função Mod localiza o remanescente (módulo) do primeiro raster quando dividido pelo segundo raster em uma base de pixel a pixel. A ordem das entradas é importante e afeta o resultado de saída.",
		mosaicRastersName: "Rasters do Mosaico",
		mosaicRastersSnip: "Liga os pontos dos conjuntos de dados rasters para criar um conjunto de dados.",
		mosaicRastersDesc: "A função Rasters do Mosaico cria uma imagem de mosaico a partir de múltiplas imagens. Quando houver sobreposição entre as imagens, há diversos métodos que você pode escolher para determinar quais imagens são exibidas.",
		ndviColorizedName: "NDVI Colorizado",
		ndviColorizedSnip: "Cria um conjunto de dados de múltiplas bandas que representa a saúde de vegetação, baseado na diferença entre as bandas do vermelho e infravermelho próximas.",
		ndviColorizedDesc: "A função NDVI Colorizado aplica a função NDVI na imagem de entrada e então utiliza um mapa de cores ou rampa de cores para exibir o resultado.",
		ndviName: "NDVI",
		ndviSnip: "Índice de Vegetação de Diferença Normalizada (NDVI)",
		ndviDesc: "A função NDVI cria um conjunto de dados de múltiplas bandas que representa a saúde de vegetação, baseado na diferença entre as bandas do vermelho e infravermelho próximas.<div><br/>NDVI é um índice padronizado permitindo a você gerar uma imagem exibindo verde, conhecido também como biomassa relativa. Este índice aproveita o contraste das características de duas bandas de um conjunto de dados raster multiespectral: absorções de pigmento da clorofila na banda vermelha e a alta refletividade de materiais vegetais na banda de infravermelho próximo (NIR). Os valores de NDVI extremamente baixos ou negativos representam áreas sem vegetação, tais como, nuvem, água ou chuvisco. Os valores muito baixos representam áreas de pequenas sem vegetação, tais como, concreto, pedra ou solo bruto. Os valores moderados representam áreas de arbustos e pastagens. Os valores altos representam áreas de floresta e vegetação exuberante.</div>",
		negateName: "Negativo",
		negateSnip: "Altera o sinal (multiplica por -1) dos valores de célula do raster de entrada em uma base de célula por célula.",
		negateDesc: "A função Negativo altera o sinal (multiplica por -1) dos valores de pixel do raster de entrada em um pixel ",
		nibbleName: "Extrair por Partes",
		nibbleSnip: "Substitui as células de um raster correspondendo à máscara com os valores dos vizinhos mais próximos.",
		nibbleDesc: "A função global Nibble permite áreas selecionadas de um raster para ser atribuído o valor de seu vizinho mais próximo. Isto é útil para áreas de edição de um raster onde os dados podem apresentar erros.",
		notEqualName: "Não Igual",
		notEqualSnip: "Executa uma operação não-igual-a Relacional em duas entradas em uma base célula a célula. Retorna 1 para células onde o primeiro raster não é igual ao segundo raster e 0 onde é igual.",
		notEqualDesc: "A função executa uma operação não-igual-a Relacional em duas entradas em uma base pixel a pixel. Retorna um valor de 1 de pixels onde o primeiro raster não é igual ao segundo raster e um valor de 0 para pixels onde ele é igual ao segundo raster.",
		pansharpeningName: "Nitidez Pancromática",
		pansharpeningSnip: "Realça artificialmente a resolução espacial de uma imagem de múltiplas bandas fundindo com uma imagem pancromática de resolução mais alta.",
		pansharpeningDesc: "A função Nitidez Pancromática utiliza uma imagem pancromática de alta resolução ou uma banda de raster para se fundir com um conjunto de dados raster de múltiplas bandas, de menor resolução para aumentar a resolução espacial da imagem de múltiplas bandas.<div><br/>O propósito da nitidez pancromática é criar uma imagem visual de melhor qualidade. Já que as técnicas alteram a radiometria e as características espectrais da imagem de múltiplas bandas, a imagem pancromática precisa ser utilizada com cautela para propósitos de sensoriamento remoto analítico.</div>",
		pathAllocationName: "Alocação da Distância do Caminho",
		pathAllocationSnip: "Calcula a fonte de menor custo para cada célula baseada no menor custo acumulativo sobre uma superfície de custo, ao responder pela distância da superfície junto com fatores de custo horizontais e verticais.",
		pathAllocationDesc: "A função Alocação da Distância do Caminho calcula a fonte mais próxima para cada célula com base no menor custo acumulativo sobre uma superfície de custo, enquanto considera a distância e os fatores de custo vertical e horizontal.",
		pathBackLinkName: "Vínculo Anterior de Distância do Caminho",
		pathBackLinkSnip: "Define o vizinho que está próximo da célula no caminho de menor custo acumulativo até a fonte de menor custo, ao responder pela distância da superfície junto com fatores de custo horizontais e verticais.",
		pathBackLinkDesc: "A função Vínculo Anterior de Distância do Caminho identifica a direcionalidade do vizinho que é a próxima célula no caminho de menor custo acumulativo até a fonte mais próxima, enquanto considera a distância de superfície e fatores de custo horizontais e verticais.",
		pathDistanceName: "Distância do Caminho",
		pathDistanceSnip: "Calcula, para cada célula, a distância de menor custo acumulativo de ou até a fonte de menor custo, ao responder pela distância da superfície junto com fatores de custo horizontais e verticais.",
		pathDistanceDesc: "A função Distância do Caminho calcula, para cada célula, a distância de menor custo acumulativo até a fonte mais próxima, enquanto considera a distância de superfície e os fatores de custo horizontal e vertical.",
		plusName: "Plus",
		plusSnip: "Adiciona (somas) os valores de dois rasters em uma base de célula por célula.",
		plusDesc: "A função Adição adiciona (somas) os valores de dois rasters em uma base de pixel a pixel.",
		powerName: "Potência",
		powerSnip: "Eleva os valores de célula em um raster para a potência dos valores encontrados em outro raster.",
		powerDesc: "A função Potência eleva os valores de pixel em um raster à potência dos valores localizados em outro raster.",
		radarCalibrationName: "Calibração de Radar",
		radarCalibrationSnip: "Converte RADARSAT-2 backscatter.",
		radarCalibrationDesc: "Esta função pode ser utilizada para calibrar imagem RADARSAT-2 em um conjunto de dados do mosaico ou como um produto de raster. A calibração é executada em imagem de radar de forma que os valores de pixel sejam uma representação verdadeira do radar backscatter.",
		rasterInfoName: "RasterInfo",
		rasterInfoSnip: "Modifica propriedades do raster, como tamanho de bit, um valor de NoData, tamanho da célula, e assim por diante.",
		rasterInfoDesc: "O parâmetro Info do Raster inclui um diálogo com propriedades do conjunto de dados raster, como o número de colunas e linhas, o número de bandas, o tipo de pixel, a extensão e a referência espacial. Você pode editar estas propriedades selecionando um conjunto de dados raster para utilizar como um modelo. ",
		rasterizeAttributesName: "Rasterizar Atributos",
		rasterizeAttributesSnip: "Enriquece um raster por bandas adicionais derivadas dos valores de atributos especificados de um serviço da feição ou tabela externa.",
		rasterizeAttributesDesc: "A função Rasterizar Atributo enriquece um raster ao adicionar bandas derivadas dos valores de atributos especificados de um serviço da feição ou tabela externa. Opcionalmente, você pode especificar um raster de zona e o atributo de ID da zona associada para habilitar a consulta baseada na região.",
		rasterizeFeatureClassName: "Feições Rasterizadas",
		rasterizeFeatureClassSnip: "Converte feições para raster.",
		rasterizeFeatureClassDesc: "Esta função converte dados da classe de feição de polígono, polilinha e ponto para uma camada raster.<div><br/>As feições são valores de pixel atribuídos com base no OBJECTID (padrão) da feição. Opcionalmente, os valores de pixel podem ser baseados em um campo de valor definido pelo usuário na tabela de atributos da feição de entrada.</div>",
		recastName: "Remodelar",
		recastSnip: "Modifica os parâmetros de uma cadeia de função em um conjunto de dados do mosaico ou serviço de imagem. Isto é normalmente utilizado com conjuntos de dados LAS para evitar de ter que criar um conjunto de dados do mosaico separado para diferentes representações do terreno.",
		recastDesc: "A função Remodelar é utilizada para modificar o parâmetro de função utilizado em um conjunto de dados do mosaico ou serviço de imagem dinamicamente sem persistir fisicamente nas alterações.",
		regionGroupName: "Agrupar por Regiões",
		regionGroupSnip: "Para cada célula na saída, a identidade da região conectada na qual a célula pertence é registrada. Um único número é atribuído para cada região.",
		regionGroupDesc: "A função Agrupar por Regiões global registra em cada célula na saída, a identidade da região conectada na qual a célula pertence. Um único número é atribuído para cada região.<div><br/>A primeiro região escaneada recebe o valor um, a segunda dois, e assim por diante, até que todas as regiões tenham um valor atribuído. O escaneamento move da esquerda para direita, da parte superior para parte inferior. Os valores atribuídos às zonas de saída são baseados quando eles forem encontrados no processo de escaneamento.</div>",
		regionGrowName: "Região de Crescimento",
		regionGrowSnip: "Regiões de crescimento dos pontos de origem.",
		regionGrowDesc: "A função Crescimento de Região agrupa pixels vizinhos em grupos dependendo do raio especificado a partir do ponto de origem. O grupo de pixels ou objeto recebe um valor de preenchimento especificado.",
		remapName: "Remapear",
		remapSnip: "Altera os valores do pixel atribuindo novos valores para intervalos de valores do pixel ou utilizando uma tabela externa.",
		remapDesc: "A função Remapear permite a você alterar ou reclassificar os valores de pixels dos dados raster. Isto pode ser feito especificando uma faixa de valores de pixels para mapear um valor de pixel de saída ou utilizando uma tabela para mapear os valores de pixel para o valor de pixel de saída.",
		reprojectName: "Reprojetar",
		reprojectSnip: "Modifica a projeção de um conjunto de dados raster, um conjunto de dados de mosaico ou um item do raster em um conjunto de dados de mosaico. Também pode reamostrar os dados para um novo tamanho de célula e definir uma origem.",
		reprojectDesc: "A função Reprojetar modifica a projeção de um conjunto de dados raster, um conjunto de dados de mosaico ou um item do raster em um conjunto de dados de mosaico. Também pode reamostrar os dados para um novo tamanho de célula e definir uma origem.<div><br/>A função Reprojetar pode ser utilizada ao criar um cache a partir de um conjunto de dados raster ou de mosaico que não esteja na projeção exigida. Por exemplo, ao criar um serviço de imagem com cache que pode ser integrado por aplicativos com outros serviços com cache, é importante que todos estejam na mesma projeção. Isto geralmente é uma projeção Web Mercator. Já que o conjunto de dados de mosaico não pode ser reprojetado, você pode fazer uma das duas coisas—criar um conjunto de dados de mosaico referenciado a partir do seu conjunto de dados de mosaico na projeção necessária ou adicionar a função Reprojetar à cadeia de função do conjunto de dados de mosaico. Outro exemplo utiliza esta função no item do raster em um conjunto de dados de mosaico. Ao utilizar a função Raster Com Cache, você pode desejar a inserção da função Reprojetar para que o cache seja criado na nova projeção. Os itens do raster em um conjunto de dados de mosaico podem ser armazenados em cache quando o processamento é intenso e você está tentando publicar um serviço de imagem rápido, sem armazenar em cache o serviço de imagem inteiro.</div>",
		resampleName: "Reamostrar",
		resampleSnip: "Altera o tamanho de célula de um raster.",
		resampleDesc: "A função Reamostrar altera o tamanho de célula, tipo de reamostragem ou ambos.<div><br/>A função Reamostrar deve somente ser utilizada com requisitos de computação específicos; por exemplo, quando você estiver computando o vento ou direção de magnitude atual que exige a reamostragem da resolução de origem.</div>",
		roundDownName: "Arredondar para Menos",
		roundDownSnip: "Retorna o próximo valor inteiro mais baixo, apenas representado como um ponto flutuante, para cada célula em um raster.",
		roundDownDesc: "A função Arredondar para Menos retorna o próximo valor inteiro mais baixo, como um valor de ponto flutuante de cada pixel em um raster.",
		roundUpName: "Arredondar para mais",
		roundUpSnip: "Retorna o próximo valor inteiro mais alto, apenas representado como um ponto flutuante, para cada célula em um raster.",
		roundUpDesc: "A função Arredondar para mais, retorna o próximo valor inteiro mais alto, como um valor de ponto flutuante, para cada pixel em um raster.",
		segmentMeanShiftName: "Deslocamento Médio do Segmento",
		segmentMeanShiftSnip: "Agrupa pixels vizinhos com características espectrais semelhantes em segmentos.",
		segmentMeanShiftDesc: "A função identifica objetos, feições ou segmentos na sua imagem agrupando pixels adjacentes com características espectrais semelhantes. Você pode controlar a quantidade de suavização espectral e espacial para ajudar a derivar as feições de interesse.",
		s1RadiometricCalibrationName: "Calibração Radiométrica do Sentinel-1",
		s1RadiometricCalibrationSnip: "Executa diferentes tipos de calibração radiométrica em conjuntos de dados do Sentinel-1.",
		s1RadiometricCalibrationDesc: "Esta função de raster executa três calibrações diferentes pra conjunto de dados Sentinel 1, incluindo beta zero e gama, e gera a saída do conjunto de dados calibrado. O objetivo de calibração de SAR é fornecer imagem em quais valores de pixels podem ser diretamente relacionados à retrodispersão do radar da cena. Entretanto a imagem SAR não calibrada é suficiente para uso qualitativo, as imagens de SAR calibradas são essenciais para uso quantitativo dos dados de SAR.<div><br/>O processamento de dados de SAR típico, que produz imagens de Nível 1, não inclui correções radiométricas e o desvio significante radiométrico permanece. Portanto, é necessário se aplicar correção radiométrica para imagens de SAR de forma que os valores de pixel das imagens representam verdadeiramente a retrodispersão do radar da superfície refletida. A correção radiométrica também é necessária para a comparação de imagens SAR adquiridas com sensores diferentes ou adquiridas a partir do mesmo sensor em tempos diferentes, em modos diferentes ou processadas por processadores diferentes.</div>",
		s1ThermalNoiseRemovalName: "Remoção de Ruído Térmico do Sentinel-1",
		s1ThermalNoiseRemovalSnip: "Remove ruído térmico de dados do Sentinel-1.",
		s1ThermalNoiseRemovalDesc: "A correção de ruído térmico pode ser aplicada aos produtos Sentinel-1 Level-1 Single Look Complex (SLC) como também produtos Level-1 Ground Range Detection (GRD) que já não foram corrigidos. O operador também pode remover esta correção baseada nas anotações de produto para re-introduzir o sinal de ruído que foi removido para produzir o produto original. As anotações de produto serão consequentemente atualizadas para permitir a re-aplicação da correção. ",
		setNullName: "Definir Nulo",
		setNullSnip: "Configurar para Nulo define localizações de célula identificadas para NoData baseado em critérios especificados. Ele retorna NoData se uma avaliação condicional for verdadeira e retorna o valor especificado por outro dado raster se falsa.",
		setNullDesc: "A função Configurar para Nulo define os pixels identificados para NoData baseado em critérios específicos. Ele retorna NoData se uma avaliação condicional for verdadeira (1) e retorna o valor especificado no Raster Falso se avaliação condicional for falsa (0). Estes critérios são especificados pela saída de uma função matemática lógica, que será o Raster de entrada.",
		shadedReliefName: "Relevo Sombreado",
		shadedReliefSnip: "Cria uma representação da superfície 3D, de cores codificadas, de múltiplas bandas, levando em conta a posição relativa do sol para sombramento da imagem.",
		shadedReliefDesc: "A função Relevo Sombreado cria uma representação de cor 3D do terreno que é criado juntando as imagens dos métodos de elevação e relevo sombreado codificados. Esta função utiliza a altitude e propriedades de azimute para especificar a posição do sol.<div><br/></div>",
		sinHName: "SenH",
		sinHSnip: "Calcula o seno hiperbólico de células em um raster.",
		sinHDesc: "A função calcula o seno hiperbólico dos pixels em um raster.",
		sinName: "Sen",
		sinSnip: "Calcula o seno das células em um raster.",
		sinDesc: "A função calcula o seno dos pixels em um raster.",
		slopeName: "Declividade",
		slopeSnip: "Calcula a taxa de alteração de um valor de pixel para seus vizinhos.",
		slopeDesc: "Esta função de raster calcula a declividade que é a taxa de mudança de elevação de cada célula do modelo de elevação digital (DEM). É o primeiro derivado de um DEM.<div><br/>Esta função utiliza uma função acelerada atan(). É seis vezes mais rápido e o erro de aproximação é sempre menos que 0.3 graus.</div>",
		speckleName: "Manchar",
		speckleSnip: "Fornece filtros para retirar ruído dos conjuntos de dados do rada de abertura sintética.",
		speckleDesc: "Manchar, é o ruído de alta-frequência em dados de radar. As imagens geradas por sistemas de radar de abertura sintética (SAR) são altamente sujeito a efeitos de manchas devido ao processamento de sinais dispersos e interferência de ondas de eletromagnético dispersos de superfícies ou objetos. Esta função Manchar filtra o conjunto de dados de radar manchado e suaviza o ruído ao reter as bordas ou feições nítidas na imagem.",
		spectralConversionName: "Conversão Espectral",
		spectralConversionSnip: "Aplica uma matriz para uma imagem de múltiplas bandas.",
		spectralConversionDesc: "A função Conversão Espectral aplica uma matriz para uma imagem de bandas múltiplas para afetar os valores de cores da saída.<div><br/>Alguns sensores não coletam bandas azuis por causa de uma sinal baixo para taxa de ruído. Isto pode ser utilizado, por exemplo, para converter uma imagem infravermelha falsa para uma imagem de cor natural.</div>",
		squareRootName: "Raiz Quadrada",
		squareRootSnip: "Calcula a raiz quadrada dos valores da célula em um raster.",
		squareRootDesc: "A função Raiz Quadrada calcula a raiz quadrada dos valores de pixel em um raster.",
		squareName: "Quadrado",
		squareSnip: "Calcule a equação dos valores de célula em um raster.",
		squareDesc: "A função Quadrado calcule o quadrado dos valores de pixel em um raster.",
		statisticsHistogramName: "Estatísticas e Histograma",
		statisticsHistogramSnip: "Define ou associa a estatísticas e histograma.",
		statisticsHistogramDesc: "A função Estatística e Histograma é utilizada para definir a estatística e histograma de um raster. Você pode inserir esta função no final da cadeia de função para descrever a estatística e histograma de um modelo de função do raster (RFT). Isto pode ser necessário para controlar a visualização padrão do resultado de processamento, especialmente ao definir uma cadeia de função que contém muitas funções.<div><br/>Você pode definir estatísticas digitando os valores ou importando de um conjunto de dados raster ou um arquivo XML. Os histogramas podem somente ser definidos importando um arquivo.</div>",
		statisticsName: "Estatística",
		statisticsSnip: "Calcula a estatística focal para cada pixel de uma imagem baseado em uma vizinhança focal definida.",
		statisticsDesc: "A função Estatística calcula a estatística focal para cada pixel de uma imagem baseado em uma vizinhança focal definida.<div><br/>A função Estatística pode ser utilizada para preencher linhas descartadas em uma imagem. As linhas descartadas estão frequentemente causadas por problemas no sensor onde os dados não são coletados. Isto ocorreu em sensores como Landsat 7's Enhanced Thematic Mapper Plus (ETM+). Estes problemas causam perda de dados para análise e também quando visualizar a imagem. Há pouco que pode ser feito ao utilizar a imagem para análise; entretanto, se houver uma imagem de sobreposição, pode ser utilizado no lugar do conteúdo perdido. O mesmo pode ser feito se a imagem estiver sendo utilizada para visualização. Entretanto, não há sempre uma imagem extra para preencher o conteúdo perdido, então ele deve ser obtido a partir de dados existentes.</div>",
		streamLinkName: "Link do Fluxo",
		streamLinkSnip: "Atribui valores únicos para seções da rede linear do raster entre interseções.",
		streamLinkDesc: "A função Link do Fluxo global atribui valores únicos para seções da rede linear do raster entre intersecções.<div><br/>Links são as seções de um canal de fluxo conectando duas junções sucessivas, uma junção e a saída, ou uma junção e a divisão de drenagem. Em hidrologia, estes segmentos de fluxo são chamados de alcances. Uma junção é relacionada a um ponto de escoamento e ajuda delinear uma bacia ou limite de drenagem de sub-bacia.</div>",
		stretchName: "Contraste",
		stretchSnip: "Melhora uma imagem ajustando a faixa de valores exibidos. Isto não altera os valores de pixel subjacentes. Se um pixel tiver um valor fora da faixa especificada, ele aparecerá como o valor mínimo ou máximo.",
		stretchDesc: "A função Contraste melhora uma imagem pela alteração das propriedades, tal como, brilho, contraste e gama através de vários tipos de contraste. Esta função utiliza a estatística dos rasters dentro do conjunto de dados do mosaico; portanto, se você utilizar esta função, você deve certificar-se que as estatísticas foram calculadas.<div><br/>O tipo de contraste define um contraste de histograma que será aplicado aos rasters para melhorar sua aparência. O contraste melhora a aparência dos dados espalhando os valores de pixel ao longo de um histograma a partir de valores mínimos e máximos definidos por sua profundidade de bit. </div>",
		swathName: "Fileira",
		swathSnip: "Interpola de grades irregulares ou dados de fileira.",
		swathDesc: "Alguns conjunto de dados netCDF ou HDF armazenam sua localização geográfica como vetores espaçados irregularmente. Ao adicionar estes conjunto de dados para um conjunto de dados do mosaico, a função de fileira utiliza os dados irregularmente na grade e reamostra de forma que cada pixel é de tamanho uniforme e é quadrado.<div><br/>Ao adicionar variáveis de netCDF ou HDF a um conjunto de dados de mosaico, ela verificará automaticamente se os dados estão dispostos regularmente. Se ela não for, a função de fileira é automaticamente aplicado para converter o raster irregular em pontos e então para uma raster regularmente na grade. Você pode alterar o método de interpolação e tamanho de célula utilizado na função de raster de fileira. Para dados raster espaçado de forma regular, nenhuma interpolação será aplicada, os dados serão lidos como estão.</div>",
		tanHName: "TanH",
		tanHSnip: "Calcula a tangente hiperbólica de células em um raster.",
		tanHDesc: "A função calcula a tangente hiperbólica dos pixels em um raster.",
		tanName: "Tangente",
		tanSnip: "Calcula a tangente de células em um raster.",
		tanDesc: "A função calcula a tangente dos pixels em um raster. ",
		tasseledCapName: "Tasseled Cap (Kauth-Thomas)",
		tasseledCapSnip: "Calcula níveis de vegetação, umidade e brilho. Esta técnica conta com coeficientes que devem ser especificamente calculados para um sensor.",
		tasseledCapDesc: "A transformação Tasseled Cap (Kauth-Thomas) é projetada para analisar e mapear a fenomenologia de vegetação e alterações de desenvolvimento urbano detectadas por vários sistemas de sensor do satélite. É conhecida como a transformação Tasseled Cap devido à forma da distribuição gráfica dos dados. A transformação forneceu uma razão para os padrões localizados em dados de Landsat MSS de campos agrícola como uma função do ciclo vitalício da colheita. Essencialmente, à medida que as colheitas crescem da semente à maturidade, há um aumento líquido no infravermelho próximo e uma diminuição na refletância do vermelho com base na cor do solo<div><br>O utilitário desta transformação expandiu a partir do monitoramento de colheitas para analisar e mapear a vegetação para suportar uma variedade de aplicações, tais como, silvicultura, gerenciamento de vegetação industrial, mapeamento e gerenciamento de ecossistema, inventário e monitoramento do isolamento de carbono e créditos, desenvolvimento urbano e mais. Também expandiu a partir do suporte do Landsat MSS para incluir outros sistemas de satélites populares, como sensores multiespectrais do Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, WorldView-2 e RapidEye.</div>",
		timesName: "Multiplicar",
		timesSnip: "Multiplica os valores de dois rasters em uma base de célula por célula.",
		timesDesc: "A função Multiplicar divide os valores de dois rasters em uma base de pixel a pixel.",
		transposeBitsName: "Transportar Bits",
		transposeBitsSnip: "Descompacta os bits do pixel de entrada e mapeie-os para bits especificados no pixel de saída. O propósito desta função é manipular bits de algumas entradas, como produtos de banda da qualidade Landsat 8.",
		transposeBitsDesc: "A função Transportar Bits descompacta os bits do pixel de entrada e mapeie-os para bits especificados no pixel de saída. O propósito desta função é manipular bits de algumas entradas, como produtos de banda da qualidade Landsat 8.",
		unitConversionName: "Conversão da Unidade",
		unitConversionSnip: "Altera valores de uma unidade de medição para outra.",
		unitConversionDesc: "Esta função converte pixels de uma unidade até outra. Suporta conversão de distância, velocidade e temperatura.",
		vectorFieldName: "Campo de Vetor",
		vectorFieldSnip: "Exibe conjuntos de dados com ambas a magnitude (u) e direção (v) como setas onde a magnitude é representada pelo tamanho e a direção é representada pelo ângulo da seta.",
		vectorFieldDesc: "A função Campo de Vetor é utilizada para compor e converter dois rasters em um raster de duas bandas que é do tipo de dados Direção de Magnitude ou tipo de dados U-V.<div><br/>O valor U é às vezes chamado da velocidade zonal e valor V é às vezes chamado de velocidade meridional.</div>",
		viewshed2Name: "Panorama",
		viewshed2Snip: "Determina os locais de superfície do raster visíveis para um conjunto de feições do observador, utilizando métodos geodésicos.",
		viewshed2Desc: "A função Panorama determinas as localizações visíveis da superfície do raster para um conjunto de feições do observador utilizando métodos geodésicos<div><br/>A visibilidade de cada centro do pixel é determinado por um teste de linha-de-visada entre o alvo e cada observador. Se um observador pode visualizar o alvo no centro do pixel, o pixel é considerado visível. Esta ferramenta sempre considera a curvatura da Terra quando a visibilidade é determinada.</div>",
		watershedName: "Vertente",
		watershedSnip: "Determina a área de contribuição sobre um conjunto de células em um raster.",
		watershedDesc: "A função Vertente global determina a contribuição de área sobre um conjunto de pixels em um raster. As vertentes são delineadas a partir de um raster de direção de fluxo que identifica a direção de fluxo de cada pixel.",
		weightedOverlayName: "Sobreposição Ponderada",
		weightedOverlaySnip: "Sobrepõe diversos dados raster utilizando uma escala de medida comum e pesa cada um de acordo com sua importância.",
		weightedOverlayDesc: "Esta função permite a você sobrepor diversos rasters utilizando uma escala de medida comum e pesos, cada um de acordo com sua importância.",
		weightedSumName: "Soma Ponderada",
		weightedSumSnip: "Pesa e adiciona um conjunto de dados rasters em uma base de célula a célula.",
		weightedSumDesc: "A função Soma Ponderada permite a você sobrepor vários rasters, multiplicando cada um pelo seu peso e somando-os juntos.",
		windchillName: "Vento Frio",
		windchillSnip: "Combina temperatura do ambiente e velocidade do vento para calcular a sensação térmica.",
		windchillDesc: "A função de Vento Frio é útil para identificar condições perigosas de inverno que, dependendo dos tempos de exposição aos elementos, pode resultar em ulceração ou até hipotermia. O vento frio é uma forma para medir o quanto está frio quando o vento é levado em conta com temperaturas já baixas. Quanto mais rápida a velocidade do vento, o corpo perderá calor mais rapidamente e mais frio eles sentirão.",
		zonalRemapName: "Remapeamento Zonal",
		zonalRemapSnip: "Remapeia pixels em um raster baseado em zonas definidas por outro raster e um mapeamento de valores dependente de zona definido em uma tabela.",
		zonalRemapDesc: "Esta é uma função que permite a você remapear pixels em um raster baseado em zonas definidas por outro raster e um mapeamento de valores dependente de zona definido em uma tabela.",
		zonalStatisticsName: "Estatística Zonal",
		zonalStatisticsSnip: "Calcula a estatística em valores de um raster dentro das zonas de outro conjunto de dados.",
		zonalStatisticsDesc: "A função calcula a estatística em valores de um raster dentro das zonas de outro conjunto de dados. A zona é definida por todos os locais na entrada que tenham o mesmo valor. Estas áreas não têm que ser contíguas. Quando a zona e entradas de valores são ambos rasters da mesma resolução, eles serão diretamente utilizados. Se as resoluções forem diferentes, uma reamostragem interna é aplicada para corresponder às resoluções antes da operação zonal ser executada.",
		flowLengthName: "Comprimento do Fluxo",
		flowLengthSnip: "Calcula a distância a montante ou a jusante, ou a distância ponderada, ao longo do caminho do fluxo para cada célula.",
		flowLengthDesc: "Esta é uma função de raster global . Esta função cria uma camada de raster da distância de montante ou jusante, ou distância ponderada, ao longo do trajeto de fluxo para cada célula.<div><br/>Um uso importante da função Comprimento do Fluxo é calcular o comprimento de trajeto do fluxo mais longo dentro de uma determinada bacia. Esta medida é normalmente utilizada para calcular o tempo de concentração de uma bacia. Isto é concluído com o uso da opção Montante. A função também pode ser utilizada para criar diagramas de área-distância de eventos hipotéticos de precipitação e escoamento utilizando um raster de peso como uma impedância ao movimento de declividade.</div>",
		streamOrderName: "Ordem do Fluxo",
		streamOrderSnip: "Atribui uma ordem numérica aos segmentos do raster representando ramificações de uma rede linear",
		streamOrderDesc: "Esta é uma função de raster global . Esta função cria uma camada de raster que atribui uma ordem numérica para segmentos de um raster representando ramificações de uma rede linear.<div><br/>A saída da função Ordem do Fluxo será de qualidade superior se a camada de raster do fluxo de entrada e a camada de raster da direção do fluxo de entrada forem derivadas da mesma superfície. Se o raster de fluxo for derivado de um conjunto de dados de fluxos rasterizados, a saída poderá não ser utilizável, pois, em uma base de célula por célula, a direção não corresponderá à localização das células do fluxo. Os resultados da função Acumulação de Fluxo podem ser utilizados para criar uma rede de fluxo do raster, aplicando um valor limite para selecionar células com alto fluxo acumulado. Por exemplo, células que têm mais de 100 células fluindo para dentro delas são utilizadas para definir a rede de fluxo. Utilize a função Con ou Definir Nulo para criar um raster da rede de fluxo na qual valores de acumulação do fluxo de 100 ou maiores vão para um, e o restante é colocado em segundo plano (NoData). A rede de fluxo resultante pode ser utilizada na função Ordem do Fluxo. Esta função suporta somente uma camada de raster de entrada da direção de fluxo D8. As direções de fluxo D8 podem ser criadas utilizando a função Direção do Fluxo e executadas com o tipo de direção de fluxo D8 padrão.</div>",
		snapPourPointName: "Ajustar Ponto de Escoamento",
		snapPourPointSnip: "Ajusta pontos de escoamento para a célula de maior acumulação de fluxo dentro de uma distância especificada",
		snapPourPointDesc: "Esta é uma função de raster global . Esta função ajusta os pontos de escoamento na célula de maior acumulação de fluxo dentro de uma distância especificada.<div><br/>A função Ajustar Ponto de Escoamento é utilizada para garantir a seleção de pontos de alto fluxo acumulado ao delinear bacias de drenagem utilizando a função Vertente. Ajustar Ponto de Escoamento buscará a uma distância de ajuste em torno dos pontos de escoamento especificados para a célula de maior fluxo acumulado e moverá o ponto de escoamento para este local. A saída é uma camada de raster inteira quando os locais originais do ponto de escoamento foram ajustados aos locais com maior fluxo acumulado.</div>",
		sinkName: "Coletor",
		sinkSnip: "Cria um raster identificando todos os coletores ou áreas de drenagem interna",
		sinkDesc: "Esta é uma função de raster global . Esta função cria uma camada de raster identificando todos os coletores ou áreas de drenagem interna. Um coletor é uma célula ou conjunto de células conectadas espacialmente com uma direção de fluxo que não pode ser atribuída a um dos oito valores válidos em um raster de direção do fluxo. Isto pode ocorrer quando todas as células vizinhas são mais altas que a célula de processamento ou quando duas células fluem uma para a outra, criando um loop de duas células.<div><br/>A função Coletor suporta somente uma camada de raster de entrada da direção de fluxo D8. As direções de fluxo D8 podem ser criadas utilizando a função Direção do Fluxo e executadas com o tipo de direção de fluxo D8 padrão. A saída da função Coletor é um raster inteiro, com cada coletor sendo atribuído a um valor único. Estes valores únicos têm um intervalo entre um e o número total de coletores. Por exemplo, se o número total de coletores for 1000, os valores únicos variam de 1 a 1000.</div>",
		aggregateName: "Agregar",
		aggregateSnip: "Gera uma versão de resolução reduzida de um raster.",
		aggregateDesc: "A função Agregar reamostra um raster de entrada para uma resolução mais grosseira baseado em uma estratégia de agregação especificada. Cada célula de saída contém a Soma, Mínimo, Máximo, Média ou Mediano das células de entrada que são cercadas pela extensão desta célula.<div><br/>Você pode especificar o fator pelo qual multiplicar o tamanho da célula do raster de entrada. Por exemplo, um valor de fator da célula de 3 resultaria em um tamanho de célula de saída três vezes maior que o do raster de entrada. Você pode definir como manipular a extensão da saída se o número de linhas ou colunas na entrada não for um múltiplo exato do fator da célula. Por padrão, os limites da direita e superior serão expandidos para cobrir uma extensão espacial maior que o raster de entrada, a fim de assegurar que todas as células de entrada sejam processadas. Alternativamente, os limites da direita e superior podem ser reduzidos para cobrir uma extensão pequena, de forma que o número de linhas e colunas processadas sejam um múltiplo exato do fator da célula. Você pode definir como as células NoData são manipuladas pelo cálculo de agregação. O mecanismo padrão é que as células NoData de entrada que caem na extensão espacial de uma célula maior no raster de saída serão ignoradas ao determinar o valor desta célula de saída. Alternativamente, você pode especificar que, se houver uma única célula NoData de entrada na extensão espacial de uma célula de saída, esta célula será NoData no raster de saída.</div>",
		ccdcName: "Análise de CCDC",
		ccdcSnip: "Avalia as alterações valores de pixels com o passar do tempo utilizando o algoritmo Detecção de Alteração Contínua e Classificação (CCDC) e gera resultados de modelo.",
		ccdcDesc: "A função Análise CCDC avalia as alterações valores de pixels com o passar do tempo utilizando o algoritmo Detecção de Alteração Contínua e Classificação (CCDC) e gera um raster multidimensional contendo os resultados do modelo. É somente suportado junto com a função Detectar Alteração Utilizando Alterar Análise em um modelo de função raster. Para produzir uma saída de raster , conecte a função Análise de CCDC com a função Detectar Alteração Utilizando Alterar Análise, salvar como um modelo de função do raster e execute Análise Raster com o modelo de função.<div><br/>Isto função utiliza o algoritmo Detectar Alteração Contínua e Classificação (CCDC) para avaliar alterações em valores de pixels com o passar do tempo para uma pilha de imagens. Em uma série de tempo de imagens ópticas ou derivados de imagens (por exemplo, NDVI), os valores de pixels podem flutuar por diversas razões: 1. Alterações sazonais -- As alterações de valores do pixel refletem alterações em vegetação devido a variabilidade sazonal de temperatura e precipitação. No Hemisfério Norte, por exemplo, nós esperamos ver densidade mais alta de vegetação verde no verão comparado ao inverno; 2. Alteração gradual -- As alterações de valores do pixel refletem tendências em vegetação ou água de superfície devido a variabilidade de clima ou práticas de gerenciamento de solo a longo prazo. Por exemplo, o solo bruto pode gradualmente aumentar em área devido a declínio a longo prazo em precipitação; e 3. Alteração abrupta -- As alterações de valores do pixel refletem alterações de cobertura de solo que ocorre de repente devido ao desmatamento, desenvolvimento urbano, desastre natural e assim por diante. O algoritmo de CCDC identifica todos os três tipos de alteração com o propósito primário de identificar a alteração abrupta. A regressão e modelos de tendência harmônicos são ajustados aos dados para estimar alteração sazonal e gradual, e divergências súbitas a partir de modelos de tendências modelos que são indicações de alteração abrupta.<div><br/>O algoritmo CCDC foi originalmente projetado para Landsat TM, Landsat ETM+ e Reflectância de Superfície de dados Landsat OLI ou dados de Temperatura de Brilho. Entretanto, a função Detectar Alteração Utilizando Análise de Alteração junto com esta função irá detectar alteração das imagens de bandas múltiplas de qualquer sensor suportado, assim como imagens de banda única são derivadas como índices de bandas. Por exemplo, você pode executar detecção de alteração contínua em um raster Normalizar Índice de Vegetação de Diferença (NDVI), pois as alterações abruptas no NDVI pode ser indicativo de desmatamento.</div>",
		computeChangeName: "Computar Alteração",
		computeChangeSnip: "Computa a diferença entre dois conjuntos de dados raster categórico ou contínuo.",
		computeChangeDesc: "A função de Computar Alteração pode ser utilizada para enumerar as diferenças entre dois rasters classificados para análise de alteração de cobertura do solo, ou ele pode ser utilizado para examinar alterações entre dois rasters de banda única contínuo, tais como, elevação, temperatura, cobertura de copa da árvore e assim por diante.",
		detectChangeName: "Detectar Alteração Utilizando Análise de Alteração",
		detectChangeSnip: "Gera uma camada de raster contendo informações de alteração de pixel utilizando o raster de análise de alteração de saída.",
		detectChangeDesc: "<div>A função Detectar Alteração Utilizando Análise de Alteração gera uma camada de raster contendo informações de alteração de data do pixel utilizando o raster de análise de alteração. O raster de análise de alteração deve ser gerado pela ferramenta Analisar Alterações Utilizando CCDC ou Analisar Alterações Utilizando LandTrendr, ou a função do raster Análise de CCDC ou Análise de LandTrendr.</div><br><div>Esta função do raster pode ser combinada com a função do raster Análise de CCDC ou a função do raster Análise de LandTrendr em um modelo de função do raster. Para produzir uma saída de raster permanente, conecte a saída da função Análise de CCDC ou Análise de LandTrendr à função Detectar Alteração Utilizando Análise de Alteração, salve como um modelo de função do raster e execute a Análise de Raster com o modelo.</div><br><div>O parâmetro <strong>Tipo de Alteração</strong> indica as informações que são geradas. As informações são extraídas do raster da análise de alteração. Ao executar esta função na saída da função/ferramenta CCDC, você pode escolher entre as seguintes opções:</div><ul><li><strong>Hora da alteração mais recente</strong>--A data e hora mais recente na qual um pixel foi sinalizado como sendo alterado.</li><li><strong>Hora da alteração mais antiga</strong>--A data e hora mais antigas na qual um pixel foi sinalizado como sendo alterado.</li><li><strong>Hora da maior alteração</strong>--A data e hora na qual a alteração calculada foi a mais significativa para um pixel.</li><li> <strong>Número de alterações</strong>--O número total de vezes que o pixel alterou.</li></ul><div>Ao executar esta função na saída da função/ferramenta LandTrendr, as seguintes opções adicionais estão disponíveis:</div><ul><li><strong>Hora da alteração mais longa</strong>--A data na qual um pixel foi sinalizado como sendo alterado, no início ou no final do período mais longo de alteração.</li><li><strong>Hora da alteração mais curta</strong>--A data na qual um pixel foi sinalizado como sendo alterado, no início ou no final do período mais curto de alteração.</li><li><strong>Hora da alteração mais rápida</strong>--A data na qual um pixel foi sinalizado como sendo alterado, no início ou no final do período mais rápido de alteração.</li><li><strong>Hora da alteração mais lenta</strong>--A data na qual um pixel foi sinalizado como sendo alterado, no início ou no final do período mais lento de alteração.</li></ul><div>O raster de saída é um raster de múltiplas bandas no qual cada banda contém informações de alteração dependendo do tipo de alteração selecionado e do número máximo de alterações especificado. Por exemplo, se <strong>Tipo de Alteração</strong> estiver definido para <strong>Hora de Alteração Mais Antiga</strong> e <strong>Número Máximo de Alterações</strong> estiver definido como 2, a função calculará as duas primeiras datas nas quais a alteração ocorreu ao longo da série de tempo para cada pixel. O resultado é um raster no qual a primeira banda contém as datas da primeira alteração por pixel e a segunda banda contém as datas da segunda alteração mais antiga por pixel.</div><br><div>Ao aplicar esta função na saída das ferramentas LandTrendr, você pode escolher se deseja extrair a data que marca o início ou o fim de uma alteração usando o parâmetro <strong>Data do Segmento</strong> . Por exemplo, para entender como a alteração mais recente na série de tempo começou, defina o <strong>Tipo de Alteração</strong> para <strong>Hora da última alteração</strong> e a <strong>Data do Segmento</strong> para <strong>Início do segmento</strong>.</div><br><div>Use os seguintes parâmetros de filtragem para extrair datas mais específicas de alterações do seu raster da análise de alteração:</div><ul><li><strong>Filtrar por ano</strong>--Identifique alterações que ocorreram dentro de um período de tempo específico, por exemplo, se você estiver procurando por alterações que ocorreram em uma paisagem durante cinco anos de seca.</li><li><strong>Filtrar por duração</strong>--Identifique alterações que ocorreram ao longo de um determinado intervalo de anos, por exemplo, se você estiver procurando apenas alterações abruptas que ocorreram ao longo de 1 ou 2 anos. Você pode calcular a duração de seu interesse usando a fórmula<strong>ano final - ano inicial +1</strong>. Os intervalo na série de tempo serão incluídos.</li><li><strong>Filtrar por magnitude</strong>--Identifica alterações de uma determinada magnitude, por exemplo, se você estiver procurando apenas grandes alterações no índice de vegetação NDVI. Magnitude é um valor absoluto, portanto, os valores mínimo e máximo não podem ser negativos. Para especificar alteração direcional, use o parâmetro <strong>Alterar Direção</strong> .</li></ul>",
		distanceAccumulationName: "Acumulação de Distância",
		distanceAccumulationSnip: "Calcula a distância acumulada de cada célula para origens, permitindo distância de linha direta, distância de custo, distância de superfície verdadeira, como também fatores de custo vertical e horizontal.",
		distanceAccumulationDesc: "Acumulação de Distância calcula a distância para cada localização na área de estudo para a origem mais próxima ou de menos custo. Se somente as origens forem fornecidas para entrada, então uma distância de linha reta é calculada para cada localização na área de estudo. Se ambas as origens e barreiras forem utilizadas como entrada, então Acumulação de Distância calcula a distância de linha reta ao redor de barreiras. Para ambos raster de origem e o raster de barreira, o valor de plano de fundo deve ser NoData, enquanto origens e barreiras são representadas com valores de célula válidos. Os valores válidos incluem zero. <div><br/>Quando um raster de superfície for fornecido como entrada, então a distância de superfície real entre as células será calculada. Para executar análise de custo utilizando Acumulação de Distância, uma superfície de custo é precisado. Se uma superfície de custo for fornecida, o resultado será um raster de distância de custo acumulado. Quando fatores horizontais e verticais são fornecidos, então a direcionalidade é considerada conforme o custo é acumulado. Há quatro características de origem que podem ser utilizadas. Estas características, que pode ser da origem ou movedores a partir da origem, são controlados por parâmetros específicos: 1. Acumulação inicial: define o custo inicial antes do movimento iniciar. 2. Acumulação máxima: especifica quanto o custo de uma fonte pode acumular antes de alcançar seu limite. 3. Multiplicador para aplicar aos custos: especifica o modo de viagem ou magnitude na origem. 4. A direção de viagem: identifica se o transportador está iniciando em uma origem e mudando para localizações de não origem, ou está iniciando em localizações de não origem e movendo de volta para uma origem.<div><br/>Por padrão, o resultado da Acumulação de Distância é uma banda única, que é o raster de acumulação de distância. Entretanto, uma segunda banda também pode ser criada, a banda de direção de volta.  Esta banda indica cada localização na área de estudo, que direção seguir para obter a origem de menor custo.  Ambas as bandas serão necessárias para determinar caminhos favoráveis dentro da área de estudo. Para gerar um caminho, primeiro utilize a função Extrair Banda para extrair o raster de acumulação de distância e o raster de direção de volta. Utilize estas camadas como entrada para a função Caminho de Custo. Na função, utilize o raster de acumulação de distância como entrada do Raster da Distância de Custo e o raster de direção de volta como a entrada do Raster de Vínculo de Retorno de Custo.</div>",
		distanceAllocationName: "Alocação de Distância",
		distanceAllocationSnip: "Calcula a alocação de distância de cada célula para origens fornecidas com base em distância de linha direta, distância de custo, distância de superfície verdadeira, como também fatores de custo vertical e horizontal.",
		distanceAllocationDesc: "Alocação de Distância calcula qual origem cada localização na área de estudo é alocado. Se somente as origens forem fornecidas para entrada, então as localizações são alocadas utilizando uma distância de linha reta para a origem mais próxima. Se ambas as origens e barreiras forem utilizadas como entrada, então Alocação de Distância calcula a distância de linha reta ao redor de barreiras para determinar qual origem uma localização está alocada. Para ambos raster de origem e o raster de barreira, o valor de plano de fundo deve ser NoData, enquanto origens e barreiras são representadas com valores de célula válidos. Os valores válidos incluem zero.<div><br/>Para executar análise de custo utilizando Alocação de Distância, uma superfície de custo é precisado. Se uma superfície de custo for fornecida, então o resultado será um raster de alocação baseado em custo acumulativo, não em uma distância de linha reta. Quando fatores horizontais e verticais são fornecidos, então a direcionalidade é considerada conforme o custo é acumulado. Quando um raster de superfície for fornecido como entrada, então a distância de superfície real coberta ao passar entre células é calculado quando a alocação for determinada. Há quatro características de origem que podem ser utilizadas. Estas características, que pode ser da origem ou movedores a partir da origem, são controlados por parâmetros específicos: 1. Acumulação inicial: define o custo inicial antes do movimento iniciar. 2. Acumulação máxima: especifica quanto o custo de uma fonte pode acumular antes de alcançar seu limite. 3. Multiplicador para aplicar aos custos: especifica o modo de viagem ou magnitude na origem. 4. A direção de viagem: identifica se o transportador está iniciando em uma origem e mudando para localizações de não origem, ou está iniciando em localizações de não origem e movendo de volta para uma origem.<div><br/>Por padrão, o resultado da Alocação de Distância é uma banda única, que é o raster de alocação de distância. Marcar a opção Booleano, Gerar linha e coluna de origem como bandas adicionais na saída resultará em um raster de bandas múltiplas consistindo em três bandas. A primeira banda é a banda de alocação de distância, a segunda banda contém um índice de linha e a terceira banda contém um índice de coluna. Estes índices identificam o local da célula de origem que é a menor distância de custo acumulada. O índice de linha de origem e índice de coluna de origem pode ser utilizado junto para executar o mapeamento de intensidade. Se você consultar qualquer localização em sua área de estudo através das bandas duas e três, você saberá a linha e coluna da origem de menor custo para esta localização.</div>",
		eucBackDirectionName: "Direção Euclidiana de Retorno",
		eucBackDirectionSnip: "Calcula, para cada célula, a direção, em graus, até a célula vizinha ao longo do caminho mais curto de volta à fonte mais próxima, evitando barreiras.",
		eucBackDirectionDesc: "A função Direção de Volta Euclideana resulta em um raster de ponto flutuante contínuo que representa a direção em graus de volta para a origem mais próxima enquanto evita barreiras, se barreiras forem fornecidas.<div><br/>As entradas para Direção de Volta Euclideana são a origem que a direção será calculada. Uma entrada opcional é um raster que representa barreiras dentro da área de estudo. Para ambos raster de origem e o raster de barreira, o valor de plano de fundo deve ser NoData, enquanto origens e barreiras são representadas com valores válidos. Os valores válidos incluem zero. Por padrão, o cálculo irá processar na extensão combinada das origens e barreiras, mais 2 linhas e colunas. Se a análise for somente necessária dentro de uma distância especificada a partir das origens, então o parâmetro Distância Máxima pode ser utilizada. Direção de Volta Euclideana suporta ambos um método Plano e um método Geodésico no cálculo. O cálculo do método Planar será executado em um plano projetado utilizando um sistema de coordenadas Cartesianas 2D. O cálculo de método Geodésico será executado no elipsóide, o qual significa que não importando a projeção de entrada ou saída, os resultados não alteram.<div><br/>O resultado da função Direção de Volta Euclideana pode ser utilizado junto com o resultado da função Distância Euclideana para determinar os menores caminhos de localizações dentro da área de estudo de volta para a origem. Ambos os resultados de Direção de Volta Euclideana e Distância Euclideana são utilizadas na função Caminho de Custo junto com destinos para gerar os menores caminhos.</div>",
		expandName: "Expandir",
		expandSnip: "Expande zonas selecionadas de um raster por zonas, por um número de células específico.",
		expandDesc: "Com a função global Expandir, você pode generalizar ou simplificar rasters criando zonas particulares maiores. Você também pode controlar a quantia de generalização que ocorrerá.<div><br/>As zonas que você seleciona aumentará em tamanho expandindo em outras zonas. Conceitualmente, os Valores de Zona selecionados podem ser visualizados como zonas de primeiro plano, enquanto os outros valores permanecem zonas de plano de fundo. As zonas de primeiro plano podem expandir nas zonas de plano de fundo.<div><br/>A quantia de generalização pode ser controlada com o parâmetro Número de Células. Por padrão, este valor é 1, que significa que as zonas selecionadas expandirá pela quantia correspondendo para um tamanho da célula. Para aumentar o grau de generalização, você pode especificar um valor maior para este parâmetro. Conceitualmente, é como executar a ferramenta tantos quanto o número especificado, com os resultados dos anteriores na execução sendo a entrada na interação subsequente.</div>",
		trendAnalysisName: "Gerar Tendência",
		trendAnalysisSnip: "Estima a tendência de cada pixel ao longo de uma dimensão para um ou mais variáveis em um raster multidimensional.",
		trendAnalysisDesc: "<div>Esta função pode ser usada para ajustar os dados ao longo de uma linha de tendência linear, harmônica ou polinomial, ou pode ser usada para realizar a detecção de tendência usando o teste de Mann-Kendall ou Sazonal-Kendall.</div><br><div>O raster de tendência de saída gerado com esta função é usado como entrada para a função <strong>Prever Utilizando Tendência</strong> .</div><br><div>Os testes de Mann-Kendall e Seasonal-Kendall são usados para determinar se há uma tendência monotônica nos dados. Eles são não paramétricos, o que significa que não assumem uma distribuição específica de dados. O teste de Mann-Kendall não considera correlação serial ou efeitos sazonais. Se os dados forem sazonais, o teste de Sazonal-Kendall será mais apropriado.</div><br><div>Se a ferramenta for usada para realizar o teste de Mann-Kendall ou Sazonal-Kendall, a saída será um raster de cinco bandas como segue:</div><ul><li>Banda 1 = declividade de Sen</li><li>Banda 2 = valor p</li><li>Banda 3 = pontuação (S) de Mann-Kendall</li><li>Banda 4 = Variância S</li><li>Banda 4 = Variância S</li><li>Banda 5 = pontuação Z</li></ul><div>As saídas do teste de Mann-Kendall ou Sazonal-Kendall podem ser usadas para determinar quais pixels em sua série de tempo multidimensional têm uma tendência estatisticamente significativa. Você pode usar estas informações em conjunto com a análise de tendência linear, harmônica ou polinomial para extrair tendências significativas em sua série de tempo. Você pode gerar uma máscara incluindo pixels com valores p significativos, aplicar a máscara ao raster multidimensional e usar este raster multidimensional mascarado como entrada para a ferramenta para realizar análises de tendência linear, harmônica ou polinomial.</div><br><div>Há três opções de linha de tendência para ajustar uma tendência aos valores de variáveis ao longo de uma dimensão: linear, polinomial e harmônico.</div><br><div>Para análise de tendência linear, a saída é um raster de três bandas como segue:</div><ul><li>Banda 1 = Declividade</li><li>Banda 2 = Interceptar</li><li>Banda 3 = Erro Médio Quadrático (RMSE) ou o erro em torno da linha de melhor ajuste</li></ul><div>Para análise de tendência polinomial, o número de bandas na saída depende da ordem polinomial. O ajuste polinomial de segunda ordem produz um raster de quatro bandas como segue:</div><ul><li>Banda 1 = Polynomial_2</li><li>Banda 2 = Polynomial_1</li><li>Banda 3 = Polynomial_0</li><li>Banda 4 = RMSE</li></ul><div>O ajuste polinomial de terceira ordem produz um raster de cinco bandas como segue:</div><ul><li>Banda 1 = Polynomial_3</li><li>Banda 2 = Polynomial_2</li><li>Banda 3 = Polynomial_1</li><li>Banda 4 = Polynomial_0</li><li>Banda 5 = RMSE</li></ul><div>Para análise de tendência harmônica, o número de bandas na saída depende da frequência harmônica. Quando a frequência é definida como 1, a saída é um raster de cinco bandas como segue:</div><ul><li>Banda 1 = Declividade</li><li>Banda 2 = Interceptar</li><li>Banda 3 = Harmonic_sin1</li><li>Banda 4 = Harmonic_cos1</li><li>Banda 5 = RMSE</li></ul><div>Quando a frequência é definida como 2, a saída é um raster de sete bandas como segue:</div><ul><li>Banda 1 = Declividade</li><li>Banda 2 = Interceptar</li><li>Banda 3 = Harmonic_sin1</li><li>Banda 4 = Harmonic_cos1</li><li>Banda 5 = Harmonic_sin2</li><li>Banda 6 = Harmonic_cos2</li><li>Banda 7 = RMSE</li></ul><div>O parâmetro <strong>Comprimento do Ciclo</strong> para análise de tendência harmônica é usado para indicar o número e a duração dos ciclos que você espera visualizar em seus dados ao longo de um dia ou ano. Por exemplo, se você espera que seus dados passem por dois ciclos de variação em um ano, a duração do ciclo será de 182.5 dias ou 0.5 anos. Se você tiver dados de temperatura coletados a cada três horas e houver um ciclo de variação por dia, a duração do ciclo será de um dia.</div><br><div>O parâmetro <strong>Frequência</strong> para análise de tendência harmônica é usado para descrever o modelo harmônico para se ajustar aos dados. Se a frequência for definida como 1, uma combinação da curva linear e da curva harmônica de primeira ordem será usada para ajustar o modelo. Se a frequência for 2, uma combinação de curva harmônica linear de primeira ordem e curva harmônica de segunda ordem será usada para ajustar os dados. Se a frequência for 3, uma curva harmônica de terceira ordem adicional será usada para modelar os dados, e assim por diante.</div><br><div>As estatísticas de ajuste perfeito do modelo podem ser geradas como saídas opcionais. A raiz do erro quadrático médio (RMSE), R-quadrado e o valor p da inclinação da tendência podem ser calculados e simbolizados. Simbolize a camada de raster de tendência de saída usando a simbologia <strong>RGB</strong> e especifique as estatísticas como as bandas vermelha, verde e azul.</div><br>",
		spectralUnmixingName: "Separar Linear Espectral",
		spectralUnmixingSnip: "Executa classificação de subpixel e calcula a abundância fracionária de tipos de cobertura de solo diferentes para pixels individuais.",
		spectralUnmixingDesc: "A função Separar Linear Espectral calcula a cobertura fracionária de pixels individuais que contenham tipos de cobertura de solo múltiplos. Ela gera uma camada de bandas múltiplas, onde cada banda corresponde à abundância fracionária de cada classe de cobertura de solo. Por exemplo, você pode utilizá-la to executar classificação de cobertura de solo em uma imagem multiespectral para identificar vegetação fotossintética, solo bruto e vegetação morta ou não fotossintética.<div><br/>A ordem do raster de bandas múltiplas de saída segue a ordem do perfil de entrada espectral. O número de classes não pode exceder o número de bandas no raster de entrada. Por exemplo, você não pode extrair informações sobre mais de 8 classes de raster de 8-bandas.</div>",
		multidimensionalFilterName: "Filtro Multidimensional",
		interpolateRasterByDimensionFunctionName: "Interpolar Raster por Dimensão",
		interpolateRasterByDimensionFunctionSnip: "Interpola um raster multidimensional em valores de dimensão especificados usando divisões adjacentes.",
		interpolateRasterByDimensionFunctionDesc: "<p>Esta função permite estimar valores de pixel para uma divisão de dimensão indefinida em um raster multidimensional. Por exemplo, se você tem um conjunto de dados contendo a temperatura do oceano ao nível da superfície e a 100 metros abaixo do nível do mar e deseja estimar a temperatura a 50 metros abaixo do nível do mar, você pode usar esta função para obter uma estimativa nessa profundidade usando o botão Por definição de dimensão de valores.</p><p>Você também pode reduzir a amostra de um conjunto de dados mensal em um conjunto de dados diário usando a definição de dimensão Por intervalo e especificando o valor do parâmetro Etapa como 1 e o valor do parâmetro Unidade como Dias.</p><p>Use a opção Definição de dimensão por Raster de Destino para estimar o valor do Raster de Destino.</p>",
		multidimensionalFilterSnip: "Cria uma camada raster a partir de um conjunto de dados raster multidimensional ou camada raster multidimensional dividindo os dados ao longo de variáveis e dimensões definidas.",
		multidimensionalFilterDesc: "O Filtro Multidimensional cria uma camada raster multidimensional filtrando e extraindo um subconjunto de variáveis de um raster multidimensional. Por exemplo, você tem um conjunto de dados multidimensional que contém 30 anos de dados de precipitação mensal e deseja extrair dados de cada Janeiro para verificar como a precipitação foi alterada para este mês.<div><br/>Utilize o parâmetro Definição de Dimensão para dividir dimensões utilizando um intervalo, um valor ou um intervalo de valores. Por exemplo, se você tiver 10 anos de dados de salinidade do oceano, coletados mensalmente e a cada 2 metros de profundidade até 500 metros, poderá utilizar as diferentes opções da definição de dimensão para os seguintes cenários. Cenário 1: Extrair dados de salinidade para o mês de Janeiro durante o período de 10 anos. Escolha Por Valores, defina Dimensão para StdTime e defina Valores para Janeiro. Cenário 2: Dividir dados de salinidade em um intervalo de profundidade de 0 a 150 metros. Escolha Por Intervalos, defina Dimensão para StdZ e defina Valor Mínimo para -150 e Valor Máximo para 0. Cenário 3: Extrair dados de salinidade dos 10 primeiros dias de cada Janeiro, durante um período de 10 anos. Escolha Por Iteração, defina Dimensão para StdTime, defina o Início da primeira iteração e Término da primeira iteração para o início e o término correspondentes do período da iteração, defina Etapa para 1 e defina Unidade para Anos.</div>",
		multidimensionalRasterName: "Raster Multidimensional",
		multidimensionalRasterSnip: "Adiciona dados multidimensionais a um mapa como uma camada raster multidimensional.",
		multidimensionalRasterDesc: "A função Raster Multidimensional adiciona dados multidimensionais a um mapa como uma camada multidimensional. Essa função é útil ao executar fluxos de trabalho da análise de raster utilizando uma cadeia de funções.<div><br/>Os conjuntos de dados raster multidimensionais suportados incluem netCDF, GRIB, HDF e CRF da Esri. Conjuntos de dados de mosaico multidimensionais também são suportados.</div>",
		optimalPathAsRasterName: "Caminho Favorável como Raster",
		optimalPathAsRasterSnip: "Calcula o caminho de menor custo da origem até o destino.",
		optimalPathAsRasterDesc: "Esta função global produz um raster de saída que registra o caminho favorável ou caminhos de localizações selecionadas para a célula de origem mais próxima definida dentro da superfície de custo acumulativo, em termos de distância de custo.<div><br/>Uma ou mais funções de custo ponderado (Acumulação de Distância ou Alocação de Distância) são geralmente exigidas antes de executar a função Caminho Favorável como função Raster para criar a acumulação da distância de entrada e os rasters da direção de retorno. Estas são camadas raster de entrada obrigatórias para a função Caminho Favorável. Os valores no caminho favorável de saída representam o número de caminhos em um determinado local. Em muitos casos, os caminhos seguem a mesma rota, deixando uma fonte e então divergindo para ir até diferentes destinos. Por exemplo, o valor de um indica que existe somente um caminho favorável em um determinado local, enquanto um valor de cinco significa que neste local há cinco caminhos favoráveis passando por esta célula na área de estudo.<div><br/>Os dados de destino de entrada devem ser uma camada raster. O conjunto de células de destino consiste em todas as células no raster de entrada que tem valores válidos. As células com valores NoData não são incluídas no conjunto. O valor de zero é considerado um destino legítimo. Um raster de destino pode ser criado utilizando as ferramentas de extração. Se você tiver feições de origem ou destino, poderá convertê-las em raster utilizando a função Rasterizar Feições. Utilize o raster de acumulação de distância ou direção de volta como entrada do Raster para a função de rasterização. Isto garantirá que a feição seja rasterizada utilizando o mesmo tamanho de célula, extensão e referência espacial que os outros rasters que entram na função Caminho Favorável como Raster. A função Caminho Favorável como Raster também pode ser utilizada para derivar o caminho de menor resistência em um modelo de elevação digital (DEM). Neste caso, utilize o DEM para o raster de acumulação da distância de entrada e a saída da função Direção do Fluxo para o Raster da direção de volta.</div>",
		trendName: "Prever Utilizando Tendência",
		trendSnip: "Calcula uma camada raster multidimensional prevista utilizando o raster de tendência de saída da função Gerar Tendência ou da ferramenta de geoprocessamento Gerar Raster de Tendência.",
		trendDesc: "A função Prever Utilizando Tendência calcula uma camada raster multidimensional prevista utilizando o raster de tendência de saída da função Gerar Tendência ou da ferramenta de geoprocessamento Gerar Raster de Tendência.",
		rasterCollectionName: "Processar Coleção de Raster",
		rasterCollectionSnip: "Processa cada parte de um raster multidimensional ou cada item em um raster de mosaico. Esta função também pode agregar divisões múltiplas em uma divisão única.",
		rasterCollectionDesc: "A função Processar Coleção de Raster processa cada parte em um raster multidimensional ou cada item em um raster de mosaico. Esta função também pode agregar divisões múltiplas em uma divisão única.<div><br/>Esta função processa cada parte no raster multidimensional ou raster de mosaico utilizando um modelo de função do raster. Esta função suporta as seguintes opções: 1. Especificar um modelo de função raster para Função Item. Por exemplo, você tem um conjunto de dados de mosaico que contém 20 anos de imagens do Landsat e deseja calcular o NDVI para cada cena na série temporal. Para Função Item, especifique um modelo de função do raster que contenha a função de raster do NDVI. Especificar um modelo de função do raster para a Função Agregação. Por exemplo, você tem um raster multidimensional que contém 10 anos de dados diários de temperatura e deseja calcular a temperatura máxima para cada ano. Na Função Agregação, especifique um modelo de função do raster que contenha a função Estatísticas da Célula, com a operação definida como Máximo. Em Definição de Agregação, defina Dimensão para StdTime, defina Tipo para Palavra-Chave do Intervalo e defina o Intervalo da Palavras-Chave para Anual. Note que, se o conjunto de dados de mosaico de entrada não for multidimensional, a função de agregação não respeitará a definição de agregação. A função de agregação agregará todos os itens ou cada grupo em um, se eles estiverem definidos no modelo de função de agregação. Para mais informações sobre o uso de grupos em um conjunto de dados de mosaico, consulte Utilizando itens do conjunto de dados de mosaico em modelos de função do raster. Especificar um modelo de função do raster para a Função Processamento. A função ou cadeia de funções neste modelo é utilizada para exibir o novo raster processado. Por exemplo, especifique um modelo de função do raster que contenha a função Mapa de Cores para alterar como a camada raster processada é exibida. Note que, se a entrada for um raster multidimensional, a função de processamento será aplicada à parte de exibição atual. Se a entrada for uma camada ou conjunto de dados de mosaico, a função de processamento será aplicada ao raster de mosaico utilizando o método Primeiro para resolver sobreposições. 3. Especificar modelos para qualquer combinação das três funções. Por exemplo, você tem um conjunto de dados de mosaico que contém imagens do Landsat de séries temporais e deseja gerar uma imagem composta com o máximo de NDVI. Para Função Item, especifique um modelo de função do raster que contenha a função de raster do NDVI. Para a Função Agregação, especifique um modelo de função do raster que contenha a função Estatísticas da Célula, com a operação definida para Máximo. Para a Função Processamento, especifique um modelo de função do raster que contenha a função Mapa de Cores. Note que a ordem de processamento da função segue a ordem dos parâmetros de entrada. Por exemplo, a Função Item será processada primeiro.</div>",
		randomName: "Aleatório",
		randomSnip: "Cria um raster com valores de pixel aleatórios extraídos de uma distribuição pseudo-aleatória. Diversas distribuições e geradores de números aleatórios são suportados.",
		randomDesc: "A função Aleatório cria um raster com valores de pixel aleatórios que podem ser utilizados em modelos de função do raster ou conjuntos de dados de mosaico.<div><br/>Embora muitas funções funcionem em uma ou mais fontes de entrada, a função Aleatório não exige um raster de entrada. Isto significa que ele se comporta mais como um conjunto de dados raster do que como uma função, portanto, deve-se tomar cuidado especial ao adicioná-lo ou removê-lo da cadeia de funções.</div>",
		shrinkName: "Reduzir",
		shrinkSnip: "Diminui as zonas selecionadas por um número especificado de células substituindo-as com o valor da célula que é mais frequente em sua vizinhança.",
		shrinkDesc: "Com a função global Reduzir, você pode generalizar ou simplificar rasters, diminuindo zonas específicas. Você também pode controlar a quantia de generalização que ocorrerá.<div><br/>As zonas que você seleciona encolherão ou reduzirão de tamanho, fazendo com que as células das zonas circundantes se expandam para elas. Conceitualmente, os Valores de Zona selecionados podem ser visualizados como zonas de primeiro plano, enquanto os outros valores permanecem zonas de plano de fundo. As células nas zonas de primeiro plano podem ser substituídas por células nas zonas de segundo plano. Ilhas finas dentro de uma zona, que podem ser visualizadas como limites de compartilhamento com a zona, também podem ser substituídas.<div><br/>A quantia de generalização pode ser controlada com o parâmetro Número de Células. Por padrão, este valor é 1, o que significa que as zonas selecionadas serão reduzidas pela quantidade correspondente ao tamanho de uma célula. Para aumentar o grau de generalização, você pode especificar um valor maior para este parâmetro. Conceitualmente, é como executar a ferramenta tantos quanto o número especificado, com os resultados dos anteriores na execução sendo a entrada na interação subsequente.</div>",
		trendToRGBName: "Tendência para RGB",
		trendToRGBSnip: "Converte um raster de tendência em um raster de três bandas (vermelho, verde e azul).",
		trendToRGBDesc: "A função Tendência para RGB converte um raster de tendência para um raster de três bandas (vermelho, verde e azul). O raster de tendência é gerado a partir da função do raster Gerar Tendência ou da função do raster Análise de CCDC.<div><br/>Esta função é útil para visualizar dados de coeficiente do modelo a partir da função Gerar Tendência ou da função Análise de CCDC. Ambas as funções estimam tendências na alteração dos valores de pixel, mas os resultados das funções são difíceis de interpretar diretamente.<div><br/>Como muitas funções do raster, talvez seja necessário utilizar o Ajuste de Intervalo Dinâmico (DRA) para exibir melhor os resultados desta função.</div>",
		landTrendrName: "Análise LandTrendr",
		landTrendrSnip: "Avalia alterações em valores de pixel com o passar do tempo usando a detecção de tendências baseada em Landsat no metódo de perturbação e recuperação (LandTrendr) e gera um raster de análise de alteração contendo os resultados do modelo.",
		landTrendrDesc: "Esta função do raster pode ser usada somente como entrada para a função do raster Detectar Alteração Utilizando Análise de Alteração. Para gerar uma saída de raster, conecte a função Análise de LandTrendr à função Detectar Alteração Utilizando Análise de Alteração em um modelo de função do raster e use o modelo como entrada na ferramenta de geoprocessamento Gerar Raster de Função do Raster. O resultado é um raster contendo informações sobre o momento no qual os valores de pixel mudaram.<div><br>O objetivo desta função do raster é extrair alterações em uma feição observada, de modo que a imagem multidimensional de entrada ideal deve capturar uma observação consistente ao longo do tempo e não deve incluir interferências atmosféricas ou de sensores, nuvens ou sombra de nuvem. A melhor prática é usar dados que foram normalizados e podem ser mascarados usando uma banda de QA, por exemplo, produtos Landsat Collection 1 Surface Reflectance com uma máscara de nuvem.<div><br>A função executa a análise em uma imagem por ano, e o número de divisões anuais deve ser igual ou maior que o valor especificado no parâmetro <strong>Número Mínimo de Observações</strong> . É recomendado que você tenha pelo menos seis anos de dados.<div><br>Se você tiver dados mensais, semanais ou diários, é recomendado que você selecione várias imagens de cada ano (de preferência da mesma estação), remova nuvens e sombras de nuvens e combine as imagens para gerar uma única imagem que capture bem a observação. Se dados mensais, semanais ou diários forem fornecidos como raster multidimensional de entrada, a função identificará uma divisão para análise com base na data mais próxima daquela fornecida no parâmetro <strong>Ajustar Data</strong> .<div><br>Uma feição em uma paisagem geralmente leva tempo para se recuperar de uma mudança não permanente, como um incêndio florestal ou uma infestação de insetos. Para controlar a taxa de recuperação reconhecida pelo modelo, defina o parâmetro Limite de Recuperação. Um segmento distinto não pode ter uma taxa de recuperação mais rápida do que 1/limite de recuperação.<div><br>A recuperação de uma mudança na paisagem pode ocorrer na direção positiva ou negativa. Por exemplo, quando uma paisagem sofre perda de floresta, uma série temporal de valores do índice de vegetação mostra uma queda nos valores de índice e a recuperação mostra um aumento gradual nos valores do índice de vegetação ou uma tendência de recuperação positiva. Especifique a direção da tendência de recuperação com o parâmetro<strong>A Recuperação Tem Tendência de Aumentar</strong> .",
		aggregateMultidimensionalName: "Agregar Multidimensional",
		aggregateMultidimensionalSnip: "Combina dados de variável do raster multidimensional existentes ao longo de uma dimensão.",
		aggregateMultidimensionalDesc: "A função Agregar Multidimensional cria uma camada de raster multidimensional combinando dados da variável de raster multidimensional existentes ao longo de uma dimensão.<div><br>Use o <strong>parâmetro Definição da Dimensão</strong> para filtrar primeiro os dados de entrada que deseja agregar. Por exemplo, se você tiver 30 anos de dados mensais, mas deseja criar apenas uma camada agregada para os primeiros 15 anos, poderá usar o parâmetro <strong>Definição da Dimensão</strong> para especificar os anos para incluir na análise.<div><br><ul><li>Extraia os dados de salinidade do mês de Janeiro durante o período de 10 anos. Escolha <strong>Por Valores</strong>, defina <strong>Dimensão</strong> para <strong>StdTime</strong>, e defina <strong>Valores</strong>para <strong>Janeiro</strong>.</li><li>Divida os dados de salinidade em uma faixa de profundidade de 0 a 150 metros. Escolha <strong>Por Intervalos</strong>, defina <strong>Dimensão</strong> para <strong>StdZ</strong>, e defina <strong>Valor Mínimo</strong> para <strong>-150</strong> e <strong>Valor Máximo</strong> para <strong>0</strong>.</li><li>Extraia dados de salinidade para os primeiros 10 dias de cada Janeiro durante um período de 10 anos. Escolha <strong>Por Interação</strong>, defina <strong>Dimensão</strong> para <strong>StdTime</strong>, defina <strong>Começo da primeiro iteração</strong> e <strong>Final da primeiro iteração</strong> para o início e fim correspondentes do período de iteração, defina <strong>Etapa</strong> para <strong>1</strong>, e defina <strong>Unidade</strong> para <strong>Anos</strong>.</li></ul><div><br>Use o parâmetro <strong>Definição de Agregação</strong> para escolher a dimensão a ser avaliada e o intervalo de agregação usando uma palavra-chave, um valor ou um intervalo de valores. Por exemplo, se você tiver 30 anos de dados de temperatura da superfície do mar, coletados diariamente e a cada 5 metros de profundidade até 100 metros, poderá usar as diferentes opções de intervalo para os seguintes cenários: <div><br><ul><li>Agregue dados diários de temperatura em dados mensais, onde o resultado é um raster multidimensional com 12 divisões de tempo, e cada divisão é o agregado de cada mês ao longo dos anos. Escolha <strong>Palavra-Chave de Intervalo</strong> e defina a palavra-chave para <strong>Mensal Recorrente</strong>.</li><li>Agregue dados de temperatura diários em dados mensais, onde o resultado é um raster multidimensional com 360 divisões, ou 12 divisões de tempo por ano (30 anos x 12 meses = 360 divisões). Escolha <strong>Palavra-Chave de Intervalo</strong> e defina a palavra-chave para <strong>Mensal</strong>.</li><li>Agregue dados de temperatura mensais em intervalos de 4 meses. Escolha <strong>Valor de Intervalo</strong> defina <strong>Intervalo de Valor</strong> para 4 e defina <strong>Unidade</strong> para <strong>Meses</strong>.</li><li>Agregue dados de temperatura de 0 a 25 metros, então de 25 a 50 metros, então de 50 a 100 metros. Escolha <strong>Faixas de Intervalos</strong> e especifique as profundidades mínima e máxima como <strong>0 25; 25 50; 50 100</strong>.</li></ul>",
		mergeRastersName: "Juntar Rasters",
		mergeRastersSnip: "Combina múltiplos conjunto de dados raster espacialmente ou em todas as variáveis e dimensões.",
		mergeRastersDesc: "Esta função cria um raster mesclado de uma lista de raster. Por exemplo, se você tiver um conjunto de dados de mosaico que contenha 30 anos de dados mensais de precipitação e outro conjunto de dados com 10 anos de dados mensais de temperatura, poderá combiná-los em um raster multidimensional com ambas as variáveis. <div><br>Se os rasters multidimensionais de entrada tiverem variáveis diferentes, o raster multidimensional de saída conterá todas as variáveis. <div><br>Se os raster multidimensionais de entrada tiverem dimensões ou valores de dimensão diferentes, o raster multidimensional de saída incluirá todas as dimensões e valores de dimensão. <div><br>Se os rasters multidimensionais de entrada tiverem as mesmas dimensões e variáveis, mas diferentes extensões espaciais, o raster multidimensional de saída incluirá as variáveis e dimensões nas extensões espaciais mescladas.<div><br>Esta função também pode ser usada quando você tiver vários rasters que deseja que sejam tratados como um único item, como calcular as mesmas estatísticas para todos, ou ao balancear cores, de forma que não seja necessário balancear cada imagem separadamente. Isto é útil ao trabalhar com imagens armazenadas como mosaicos separados devido a restrições de tamanho do arquivo; desta forma, os mosaicos serão tratados como parte da mesma imagem.",
		boundaryCleanName: "Limpar Limites",
		boundaryCleanSnip: "Suaviza o limite entre as zonas.",
		boundaryCleanDesc: "<p>A função generaliza ou simplifica os rasters suavizando os limites entre as zonas. A função fornece opções para controlar como as células das zonas na entrada influenciam a suavização e a quantidade de suavização que será aplicada. Cada célula de entrada é avaliada usando seus oito vizinhos imediatos.</p><p>O processo de suavização primeiro classifica as células vizinhas por uma prioridade em particular. A prioridade determina qual zona das células vizinhas pode substituir o valor da célula de processamento na saída.</p><p>A prioridade pode ser baseada no valor das zonas ou no tamanho das zonas. O parâmetro <strong>Tipo de classificação</strong> determina o tipo de classificação a ser usado. </p><p>A configuração padrão <strong>Não classificar</strong> avalia a prioridade com base no valor das zonas. Células de zonas com valores maiores terão uma prioridade mais alta para expandir em zonas com valores menores.</p><p>O tamanho ou área total, das zonas pode ser usado para classificar a prioridade. Com a configuração <strong>Decrescente</strong> , as zonas são classificadas por tamanho em ordem decrescente. As zonas com total de áreas maiores terão a prioridade de expansão para zonas com áreas menores. Com a configuração <strong>Ascendente</strong> , o oposto é verdadeiro: zonas com o total de áreas menores terão a prioridade de expansão em zonas com o total de áreas maiores.</p><p>A quantidade de suavização é controlada pelo parâmetro <strong>Executar expansão e redução duas vezes</strong> , que determina o número de vezes que o processo de expansão e redução será realizado.</p><p>Com a configuração desmarcada, o processo de expandir e reduzir é executado uma vez. Com a configuração marcada, o processo de expandir e reduzir é executado duas vezes, resultando em um grau adicional de suavização dos limites da zona.</p><p>Se os valores de todas as oito células vizinhas forem iguais aos da célula de processamento, a célula de saída manterá o valor da célula de entrada.</p>",
		predictUsingRegressionName: "Prever utilizando Regressão",
		predictUsingRegressionSnip: "Calcula um raster previsto com base em entradas de dados raster e um modelo de regressão. O modelo de regressão é a saída da ferramenta de geoprocessamento do raster <strong>Treinar Modelo de Regressão de Árvores Aleatórias</strong>.",
		predictUsingRegressionDesc: "<p>O modelo de regressão é definido em um arquivo da definição de regressão da Esri (.ecd). Ele contém todas as informações para um conjunto de dados específico ou um conjunto de conjuntos de dados, e o modelo de regressão, e é gerado pela ferramenta de geoprocessamento do raster <strong>Treinar Modelo de Regressão de Árvores Aleatórias</strong>.</p><p>A entrada pode ser uma única banda, múltiplas bandas, ou um raster multidimensional, ou uma lista destes tipos. Os tipos de raster de entrada devem ser o mesmo tipo de raster treinado pelo modelo de regressão.</p><ul><li>Quando a entrada é um raster de múltipls bandas, cada banda é tratada como uma variável preditora. As bandas devem estar na mesma ordem que a entrada de múltiplas bandas para a ferramenta de treinamento do modelo de regressão. </li><li>Quando a entrada é um raster multidimensional, cada variável é tratada como uma variável preditora e a variável deve ser uma banda única e ter uma dimensão de tempo. Os nomes e a ordem da variável devem ser os mesmos da entrada quando o modelo de regressão foi treinado. A saída é um raster multidimensional.</li><li>A entrada pode ser uma lista de itens. O número e a ordem dos itens devem corresponder à entrada quando o modelo de regressão foi treinado.</li></ul>",
		dimensionalMovingStatisticsName: "Estatística de Movimento Dimensional",
		dimensionalMovingStatisticsSnip: "Calcula estatísticas sobre uma janela móvel em dados multidimensionais ao longo de uma dimensão especificada.",
		dimensionalMovingStatisticsDesc: "<p>A função Estatística de Movimento Dimensional calcula várias estatísticas dentro de uma janela predefinida para todos os valores de dimensão ao longo de uma dimensão. Esta função recebe uma camada raster multidimensional como entrada e cria uma camada raster multidimensional como saída que tem o mesmo tamanho dimensional da camada de entrada.</p><p>Você pode especificar uma dimensão para a qual os valores de dimensão são considerados durante o cálculo. Por padrão, ele calcula ao longo da primeira dimensão não espacial. Você também pode especificar um tamanho de janela especificando os parâmetros Janela de Trás e Janela da Frente.</p><p>Quando o Tipo de Estatística é definido como Percentil, os parâmetros Valor de Percentil e Tipo de Interpolação de Percentual ficam disponíveis. Você pode usar esses parâmetros para especificar o percentil a ser calculado e escolher o tipo de interpolação a ser usado, respectivamente. Quando o Tipo de Estatística é definido como Média Circular, o parâmetro Valor de Quebra Circular fica disponível. O valor de quebra circular é usado para converter um valor linear no intervalo de uma determinada média circular.</p>",
		terrainFlattenFunctionName: "Nivelar Terreno",
		terrainFlattenFunctionSnip: "Corrige os dados do radar de abertura sintética (SAR) de entrada para distorções radiométricas devido à topografia.",
		terrainFlattenFunctionDesc: "<p>A função Nivelar Terreno raster corrige os dados de entrada do radar de abertura sintética (SAR) para distorções radiométricas devido à topografia.</p><p>Os dados do radar de entrada devem primeiro ser calibrados para zero beta. Use a ferramenta Aplicar calibração radiométrica para calibrar os dados do radar para zero beta.</p><p>If the input DEM does not span the entire SAR dataset, the tool will output NoData values for the pixels outside of the DEM extent for gamma nought, sigma nought, scattering area, and geometric distortion outputs. Para a saída da máscara de distorção geométrica, a ferramenta produzirá valores indeterminados para pixels fora da extensão do DEM.</p><p>A entrada DEM deve estar no sistema de coordenadas geográficas WGS 1984 (EPSG:4326).</p>",
		createColorCompositeFunctionName: "Criar Composição de Cores",
		createColorCompositeFunctionSnip: "Cria um raster de três bandas a partir de um conjunto de dados raster multibanda no qual cada banda pode usar um cálculo algébrico com base na álgebra de banda.",
		createColorCompositeFunctionDesc: "<p>A função de raster Criar Composição de Cores cria um raster de três bandas a partir de um conjunto de dados raster multibanda no qual cada banda pode usar um cálculo algébrico baseado em álgebra de banda.</p><p>Ao definir um algoritmo aritmético de banda, você pode inserir uma fórmula algébrica de linha única para cada expressão para criar uma saída multibanda. Os operadores suportados são unários, mais (+), menos (-), vezes (*) e divisão (/).</p><p>Ao usar um ID de banda em uma expressão, identifique a banda prefixando B ou b ao número da banda.</p><p>Uma combinação de banda comum usada para radar de abertura sintética (SAR) em unidades lineares é VV para vermelho, VH para verde e VV/VH para azul. Se os dados de entrada estiverem em decibéis, a combinação de bandas deve ser VV para vermelho, VH para verde e VV-VH para azul.</p>",
		surfaceParametersName: "Parâmetros da Superfície",
		surfaceParametersSnip: "Determina parâmetros de um raster de superfície como aspecto, inclinação e diversos tipos de curvaturas usando métodos geodésicos.",
		surfaceParametersDesc: "<p>A função Parâmetros de Superfície determina parâmetros de um raster de superfície, como aspecto, declividade e vários tipos de curvaturas usando métodos geodésicos.</p><p>Esta função pode ser usada para as seguintes aplicações:</p><ul><li>Calcular aspecto e declividade usando métodos geodésicos.</li><li>Calcular diferentes tipos de curvaturas de um raster de superfície de entrada, por exemplo, <strong>Curvatura tangencial (curva de nível normal)</strong> que caracteriza a convergência topográfica e a divergência de fluxo ao longo da superfície.</li></ul>",
		leastCostCorridorName: "Corredor de Menor Custo",
		leastCostCorridorSnip: "Calcula a soma de dois rasters de distância de custo acumulativo com a opção de aplicar um limite baseado em porcentagem ou custo acumulativo.",
		leastCostCorridorDesc: "<p>Os rasters de entrada devem ser da acumulação de distância e rasters de direção inversa resultantes da função <strong>Acumulação de Distância</strong> ou <strong>Distância-Alocação</strong>. Estes devem ser baseados na distância de custo e as mesmas configurações de parâmetros devem ser usadas ao criar as camadas para cada fonte. Nenhum parâmetro que dependa da direcionalidade (fator horizontal, fator vertical e direção da viagem) deve ser usado na criação desses rasters.</p><p>Os valores no raster do corredor de saída são a soma do custo acumulativo para chegar a um determinado local com as mesmas unidades que os rasters da distância de custo acumulativo de entrada.</p><p>Se um valor de <strong>Limite</strong> especificado for maior que o custo acumulativo máximo quando os dois rasters da acumulação de distância forem somados, o raster do corredor de saída cobrirá a mesma área que os rasters acumulativos de entrada.</p><p>Se um valor de limite especificado for menor que o valor mínimo no raster do corredor, uma mensagem de aviso será retornada e o raster de saída ficará vazio.</p><p>O raster do corredor de saída pode conter células com custos acumulativos ligeiramente maiores que o valor limite. Isso vem dos rasters de direção de volta usando células com custos ligeiramente mais altos do que o limite para conectar células desconectadas ao corredor.</p>",
		geometricMedianName: "Mediana Geométrica",
		geometricMedianSnip: "A função Mediana Geométrica calcula a mediana geométrica entre pixels em uma série temporal de imagens de múltiplas bandas.",
		geometricMedianDesc: "<p>Essa função reduz ruídos e discrepâncias em imagens de séries temporais calculando um pixel geométrico mediano para cada matriz de pixels na pilha de imagens. O algoritmo mantém os relacionamentos espectrais entre as bandas nos espectros de pixels, para que a saída possa ser usada em análises, como índices de vegetação.</p><p>Nuvens e sombras devem ser mascaradas usando a banda de controle de qualidade do conjunto de dados antes de aplicar esta função.</p><p>Se a imagem de entrada for de ponto flutuante, como refletância de superfície com valores entre 0 e 1, um valor épsilon de 0.001 deverá produzir resultados de qualidade.</p>"
	},
	rfxArgs: {
		rasterName: "Raster",
		colorSchemeTypeName: "Tipo do Esquema de Cores",
		colormapName: "Mapa de Cores",
		colormapNameName: "Nome do Mapa de Cores",
		colorRampName: "Rampa de Cores",
		contrastOffsetName: "Deslocamento de Contraste",
		brightnessOffsetName: "Deslocamento de Brilho",
		methodName: "Método",
		bandNamesName: "Nomes de Bandas",
		bandWavelengthsName: "Comprimentos de Onda da Banda",
		bandIdsName: "IDs de Banda",
		missingBandActionName: "Ação da Banda Ausente",
		conversionParametersName: "Parâmetros de Conversão",
		hillshadeTypeName: "Tipo de Relevo Sombreado",
		azimuthName: "Azimute",
		altitudeName: "Altitude",
		slopeTypeName: "Escala",
		zFactorName: "Fator Z",
		PSPowerName: "Potência de Tamanho do Pixel",
		PSZFactorName: "Fator de Tamanho do Pixel",
		removeEdgeEffectName: "Desativar interpolação de pixel do segmento padrão",
		fromUnitName: "Da Unidade",
		toUnitName: "Para Unidade",
		rasterTypeName: "Tipo",
		minName: "Mínimo de Saída",
		maxName: "Máximo de Saída",
		minPercentName: "Porcentagem Mínima de Recorte",
		maxPercentName: "Porcentagem Máxima de Recorte",
		numberOfStandardDeviationName: "Número de desvios padrão",
		sigmoidStrengthLevelName: "Nível de Contraste do Sigmóide",
		estimateStatsHistogramName: "Avaliar Estatística",
		DRAName: "Ajuste de Intervalo Dinâmico",
		statisticsName: "Estatística",
		histogramsName: "Histogramas",
		statisticsHistogramName: "Definir Estatísticas e Histograma",
		computeGammaName: "Gama Automático",
		useGammaName: "Utilizar Gama",
		gammaName: "Gama",
		inputNamesName: "Nomes",
		expressionName: "Expressão",
		cellsizeTypeName: "Tipo de Tamanho da Célula",
		extentTypeName: "Tipo de Extensão",
		classifierDefinitionFileName: "Arquivo de Definição de Entrada",
		raster1Name: "Raster1",
		raster2Name: "Raster2",
		raster3Name: "Raster3",
		trueRasterName: "Raster Verdadeiro",
		falseRasterName: "Raster Falso",
		noDataInterpretationName: "Interpretação de NoData",
		noDataValuesName: "Valores de NoData",
		includedRangesName: "Intervalos Incluídos",
		curvatureTypeName: "Tipo de Curvatura",
		rastersName: "Rasters",
		attributeTableName: "Tabela",
		attributeTableTypeName: "Tipo de Tabela",
		rowsName: "Número de Linhas",
		columnsName: "Número de Colunas",
		kernelName: "Kernel",
		mirrorEdgesName: "Refletir Bordas",
		influencesName: "Influências",
		fieldsName: "Campos",
		remapsName: "Tabela de Remapeamento",
		evalFromName: "Da Escala de Avaliação",
		evalToName: "Para Escala de Avaliação",
		weightsName: "Pesos",
		DEMName: "DEM",
		shortRangeIDWRadiusName: "Raio IDW de Intervalo Curto",
		maxVoidWidthName: "Largura Máxima do Vazio",
		sigmaGaussianName: "Suavização Adaptativa",
		contourTypeName: "Tipo de Contorno",
		zBaseName: "Base Z",
		numberOfContoursName: "Número de Curvas de Nível",
		contourIntervalName: "Intervalo da Curva de Nível",
		nthContourLineInBoldName: "Linha de Curva de Nível Nth em Negrito",
		featureClassName: "Feições de Entrada",
		classIndexFieldName: "Campo",
		resolveOverlapMethodName: "Solucionar Método de Sobreposição",
		resamplingTypeName: "Tipo de Reamostragem",
		inputCellsizeName: "Tamanho da Célula de Entrada",
		outputCellsizeName: "Tamanho da Célula de Saída",
		pointFeatureClassName: "Pontos de Origem",
		maxGrowthRadiusFieldName: "Campo do Raio de Crescimento Máximo",
		similarityThresholdFieldName: "Campo do Limite de Similaridade",
		fillValueFieldName: "Campo do Valor de Preenchimento",
		spectralDetailName: "Detalhe Espectral [1..20]",
		spatialDetailName: "Detalhe Espacial [1..20]",
		minNumPixelsPerSegmentName: "Tamanho Mínimo do Segmento em Pixels",
		boundariesOnlyName: "Somente limites de segmento",
		statisticsTypeName: "Tipo de Estatística",
		fillNoDataOnlyName: "Somente preencher pixels de NoData",
		inputDataTypeName: "Tipo de Dados de Entrada",
		angleReferenceSystemName: "Sistema de Referência do Ângulo",
		outputDataTypeName: "Tipo de Dados de Saída",
		inputSamplePointFeatureClassName: "Amostras de Entrada",
		valueFieldName: "Campo de Valor",
		rasterInfoName: "Info do Raster",
		interpolationMethodName: "Método de Interpolação",
		radiusName: "Proporção",
		radianceGainValuesName: "Ganho de Radiação",
		radianceBiasValuesName: "Bias de Radiância",
		reflectedGainValuesName: "Ganho de Reflectância",
		reflectedBiasValuesName: "Bias de Reflectância",
		sunElevationName: "Elevação do Sol (graus)",
		albedoName: "Albedo",
		scaleFactorName: "Fator de Escala",
		offsetName: "Deslocamento",
		thresholdTypeName: "Tipo de Limite",
		thresholdsName: "Limites",
		undefinedClassName: "Classe Indefinida",
		minValueName: "Mín",
		maxValueName: "Máx",
		operationName: "Operação",
		clippingTypeName: "Tipo de Recorte",
		clippingGeometryName: "Recortando Geometria / Raster",
		extentName: "Extensão de Saída",
		useInputFeatureGeometryName: "Utilizar feições de entrada para recortar geometria",
		remapDefinitionTypeName: "Tipo da Definição de Remapeamento",
		inputRangeName: "Intervalos de Entrada",
		outputValuesName: "Valores de Saída",
		noDataRangeName: "Intervalos de NoData",
		inputFieldName: "Campo de Entrada",
		outputFieldName: "Campo de Saída",
		inputMaxFieldName: "Campo Máximo de Entrada (opcional)",
		remapTableTypeName: "Tipo da Tabela de Remapeamento",
		allowUnmatchedName: "Permitir Valores de Pixels Incomparáveis",
		changeMissingValuesToNoDataName: "Alterar valores ausentes para Nodata",
		visibleBandIDName: "ID da Banda Visível",
		infraredBandIDName: "ID da Banda de InfraVermelho",
		scientificOutputName: "Saída Científica",
		bandIndexesName: "Índices da Banda",
		constantName: "Constante",
		weightName: "Peso",
		minimumName: "Mínimo",
		maximumName: "Máximo",
		sourceDataName: "Raster de Origem",
		sourceFieldName: "Campo de Origem",
		costRasterName: "Raster de Custo",
		maxDistanceName: "Distância Máxima",
		valueRasterName: "Raster de Valor",
		costMultiplierName: "Multiplicador para Aplicar aos Custos",
		startCostName: "Custo Inicial",
		accumCostResistanceRateName: "Taxa de Resistência do Custo Acumulativo",
		capacityName: "Capacidade",
		travelDirectionName: "Direção do Percurso",
		cellSizeName: "Tamanho da Célula",
		populationFieldName: "Campo de Preenchimento",
		areaUnitsName: "Unidades de Área",
		outputValueTypeName: "Valores da Célula de Saída",
		barriersName: "Barreiras de Entrada",
		destinationDataName: "Raster de Destino",
		destinationFieldName: "Campo de Destino",
		pathTypeName: "Tipo de Caminho",
		observerFeaturesName: "Feições do Observador",
		analysisMethodName: "Método de Análise",
		analysisTypeName: "Tipo de Análise",
		verticalErrorName: "Erro Vertical",
		refractivityCoefficientName: "Coeficiente de Refratividade",
		surfaceOffsetName: "Deslocamento de Superfície",
		observerElevationName: "Elevação do Observador",
		observerOffsetName: "Deslocamento do Observador",
		innerRadiusName: "Raio Interno",
		innerRadiusIs3DDistanceName: "O Raio Interno é a Distância 3D",
		outerRadiusName: "Raio Externo",
		outerRadiusIs3DDistanceName: "O Raio Externo é a Distância 3D",
		horizontalStartAngleName: "Ângulo Inicial Horizontal",
		horizontalEndAngleName: "Ângulo Final Horizontal",
		verticalUpperAngleName: "Ângulo Superior Vertical",
		verticalLowerAngleName: "Ângulo Inferior Vertical",
		zoneDataName: "Raster de Zona",
		zoneFieldName: "Campo de Zona",
		ignoreNoDataName: "Ignorar NoData nos cálculos",
		temperatureRasterName: "Raster de Temperatura",
		inTemperatureUnitsName: "Unidades de Temperatura",
		outHeatIndexTemperatureUnitsName: "Unidades do Índice de Aquecimento",
		relativeHumidityRasterName: "Raster de Humidade Relativa",
		outWindChillTemperatureUnitsName: "Unidades da Sensação Térmica",
		windSpeedRasterName: "Raster de Velocidade do Vento",
		inWindSpeedUnitsName: "Unidades de Velocidade do Vento",
		valueName: "Valor",
		propertyName: "Propriedade do Nome",
		jsonName: "Metadados JSON",
		zoneTableName: "Tabela de Atributos Zonais",
		attributeFieldNames: "Nomes do Campo de Atributo",
		backgroundName: "Valor do Plano de Fundo",
		whereClauseName: "Cláusula Where",
		minimumValueFieldName: "Nome do Campo de Valor Mínimo",
		maximumValueFieldName: "Nome do Campo de Valor Máximo",
		outValueFieldName: "Nome do Campo de Valor de Saída",
		defaultValueName: "Valor de Saída Padrão",
		conversionMatrixName: "Matriz de Conversão",
		IsPseudoColorOutputName: "É uma pseudo cor de saída",
		unmappedAsRandomColorName: "Atribuir Cor Aleatoriamente Para Pixels Não Mapeados",
		distanceMethodName: "Método de Distância",
		flowDirRasterName: "Raster de Direção de Fluxo",
		pourPointName: "Fluir Raster de Ponto",
		pourPointFieldName: "Fluir Campo de Ponto",
		constantZName: "Constante Z",
		zOffsetName: "Deslocamento Z",
		geoIdName: "Geóide",
		calibrationTypeName: "Tipo de Calibração",
		filterTypeName: "Tipo de Filtro",
		filterSizeName: "Tamanho de Filtro",
		noiseModelName: "Modelo de Ruído",
		noiseVarianceName: "Variação de Ruído",
		additiveNoiseMeanName: "Média de Ruído Aditivo",
		multiplicativeNoiseMeanName: "Média de Ruído Multiplicativo",
		numberofLooksName: "Número de Visualizações",
		dampingFactorName: "Fator de Amortecimento",
		maskRasterName: "Raster de Máscara",
		nibbleValuesName: "Utilizar valores Nodata se forem vizinhos mais próximos",
		nibbleNoDataName: "Extrair células de NoData",
		zLimitName: "Limite Z",
		flowDirectionTypeName: "Tipo de Direção do Fluxo",
		weightRasterName: "Raster de Peso",
		forceEdgeName: "Forçar a saída do fluxo de todas as células do segmento",
		streamRasterName: "Raster do Fluxo",
		surfaceRasterName: "Raster de Superfície",
		conversionType: "Tipo de Conversão",
		distanceRaster1: "Raster de Distância 1",
		distanceRaster2: "Raster de Distância 2",
		costDistanceRaster: "Raster da Distância de Custo",
		costBacklinkRaster: "Raster de Vínculo Anterior de Custo",
		overridesName: "Substituições",
		fieldName: "Campo",
		signatureFileOrUrl: "Arquivo de Assinatura ou URL",
		redName: "Vermelho",
		greenName: "Verde",
		blueName: "Azul",
		infraredName: "Infra-Vermelho",
		panchromaticName: "Pancromática",
		multispectralName: "Multiespectral",
		pansharpeningType: "Tipo de Nitidez Pancromática",
		sensorName: "Sensor",
		spatialReferenceName: "Referência Espacial",
		xCellsizeName: "Tamanho da Célula X",
		yCellsizeName: "Tamanho da Célula Y",
		xOriginName: "Ponto de Registro X",
		yOriginName: "Ponto de Registro Y",
		percentileName: "Valor Percentil",
		neighborhoodType: "Tipo de Vizinhança",
		widthName: "Largura",
		heightName: "Altura",
		startAngleName: "Ângulo Inicial",
		endAngleName: "Ângulo Final",
		neighborhoodValues: "Valores de Vizinhança",
		horizontalRaster: "Raster Horizontal",
		horizontalFactor: "Fator Horizontal",
		verticalRaster: "Raster Vertical",
		verticalFactor: "Fator Vertical",
		streamRaster: "Raster do Fluxo",
		flowDirRaster: "Raster de Direção de Fluxo",
		numberNeighborCells: "Número de Células Vizinhas",
		zoneConnectivity: "Conectividade de Zona",
		addLinkBehavior: "Adicionar Link",
		excludedValue: "Valores Excluídos",
		constantFillCheck: "Gerar Raster de Preenchimento da Constante",
		fillRaster: "Raster de Preenchimento",
		constantFillValue: "Valor Constante",
		inputBitPositions: "Bit de Entrada",
		outputBitPositions: "Bit de Saída",
		distanceTypeName: "Tipo de Distância",
		barrierDataName: "Barreiras do Raster",
		pourPointDataName: "Raster de Ponto de Escoamento",
		accumulationRasterName: "Raster de Acumulação de Fluxo",
		snapDistanceName: "Ajustar Distância",
		orderMethodName: "Método de Ordenação",
		directionMeasurementName: "Direção da Medida",
		processAsMultiband: "Processar como Múltiplas Bandas",
		processMultidimensional: "Processar como multidimensional",
		forceFlowDirectionConvention: "Forçar convenção de direção de fluxo para raster do link de retorno",
		initialAccumulation: "Acumulação Inicial",
		maximumAccumulation: "Acumulação Máxima",
		sourceLocationBands: "Gerar linha e coluna de origem como bandas adicionais na saída",
		backDirectionBand: "Gerar direção de volta como banda adicional na saída",
		numberOfCells: "Número de Células",
		zoneValues: "Valores de Zona",
		shrinkMethod: "Método Reduzir",
		expandMethod: "Método Expandir",
		inputSpectralProfileType: "Tipo de Perfil Espectral",
		spectralProfileFileName: "Perfil Espectral",
		trainingFeatureFileName: "Feição de Treinamento",
		nonNegative: "Não-negativo",
		sumToOne: "Somar para Um",
		randomDistribution: "Distribuição",
		meanName: "Média",
		probabilityName: "Probabilidade",
		alphaName: "Alfa",
		betaName: "Beta",
		rName: "r",
		nName: "N",
		seed: "Origem",
		randomNumberGenerator: "Gerador de Número Aleatório",
		cellFactor: "Fator da Célula",
		aggregationType: "Técnica de Agregação",
		extentHandling: "Expandir extensão se necessário",
		trendAnalysisDimensionName: "Nome da dimensão",
		trendAnalysisType: "Tipo de Tendência",
		harmonicFrequency: "Frequência Harmônica",
		polynomialOrder: "Ordem Polinomial",
		cycleLengthName: "Comprimento do Ciclo",
		trendAnalysisRMSE: "RMSE",
		trendAnalysisR2: "R-Quadrada",
		trendAnalysisSlopePValue: "Valor P do Coeficiente de Declividade",
		trendAnalysisSeasonalPeriod: "Período Sazonal",
		cycleUnitName: "Unidade de Ciclo",
		predictDimensionValues: "Valores",
		dimensionDefinitionType: "Definição de Dimensão",
		predictDimensionStart: "Iniciar",
		predictDimensionEnd: "Final",
		predictDimensionInterval: "Intervalo do Valor",
		dimensionUnit: "Unidade",
		interpolationCellsizeName: "Tamanho da Célula de Interpolação",
		variableName: "Variáveis",
		dimensionlessName: "Adimensional",
		mdimDefinition: "Definição de Dimensão",
		dimensionName: "Dimensão",
		iterationStart: "Iniciar da primeira iteração",
		iterationEnd: "Finalizar da primeira iteração",
		intervalStart: "Início do Intervalo",
		intervalEnd: "Fim do Intervalo",
		stepName: "Intervalo",
		rangesName: "Faixas",
		minValue: "Valor Mínimo",
		maxValue: "Valor Máximo",
		changeAnalysisRasterName: "Raster da Análise de Alteração",
		changeTypeName: "Alterar Tipo",
		segmentDate: "Data do Segmento",
		changeDirectionName: "Alterar Direção",
		maxNumChangesName: "Número Máximo de Alterações",
		filterByYear: "Filtrar Por Ano",
		minimumYear: "Valor Mínimo",
		maximumYear: "Valor Máximo",
		filterByDuration: "Filtrar Por Duração",
		minimumDuration: "Duração Mínima",
		maximumDuration: "Duração Máxima",
		filterByMagnitude: "Filtrar Por Magnitude",
		minimumMagnitude: "Magnitude Mínima",
		maximumMagnitude: "Magnitude Máxima",
		filterByStartValue: "Filtrar por Valor Inicial",
		minimumStartValue: "Valor Inicial Mínimo",
		maximumStartValue: "Valor Inicial Máximo",
		filterByEndValue: "Filtrar por Valor Final",
		minimumEndValue: "Valor Final Mínimo",
		maximumEndValue: "Valor Final Máximo",
		modelTypeName: "Tipo de Modelo",
		fromRasterName: "Do Raster",
		toRasterName: "Para Raster",
		computeChangeMethod: "Calcular Método de Alteração",
		fromClassValues: "De Valores de Classe (Exemplo: 2 5)",
		toClassValues: "Para Valores de Classe (Exemplo: 2 5)",
		keepMethod: "Método de Filtro",
		useColorMethod: "Definir Cores de Transição",
		detectChangeBands: "Bandas para Detectar Alterações (começar em 0)",
		tmaskBands: "Bandas para Máscara Temporal (começar em 0)",
		chiSquaredThreshold: "Limite de Chi-Quadrado para Detectar Alterações",
		minAnomaly: "Observações de Anomalia Sucessivas Mínimas",
		updatingFrequency: "Atualizando Frequência de Ajuste (em anos)",
		distanceAccumulationRasterName: "Raster de Acumulação de Distância",
		costBackdirectionRasterName: "Direção de Volta ou Raster de Direção de Fluxo",
		rasterCollectionName: "Coleção de Raster",
		itemFunctionName: "Função do Item",
		aggregationFunctionName: "Função de Agregação",
		processingFunctionName: "Função de Processamento",
		aggregationDefinitionName: "Definição de Agregação",
		queryGeometryName: "Consultar geometria",
		factorFunctionZeroFactor: "Fator Zero",
		factorFunctionCutAngle: "Ângulo de Corte",
		factorFunctionSideFactor: "Fator Lateral",
		factorFunctionSlope: "Declividade",
		factorFunctionLowCutAngle: "Ângulo de Corte Baixo",
		factorFunctionHighCutAngle: "Ângulo de Corte Alto",
		factorFunctionCosPower: "Potência do Co-seno",
		factorFunctionSecPower: "Potência da Secante",
		factorFunctionTablePath: "Caminho da Tabela",
		processingBand: "Banda de Processamento",
		processingBandName: "Nome da Banda de Processamento",
		snappingDate: "Data de Ajuste",
		maxNumSegments: "Número Máximo de Segmentos",
		vertexCountOvershoot: "Excesso da Contagem de Vértice",
		spikeThreshold: "Limite de Spike",
		recoveryThreshold: "Limite de Recuperação",
		minNumObs: "Número mínimo de Observações",
		pValueThreshold: "Limite de Valor P",
		bestModelProportion: "Melhor Proporção do Modelo",
		preventOneYearRecovery: "Impedir Recuperação de Um Ano",
		recoveryIncreaseTrend: "A Recuperação Tem Tendência de Aumento",
		outputOtherBands: "Saída de Outras Bandas",
		sortType: "Tipo de Classificação",
		numberOfRuns: "Executar expansão e redução duas vezes",
		percentileValue: "Valor Percentil",
		percentileInterpolationType: "Tipo de interpolação de percentil",
		rasterInfoProperty: "Propriedade",
		rasterInfoValue: "Valor",
		rasterInfoColumns: "Colunas:",
		rasterInfoRows: "Linhas",
		rasterInfoBandCount: "Número de Bandas",
		rasterInfoPixelSizeX: "Tamanho da Célula X",
		rasterInfoPixelSizeY: "Tamanho da Célula Y",
		rasterInfoPixelType: "Tipo de Pixel",
		rasterExtentTop: "Superior",
		rasterExtentBottom: "Inferior",
		rasterExtentLeft: "Esquerda",
		rasterExtentRight: "Direita",
		rasterStatisticsNotCalculated: "A estatística não foi calculada.",
		spatialReferenceProjection: "Projeção",
		spatialReferenceWkid: "WKID",
		spatialReferenceLatestWkid: "WKID Anterior",
		spatialReferenceWkt: "WKT",
		spatialReferenceVcsWkid: "VCSWKID",
		spatialReferenceLatestVcsWkid: "VCSWKID Anterior",
		spatialReferenceAuthority: "Autoridade",
		spatialReferenceLinearUnit: "Unidade Linear",
		spatialReferenceAngularUnit: "Unidade Angular",
		spatialReferenceFalseEasting: "Falso Leste",
		spatialReferenceFalseNorthing: "Falso Norte",
		spatialReferenceCentralMeridian: "Meridiano Central",
		spatialReferencePrimeMeridian: "Meridiano Principal",
		spatialReferenceStandardParallel1: "Paralelo Padrão 1",
		spatialReferenceStandardParallel2: "Paralelo Padrão 2",
		spatialReferenceLatitudeOfOrigin: "Latitude de Origem",
		spatialReferenceAuxiliarySphereType: "Tipo de Esfera Auxiliar",
		spatialReferenceDatum: "Datum",
		spatialReferenceSpheroid: "Esferóide",
		spatialReferenceSemimajorAxis: "Semi-Eixo Maior",
		spatialReferenceSemiminorAxis: "Semi-Eixo Menor",
		spatialReferenceInverseFlattening: "Achatamento Inverso",
		inputDefinitionFileName: "Arquivo de Definição de Entrada",
		deleteName: "Excluir",
		addVariableName: "Adicionar variável",
		maxNumPixelsPerSegment: "Tamanho Máximo do Segmento em Pixels",
		forwardWindowName: "Janela da Frente",
		backwardWindowName: "Janela de Trás",
		noDataHandlingName: "Manipulação do NoData",
		circularWrapValueName: "Valor de Quebra Circular",
		fromClassNameFieldName: "Nome de Campo para Nomes da Classe em Do Raster",
		toClassNameFieldName: "Nome de Campo para Nomes da Classe em Para Raster",
		targetRasterName: "Raster de Destino",
		circularWrapValue: "Valor de Quebra Circular",
		bandIndexesR: "Expressão Vermelha",
		bandIndexesG: "Expressão Verde",
		bandIndexesB: "Expressão Azul",
		exampleName: "Exemplo",
		inputName: "Entrada",
		outputName: "Saída",
		optionalName: "Opcional",
		browseDefinitionFile: "Procurar arquivo de definição",
		selectDefinitionFile: "Selecione o arquivo de definição de entrada",
		inputDefinitionURL: "URL do arquivo de definição de entrada",
		enterDefinitionFileURL: "Insira a URL do arquivo de definição",
		browseXMLFile: "Procurar arquivo XML",
		selectStatsFile: "Selecione o arquivo de estatísticas e histogramas",
		enterXMLFileURL: "Digite a URL do arquivo XML",
		xmlFileURL: "URL do arquivo XML",
		circularCalculation: "Calcular Estatística Circular",
		localSurfaceType: "Tipo de Superfície Local",
		surfaceParameterType: "Tipo de Parâmetro",
		neighborhoodDistance: "Distância de Vizinhança",
		useAdaptiveNeighborhood: "Usar Vizinhança Adaptável",
		outputSlopeType: "Medição de Inclinação de Saída",
		projectAzimuths: "Azimutes Geodésicos do Projeto",
		useEquatorialAspect: "Usar Aspecto Equatorial",
		zUnit: "Unidade Z",
		analysisMask: "Máscara de Análise",
		stdDeviation: "Desvio Padrão",
		"true": "Verdadeiro",
		"false": "Falso",
		costDistanceRaster1: "Raster de Distância de Custo Acumulado de Entrada 1",
		costDistanceRaster2: "Raster de Distância de Custo Acumulado de Entrada 2",
		threshold: "Limite",
		thresholdMethod: "Método de Limite",
		directionRaster1: "Raster de Direção de Volta de Entrada 1",
		directionRaster2: "Raster de Direção de Volta de Entrada 2",
		maxIterations: "Número Máximo de Iterações",
		epsilon: "Épsilon"
	},
	enumLabels: {
		attributeTableTypeManual: "Manual",
		attributeTableTypeExternal: "Externo",
		clrSchemeTypeColormap: "Mapa de Cores",
		clrSchemeTypeColorRamp: "Rampa de Cores",
		colormapTypeElevation: "Elevação",
		colormapTypeGray: "Cinza",
		colormapTypeNDVI: "NDVI",
		colormapTypeNDVI2: "NDVI2",
		colormapTypeNDVI3: "NDVI3",
		colormapTypeRandom: "Aleatório",
		none: "Nenhum",
		slopeTypeAdjusted: "Ajustado",
		slopeTypeDegree: "Graus",
		slopeTypePercentRise: "Aumento da Porcentagem",
		slopeTypeScaled: "Dimensionado",
		stretchTypeMinMax: "Mín-Máx",
		stretchTypePercentMinMax: "Percentagem Mín-Máx",
		stretchTypeSigmoid: "Sigmóide",
		stretchTypeStdDev: "Desvio Padrão",
		hillshadeTypeSimple: "Tradicional",
		hillshadeTypeMultidirectional: "Multidirecional",
		bandComboByNames: "Nomes de Bandas",
		bandComboByWavelength: "Comprimentos de Onda da Banda",
		bandComboByIDs: "IDs de Banda",
		missingBandActionBestMatch: "Melhor Combinação",
		missingBandActionFail: "Falha",
		unitTypeCelsius: "Celsius",
		unitTypeCentimeters: "Centímetros",
		unitTypeDecimeters: "Decímetros",
		unitTypeFahrenheit: "Fahrenheit",
		unitTypeFeet: "Pés",
		unitTypeFeetPerSec: "Pés por Segundo (ft/s)",
		unitTypeInches: "Polegadas",
		unitTypeKelvin: "Kelvin",
		unitTypeKilometers: "Quilômetros",
		unitTypeKmsPerHour: "Quilômetros Por Hora (km/h)",
		unitTypeKnots: "Nó (kn)",
		unitTypeMeters: "Metros",
		unitTypeMetersPerSec: "Metros por Segundos (m/s)",
		unitTypeMiles: "Milhas",
		unitTypeMilesPerHour: "Milhas por Hora (mph)",
		unitTypeMillimeters: "Milímetros",
		unitTypeNauticalMiles: "Milhas Náuticas",
		unitTypeYards: "Jardas",
		unitTypeDecimalDegrees: "Graus Decimais",
		unitTypePoints: "Pontos",
		unitTypeUnknown: "Desconhecido",
		unitTypeSqMapUnits: "Unidades Quadráticas do Mapa",
		unitTypeSqMiles: "Milhas Quadradas",
		unitTypeSqKms: "Quilômetros Quadrados",
		unitTypeAcres: "Acres",
		unitTypeHectares: "Hectares",
		unitTypeSqYards: "Jardas Quadradas",
		unitTypeSqFt: "Pés Quadrados",
		unitTypeSqInches: "Polegadas Quadradas",
		unitTypeSqMts: "Metros Quadrados",
		unitTypeSqCms: "Centímetros Quadrados",
		unitTypeSqMms: "Milímetros Quadrados",
		cellsizeTypeFirst: "Primeiro De",
		cellsizeTypeMin: "Mínimo De",
		cellsizeTypeMax: "Máximo De",
		cellsizeTypeMean: "Média De",
		cellsizeTypeLast: "Último De",
		extentTypeFirst: "Primeiro De",
		extentTypeIntersection: "Intersecção De",
		extentTypeUnion: "União De",
		extentTypeLast: "Último De",
		noDataInterpretAny: "Combinar Qualquer Um",
		noDataInterpretAll: "Combinar Todos",
		curvatureTypeStandard: "Standard",
		curvatureTypeProfile: "Perfil",
		curvatureTypePlanform: "Forma Plana",
		filterTypeLineDetectionHorizontal: "Detecção de Linha Horizontal",
		filterTypeLineDetectionVertical: "Detecção de Linha Vertical",
		filterTypeLineDetectionLeftDiagonal: "Detecção de Linha Diagonal Esquerda",
		filterTypeLineDetectionRightDiagonal: "Detecção de Linha Diagonal Direita",
		filterTypeGradientNorth: "Norte Gradiente",
		filterTypeGradientWest: "Oeste Gradiente",
		filterTypeGradientEast: "Leste Gradiente",
		filterTypeGradientSouth: "Sul Gradiente",
		filterTypeGradientNorthEast: "Nordeste Gradiente",
		filterTypeGradientNorthWest: "Noroeste Gradiente",
		filterTypeSmoothArithmeticMean: "Suavizar Média Aritmética",
		filterTypeSmoothing3x3: "Suavização 3x3",
		filterTypeSmoothing5x5: "Suavização 5x5",
		filterTypeSharpening3x3: "Nitidez 3x3",
		filterTypeSharpening5x5: "Nitidez 5x5",
		filterTypeLaplacian3x3: "Laplaciano 3x3",
		filterTypeLaplacian5x5: "Laplaciano 5x5",
		filterTypeSobelHorizontal: "Horizontal de Sobel",
		filterTypeSobelVertical: "Vertical de Sobel",
		filterTypeSharpen: "Nítido",
		filterTypeSharpen2: "Mais Nítido",
		filterTypePointSpread: "Propagação de Ponto",
		userDefined: "Usuário Definido",
		ContourTypeLines: "Linhas de Contorno",
		ContourTypeFill: "Preenchimento de Contorno",
		ContourTypeSmoothOnly: "Somente superfície suave",
		rasterizeFirst: "Primeiro",
		rasterizeLast: "Último",
		rasterizeSmallest: "Menor",
		rasterizeLargest: "Maior",
		resamplingTypeNearest: "Vizinho Mais Próximo",
		resamplingTypeBilinear: "Interpolação Bilinear",
		resamplingTypeCubic: "Convolução Cúbica",
		resamplingTypeMajority: "Maioria",
		resamplingTypeBilinearPlus: "Interpolação Bilinear Adicional",
		resamplingTypeGauss: "Gauss Blur",
		resamplingTypeGaussPlus: "Gauss Blur Adicional",
		resamplingTypeAverage: "Média",
		resamplingTypeMinimum: "Mínimo",
		resamplingTypeMaximum: "Máximo",
		resamplingTypeVectorAvg: "Média Vetorial",
		minimum: "Mínimo",
		maximum: "Máximo",
		mean: "Média",
		stdDeviation: "Desvio Padrão",
		uvMagDirTypeUV: "U-V",
		uvMagDirTypeMagDir: "Magnitude-Direção",
		unknown: "Desconhecido",
		angleRefSysGeographic: "Geográfico",
		angleRefSysArithmetic: "Aritmético",
		interpolateIrregularDataNearest: "Vizinho Mais Próximo",
		interpolateIrregularDataBilinear: "Bilinear",
		interpolateIrregularDataTinningLinear: "Estanhagem Linear",
		interpolateIrregularDataTinningNaturalNeighbor: "Vizinho Natural",
		interpolateIrregularDataTinningIDW: "Distância Inversa Ponderada",
		esriRasterThresholdTypeConstant: "Constante",
		esriRasterThresholdTypeOtsu: "Otsu",
		esriRasterThresholdTypeTsai: "Tsai",
		esriRasterThresholdTypeKapur: "Kapur",
		esriRasterThresholdTypeKittler: "Kittler",
		esriRasterThresholdTypeRosin: "Rosin",
		argStatsTypeMax: "Parâmetro Máximo",
		argStatsTypeMin: "Parâmetro Mínimo",
		argStatsTypeMedian: "Parâmetro da Mediana",
		argStatsTypeDuration: "Duração",
		arithmeticOpPlus: "Adição",
		arithmeticOpMinus: "Subtrair",
		arithmeticOpMultiply: "Multiplicar",
		arithmeticOpDivide: "Dividir",
		arithmeticOpPower: "Potência",
		arithmeticOpMode: "Modo",
		clipTypeOutside: "Recortar Fora",
		clipTypeInside: "Recortar Dentro",
		yes: "Sim",
		no: "Não",
		densities: "Densidades",
		expectedCounts: "Contagens Esperadas",
		planar: "Planar",
		geodesic: "Geodésica",
		eachCell: "Cada Célula",
		eachZone: "Cada Zona",
		bestSingle: "Mais Simples",
		allSightlines: "Todas as Linhas de Visão",
		perimeterSightlines: "Linhas de Visão do Perímetro",
		frequency: "Frequência",
		observers: "Observadores",
		majority: "Maioria",
		median: "Mediana",
		minority: "Minoria",
		percentile: "Percentil",
		range: "Intervalo",
		sum: "Soma",
		variety: "Variedade",
		ndvi: "NDVI",
		savi: "SAVI",
		bandArithmeticMethodTSAVI: "SAVI Transformado",
		bandArithmeticMethodMSAVI: "SAVI Modificado",
		bandArithmeticMethodSultan: "Fórmula de Sultan",
		gemi: "GEMI",
		pvi: "PVI",
		gvi: "GVI (Landsat TM)",
		vari: "VARI",
		sr: "SR",
		gndvi: "GNDVI",
		ndvire: "NDVIre",
		srre: "SRre",
		mtvi2: "MTVI2",
		rtviCore: "RTVICore",
		cire: "CIre",
		cig: "CIg",
		ndwi: "NDWI",
		evi: "EVI",
		ironOxide: "Óxido de Ferro",
		ferrousMinerals: "Minerais Férreos",
		clayMinerals: "Minerais do Barro",
		wndwi: "WNDWI",
		bai: "BAI",
		mndwi: "MNDWI",
		nbr: "NBR",
		ndbi: "NDBI",
		ndmi: "NDMI",
		ndsi: "NDSI",
		localSquareRoot: "Raiz Quadrada",
		localACos: "ACos",
		localASin: "ASen",
		localATan: "ATan",
		localATanH: "ATanH",
		localAbs: "Abs",
		localBitwiseNot: "Não Bitwise",
		localBooleanNot: "Não Booleano",
		localCos: "Cos",
		localCosH: "CosH",
		localExp: "Exp",
		localExp10: "Exp10",
		localExp2: "Exp2",
		localInt: "Int",
		localIsNull: "Nulo",
		localFloat: "Real",
		localLn: "Ln",
		localLog10: "Log10",
		localLog2: "Log2",
		localNegate: "Negativo",
		localRoundDown: "Arredondar para Menos",
		localRoundUp: "Arredondar para mais",
		localSin: "Sen",
		localSinH: "SenH",
		localTan: "Tangente",
		localTanH: "TanH",
		localACosH: "ACosH",
		localASinH: "ASenH",
		localPlus: "Adição",
		localMinus: "Subtrair",
		localTimes: "Multiplicar",
		localPower: "Potência",
		localBitwiseAnd: "E Bitwise",
		localBitwiseLeftShift: "Mudança à Esquerda de Bitwise",
		localBitwiseOr: "Ou Bitwise",
		localBitwiseRightShift: "Deslocar à Direita do Bitwise",
		localBitwiseXor: "XOu Bitwise",
		localBooleanAnd: "E Booleano",
		localBooleanOr: "Ou Booleano",
		localBooleanXor: "XOu Boolean",
		localDivide: "Dividir",
		localEqualTo: "Igual A",
		localGreaterThan: "Maior Que",
		localGreaterThanEqual: "Maior que Igual",
		localLessThan: "Menor Que",
		localLessThanEqual: "Menor que Igual",
		localMod: "Mod",
		localNotEqual: "Não Igual",
		localATan2: "ATan2",
		localSquare: "Quadrado",
		localSetNull: "Definir Nulo",
		remapDefTypeList: "Lista",
		remapDefTypeTable: "Tabela",
		remapTableTypeSimple: "Simples",
		remapTableTypeDynamic: "Dinâmico",
		remapTableTypeReassignment: "Reatribuição",
		geomCorrectionByConstZ: "Utilizar Constante Z",
		geomCorrectionByDEM: "Utilizar DEM",
		radarCalibBetaNought: "Beta zero",
		radarCalibSigmaNought: "Sigma zero",
		radarCalibGammaNought: "Gama zero",
		speckleFilterTypeLee: "Filtro de Lee",
		speckleFilterTypeEnhancedLee: "Filtro de Lee Melhorado",
		speckleFilterTypeFrost: "Filtro de Frost",
		speckleFilterTypeKuan: "Filtro de Kuan",
		speckleNoiseModelMul: "Ruído Multiplicativo",
		speckleNoiseModelAdd: "Ruído Aditivo",
		speckleNoiseModelAddnMul: "Ruído Multiplicativo e Aditivo",
		mosaicOpTypeFirst: "Primeiro",
		mosaicOpTypeLast: "Último",
		mosaicOpTypeMin: "Mín",
		mosaicOpTypeMax: "Máx",
		mosaicOpTypeMean: "Média",
		mosaicOpTypeBlend: "Mesclar",
		mosaicOpTypeSum: "Soma",
		integer: "Inteiro",
		rfxD8: "D8",
		rfxMFD: "MFD",
		dinf: "Dinf",
		vertical: "Vertical",
		horizontal: "Horizontal",
		localCellStatisticsMajority: "Maioria",
		localCellStatisticsMax: "Máximo",
		localCellStatisticsMean: "Média",
		localCellStatisticsMedian: "Mediana",
		localCellStatisticsMin: "Mínimo",
		localCellStatisticsMinority: "Minoria",
		localCellStatisticsRange: "Intervalo",
		localCellStatisticsStdDev: "Desvio Padrão",
		localCellStatisticsSum: "Soma",
		localCellStatisticsVariety: "Variedade",
		localCellStatisticsMajorityIgnoreND: "Maioria (Ignorar NoData)",
		localCellStatisticsMaxIgnoreND: "Máximo (Ignorar NoData)",
		localCellStatisticsMeanIgnoreND: "Média (Ignorar NoData)",
		localCellStatisticsMedianIgnoreND: "Mediana (Ignorar NoData)",
		localCellStatisticsMinIgnoreND: "Mínimo (Ignorar NoData)",
		localCellStatisticsMinorityIgnoreND: "Minoria (Ignorar NoData)",
		localCellStatisticsRangeIgnoreND: "Intervalo (Ignorar NoData)",
		localCellStatisticsStdDevIgnoreND: "Desvio Padrão (Ignorar NoData)",
		localCellStatisticsSumIgnoreND: "Soma (Ignorar NoData)",
		localCellStatisticsVarietyIgnoreND: "Variedade (Ignorar NoData)",
		localCellStatisticsTypePercentileIgnoreND: "Percentil (ignorar NoData)",
		fromSource: "Da Origem",
		toSource: "Para Origem",
		colorspaceConversionRgbToHsv: "RGB para HSV",
		colorspaceConversionHsvToRgb: "HSV para RGB",
		pansharpenTypeIHS: "IHS",
		pansharpenTypeBrovey: "Brovey",
		pansharpenTypeEsri: "Esri",
		pansharpenTypeMean: "Média",
		pansharpenTypeGramSchmidt: "GramSchmidt",
		rectangleNeighborhood: "Retângulo",
		circleNeighborhood: "Círculo",
		annulusNeighborhood: "Anelar",
		wedgeNeighborhood: "Cunha",
		irregularNeighborhood: "Irregular",
		weightNeighborhood: "Peso",
		four: "Quatro",
		eight: "Oito",
		within: "Dentro",
		cross: "Transversal",
		addLink: "Adicionar Link",
		noLink: "Nenhum Link",
		weightedMean: "Média Ponderada",
		ls8QCBitPatternCirrus: "Landsat 8 Cirros",
		ls8QCBitPatternCloud: "Landsat 8 Nuvem",
		ls8QCBitPatternCloudShadow: "Landsat 8 Sombra de Nuvem",
		ls8QCBitPatternDesignatedFill: "Landsat 8 Preenchimento Designado",
		ls8QCBitPatternDroppedFrame: "Landsat 8 Estrutura Danificada",
		ls8QCBitPatternSnowIce: "Landsat 8 Neve/Gelo",
		ls8QCBitPatternTerrainOcclusion: "Landsat 8 Oclusão de Terreno",
		ls8QCBitPatternVegetation: "Landsat 8 Vegetação",
		ls8QCBitPatternWater: "Landsat 8 Água",
		downStream: "Corrente Inativa",
		upStream: "Corrente Ativa",
		strahler: "STRAHLER",
		shreve: "SHREVE",
		currentSlice: "Divisão Atual",
		allSlices: "Todas as Divisões",
		expandDistance: "DISTÂNCIA",
		expandMorphological: "MORFOLÓGICO",
		spectralProfileFile: "Perfil Espectral",
		trainingFeatureFile: "Feição de Treinamento",
		randomDistributionTypeUniform: "Uniforme",
		randomDistributionTypeUniformInteger: "Inteiro",
		randomDistributionTypeNormal: "Normal",
		randomDistributionTypeExponential: "Exponencial",
		randomDistributionTypePoisson: "Poisson",
		randomDistributionTypeGamma: "Gama",
		randomDistributionTypeBinomial: "Binômio",
		randomDistributionTypeGeometric: "Geométrico",
		randomDistributionTypeNegativeBinomial: "Binômio Negativo",
		randomGeneratorTypeStandardCRand: "Standard C Rand",
		randomGeneratorTypeAlgorithmACM599: "Algoritmo ACM coletado 599",
		randomGeneratorTypeMersenneTwister: "Mersenne Twister",
		sumName: "Soma",
		medainName: "Mediana",
		trendLinear: "Linear",
		trendHarmonic: "Harmônico",
		trendPolynomial: "Polinomial",
		trendMannKendall: "Mann-Kendall",
		trendSeasonalKendall: "Kendall Sazonal",
		dimensionByValue: "Por Valor",
		dimensionByInterval: "Por Intervalo",
		mdimDefTypeAll: "Todos",
		mdimDefTypeByValues: "Por Valores",
		mdimDefTypeByRanges: "Por Intervalos",
		mdimDefTypeByIteration: "Por Iteração",
		mdimDefTypeByInterval: "Por Intervalo",
		mdimDefTypeByTargetRaster: "Por Raster de Destino",
		esriTimeUnitsHours: "Horas",
		esriTimeUnitsDays: "Dias",
		esriTimeUnitsWeeks: "Semanas",
		esriTimeUnitsMonths: "Meses",
		esriTimeUnitsYears: "Anos",
		esriTimeIntervalKeywordHourly: "A Cada Hora",
		esriTimeIntervalKeywordDaily: "Diariamente",
		esriTimeIntervalKeywordWeekly: "Semanalmente",
		esriTimeIntervalKeywordDekadly: "Décadas",
		esriTimeIntervalKeywordPentadly: "Quinquênio",
		esriTimeIntervalKeywordMonthly: "Mensalmente",
		esriTimeIntervalKeywordQuarterly: "Trimestral",
		esriTimeIntervalKeywordYearly: "Anualmente",
		esriTimeIntervalKeywordRecurringDaily: "Diariamente recorrente",
		esriTimeIntervalKeywordRecurringWeekly: "Semanalmente recorrente",
		esriTimeIntervalKeywordRecurringMonthly: "Mensalmente recorrente",
		esriTimeIntervalKeywordRecurringQuarterly: "Trimestralmente recorrente",
		aggDefTypeAll: "Todos",
		aggDefTypeIntervalKeyword: "Palavra-chave de Intervalo",
		aggDefTypeIntervalValue: "Valor do Intervalo",
		aggDefTypeIntervalRanges: "Faixas de Intervalo",
		latestChange: "Hora da Última Alteração",
		earliestChange: "Hora da Primeira Alteração",
		largestChange: "Hora da Maior Alteração",
		numberOfChanges: "Número de Alterações",
		longestChange: "Tempo de Alteração mais Longo",
		shortestChange: "Tempo de Alteração Menor",
		fastestChange: "Tempo de Alteração Mais Rápido",
		slowestChange: "Tempo de Alteração Mais Lento",
		allChanges: "Todos",
		increaseChanges: "Aumentar",
		decreaseChanges: "Diminuir",
		segmentBeginning: "Início do segmento",
		segmentEnd: "Final do segmento",
		esriComputeChangeMethodDifference: "Diferença",
		esriComputeChangeMethodRelativeDifference: "Diferença Relativa",
		esriComputeChangeMethodCategorical: "Diferença Categórica",
		esriComputeChangeMethodMultispectralEuclideanDistance: "Distância Euclidiana Espectral",
		esriComputeChangeMethodMultispectralAngularDifference: "Diferença de Ângulo Espectral",
		esriComputeChangeMethodMultispectralAxisWithBiggestChange: "Banda Com Mais Alterações",
		esriComputeChangeKeepAll: "Manter Todos",
		esriComputeChangeKeepChangedOnly: "Manter Somente Pixels Alterados",
		esriComputeChangeKeepUnchangedOnly: "Manter Somente Pixels Não Alterados",
		esriComputeChangeUseColorAverage: "Média De e Para Cores",
		esriComputeChangeUseColorFrom: "Utilizar De Cores",
		esriComputeChangeUseColorTo: "Utilizar Para Cores",
		factorFunctionBinary: "Binário",
		factorFunctionForward: "Para Frente",
		factorFunctionLinear: "Linear",
		factorFunctionInvLinear: "Linear Inverso",
		factorFunctionTable: "Tabela",
		factorFunctionSymLinear: "Linear Simétrico",
		factorFunctionSymInvLinear: "Linear Simétrico Inverso",
		factorFunctionCos: "Co-seno",
		factorFunctionSec: "Secante",
		factorFunctionCosSec: "Co-seno Secante",
		factorFunctionSecCos: "Secante Co-seno",
		noSort: "Não Classificar",
		ascend: "Ascendente",
		descend: "Descendente",
		autoDetect: "Detecção automática",
		nearest: "Mais Próximo",
		linear: "Linear",
		esriMonthJanuary: "Janeiro",
		esriMonthFebruary: "Fevereiro",
		esriMonthMarch: "Março",
		esriMonthApril: "Abril",
		esriMonthMay: "Maio",
		esriMonthJune: "Junho",
		esriMonthJuly: "Julho",
		esriMonthAugust: "Agosto",
		esriMonthSeptember: "Setembro",
		esriMonthOctober: "Outubro",
		esriMonthNovember: "Novembro",
		esriMonthDecember: "Dezembro",
		dimensionalMovingIgnoreNoData: "Dados",
		dimensionalMovingPropagateNoData: "NoData",
		dimensionalMovingFillOnlyNoData: "Preenchimento de NoData",
		circularMean: "Média Circular",
		circularName: "Circular",
		arithmeticName: "Aritmético",
		slopeName: "Declividade",
		aspectName: "Aspecto",
		meanCurvature: "Curvatura média",
		profileCurvature: "Curvatura do perfil (linha de declividade normal)",
		tangentialCurvature: "Curvatura tangencial (curva de nível normal)",
		planCurvature: "Curvatura do plano (curva de nível projetada)",
		contourGeodesicTorsion: "Torção geodésica de curva de nível",
		gaussianCurvature: "Curvatura Gaussiana",
		casoratiCurvature: "Curvatura de Casorati",
		localSurfaceTypeQuadratic: "Quadrático",
		localSurfaceTypeBiquadratic: "Biquadrático",
		thresholdNoThreshold: "Sem Limite",
		thresholdPercentLeastCost: "Porcentagem de Menor Custo",
		thresholdAccumulativeCost: "Custo Acumulativo",
		clrmapTypeHillshade: "Relevo Sombreado"
	},
	categoryLabels: {
		sourceCharacteristics: "Características de Origem",
		neighborhoodSettings: "Configurações de Vizinhança",
		statistics: "Estatística",
		gamma: "Gama",
		viewshedParameters: "Parâmetros do Panorama",
		observerParameters: "Parâmetros do Observador",
		irregularDataInterpolation: "Interpolação de Dados Irregulares",
		modelStatistics: "Estatística do Modelo",
		aggregationDef: "Definição de Agregação",
		filterByAttributes: "Filtrar Por Atributos",
		percentileName: "Percentil",
		rasterInfo: "Informações do Raster",
		extent: "Extensão",
		spatialReference: "Referência Espacial"
	},
	outputRasterHelpTexts: {
		outputName: "<p>O nome da camada que será criada e adicionada ao mapa.</p>",
		resultType: "<p>O tipo de saída que será criado. As saídas podem ser camadas de imagens mosaicadas ou camadas de imagens dinâmicas.</p>",
		saveResultIn: "<p>O nome da pasta em <b>Meu conteúdo</b> onde o resultado será salvo.</p>"
	},
	analysisEnvironmentsHelpTexts: {
		description: "<p>Configurações do ambiente para análise no Map Viewer. </p>",
		outSR: "<p>Especifica o sistema de coordenadas para análise e a camada resultante.</p>",
		extent: "<p>Especifica a área a ser usada para análise.</p>",
		snapRaster: "<p>Ajusta a extensão da saída para que corresponda ao alinhamento da célula da camada raster de ajuste especificada.</p>",
		cellSize: "<p>Especifica o tamanho ou resolução da célula que será usada para análise e para criar a camada raster de saída.</p>",
		mask: "<p>Especifica uma camada de máscara, na qual apenas as células que se enquadram na área de máscara serão usadas para análise.</p>",
		resamplingMethod: "<p>Especifica como interpolar valores de pixel quando os rasters de entrada e saída não se alinham.</p>"
	},
	mainGenStrings: {
		unsupportedDataType: "Tipo não suportado",
		currentlyUnsupported: " Um editor padrão para o ${missingType} está pendente, mas será lançado em breve. Caixa de texto temporária do espaço reservado para especificar entradas baseadas em string.",
		unsupportedOverrideWarning: "Um componente do editor de substituição que fornece um UX melhor para trabalhar com os seguintes parâmetros, está pendente, mas será lançado em breve:",
		overrideWidgetMissing: "Componente do editor de substituição ausente!",
		uiIncomplete: "Falha ao enviar trabalho. A função não pode ser executada, pois alguns dos campos obrigatórios estão incompletos ou ausentes na interface do usuário.",
		count: "Contagem",
		selectVariables: "Selecionar variáveis",
		selectFeature: "Selecione uma camada de feição",
		greaterThanErrorMessage: "O número de entrada deve ser maior que ${min}",
		lesserThanErrorMessage: "O número de entrada deve ser menor que ${max}",
		greaterThanOrEqualErrorMessage: "O número de entrada deve ser maior ou igual a ${min}",
		lesserThanOrEqualErrorMessage: "O número de entrada deve ser menor ou igual a ${max}",
		allowScalar: "Selecione uma camada ou insira uma constante",
		selectField: "Selecionar campo",
		parameterRequired: "Este parâmetro é exigido.s",
		enterAValue: "Inserir um valor...",
		invalidInput: "O valor inserido não é válido.",
		itemNotFound: "O item não existe ou está inacessível.",
		itemPermissionDenied: "Você não tem permissões para acessar este item.",
		layerNotAvailable: "Falha ao carregar a camada ${layerName}.",
		multipleLayersNotAvailable: "Falha ao carregar camada ${layerName} e outros.",
		learnMoreLabel: "Obtenha Mais Informações",
		fieldNotAvailable: "Falha ao carregar o campo.",
		allowAnalysis: "A análise não é permitida no serviço de imagem.",
		allowAnalysisReason: "Uma ou mais camadas do mapa não estão listadas aqui porque não permitem análise.",
		learnMoreText: "Saiba mais",
		atLeastOneRasterInput: "Pelo menos uma camada de entrada deve ser uma camada raster.",
		browseAnalysisLayers: "Procurar camadas",
		activeMapViewExtent: "Usar Extensão do Mapa Atual",
		chooseRaster: "Escolha Recortando Raster",
		chooseGeometry: "Escolha Recortando Geometria",
		resultType: "Tipo de resultado",
		saveInFolder: "Salvar na pasta",
		outputName: "Nome de saída",
		outputLayerType: "Tipo da camada de saída",
		dynamicImageryLayer: "Camada de imagens dinâmica",
		tiledImageryLayer: "Camada de imagens do mosaico",
		custom: "Personalizada",
		loading: "Carregando...",
		layerMissing: "Uma ou mais camadas do mapa não estão listadas aqui porque não permitem análise. Saiba mais.",
		browseCoordinateSystems: "Procurar sistemas de coordenadas",
		unableToRepopulateOutSR: "Não é possível preencher o sistema de coordenadas de saída.",
		defaultTitle: "Veja mais",
		"ARC (equal arc-second)": "ARC (segundo arco igual)",
		Africa: "África",
		Antarctica: "Antártica",
		Argentina: "Argentina",
		Asia: "Ásia",
		"Asteroid Belt": "Cinturão de Asteróides",
		"Atlantic Ocean": "Oceano Atlântico",
		Australia: "Austrália",
		"Australia and New Zealand": "Austrália e Nova Zelândia",
		Austria: "Áustria",
		"BLM (US Feet)": "BLM (US Feet)",
		Bangladesh: "Bangladeche",
		"Beijing 1954": "Beijing 1954",
		Bhutan: "Butão",
		CGCS2000: "CGCS2000",
		Canada: "Canadá",
		Caribbean: "Caribe",
		"Caribbean Sea": "Mar do Caribe",
		"Central America": "América Central",
		"Central and North America": "América do Norte e Central",
		Colombia: "Colômbia",
		Continental: "Continental",
		"County Systems": "Sistemas do Município",
		"Democratic Republic of the Congo": "Congo",
		"EPSG Arctic": "EPSG Ártico",
		Earth: "Terra",
		"Ellipsoidal-based": "Baseado no elipsoidal",
		Europe: "Europa",
		Finland: "Finlândia",
		France: "França",
		"GSK 2011": "GSK 2011",
		"Gauss Kruger": "Gauss Kruger",
		"Geographic Coordinate Systems": "Sistema de Coordenadas Geográficas",
		Germany: "Alemanha",
		"Gravity-related": "Relacionado à gravidade",
		"Greenwich-based": "Baseado no Greenwich",
		"Highways England": "Rodovias Inglaterra",
		Illinois: "Illinois",
		"Indian Ocean": "Oceano Índico",
		"Indian Subcontinent": "Subcontinente Indiano",
		Indiana: "Indiana",
		Indonesia: "Indonésia",
		Iowa: "Iowa",
		"Ireland and United Kingdom": "Irlanda e Reino Unido",
		Italy: "Itália",
		Japan: "Japão",
		Jupiter: "Júpiter",
		Kansas: "Kansas",
		"Las Vegas": "Las Vegas",
		Libya: "Líbia",
		Malaysia: "Malásia",
		"Malaysia and Singapore": "Malásia e Cingapura",
		Mars: "Marte",
		Mercury: "Mercúrio",
		Minnesota: "Minnesota",
		Montana: "Montana",
		"NAD 1927": "NAD 1927",
		"NAD 1927 (US Feet)": "NAD 1927 (US Feet)",
		"NAD 1983": "NAD 1983",
		"NAD 1983 (2011)": "NAD 1983 (2011)",
		"NAD 1983 (2011) (Intl Feet)": "NAD 1983 (2011) (Intl Feet)",
		"NAD 1983 (2011) (Meters)": "NAD 1983 (2011) (Metros)",
		"NAD 1983 (2011) (US Feet)": "NAD 1983 (2011) (US Feet)",
		"NAD 1983 (CORS96) (Intl Feet)": "NAD 1983 (CORS96) (Intl Feet)",
		"NAD 1983 (CORS96) (Meters)": "NAD 1983 (CORS96) (Metros)",
		"NAD 1983 (CORS96) (US Feet)": "NAD 1983 (CORS96) (US Feet)",
		"NAD 1983 (Intl Feet)": "NAD 1983 (Intl Feet)",
		"NAD 1983 (Meters)": "NAD 1983 (Metros)",
		"NAD 1983 (PA11) (Meters)": "NAD 1983 (PA11) (Metros)",
		"NAD 1983 (PA11) (US Feet)": "NAD 1983 (PA11) (US Feet)",
		"NAD 1983 (US Feet)": "NAD 1983 (US Feet)",
		"NAD 1983 HARN (Intl Feet)": "NAD 1983 HARN (Intl Feet)",
		"NAD 1983 HARN (Meters)": "NAD 1983 HARN (Metros)",
		"NAD 1983 HARN (US Feet)": "NAD 1983 HARN (US Feet)",
		"NAD 1983 NSRS2007 (Intl Feet)": "NAD 1983 NSRS2007 (Intl Feet)",
		"NAD 1983 NSRS2007 (Meters)": "NAD 1983 NSRS2007 (Metros)",
		"NAD 1983 NSRS2007 (US Feet)": "NAD 1983 NSRS2007 (US Feet)",
		"National Grids": "Grades Nacionais",
		Navajo: "Navajo",
		Neptune: "Netuno",
		"New Beijing": "New Beijing",
		"New Zealand": "Nova Zelândia",
		"North America": "América do Norte",
		"Northern Hemisphere": "Hemisfério Norte",
		Norway: "Noruega",
		Oceans: "Oceanos",
		Oregon: "Oregon",
		"Other GCS": "Other GCS",
		"Pacific Ocean": "Oceano Pacífico",
		Pluto: "Plutão",
		Polar: "Polar",
		Portugal: "Portugal",
		"Projected Coordinate Systems": "Sistema de Coordenadas Planas",
		"Pulkovo 1942": "Pulkovo 1942",
		"Pulkovo 1995": "Pulkovo 1995",
		Replaced: "Substituído",
		"SAD 1969": "SAD 1969",
		SIRGAS: "SIRGAS",
		"SIRGAS 2000": "SIRGAS 2000",
		Saturn: "Saturno",
		"Solar System": "Sistema Solar",
		"South Africa": "África do Sul",
		"South America": "América do Sul",
		"South Korea": "Coréia do Sul",
		"Southern Hemisphere": "Hemisfério Sul",
		"Spheroid-based": "Baseado no esferóide",
		"State Plane": "State Plane",
		"State Systems": "Sistemas Estaduais",
		Sweden: "Suécia",
		"Switzerland and Liechtenstein": "Suíça e Liechtenstein",
		Texas: "Texas",
		Tribal: "Tribal",
		Turkey: "Turquia",
		"US Feet": "US Feet",
		"USA and territories": "Estados Unidos e territórios",
		UTM: "UTM",
		Ukraine: "Ucrânia",
		"Unknown Height Systems": "Sistemas de Altura Desconhecidos",
		Uranus: "Urano",
		Venus: "Vênus",
		"Vertical Coordinate Systems": "Sistemas de Coordenadas Verticais",
		Vietnam: "Vietnã",
		"WGS 1972": "WGS 1972",
		"WGS 1984": "WGS 1984",
		Wisconsin: "Wisconsin",
		"Wisconsin CRS": "Wisconsin CRS",
		World: "Mundial",
		"World (Sphere-based)": "Mundial (baseado no esferóide)",
		Wyoming: "Wyoming",
		"Xian 1980": "Xian 1980",
		done: "Concluir",
		noResults: "Nenhum resultado encontrado",
		searchPlaceholder: "Nome ou WKID",
		browseTemplate: "Procurar modelos de função raster",
		saveTemplate: "Salvar modelo de função raster",
		preview: "Visualizar",
		previewDescription: "Visualize o resultado antes de executar a análise.",
		showPreview: "Mostrar visualização",
		previewLayer: "Camada de visualização ${number}",
		newPreview: "Nova visualização",
		previewPopup: "Habilite a visualização dos resultados da análise com base nos parâmetros de entrada.",
		updatePreviewLayer: "Atualizar camada de visualização selecionada",
		createPreviewLayer: "Crie uma nova camada de visualização",
		maximumPreviewAllowed: "Número máximo permitido de camadas de visualização: ${maxCount}",
		previewFailure: "Esta camada de visualização não está disponível. Verifique os parâmetros de entrada e atualize esta camada de visualização novamente.",
		header: "Selecionar item",
		content: "Você tem alterações não salvas em ${rftTitle}. Se você recomeçar com um novo modelo, essas alterações serão perdidas.",
		dontSave: "Não salvar",
		"continue": "Continuar",
		stretch: "Ajustar na janela",
		pan: "Mover",
		newTemplate: "Criar novo modelo",
		openTemplate: "Abrir modelo",
		addFunction: "Adicionar funções raster",
		addConstant: "Adicionar constante",
		addRaster: "Adicionar variável raster",
		move: "Mover",
		zoom: "Zoom",
		saveAs: "Salvar Como",
		clear: "Limpar",
		addRasterFunctionTitle: "Adicionar funções raster",
		templatePropertiesTitle: "Propriedades do modelo",
		browseRFT: "Procurar modelos de função raster",
		defaultToolDescription: "Ferramenta de análise ${toolTitle}.",
		openToolText: "Abrir Ferramenta",
		toolDropdownText: "Menu Suspenso da Ferramenta",
		addToMap: "Confirme e adicione ao mapa",
		confirm: "Confirmar",
		select: "Selecionar",
		selectTask: "Selecionar tarefa",
		unsupportedLayer: "Este parâmetro não suporta as seguintes camadas: ${layerName}.",
		viewDetails: "Visualizar detalhes de item completo",
		rename: "Renomear",
		duplicate: "Duplicar",
		launch: "Abrir para executar",
		templateEditor: "Editor de modelos",
		createItem: "Salvar modelo de função raster",
		actionLabel: "Filtrar",
		filterPopoverHeading: "Filtrar as funções",
		defaultSearchPlaceholder: "Pesquisar por nome",
		settings: "Configurações",
		summary: "Resumo",
		definitionQuery: "Consulta de definição",
		matchVariables: "Variáveis ​​de correspondência",
		unionDimension: "Dimensão da união",
		nameEditorPlaceholder: "Inserir título",
		summaryEditorPlaceholder: "Insira uma breve descrição.",
		definitionQueryPlaceholder: "Inserir...",
		upload: "Carregar",
		chooseImage: "Clique para escolher um arquivo",
		update: "Atualizar",
		thumbnailErrors: {
			wrongImageType: "Tipo de imagem selecionado errado",
			notAvailable: "Miniatura não disponível",
			loadError: "Não foi possível carregar a imagem",
			chooseFile: "Clique para escolher arquivo"
		}
	}
};
const copy = "Copiar";
const save = "Salvar";
const title = "Título";
const folder = "Pasta";
const tags = "Tags";
const savingMessage = "Salvando item em";
const shareWith = "Compartilhar Com";
const share = "Compartilhar";
const setSharingLevel = "Configurar Nível de Compartilhamento";
const setGroupSharing = "Configurar Compartilhamento do Grupo";
const owner = "Proprietário";
const organization = "Organização";
const everyone = "Todos (público)";
const groups = "Grupos:";
const type = "Tipo";
const mosaic = "Mosaico";
const itemGroup = "Grupo de Item";
const item = "Item";
const definitionQuery = "Consulta de Definição";
const groupItemsBy = "Agrupar Itens Por";
const groupFieldName = "Nome de Campo do Grupo";
const tagFieldName = "Nome de Campo da Tag";
const noTitleTagErrorMsg = "Você deve fornecer um título para seu item e tags para permitir ao seu mapa ser encontrado por pesquisas.";
const noTitleErrorMsg = "Você deve fornecer um título para o item.";
const noTagErrorMsg = "Você deve fornecer pelo menos uma tag para ajudar os usuários a encontrar seu item por pesquisas.";
const error = "Erro";
const warning = "Aviso";
const success = "Bem Sucedido";
const details = "Detalhes:";
const tryAgain = "Tentar Novamente";
const toolModeler = {
	save: "Salvar",
	editProperties: "Editar Propriedades",
	saveAs: "Salvar Como",
	savingNotification: "Salvando as alterações no item...",
	savingTitle: "Salvando",
	saveFailedMessage: "Falha ao salvar alterações.",
	saveWithErrorsMessage: "As alterações foram salvas com os erros seguintes.",
	viewItemMessage: "Visualizar o item salvo",
	here: "aqui.",
	itemCreatedMessage: "Novo item foi criado.",
	clickToViewItemMessage: "Clique em OK para visualizar a página de detalhes do item; clique em Cancelar para continuar.",
	readingFailed: "Falha ao carregar modelo de função raster selecionado.",
	failedToLoadXML: "Falha ao carregar modelo de função raster selecionado no formato XML.",
	learnMore: "Saiba mais",
	overwriteTitle: "Confirmar substituição",
	overwriteMessage: "Você deseja substituir o item existente?",
	overwriteSuccessMessage: "O item foi atualizado."
};
const toolEditor = {
	run: "Executar",
	save: "Salvar",
	deleteSelected: "Excluir Itens Selecionados",
	addRaster: "Adicionar Raster",
	addScalar: "Adicionar Escalar",
	layout: "Layout Automático",
	errorTitle: "Erro",
	invalidToolMessage: "O modelo de função do raster não é válido.",
	out: "Fora",
	zoomIn: "Mais Zoom",
	zoomOut: "Menos Zoom",
	zoomToFit: "Ajustar na Janela",
	panOn: "Trocar para modo mover",
	panOff: "Desativar modo mover",
	defaultModelName: "Modelo de Ferramenta",
	defaultRasterName: "Raster"
};
const toolDetailsEditor = {
	defaultToolName: "Modelo de Função do Raster",
	defaultToolDescription: "Adicionar um breve resumo sobre a função do raster.",
	defaultHelpText: "Clique no ícone de ajuda para editar o texto de ajuda",
	editHelpTitle: "Editar Ajuda",
	saveLabel: "Salvar",
	cancelLabel: "Cancelar",
	thumbnail: {
		wrongImageType: "Tipo de imagem selecionado errado",
		notAvailable: "Miniatura não disponível",
		loadError: "Não foi possível carregar a imagem",
		chooseFile: "Clique para escolher arquivo"
	}
};
const saveUtils = {
	thumbnail: "Miniatura",
	sharing: "Compartilhamento"
};
const close = "Fechar";
const unsavedWarningExisting = "Gostaria de salvar as alterações no item <b>${itemTitle}</b> ?";
const unsavedWarningNew = "Gostaria de salvar as suas alterações?";
const saveAs = "Salvar Como";
const dontSave = "Não Salvar";
const unsavedTitle = "Alterações Não Salvas";
const invalidRFTMessage = "O modelo de função do raster criado não é válido.";
const errorTitle = "Erro";
const breadcrumb = "Editor de Função do Raster";
const breadcrumbEditor = "Conteúdo > Editor de Função do Raster";
const viewerModeTitle = "Somente Leitura";
const viewerModeMessage = "O item do modelo de função raster é somente leitura. As alterações não podem ser salvas.";
const userStartDirection = "Selecione uma função para iniciar a construção de um modelo de função do raster.";
const selectFunction = "Adicionar Função";
const deselectFunction = "Função Remover";
const dialogTitle = "Sistema";
const category = "Categorias";
const search = "Procurar Funções de Raster";
const categoryNames = {
	analysis: "Análise",
	appearance: "Aparência",
	classification: "Classificação",
	conversion: "Conversão",
	correction: "Correção",
	dataManagement: "Gerenciamento de Dados",
	distance: "Distância",
	distanceLegacy: "Distância (Validada)",
	hydrology: "Hidrologia",
	math: "Matemática",
	mathConditional: "Matemática: Condicional",
	mathLogical: "Matemática: Lógica",
	mathTrigonometric: "Matemática: Trigonométrico",
	reclass: "Reclassificar",
	statistical: "Estatística",
	surface: "Superfície"
};
const commonStrings_ptBR = {
	ok: ok,
	cancel: cancel,
	enterURL: enterURL,
	serviceURL: serviceURL,
	selectRaster: selectRaster,
	failedToLoadLayer: failedToLoadLayer,
	loadingLayer: loadingLayer,
	selectFeature: selectFeature,
	enterFURL: enterFURL,
	addRaster: addRaster,
	addScalar: addScalar,
	raster: raster,
	scalar: scalar,
	defaultModelName: defaultModelName,
	general: general,
	parameters: parameters,
	variables: variables,
	name: name,
	description: description,
	parameter: parameter,
	isPublic: isPublic,
	isDataset: isDataset,
	unknownPixelType: unknownPixelType,
	outputPixelType: outputPixelType,
	u8PixelType: u8PixelType,
	s8PixelType: s8PixelType,
	u16PixelType: u16PixelType,
	s16PixelType: s16PixelType,
	u32PixelType: u32PixelType,
	s32PixelType: s32PixelType,
	f32PixelType: f32PixelType,
	f64PixelType: f64PixelType,
	properties: properties,
	multidimensionalRules: multidimensionalRules,
	matchVariables: matchVariables,
	unionDimensions: unionDimensions,
	rasterFunctionEditor: rasterFunctionEditor,
	rfxLicenseInfo: rfxLicenseInfo,
	rasterFunctions: rasterFunctions,
	copy: copy,
	save: save,
	title: title,
	folder: folder,
	tags: tags,
	savingMessage: savingMessage,
	shareWith: shareWith,
	share: share,
	setSharingLevel: setSharingLevel,
	setGroupSharing: setGroupSharing,
	owner: owner,
	organization: organization,
	everyone: everyone,
	groups: groups,
	type: type,
	mosaic: mosaic,
	itemGroup: itemGroup,
	item: item,
	definitionQuery: definitionQuery,
	groupItemsBy: groupItemsBy,
	groupFieldName: groupFieldName,
	tagFieldName: tagFieldName,
	noTitleTagErrorMsg: noTitleTagErrorMsg,
	noTitleErrorMsg: noTitleErrorMsg,
	noTagErrorMsg: noTagErrorMsg,
	error: error,
	warning: warning,
	success: success,
	details: details,
	tryAgain: tryAgain,
	toolModeler: toolModeler,
	toolEditor: toolEditor,
	toolDetailsEditor: toolDetailsEditor,
	saveUtils: saveUtils,
	close: close,
	unsavedWarningExisting: unsavedWarningExisting,
	unsavedWarningNew: unsavedWarningNew,
	saveAs: saveAs,
	dontSave: dontSave,
	unsavedTitle: unsavedTitle,
	invalidRFTMessage: invalidRFTMessage,
	errorTitle: errorTitle,
	breadcrumb: breadcrumb,
	breadcrumbEditor: breadcrumbEditor,
	viewerModeTitle: viewerModeTitle,
	viewerModeMessage: viewerModeMessage,
	userStartDirection: userStartDirection,
	selectFunction: selectFunction,
	deselectFunction: deselectFunction,
	dialogTitle: dialogTitle,
	category: category,
	search: search,
	categoryNames: categoryNames
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (commonStrings_ptBR);


//# sourceMappingURL=common-strings.pt-BR-13a658bd.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLTk0ZjIyYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNFlBQTRZLCtJQUErSSxxRUFBcUU7QUFDaG1CO0FBQ0E7QUFDQSwwWkFBMFo7QUFDMVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFJQUFxSTtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa01BQWtNO0FBQ2xNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxra0JBQWtrQjtBQUNsa0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNQQUFzUDtBQUN0UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOHBDQUE4cEMsbVRBQW1UO0FBQ2o5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdWpHQUF1akcsT0FBTztBQUM5akc7QUFDQTtBQUNBLHl3Q0FBeXdDO0FBQ3p3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLElBQUk7QUFDekUsb0VBQW9FLElBQUk7QUFDeEUsbUZBQW1GLElBQUk7QUFDdkYsa0ZBQWtGLElBQUk7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsVUFBVTtBQUM3RCwwREFBMEQsV0FBVztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLFNBQVM7QUFDekY7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFVBQVU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsVUFBVTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGtCQUFrQixFQUFDO0FBQytuQzs7QUFFanFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3IvZGlzdC9lc20vY29tbW9uLXN0cmluZ3MucHQtQlItMTNhNjU4YmQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgb2sgPSBcIk9LXCI7XG5jb25zdCBjYW5jZWwgPSBcIkNhbmNlbGFyXCI7XG5jb25zdCBlbnRlclVSTCA9IFwiSW5zZXJpciBVUkwgZG8gU2VydmnDp28gZGUgSW1hZ2VtXCI7XG5jb25zdCBzZXJ2aWNlVVJMID0gXCJVUkwgZGUgU2VydmnDp29cIjtcbmNvbnN0IHNlbGVjdFJhc3RlciA9IFwiU2VsZWNpb25hciBSYXN0ZXJcIjtcbmNvbnN0IGZhaWxlZFRvTG9hZExheWVyID0gXCJGYWxoYSBhbyBjYXJyZWdhciBDYW1hZGFcIjtcbmNvbnN0IGxvYWRpbmdMYXllciA9IFwiQ2FycmVnYW5kbyBjYW1hZGFcIjtcbmNvbnN0IHNlbGVjdEZlYXR1cmUgPSBcIlNlbGVjaW9uYXIgQ2FtYWRhIGRlIEZlacOnw6NvXCI7XG5jb25zdCBlbnRlckZVUkwgPSBcIkluc2VyaXIgVVJMIGRlIFNlcnZpw6dvIGRhIEZlacOnw6NvXCI7XG5jb25zdCBhZGRSYXN0ZXIgPSBcIkFkaWNpb25hIFZhcmnDoXZlbCBkZSBSYXN0ZXJcIjtcbmNvbnN0IGFkZFNjYWxhciA9IFwiQWRpY2lvbmFyIENvbnN0YW50ZVwiO1xuY29uc3QgcmFzdGVyID0gXCJSYXN0ZXJcIjtcbmNvbnN0IHNjYWxhciA9IFwiRXNjYWxhclwiO1xuY29uc3QgZGVmYXVsdE1vZGVsTmFtZSA9IFwiTW9kZWxvIGRlIEZ1bsOnw6NvIGRvIFJhc3RlclwiO1xuY29uc3QgZ2VuZXJhbCA9IFwiR2VyYWxcIjtcbmNvbnN0IHBhcmFtZXRlcnMgPSBcIlBhcsOibWV0cm9zXCI7XG5jb25zdCB2YXJpYWJsZXMgPSBcIlZhcmnDoXZlaXNcIjtcbmNvbnN0IG5hbWUgPSBcIk5vbWVcIjtcbmNvbnN0IGRlc2NyaXB0aW9uID0gXCJEZXNjcmnDp8Ojb1wiO1xuY29uc3QgcGFyYW1ldGVyID0gXCJQYXLDom1ldHJvXCI7XG5jb25zdCBpc1B1YmxpYyA9IFwiw4kgUMO6YmxpY29cIjtcbmNvbnN0IGlzRGF0YXNldCA9IFwiSXNEYXRhc2V0XCI7XG5jb25zdCB1bmtub3duUGl4ZWxUeXBlID0gXCJEZXNjb25oZWNpZG9cIjtcbmNvbnN0IG91dHB1dFBpeGVsVHlwZSA9IFwiVGlwbyBkZSBQaXhlbCBkZSBTYcOtZGFcIjtcbmNvbnN0IHU4UGl4ZWxUeXBlID0gXCI4IEJpdCBJbmRlZmluaWRvXCI7XG5jb25zdCBzOFBpeGVsVHlwZSA9IFwiOCBCaXQgRGVmaW5pZG9cIjtcbmNvbnN0IHUxNlBpeGVsVHlwZSA9IFwiMTYgQml0IEluZGVmaW5pZG9cIjtcbmNvbnN0IHMxNlBpeGVsVHlwZSA9IFwiMTYgQml0IERlZmluaWRvXCI7XG5jb25zdCB1MzJQaXhlbFR5cGUgPSBcIjMyIEJpdCBOw6NvIEF0cmlidcOtZG9cIjtcbmNvbnN0IHMzMlBpeGVsVHlwZSA9IFwiMzIgQml0IEF0cmlidcOtZG9cIjtcbmNvbnN0IGYzMlBpeGVsVHlwZSA9IFwiMzIgQml0IEZsdXR1YW50ZVwiO1xuY29uc3QgZjY0UGl4ZWxUeXBlID0gXCI2NCBCaXQgRHVwbG9cIjtcbmNvbnN0IHByb3BlcnRpZXMgPSBcIlByb3ByaWVkYWRlc1wiO1xuY29uc3QgbXVsdGlkaW1lbnNpb25hbFJ1bGVzID0gXCJSZWdyYXMgTXVsdGlkaW1lbnNpb25haXNcIjtcbmNvbnN0IG1hdGNoVmFyaWFibGVzID0gXCJWYXJpw6F2ZWwgQ29ycmVzcG9uZGVudGVzXCI7XG5jb25zdCB1bmlvbkRpbWVuc2lvbnMgPSBcIlVuaXIgRGltZW5zw7Vlc1wiO1xuY29uc3QgcmFzdGVyRnVuY3Rpb25FZGl0b3IgPSB7XG5cdGludmFsaWRSRlRNZXNzYWdlOiBcIk8gTW9kZWxvIGRlIEZ1bsOnw6NvIGRvIFJhc3RlciBuw6NvIMOpIHbDoWxpZG8uXCIsXG5cdHJmeEFyZ3NFZGl0b3I6IHtcblx0XHRvdXRwdXRSYXN0ZXI6IFwiT3V0cHV0UmFzdGVyXCIsXG5cdFx0cmFzdGVyOiBcIlJhc3RlclwiLFxuXHRcdHVuc3VwcG9ydGVkRGF0YVR5cGVXYXJuaW5nOiBcIk9zIHNlZ3VpbnRlcyBwYXLDom1ldHJvcyBuw6NvIHPDo28gZXhpYmlkb3MsIHBvaXMgYXR1YWxtZW50ZSBuw6NvIHPDo28gc3Vwb3J0YWRvcy5cIixcblx0XHR1bnN1cHBvcnRlZEZ1bmN0aW9uOiBcIkNvbnTDqW0gZnVuw6fDtWVzIHJhc3RlciBhdHVhbG1lbnRlIG7Do28gc3Vwb3J0YWRhcy5cIlxuXHR9LFxuXHRyZnhSYXN0ZXJJbnB1dDoge1xuXHRcdHNlbGVjdExheWVyOiBcIlNlbGVjaW9uYXIgQ2FtYWRhXCIsXG5cdFx0YnJvd3NlTGF5ZXJzOiBcIlByb2N1cmFyIENhbWFkYXNcIixcblx0XHRyZnhWYXJpYWJsZTogXCJSYXN0ZXJGdW5jdGlvblZhcmlhYmxlXCJcblx0fSxcblx0cmZ4QmFuZENvbWJpbmF0aW9uRWRpdG9yOiB7XG5cdFx0bWV0aG9kTGFiZWw6IFwiTcOpdG9kb1wiLFxuXHRcdGJhbmRMYWJlbDogXCJCYW5kYVwiLFxuXHRcdGNvbWJpbmF0aW9uTGFiZWw6IFwiQ29tYmluYcOnw6NvXCJcblx0fSxcblx0cmZ4UmVtYXBHcmlkOiB7XG5cdFx0bWluaW11bTogXCJNw61uaW1vXCIsXG5cdFx0bWF4aW11bTogXCJNw6F4aW1vXCIsXG5cdFx0b3V0cHV0OiBcIlNhw61kYVwiLFxuXHRcdG5vRGF0YTogXCJOb0RhdGFcIixcblx0XHRyZW1hcFZhbHVlc0xhYmVsOiBcIlJlbWFwZWFyIFZhbG9yZXNcIlxuXHR9LFxuXHRyZnhOYW1lZFJhc3RlckVkaXRvcjoge1xuXHRcdHJhc3RlclZhcmlhYmxlczogXCJWYXJpw6F2ZWlzIGRvIFJhc3RlclwiLFxuXHRcdGRlbGV0ZVNlbGVjdGVkVmFyczogXCJSZW1vdmVyIHZhcmnDoXZlaXMgc2VsZWNpb25hZGFzXCJcblx0fSxcblx0cmZ4Q2xpcHBpbmdHZW9tZXRyeToge1xuXHRcdGNsaXBwaW5nTGF5ZXI6IFwiUmVjb3J0YW5kbyBDYW1hZGFcIixcblx0XHRjbGlwcGluZ1Jhc3RlcjogXCJSZWNvcnRhbmRvIFJhc3RlclwiLFxuXHRcdGNsaXBwaW5nR2VvbWV0cnk6IFwiUmVjb3J0YW5kbyBHZW9tZXRyaWFcIixcblx0XHRjdXN0b21FeHRlbnQ6IFwiUGVyc29uYWxpemFyIGV4dGVuc8Ojb1wiLFxuXHRcdG91dHB1dEV4dGVudDogXCJFeHRlbnPDo28gZGUgU2HDrWRhXCIsXG5cdFx0Y3VycmVudEV4dGVudDogXCJFeHRlbnPDo28gZG8gTWFwYSBBdHVhbFwiLFxuXHRcdGRyYXdMYWJlbDogXCJEZXNlbmhhclwiXG5cdH0sXG5cdHJmeEN1c3RvbUV4dGVudDoge1xuXHRcdHRvcDogXCJTdXBlcmlvclwiLFxuXHRcdHJpZ2h0OiBcIkRpcmVpdGFcIixcblx0XHRib3R0b206IFwiSW5mZXJpb3JcIixcblx0XHRsZWZ0OiBcIkVzcXVlcmRhXCJcblx0fSxcblx0cmZ4UmFzdGVyQXJyYXlFZGl0b3I6IHtcblx0XHRtb3ZlVXA6IFwiTW92ZXIgcGFyYSBDaW1hXCIsXG5cdFx0bW92ZURvd246IFwiTW92ZXIgcGFyYSBCYWl4b1wiLFxuXHRcdHJlbW92ZTogXCJSZW1vdmVyXCJcblx0fSxcblx0cmZ4U3RhdGlzdGljc0dyaWQ6IHtcblx0XHRzdGREZXY6IFwiRGVzdmlvIFBhZHLDo29cIixcblx0XHRtaW46IFwiTcOtblwiLFxuXHRcdG1heDogXCJNw6F4XCIsXG5cdFx0bWVhbjogXCJNw6lkaWFcIlxuXHR9LFxuXHRyZnhXZWlnaHRlZFN1bVRhYmxlRWRpdG9yOiB7XG5cdFx0d2VpZ2h0ZWRTdW1UYWJsZTogXCJUYWJlbGEgZGUgU29tYSBQb25kZXJhZGFcIixcblx0XHRpZDogXCJJRFwiLFxuXHRcdGxheWVyOiBcIkNhbWFkYVwiLFxuXHRcdGZpZWxkOiBcIkNhbXBvXCIsXG5cdFx0d2VpZ2h0OiBcIlBlc29cIixcblx0XHR2YWx1ZTogXCJWYWxvclwiLFxuXHRcdHNlbGVjdExheWVyOiBcIlNlbGVjaW9uYXIgQ2FtYWRhXCJcblx0fSxcblx0cmZ4V2VpZ2h0ZWRPdmVybGF5VGFibGVFZGl0b3I6IHtcblx0XHR3ZWlnaHRlZE92ZXJsYXlUYWJsZTogXCJUYWJlbGEgZGUgU29icmVwb3Npw6fDo28gUG9uZGVyYWRhXCIsXG5cdFx0aWQ6IFwiSURcIixcblx0XHRsYXllcjogXCJDYW1hZGFcIixcblx0XHRmaWVsZDogXCJDYW1wb1wiLFxuXHRcdGluZmx1ZW5jZTogXCJJbmZsdcOqbmNpYVwiLFxuXHRcdHN1bU9mSW5mbHVlbmNlOiBcIlNvbWEgZGUgSW5mbHXDqm5jaWFcIixcblx0XHR2YWx1ZTogXCJWYWxvclwiLFxuXHRcdHJlbWFwVGFibGU6IFwiVGFiZWxhIGRlIFJlbWFwZWFtZW50b1wiLFxuXHRcdHNjYWxlOiBcIkVzY2FsYVwiLFxuXHRcdHNjYWxlczogXCJFc2NhbGFzXCIsXG5cdFx0c2VsZWN0UmFzdGVyOiBcIlNlbGVjaW9uYXIgUmFzdGVyXCJcblx0fSxcblx0cmZ4RmVhdHVyZVNlbGVjdDoge1xuXHRcdGFkZEZlYXR1cmVMYXllcjogXCJQcm9jdXJhciBwb3IgdW1hIGNhbWFkYSBkZSBmZWnDp8Ojb1wiLFxuXHRcdGFkZFBvaW50TGF5ZXI6IFwiUHJvY3VyYXIgcG9yIHVtYSBjYW1hZGEgZGUgcG9udG9cIlxuXHR9LFxuXHRyZnhGaWVsZFNlbGVjdDoge1xuXHRcdHZhbHVlOiBcIlZhbG9yXCIsXG5cdFx0Y291bnQ6IFwiQ29udGFnZW1cIlxuXHR9LFxuXHRyZnhBdHRyaWJ1dGVUYWJsZToge1xuXHRcdHRhYmxlVHlwZTogXCJUaXBvIGRlIFRhYmVsYVwiLFxuXHRcdG1hbnVhbDogXCJNYW51YWxcIixcblx0XHRleHRlcm5hbDogXCJFeHRlcm5vXCIsXG5cdFx0bWluVmFsOiBcIlZhbG9yIE3DrW5pbW9cIixcblx0XHRtYXhWYWw6IFwiVmFsb3IgTcOheGltb1wiLFxuXHRcdGJhc2VDbGFzc05hbWU6IFwiTm9tZSBkZSBCYXNlIGRlIENsYXNzZVwiLFxuXHRcdGNvbG9yU2NoZW1lOiBcIkVzcXVlbWEgZGUgQ29yZXNcIixcblx0XHRkZWZhdWx0Q2xhc3NOYW1lOiBcIkxhYmVsX1wiLFxuXHRcdGdlbmVyYXRlVGFibGU6IFwiR2VyYXIgVGFiZWxhXCIsXG5cdFx0YnJvd3NlVGFibGU6IFwiUHJvY3VyYXIgVGFiZWxhXCIsXG5cdFx0dmFsdWU6IFwiVmFsb3JcIixcblx0XHRjbGFzc25hbWU6IFwiQ2xhc3NOYW1lXCIsXG5cdFx0Y29sb3I6IFwiQ29yXCJcblx0fSxcblx0cmZ4RmllbGROdW1iZXJTd2l0Y2hhYmxlOiB7XG5cdFx0bnVtYmVyOiBcIk51bcOpcmljb1wiLFxuXHRcdGZpZWxkOiBcIkNhbXBvXCIsXG5cdFx0c3RyaW5nOiBcIlRleHRvXCIsXG5cdFx0bGluZWFyVW5pdDogXCJVbmlkYWRlIExpbmVhclwiXG5cdH0sXG5cdHJmeFByb3BlcnR5U2V0OiB7XG5cdFx0bmFtZTogXCJOb21lXCIsXG5cdFx0dmFsdWU6IFwiVmFsb3JcIlxuXHR9LFxuXHRyZnhDb252ZXJzaW9uR3JpZDoge1xuXHRcdHNpemU6IFwiVGFtYW5ob1wiXG5cdH0sXG5cdHJmeFRyYW5zcG9zZUJpdDoge1xuXHRcdGJpdFBhdHRlcm46IFwiUGFkcsOjbyBCaXRcIixcblx0XHRvdXRwdXRCaXQ6IFwiQml0IGRlIFNhw61kYVwiLFxuXHRcdGlucHV0Qml0OiBcIkJpdCBkZSBFbnRyYWRhXCJcblx0fSxcblx0cmZ4U3BhdGlhbFJlZmVyZW5jZToge1xuXHRcdHBsYWNlSG9sZGVyOiBcIlJlZmluYXIgcG9yIFBhbGF2cmEtQ2hhdmVcIixcblx0XHRjb29yZGluYXRlU3lzdGVtOiBcIlNpc3RlbWEgZGUgQ29vcmRlbmFkYXNcIixcblx0XHRnY3M6IFwiU2lzdGVtYSBkZSBDb29yZGVuYWRhcyBHZW9ncsOhZmljYXNcIixcblx0XHRwY3M6IFwiU2lzdGVtYSBkZSBDb29yZGVuYWRhcyBQbGFuYXNcIixcblx0XHR2Y3M6IFwiU2lzdGVtYSBkZSBDb29yZGVuYWRhcyBWZXJ0aWNhaXNcIlxuXHR9XG59O1xuY29uc3QgcmZ4TGljZW5zZUluZm8gPSBcIkVzdGUgbW9kZWxvIGRlIGZ1bsOnw6NvIHJhc3RlciBwb2RlIHNlciB1dGlsaXphZG8gcGFyYSBwcm9jZXNzYXIgc3VhIGltYWdlbSB1dGlsaXphbmRvIG8gQXJjR0lTIEltYWdlIFNlcnZlci5cIjtcbmNvbnN0IHJhc3RlckZ1bmN0aW9ucyA9IHtcblx0cmZ4OiB7XG5cdFx0YUNvc0hOYW1lOiBcIkFDb3NIXCIsXG5cdFx0YUNvc0hTbmlwOiBcIkNhbGN1bGUgbyBjby1zZW5vIGhpcGVyYsOzbGljbyBpbnZlcnNvIGRlIGPDqWx1bGFzIGVtIHVtIHJhc3Rlci5cIixcblx0XHRhQ29zSERlc2M6IFwiQSBmdW7Dp8OjbyBjYWxjdWxhIG8gY28tc2VubyBoaXBlcmLDs2xpY28gaW52ZXJzbyBkb3MgcGl4ZWxzIGVtIHVtIHJhc3Rlci5cIixcblx0XHRhQ29zTmFtZTogXCJBQ29zXCIsXG5cdFx0YUNvc1NuaXA6IFwiQ2FsY3VsYSBvIGNvLXNlbm8gaW52ZXJzbyBkb3MgcGl4ZWxzIGVtIHVtIHJhc3Rlci5cIixcblx0XHRhQ29zRGVzYzogXCJFc3RhIGZ1bsOnw6NvIGRlIHJhc3RlciBjYWxjdWxhIG8gY28tc2VubyBpbnZlcnNvIGRhcyBjw6lsdWxhcyBlbSB1bSByYXN0ZXIuIEVtIG1hdGVtw6F0aWNhLCB0b2RhcyBhcyBmdW7Dp8O1ZXMgdHJpZ29ub23DqXRyaWNhcyB0w6ptIHVtYSBmYWl4YSBkZWZpbmlkYSBkZSB2YWxvcmVzIGRlIGVudHJhZGEgdsOhbGlkb3MsIGNoYW1hZGEgZGUgZG9tw61uaW8uIE9zIHZhbG9yZXMgZGUgc2HDrWRhIGRlIGNhZGEgZnVuw6fDo28gdGFtYsOpbSB0w6ptIHVtYSBmYWl4YSBkZWZpbmlkYS4gUGFyYSBlc3RhIGZlcnJhbWVudGEsIG8gZG9tw61uaW8gw6kgWy0xLCAxXSwgZSBvIGludGVydmFsbyDDqSBbMCwgcGldLlwiLFxuXHRcdGFTaW5ITmFtZTogXCJBU2VuSFwiLFxuXHRcdGFTaW5IU25pcDogXCJDYWxjdWxhIG8gc2VubyBoaXBlcmLDs2xpY28gaW52ZXJzbyBkZSBjw6lsdWxhcyBlbSB1bSByYXN0ZXIuXCIsXG5cdFx0YVNpbkhEZXNjOiBcIkEgZnVuw6fDo28gY2FsY3VsYSBvIHNlbm8gaGlwZXJiw7NsaWNvIGludmVyc28gZG9zIHBpeGVscyBlbSB1bSByYXN0ZXIuXCIsXG5cdFx0YVNpbk5hbWU6IFwiQVNlblwiLFxuXHRcdGFTaW5TbmlwOiBcIkNhbGN1bGEgbyBzZW5vIGludmVyc28gZGUgY8OpbHVsYXMgZW0gdW0gcmFzdGVyLlwiLFxuXHRcdGFTaW5EZXNjOiBcIkEgZnVuw6fDo28gY2FsY3VsYSBvIHNlbm8gaW52ZXJzbyBkb3MgcGl4ZWxzIGVtIHVtIHJhc3Rlci5cIixcblx0XHRhVGFuMk5hbWU6IFwiQVRhbjJcIixcblx0XHRhVGFuMlNuaXA6IFwiQ2FsY3VsYSBhIHRhbmdlbnRlIGludmVyc2EgKGJhc2VhZG8gZW0geCx5KSBkZSBjw6lsdWxhcyBlbSB1bSByYXN0ZXIuXCIsXG5cdFx0YVRhbjJEZXNjOiBcIkEgZnVuw6fDo28gY2FsY3VsYSBhIHRhbmdlbnRlIGludmVyc2EgKGJhc2VhZG8gZW0geCx5KSBkb3MgcGl4ZWxzIGVtIHVtIHJhc3Rlci5cIixcblx0XHRhVGFuSE5hbWU6IFwiQVRhbkhcIixcblx0XHRhVGFuSFNuaXA6IFwiQ2FsY3VsYSBhIHRhbmdlbnRlIGhpcGVyYsOzbGljYSBpbnZlcnNhIGRlIGPDqWx1bGFzIGVtIHVtIHJhc3Rlci5cIixcblx0XHRhVGFuSERlc2M6IFwiQSBmdW7Dp8OjbyBjYWxjdWxhIGEgdGFuZ2VudGUgaGlwZXJiw7NsaWNhIGludmVyc2EgZG9zIHBpeGVscyBlbSB1bSByYXN0ZXIuXCIsXG5cdFx0YVRhbk5hbWU6IFwiQVRhblwiLFxuXHRcdGFUYW5TbmlwOiBcIkNhbGN1bGEgYSB0YW5nZW50ZSBpbnZlcnNhIGRlIGPDqWx1bGFzIGVtIHVtIHJhc3Rlci5cIixcblx0XHRhVGFuRGVzYzogXCJBIGZ1bsOnw6NvIGNhbGN1bGEgYSB0YW5nZW50ZSBpbnZlcnNhIGRvcyBwaXhlbHMgZW0gdW0gcmFzdGVyLlwiLFxuXHRcdGFic05hbWU6IFwiQWJzXCIsXG5cdFx0YWJzU25pcDogXCJDYWxjdWxlIG8gdmFsb3IgYWJzb2x1dG8gZGFzIGPDqWx1bGFzIGVtIHVtIHJhc3Rlci5cIixcblx0XHRhYnNEZXNjOiBcIkEgZnVuw6fDo28gQWJzIGNhbGN1bGEgbyB2YWxvciBhYnNvbHV0byBkb3MgcGl4ZWxzIGVtIHVtIHJhc3Rlci5cIixcblx0XHRyZWZsZWN0YW5jZU5hbWU6IFwiUmVmbGVjdMOibmNpYSBBcGFyZW50ZVwiLFxuXHRcdHJlZmxlY3RhbmNlU25pcDogXCJDb252ZXJ0ZSBpbWFnZW0gYnJ1dGEgZW0gdmFsb3JlcyBkbyBUb3BvIGRhIEF0bW9zZmVyYSBsZXZhbmRvIGVtIGNvbnRhIGFzIGNhcmFjdGVyw61zdGljYXMgZG8gc2Vuc29yLCBhIHBvc2nDp8OjbyBkbyBzb2wgZSBvIHRlbXBvIGRlIGFxdWlzacOnw6NvLlwiLFxuXHRcdHJlZmxlY3RhbmNlRGVzYzogXCJFc3RhIGZ1bsOnw6NvIGRlIHJhc3RlciBxdWUgYWp1c3RhIG9zIHZhbG9yZXMgZG8gbsO6bWVybyBkaWdpdGFsIGRlIGJyaWxobyBkYSBpbWFnZW0gKEROKSBwYXJhIGFsZ3VucyBzZW5zb3JlcyBkZSBzYXTDqWxpdGUuIE9zIGFqdXN0ZXMgc8OjbyBiYXNlYWRvcyBuYSBlbGV2YcOnw6NvIGRvIFNvbCwgbmEgZGF0YSBkZSBhcXVpc2nDp8OjbyBlIG5hcyBwcm9wcmllZGFkZXMgZG8gc2Vuc29yIHBhcmEgZGVmaW5pciBvIGdhbmhvIGUgYSBwb2xhcml6YcOnw6NvIHBhcmEgY2FkYSBiYW5kYS4gRXN0YSBmdW7Dp8OjbyDDqSB1dGlsaXphZGEgcGFyYSBhanVzdGFyIG9zIHZhbG9yZXMgZGUgcmVmbGVjdMOibmNpYSBvdSBicmlsaG8gZGUgYWxndW1hcyBpbWFnZW5zIGRlIHNhdMOpbGl0ZSBjb20gYmFzZSBuYSBpbHVtaW5hw6fDo28gZGEgY2VuYSBlIG5hcyBjb25maWd1cmHDp8O1ZXMgZGUgZ2FuaG8gZG8gc2Vuc29yLiBBcyBpbWFnZW5zIHPDo28gYWp1c3RhZGFzIHBhcmEgdW1hIGNvbmRpw6fDo28gZGUgaWx1bWluYcOnw6NvIHRlb3JpY2FtZW50ZSBjb211bSwgcG9ydGFudG8sIGRldmUgaGF2ZXIgbWVub3IgdmFyaWHDp8OjbyBlbnRyZSBjZW5hcyBkZSBkaWZlcmVudGVzIGRhdGFzIGUgZGlmZXJlbnRlcyBzZW5zb3Jlcy4gSXN0byBwb2RlIHNlciDDunRpbCBwYXJhIGNsYXNzaWZpY2HDp8OjbyBkZSBpbWFnZW0sIGJhbGFuY2VhbWVudG8gZGUgY29yZXMgZSBtb3NhaWNvLiBFc3RhIGZ1bsOnw6NvIHBvZGUgc2VyIHV0aWxpemFkYSBzb21lbnRlIGNvbSBpbWFnZW5zIGVzcGVjw61maWNhcy4gT3Mgc2Vuc29yZXMgYXBsaWPDoXZlaXMgc8OjbyBMYW5kc2F0IE1TUywgTGFuZHNhdCBUTSwgTGFuZHNhdCBFVE0rLCBMYW5kc2F0IDgsIElLT05PUywgUXVpY2tCaXJkLCBHZW9FeWUtMSwgUmFwaWRFeWUsIERNQ2lpLCBXb3JsZFZpZXctMSwgV29ybGRWaWV3LTIsIFNQT1QgNiBlIFBsZWlhZGVzLjxkaXY+PGJyLz5BIGZ1bsOnw6NvIGV4ZWN1dGEgZHVhcyBjb3JyZcOnw7Vlcy4gTyBwcmltZWlybyDDqSBiYXNlYWRvIG5hcyBjb25maWd1cmHDp8O1ZXMgZGUgZ2FuaG8uIE9zIHZhbG9yZXMgZGUgYnJpbGhvIG9yaWdpbmFpcyBzw6NvIHJlY3JpYWRvcyBhIHBhcnRpciBkb3MgdmFsb3JlcyBkYSBpbWFnZW0gYW8gcmV2ZXJ0ZXIgYXMgZXF1YcOnw7VlcyBkZSBnYW5oby4gQSBzZWd1bmRhIGNvcnJlw6fDo28gdGVtIGEgdmVyIGNvbSBhcyBkaWZlcmVuw6dhcyBkZSDDom5ndWxvIGUgYnJpbGhvIGRvIFNvbC4gT3MgdmFsb3JlcyBkZSBicmlsaG8gb3JpZ2luYWlzIHPDo28gYWp1c3RhZG9zIHBhcmEgdW1hIGNvbmRpw6fDo28gZGUgaWx1bWluYcOnw6NvIGNvbXVtIG5vcm1hbGl6YW5kbyBjZW5hcyBjYXB0dXJhZGFzIGVtIGNvbmRpw6fDtWVzIGRlIGlsdW1pbmHDp8OjbyB2YXJpw6F2ZWwuIEVtIGdlcmFsLCBlbnF1YW50byBvIHRpcG8gZGUgZGFkb3MgZGEgaW1hZ2VtIGRlIHNhw61kYSBmb3IgbyBtZXNtbyBxdWUgbyB0aXBvIGRlIGRhZG9zIGRhIGltYWdlbSBkZSBlbnRyYWRhLCBvcyB2YWxvcmVzIGRlIHNhw61kYSBzZXLDo28gaW5mZXJpb3JlcyBhb3MgdmFsb3JlcyBkZSBlbnRyYWRhIGUgc2Vyw6NvIGNvcnRhZG9zIG5vIGludGVydmFsbyBkZSBkYWRvcyB2w6FsaWRvLjwvZGl2PlwiLFxuXHRcdGFyZ1N0YXRpc3RpY3NOYW1lOiBcIkFyZ1N0YXRpc3RpY3NcIixcblx0XHRhcmdTdGF0aXN0aWNzU25pcDogXCJDYWxjdWxhIGEgZXN0YXTDrXN0aWNhIGRlIGNlbsOhcmlvIGluY2x1aW5kbyBBcmcgTcOheCwgQXJnIE3DrW4sIEFyZyBNw6lkaWEgZSBEdXJhw6fDo28uXCIsXG5cdFx0YXJnU3RhdGlzdGljc0Rlc2M6IFwiQSBmdW7Dp8OjbyBjb21wdXRhIGVzdGF0w61zdGljYSBkZSBhcmd1bWVudG8uIEjDoSBxdWF0cm8gbcOpdG9kb3MgbmEgZnVuw6fDo28gQXJnU3RhdGlzdGljczogQXJnTWF4LCBBcmdNaW4sIEFyZ01lZGlhbiBlIER1cmF0aW9uLlwiLFxuXHRcdGFyaXRobWV0aWNOYW1lOiBcIkFyaXRtw6l0aWNvXCIsXG5cdFx0YXJpdGhtZXRpY1NuaXA6IFwiRXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBhcml0bcOpdGljYSBlbnRyZSBkb2lzIHJhc3RlcnMgb3UgdW0gcmFzdGVyIGUgdW0gZXNjYWxhci5cIixcblx0XHRhcml0aG1ldGljRGVzYzogXCJBIGZ1bsOnw6NvIEFyaXRtw6l0aWNhIGV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gYXJpdG3DqXRpY2EgZW50cmUgZG9pcyByYXN0ZXJzIG91IHVtIHJhc3RlciBlIHVtIGVzY2FsYXIsIGUgdmljZSB2ZXJzYS5cIixcblx0XHRhc3BlY3RTbG9wZU5hbWU6IFwiQXNwZWN0by1EZWNsaXZpZGFkZVwiLFxuXHRcdGFzcGVjdFNsb3BlU25pcDogXCJDcmlhIHVtIHJhc3RlciBxdWUgZXhpYmUgc2ltdWx0YW5lYW1lbnRlIG8gYXNwZWN0byAoZGlyZcOnw6NvKSBlIGEgZGVjbGl2aWRhZGUgKGluY2xpbmHDp8OjbykgZGUgdW1hIHN1cGVyZsOtY2llIGNvbnTDrW51YSwgY29uZm9ybWUgcmVwcmVzZW50YWRvIGVtIHVtIG1vZGVsbyBkZSBlbGV2YcOnw6NvIGRpZ2l0YWwuXCIsXG5cdFx0YXNwZWN0U2xvcGVEZXNjOiBcIkEgZnVuw6fDo28gQXNwZWN0byBkZSBEZWNsaXZpZGFkZSBjcmlhIHVtYSBjYW1hZGEgcmFzdGVyIHF1ZSBleGliZSBzaW11bHRhbmVhbWVudGUgbyBhc3BlY3RvIGUgZGVjbGl2ZSBkZSB1bWEgc3VwZXJmw61jaWUuIE8gYXNwZWN0byBpZGVudGlmaWNhIGEgZGlyZcOnw6NvIGRlIGRlY2xpdmlkYWRlIGRhIHRheGEgbcOheGltYSBkZSBhbHRlcmHDp8OjbyBubyB2YWxvciBkZSBjYWRhIHBpeGVsIHBhcmEgc2V1cyB2aXppbmhvcy4gTyBhc3BlY3RvIHBvZGUgc2VyIHZpc3RvIGNvbW8gYSBkaXJlw6fDo28gZGUgZGVjbGl2aWRhZGUuIE9zIHZhbG9yZXMgZG8gcmFzdGVyIGRlIHNhw61kYSBzZXLDo28gYSBkaXJlw6fDo28gZGUgYsO6c3NvbGEgZG8gYXNwZWN0bywgcmVwcmVzZW50YWRvcyBwb3IgdW1hIHRvbmFsaWRhZGUgKGNvcikuIEEgZGVjbGl2aWRhZGUgcmVwcmVzZW50YSBhIHRheGEgZGUgYWx0ZXJhw6fDo28gZGUgZWxldmHDp8OjbyBkZSBjYWRhIHBpeGVsIGRvIG1vZGVsbyBkZSBlbGV2YcOnw6NvIGRpZ2l0YWwgKERFTSkuIEEgZGVjbGl2aWRhZGUgcmVwcmVzZW50YSBhIHBhcnRlIMOtbmdyZW1lIGRhIHN1cGVyZsOtY2llIGUgw6kgc2ltYm9saXphZGEgZW0gdHLDqnMgY2xhc3NlcyBxdWUgc8OjbyBtb3N0cmFkYXMgdXRpbGl6YW5kbyBzYXR1cmHDp8OjbyBkZSBjb3IgKGJyaWxobykuPGRpdj48YnIvPk9zIHZhbG9yZXMgZGUgcGl4ZWwgbm8gcmFzdGVyIGRlIGRlY2xpdmlkYWRlLWFzcGVjdG8gZGUgc2HDrWRhIHJlZmxldGVtIHVtYSBjb21iaW5hw6fDo28gZGUgYXNwZWN0byBlIGRlY2xpdmlkYWRlLiBQaXhlbHMgY29tIHZhbG9yZXMgYWJhaXhvIGRlIDIwIHPDo28gY29uc2lkZXJhZG9zIHBsYW5vcyBlIHPDo28gbW9zdHJhZG9zIGVtIGNpbnphcy4gT3MgdmFsb3JlcyBkZSBkZWNsaXZpZGFkZS1hc3BlY3RvIGRlIDIxIGUgYWNpbWEgZGUgc2Vyw6NvIGV4aWJpZG9zIGNvbSBzYXR1cmHDp8O1ZXMgdmFyaWFkYXMgY29tbyBzZWd1ZW06IDIxIGEgMzAg4oCUU2F0dXJhw6fDo28gZGUgZGVjbGl2aWRhZGUgYmFpeGEsIDMxIHBhcmEgNDDigJRTYXR1cmHDp8OjbyBkZSBkZWNsaXZpZGFkZSBtb2RlcmFkYSwgNDEgZSBhY2ltYeKAlFNhdHVyYcOnw6NvIGRlIGRlY2xpdmlkYWRlIGFsdGE8L2Rpdj5cIixcblx0XHRhc3BlY3ROYW1lOiBcIkFzcGVjdG9cIixcblx0XHRhc3BlY3RTbmlwOiBcIk1vc3RyYSBxdWFsIMOpIGEgZGlyZcOnw6NvIGRlIHVtIHBpeGVsLCBvbmRlIDAgw6kgZGV2aWRvIGFvIG5vcnRlIGUgYW8gw6JuZ3VsbyBhdW1lbnRhbmRvIG5vIHNlbnRpZG8gaG9yw6FyaW8gcGFyYSAzNjAuXCIsXG5cdFx0YXNwZWN0RGVzYzogXCJBIGZ1bsOnw6NvIEFzcGVjdG8gaWRlbnRpZmljYSBhIGRpcmXDp8OjbyBkZSBkZWNsaXZpZGFkZSBkYSB0YXhhIG3DoXhpbWEgZGUgYWx0ZXJhw6fDo28gbm8gdmFsb3IgZGUgY2FkYSBjw6lsdWxhIHBhcmEgc2V1cyB2aXppbmhvcy4gTyBhc3BlY3RvIHBvZGUgc2VyIHZpc3RvIGNvbW8gYSBkaXJlw6fDo28gZGUgZGVjbGl2aWRhZGUuIE9zIHZhbG9yZXMgZG8gcmFzdGVyIGRlIHNhw61kYSBzZXLDo28gYSBkaXJlw6fDo28gZGUgYsO6c3NvbGEgZG8gYXNwZWN0by48ZGl2Pjxici8+QSBlbnRyYWRhIGRlc3RhIGZ1bsOnw6NvIMOpIFJhc3RlciBkZSBFbnRyYWRhLiBBIGZ1bsOnw6NvIEFzcGVjdG8gw6kgbm9ybWFsbWVudGUgYXBsaWNhZGEgYSB1bSBtb2RlbG8gZGlnaXRhbCBkZSBlbGV2YcOnw6NvIChERU0pLiBQb3IgcGFkcsOjbywgbyBhc3BlY3RvIGFwYXJlY2UgY29tbyB1bWEgaW1hZ2VtIGVtIGVzY2FsYSBkZSBjaW56YS4gVm9jw6ogcG9kZSBhZGljaW9uYXIgYSBmdW7Dp8OjbyBNYXBhIGRlIENvcmVzIHBhcmEgZXNwZWNpZmljYXIgdW0gZXNxdWVtYSBkZSBjb3JlcyBlbSBwYXJ0aWN1bGFyIG91IHBlcm1pdGlyIHF1ZSBhIHBlc3NvYSBxdWUgdmlzdWFsaXphIG8gbW9zYWljbyBtb2RpZmlxdWUgYSBzaW1ib2xvZ2lhIGNvbSBzZXUgcHLDs3ByaW8gZXNxdWVtYSBkZSBjb3Jlcy48L2Rpdj5cIixcblx0XHR0YWJsZU5hbWU6IFwiVGFiZWxhIGRlIEF0cmlidXRvc1wiLFxuXHRcdHRhYmxlU25pcDogXCJVdGlsaXplIHVtYSB0YWJlbGEgcGFyYSBub21lYXIgZSBzaW1ib2xpemFyIG9zIHZhbG9yZXMgZW0gdW0gY29uanVudG8gZGUgZGFkb3MuIEFzIGNvbHVuYXMgZGEgdGFiZWxhIHPDo28gZGVsaW1pdGFkYXMgcG9yIHbDrXJndWxhOiBQaXhlbFZhbHVlLCBBdHRyaWJ1dGVOYW1lLCBSZWRWYWx1ZSwgR3JlZW5WYWx1ZSwgQmx1ZVZhbHUuXCIsXG5cdFx0dGFibGVEZXNjOiBcIkEgZnVuw6fDo28gVGFiZWxhIGRlIEF0cmlidXRvIHBlcm1pdGUgYSB2b2PDqiBkZWZpbmlyIHVtYSB0YWJlbGEgZGUgYXRyaWJ1dG9zIHBhcmEgc2ltYm9saXphciB1bSBjb25qdW50byBkZSBkYWRvcyBkZSBtb3NhaWNvIGRlIMO6bmljYSBiYW5kYSBvdSBjb25qdW50byBkZSBkYWRvcyByYXN0ZXIuIDxkaXY+PGJyLz5Jc3RvIMOpIMO6dGlsIHF1YW5kbyBkZXNlamFyIGFwcmVzZW50YXIgYSBpbWFnZW0gcXVlIHNvZnJldSB1bWEgY2xhc3NpZmljYcOnw6NvIHBhcmEgdXNvIGRvIHNvbG8sIHRhaXMgY29tbywgdGVycmEgZGUgZmxvcmVzdGEsIHpvbmFzIMO6bWlkYXMsIMOhcmVhIGRlIGNvbGhlaXRhIGUgdXJiYW5hLiBBZGljaW9uYWxtZW50ZSwgc2Ugc3VhIHRhYmVsYSBjb250aXZlciBjYW1wb3Mgbm9tZWFkb3MgdmVybWVsaG8sIHZlcmRlIGUgYXp1bCwgb3MgdmFsb3JlcyBkZW50cm8gZGVzdGVzIGNhbXBvcyBzZXLDo28gdXRpbGl6YWRvcyBjb21vIHVtIG1hcGEgZGUgY29yZXMgYW8gcmVuZGVyaXphciBhIGltYWdlbS48L2Rpdj5cIixcblx0XHRiYW5kQXJpdGhtZXRpY05hbWU6IFwiQXJpdG3DqXRpY2EgZGUgQmFuZGFzXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNTbmlwOiBcIkNhbGN1bGEgw61uZGljZXMgdXRpbGl6YW5kbyBmw7NybXVsYXMgcHLDqSBkZWZpbmlkYXMgb3UgdW1hIGV4cHJlc3PDo28gZGVmaW5pZGEgcGVsbyB1c3XDoXJpby5cIixcblx0XHRiYW5kQXJpdGhtZXRpY0Rlc2M6IFwiQSBmdW7Dp8OjbyBBcml0bcOpdGljYSBkYSBCYW5kYSBleGVjdXRhIHVtYSBvcGVyYcOnw6NvIGFyaXRtw6l0aWNhIG5hcyBiYW5kYXMgZGUgdW0gY29uanVudG8gZGUgZGFkb3MgcmFzdGVyLiBWb2PDqiBwb2RlIGVzY29saGVyIGFsZ29yaXRtb3MgcHLDqS1kZWZpbmlkb3Mgb3UgaW5zZXJpciBzdWEgcHLDs3ByaWEgZsOzcm11bGEgZGUgbGluaGEgw7puaWNhLiBPcyBvcGVyYWRvcmVzIHN1cG9ydGFkb3Mgc8OjbyAtLCssLywqLCBlIHVuw6FyaW8gLS5cIixcblx0XHR0aHJlc2hvbGROYW1lOiBcIkxpbWl0ZSBCaW7DoXJpb1wiLFxuXHRcdHRocmVzaG9sZFNuaXA6IFwiT3JnYW5pemEgZGFkb3MgY29udMOtbnVvcyBubyBwcmltZWlybyBwbGFubyBlIHNlZ3VuZG8gcGxhbm8gbWluaW1pemFuZG8gYSBjb3ZhcmnDom5jaWEgZW50cmUgYXMgZHVhcyBjbGFzc2VzLlwiLFxuXHRcdHRocmVzaG9sZERlc2M6IFwiUXVhbmRvIHVtIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3RlciB0aXZlciB1bWEgZGlzdHJpYnVpw6fDo28gYmltb2RhbCwgZXN0YSBmdW7Dp8OjbyBjcmlhIHVtIG5vdm8gcmFzdGVyIHF1ZSBkaXZpZGUgb3MgZGFkb3MgZW0gZHVhcyBjbGFzc2VzIGRpc3RpbnRhcy4gRWxlIGNyaWEgdW1hIGNsYXNzZSBkZSB2YWxvciBiYWl4byBleGliaWRvIGNvbSBwaXhlbHMgcHJldG9zIGUgdW1hIGNsYXNzZSBkZSB2YWxvciBhbHRvIGV4aWJpZGEgY29tIHBpeGVscyBicmFuY29zLlwiLFxuXHRcdGJpdHdpc2VBbmROYW1lOiBcIkUgQml0d2lzZVwiLFxuXHRcdGJpdHdpc2VBbmRTbmlwOiBcIkV4ZWN1dGEgYSBvcGVyYcOnw6NvIEJpdHdpc2UgRSBlbSB2YWxvcmVzIGJpbsOhcmlvcyBkZSBkb2lzIHJhc3RlcnMgZGUgZW50cmFkYS5cIixcblx0XHRiaXR3aXNlQW5kRGVzYzogXCJCaXR3aXNlIEUgZXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBCaXR3aXNlIEUgZW0gdmFsb3JlcyBiaW7DoXJpb3MgZGUgZG9pcyByYXN0ZXJzIGRlIGVudHJhZGEuXCIsXG5cdFx0Yml0d2lzZUxlZnRTaGlmdE5hbWU6IFwiTXVkYW7Dp2Egw6AgRXNxdWVyZGEgZGUgQml0d2lzZVwiLFxuXHRcdGJpdHdpc2VMZWZ0U2hpZnRTbmlwOiBcIkV4ZWN1dGEgYSBvcGVyYcOnw6NvIE11ZGFuw6dhIMOgIEVzcXVlcmRhIGRlIEJpdHdpc2UgZW0gdmFsb3JlcyBiaW7DoXJpb3MgZGUgZG9pcyByYXN0ZXJzIGRlIGVudHJhZGEuXCIsXG5cdFx0Yml0d2lzZUxlZnRTaGlmdERlc2M6IFwiQSBmZXJyYW1lbnRhIE11ZGFuw6dhIMOgIEVzcXVlcmRhIGRlIEJpdHdpc2UgZXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBNdWRhbsOnYSDDoCBFc3F1ZXJkYSBkZSBCaXR3aXNlIG5vcyB2YWxvcmVzIGJpbsOhcmlvcyBkZSBkb2lzIGRhZG9zIHJhc3RlcnMgZGUgZW50cmFkYS5cIixcblx0XHRiaXR3aXNlTm90TmFtZTogXCJOw6NvIEJpdHdpc2VcIixcblx0XHRiaXR3aXNlTm90U25pcDogXCJFeGVjdXRhIHVtYSBvcGVyYcOnw6NvIEJpdHdpc2UgTsOjbyAoY29tcGxlbWVudG8pIG5vcyB2YWxvcmVzIGJpbsOhcmlvcyBkZSBkb2lzIHJhc3RlcnMgZGUgZW50cmFkYS5cIixcblx0XHRiaXR3aXNlTm90RGVzYzogXCJBIGZ1bsOnw6NvIGV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gQml0d2lzZSBOw6NvIChjb21wbGVtZW50bykgbm8gdmFsb3IgYmluw6FyaW8gZGUgdW0gcmFzdGVyIGRlIGVudHJhZGEuXCIsXG5cdFx0Yml0d2lzZU9yTmFtZTogXCJPdSBCaXR3aXNlXCIsXG5cdFx0Yml0d2lzZU9yU25pcDogXCJFeGVjdXRhIHVtYSBvcGVyYcOnw6NvIEJpdHdpc2UgT3UgZW0gdmFsb3JlcyBiaW7DoXJpb3MgZGUgZG9pcyByYXN0ZXJzIGRlIGVudHJhZGEuXCIsXG5cdFx0Yml0d2lzZU9yRGVzYzogXCJBIGZ1bsOnw6NvIGV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gQml0d2lzZSBPdSBlbSB2YWxvcmVzIGJpbsOhcmlvcyBkZSBkb2lzIHJhc3RlcnMgZGUgZW50cmFkYS4gXCIsXG5cdFx0Yml0d2lzZVJpZ2h0U2hpZnROYW1lOiBcIkRlc2xvY2FyIMOgIERpcmVpdGEgZG8gQml0d2lzZVwiLFxuXHRcdGJpdHdpc2VSaWdodFNoaWZ0U25pcDogXCJFeGVjdXRhIGEgb3BlcmHDp8OjbyBEZXNsb2NhciDDoCBEaXJlaXRhIGRvIEJpdHdpc2UgZW0gdmFsb3JlcyBiaW7DoXJpb3MgZGUgZG9pcyByYXN0ZXJzIGRlIGVudHJhZGEuXCIsXG5cdFx0Yml0d2lzZVJpZ2h0U2hpZnREZXNjOiBcIkEgZnVuw6fDo28gZXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBEZXNsb2NhciDDoCBEaXJlaXRhIGRvIEJpdHdpc2UgZW0gdmFsb3JlcyBiaW7DoXJpb3MgZGUgZG9pcyByYXN0ZXJzIGRlIGVudHJhZGEuXCIsXG5cdFx0Yml0d2lzZVhvck5hbWU6IFwiWE91IEJpdHdpc2VcIixcblx0XHRiaXR3aXNlWG9yU25pcDogXCJFeGVjdXRhIGEgb3BlcmHDp8OjbyBPdSBCaXR3aXNlIGVYY2x1c2l2byBlbSB2YWxvcmVzIGJpbsOhcmlvcyBkZSBkb2lzIHJhc3RlcnMgZGUgZW50cmFkYS5cIixcblx0XHRiaXR3aXNlWG9yRGVzYzogXCJBIGZ1bsOnw6NvIGV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gQml0d2lzZSBlWGNsdXNpdm8gZW0gdmFsb3JlcyBiaW7DoXJpb3MgZGUgZG9pcyByYXN0ZXJzIGRlIGVudHJhZGEuXCIsXG5cdFx0Ym9vbGVhbkFuZE5hbWU6IFwiRSBCb29sZWFub1wiLFxuXHRcdGJvb2xlYW5BbmRTbmlwOiBcIkV4ZWN1dGEgYSBvcGVyYcOnw6NvIEUgQm9vbGVhbm8gZW0gdmFsb3JlcyBkYSBjw6lsdWxhIGRlIGRvaXMgcmFzdGVycyBkZSBlbnRyYWRhLiBTZSBhbWJvcyBvcyB2YWxvcmVzIGRlIGVudHJhZGEgZm9yZW0gdmVyZGFkZWlyb3MgKG7Do28gemVybyksIG8gdmFsb3IgZGUgc2HDrWRhIHNlcsOhIDEuIFNlIHVtYSBvdSBhbWJhcyBlbnRyYWRhcyBmb3JlbSBmYWxzYXMgKHplcm8pLCBvIHZhbG9yIGRlIHNhw61kYSBzZXLDoSAwLlwiLFxuXHRcdGJvb2xlYW5BbmREZXNjOiBcIkEgZnVuw6fDo28gZXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBCb29sZWFubyBFIGVtIHZhbG9yZXMgZGUgcGl4ZWwgZGUgZG9pcyByYXN0ZXJzIGRlIGVudHJhZGEuIFNlIGFtYm9zIG9zIHZhbG9yZXMgZGUgZW50cmFkYSBmb3JlbSB2ZXJkYWRlaXJvcyAobsOjbyB6ZXJvKSwgbyB2YWxvciBkZSBzYcOtZGEgc2Vyw6EgMS4gU2UgdW0gb3UgYW1ib3Mgb3MgdmFsb3JlcyBkZSBlbnRyYWRhIGZvcmVtIGZhbHNvcyAoemVybyksIG8gdmFsb3IgZGUgc2HDrWRhIHNlcsOhIDAuIFwiLFxuXHRcdGJvb2xlYW5Ob3ROYW1lOiBcIk7Do28gQm9vbGVhbm9cIixcblx0XHRib29sZWFuTm90U25pcDogXCJFeGVjdXRhIHVtYSBvcGVyYcOnw6NvIE7Do28gQm9vbGVhbm8gKGNvbXBsZW1lbnRvKSBub3MgdmFsb3JlcyBkZSBjw6lsdWxhcyBkbyByYXN0ZXIgZGUgZW50cmFkYS4gU2Ugb3MgdmFsb3JlcyBkZSBlbnRyYWRhIGZvcmVtIHZlcmRhZGVpcm9zIChuw6NvIHplcm8pLCBvIHZhbG9yIGRlIHNhw61kYSBzZXLDoSAwLiBTZSBvcyB2YWxvcmVzIGRlIGVudHJhZGEgZm9yZW0gZmFsc29zICh6ZXJvKSwgbyB2YWxvciBkZSBzYcOtZGEgc2Vyw6EgMS5cIixcblx0XHRib29sZWFuTm90RGVzYzogXCJBIGZ1bsOnw6NvIGV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gTsOjbyBCb29sZWFubyAoY29tcGxlbWVudG8pIG5vcyB2YWxvcmVzIGRlIHBpeGVsIGRvIHJhc3RlciBkZSBlbnRyYWRhLiBTZSBvcyB2YWxvcmVzIGRlIGVudHJhZGEgZm9yZW0gdmVyZGFkZWlyb3MgKG7Do28gemVybyksIG8gdmFsb3IgZGUgc2HDrWRhIHNlcsOhIDAuIFNlIG9zIHZhbG9yZXMgZGUgZW50cmFkYSBmb3JlbSBmYWxzb3MgKHplcm8pLCBvIHZhbG9yIGRlIHNhw61kYSBzZXLDoSAxLlwiLFxuXHRcdGJvb2xlYW5Pck5hbWU6IFwiT3UgQm9vbGVhbm9cIixcblx0XHRib29sZWFuT3JTbmlwOiBcIkV4ZWN1dGEgYSBvcGVyYcOnw6NvIE91IEJvb2xlYW5vIGVtIHZhbG9yZXMgZGEgY8OpbHVsYSBkZSBkb2lzIHJhc3RlcnMgZGUgZW50cmFkYS4gU2UgdW0gb3UgYW1ib3MgdmFsb3JlcyBkZSBlbnRyYWRhIGZvcmVtIHZlcmRhZGVpcm9zIChuw6NvIHplcm8pLCBvIHZhbG9yIGRlIHNhw61kYSBzZXLDoSAxLiBTZSBhbWJvcyBvcyB2YWxvcmVzIGRlIGVudHJhZGEgZm9yZW0gZmFsc29zICh6ZXJvKSwgYSBzYcOtZGEgc2Vyw6EgMC5cIixcblx0XHRib29sZWFuT3JEZXNjOiBcIkEgZnVuw6fDo28gZXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBCaXR3aXNlIE91IGVtIHZhbG9yZXMgZGUgY8OpbHVsYXMgZGUgZG9pcyByYXN0ZXJzIGRlIGVudHJhZGEuIFNlIHVtIG91IGFtYm9zIG9zIHZhbG9yZXMgZGUgZW50cmFkYSBmb3JlbSB2ZXJkYWRlaXJvcyAobsOjbyB6ZXJvKSwgbyB2YWxvciBkZSBzYcOtZGEgc2Vyw6EgMS4gU2UgYW1ib3Mgb3MgdmFsb3JlcyBkZSBlbnRyYWRhIGZvcmVtIGZhbHNvcyAoemVybyksIG8gdmFsb3IgZGUgc2HDrWRhIHNlcsOhIDAuXCIsXG5cdFx0Ym9vbGVhblhvck5hbWU6IFwiWE91IEJvb2xlYW5cIixcblx0XHRib29sZWFuWG9yU25pcDogXCJFeGVjdXRhIGEgb3BlcmHDp8OjbyBCb29sZWFubyBlWGNsdXNpdmUgT3UgZW0gdmFsb3JlcyBkYSBjw6lsdWxhIGRlIGRvaXMgcmFzdGVycyBkZSBlbnRyYWRhLiBTZSB1bSB2YWxvciBkZSBlbnRyYWRhIGZvciB2ZXJkYWRlaXJvIChuw6NvIHplcm8pIGUgbyBvdXRybyB2YWxvciBmb3IgZmFsc28gKHplcm8pLCBvIHZhbG9yIGRlIHNhw61kYSBzZXLDoSAxLiBTZSBhbWJvcyBvcyB2YWxvcmVzIGRlIGVudHJhZGEgZm9yZW0gdmVyZGFkZWlyb3Mgb3UgYW1ib3MgZm9yZW0gZmFsc29zLCBvIHZhbG9yIGRlIHNhw61kYSBzZXLDoSAwLlwiLFxuXHRcdGJvb2xlYW5Yb3JEZXNjOiBcIkEgZnVuw6fDo28gZXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBCb29sZWFubyBlWGNsdXNpdm8gT3Ugbm9zIHZhbG9yZXMgZGUgY8OpbHVsYXMgZGUgZG9pcyByYXN0ZXJzIGRlIGVudHJhZGEuIFNlIHVtIHZhbG9yIGRlIGVudHJhZGEgZm9yIHZlcmRhZGVpcm8gKG7Do28gemVybykgZSBvIG91dHJvIHZhbG9yIGZvciBmYWxzbyAoemVybyksIG8gdmFsb3IgZGUgc2HDrWRhIHNlcsOhIDEuIFNlIGFtYm9zIG9zIHZhbG9yZXMgZGUgZW50cmFkYSBmb3JlbSB2ZXJkYWRlaXJvcyBvdSBhbWJvcyBmb3JlbSBmYWxzb3MsIG8gdmFsb3IgZGUgc2HDrWRhIHNlcsOhIDAuXCIsXG5cdFx0YnVmZmVyZWRSYXN0ZXJOYW1lOiBcIkJ1ZmZlclwiLFxuXHRcdGJ1ZmZlcmVkUmFzdGVyU25pcDogXCJHZXJhIG8gYnVmZmVyIGRvIMO6bHRpbW8gYmxvY28gZGUgcGl4ZWwgYWNlc3NhZG8uXCIsXG5cdFx0YnVmZmVyZWRSYXN0ZXJEZXNjOiBcIkEgZnVuw6fDo28gQ29tIEJ1ZmZlciDDqSB1dGlsaXphZGEgcGFyYSBvdGltaXphciBvIGRlc2VtcGVuaG8gZGUgY2FkZWlhcyBkZSBmdW7Dp8O1ZXMgY29tcGxleGFzLiBFbGEgYXJtYXplbmEgYSBzYcOtZGEgbmEgbWVtw7NyaWEgZGUgcGFydGUgZGEgY2FkZWlhIGRlIGZ1bsOnw6NvIHF1ZSB2ZW0gYW50ZXMgZGVsYS4gPGRpdj48YnIvPkluc2lyYSBlc3RhIGZ1bsOnw6NvIG5vIEVkaXRvciBkZSBGdW7Dp8OjbyBvbmRlIGRlc2VqYSBhcm1hemVuYXIgYSBzYcOtZGEuPC9kaXY+XCIsXG5cdFx0cmFzdGVyQ2FsY3VsYXRvck5hbWU6IFwiQ2FsY3VsYWRvcmFcIixcblx0XHRyYXN0ZXJDYWxjdWxhdG9yU25pcDogXCJDb21wdXRhIHVtIHJhc3RlciBhIHBhcnRpciBkZSB1bSByYXN0ZXIgYmFzZWFkbyBlbSB1bWEgZXhwcmVzc8OjbyBtYXRlbcOhdGljYS5cIixcblx0XHRyYXN0ZXJDYWxjdWxhdG9yRGVzYzogXCJBIGZ1bsOnw6NvIENhbGN1bGFkb3JhIHBlcm1pdGUgYSB2b2PDqiBjcmlhciBlIGV4ZWN1dGFyIGV4cHJlc3PDtWVzLCBlIGluY29ycG9yYXIgZXN0YXMgZW0gY2FkZWlhcyBkZSBmdW7Dp8Ojby5cIixcblx0XHRjZWxsU3RhdGlzdGljc05hbWU6IFwiRXN0YXTDrXN0aWNhcyBkYSBDw6lsdWxhXCIsXG5cdFx0Y2VsbFN0YXRpc3RpY3NTbmlwOiBcIkNhbGN1bGEgdW1hIGVzdGF0w61zdGljYSBwb3IgY8OpbHVsYSBkZSB2w6FyaW9zIHJhc3RlcnMuIEFzIGVzdGF0w61zdGljYXMgZGlzcG9uw612ZWlzIHPDo28gTWFpb3JpYSwgTcOheGltbywgTcOpZGlhLCBNZWRpYW5hLCBNw61uaW1vLCBNaW5vcmlhLCBQZXJjZW50aWwsIEludGVydmFsbywgRGVzdmlvIFBhZHLDo28sIFNvbWEgZSBWYXJpZWRhZGUuXCIsXG5cdFx0Y2VsbFN0YXRpc3RpY3NEZXNjOiBcIkVzdGEgw6kgdW1hIGZ1bsOnw6NvIHF1ZSBjYWxjdWxhIGVzdGF0w61zdGljYXMgZGUgbcO6bHRpcGxvcyByYXN0ZXJzLCBlbSB1bWEgYmFzZSBkZSBwaXhlbCBwb3IgcGl4ZWwuIEFzIGVzdGF0w61zdGljYXMgZGlzcG9uw612ZWlzIHPDo28gbWFpb3JpYSwgbcOheGltbywgbcOpZGlhLCBtZWRpYW5hLCBtw61uaW1vLCBtaW5vcmlhLCBpbnRlcnZhbG8sIGRlc3ZpbyBwYWRyw6NvLCBzb21hIGUgdmFyaWVkYWRlLlwiLFxuXHRcdGNsYXNzaWZ5TmFtZTogXCJDbGFzc2lmaWNhclwiLFxuXHRcdGNsYXNzaWZ5U25pcDogXCJBdHJpYnVpIGNhZGEgcGl4ZWwgYSB1bWEgY2xhc3NlLiBJbmNvcnBvcmEgZGFkb3Mgc3Vib3JkaW5hZG9zLCB0YWwgY29tbywgdW1hIGltYWdlbSBzZWdtZW50YWRhLlwiLFxuXHRcdGNsYXNzaWZ5RGVzYzogXCJFc3RhIGZ1bsOnw6NvIGRlIHJhc3RlciBjbGFzc2lmaWNhIHVtIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3RlciBiYXNlYWRvIGVtIHVtIGFycXVpdm8gZGUgRGVmaW5pw6fDo28gZG8gQ2xhc3NpZmljYWRvciBkYSBFc3JpICguZWNkKSBlIGVudHJhZGFzIGRvIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3Rlci4gTyBhcnF1aXZvIC5lY2QgdXRpbGl6YWRvIG5hIGZ1bsOnw6NvIENsYXNzaWZpY2FyIGNvbnTDqW0gdG9kYXMgYXMgaW5mb3JtYcOnw7VlcyBwYXJhIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGVzcGVjw61maWNvIGUgY2xhc3NpZmljYWRvciwgZSDDqSBnZXJhZG8gcGVsYXMgZmVycmFtZW50YXMgZGUgdHJlaW5hbWVudG8gZGUgY2xhc3NpZmljYcOnw6NvLCB0YWwgY29tbywgYXMgZmVycmFtZW50YXMgVHJlaW5hciBNw6FxdWluYSBWZXRvcmlhbCBkZSBTdXBvcnRlIG91IFRyZWluYXIgw4Fydm9yZXMgQWxlYXTDs3JpYXMgLlwiLFxuXHRcdGNsaXBOYW1lOiBcIlJlY29ydGFyXCIsXG5cdFx0Y2xpcFNuaXA6IFwiQ29uZmlndXJhIGEgZXh0ZW5zw6NvIGRlIHVtIHJhc3RlciB1dGlsaXphbmRvIGNvb3JkZW5hZGFzIG91IG91dHJvIGNvbmp1bnRvIGRlIGRhZG9zLlwiLFxuXHRcdGNsaXBEZXNjOiBcIkVzdGEgZnVuw6fDo28gcmVjb3J0YSB1bSByYXN0ZXIgdXRpbGl6YW5kbyB1bWEgZm9ybWEgcmV0YW5ndWxhciBkZSBhY29yZG8gY29tIGFzIGV4dGVuc8O1ZXMgZGVmaW5pZGFzIG91IHJlY29ydGFyw6EgdW0gcmFzdGVyIHBhcmEgYSBmb3JtYSBkZSB1bWEgY2xhc3NlIGRlIGZlacOnw6NvIGRlIHBvbMOtZ29ubyBkZSBlbnRyYWRhLiBBIGZvcm1hIHF1ZSBkZWZpbmUgbyByZWNvcnRlIHBvZGUgcmVjb3J0YXIgYSBleHRlbnPDo28gZG8gcmFzdGVyIG91IHJlY29ydGFyIHVtYSDDoXJlYSBkZW50cm8gZG8gcmFzdGVyLlwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uTmFtZTogXCJDb252ZXJzw6NvIGRvIE1vZGVsbyBkZSBDb3Jlc1wiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uU25pcDogXCJDb252ZXJ0ZSB1bSByYXN0ZXIgZGUgUkdCIHBhcmEgSFNWIGUgdmljZSB2ZXJzYS5cIixcblx0XHRjb2xvcnNwYWNlQ29udmVyc2lvbkRlc2M6IFwiQSBmdW7Dp8OjbyBDb252ZXJzw6NvIGRvIE1vZGVsbyBkZSBDb3JlcyBjb252ZXJ0ZSBvIG1vZGVsbyBkZSBjb3JlcyBkZSB1bWEgaW1hZ2VtIGEgcGFydGlyIGRhIHRvbmFsaWRhZGUsIHNhdHVyYcOnw6NvIGUgdmFsb3IgKEhTVikgZGUgY29yIGRlIGVzcGHDp28gcGFyYSB2ZXJtZWxobywgdmVyZGUgZSBhenVsIChSR0IpIG91IHZpY2UtdmVyc2EuPGRpdj48YnIvPkVzdGEgZnVuw6fDo28gcG9kZSBzZXIgdXRpbGl6YWRhIGVtIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGRlIG1vc2FpY28uPC9kaXY+XCIsXG5cdFx0Y29sb3JtYXBUb1JHQk5hbWU6IFwiTWFwYSBkZSBDb3JlcyBwYXJhIFJHQlwiLFxuXHRcdGNvbG9ybWFwVG9SR0JTbmlwOiBcIkNvbnZlcnRlIHVtIHJhc3RlciBkZSBiYW5kYSDDum5pY2EgY29tIHVtIG1hcGEgZGUgY29yZXMsIHBhcmEgdW0gcmFzdGVyIGRlIHRyw6pzIGJhbmRhcyAodmVybWVsaG8sIHZlcmRlIGUgYXp1bCkuXCIsXG5cdFx0Y29sb3JtYXBUb1JHQkRlc2M6IFwiRXN0YSBmdW7Dp8OjbyBjb252ZXJ0ZSB1bSByYXN0ZXIgZGUgYmFuZGEgw7puaWNhIGNvbSB1bSBtYXBhIGRlIGNvcmVzLCBwYXJhIHVtIHJhc3RlciBkZSB0csOqcyBiYW5kYXMgKHZlcm1lbGhvLCB2ZXJkZSBlIGF6dWwpLjxkaXY+PGJyLz5Fc3RhIGZ1bsOnw6NvIMOpIMO6dGlsIHF1YW5kbyB2b2PDqiBwcmVjaXNhciBjcmlhciB1bSByYXN0ZXIgZGUgdHLDqnMgYmFuZGFzIGRlIHVtIHJhc3RlciBkZSBiYW5kYSDDum5pY2EgY29tIHVtIG1hcGEgZGUgY29yZXMgYXNzb2NpYWRvLiBPcyB2YWxvcmVzIG5vIG1hcGEgZGUgY29yZXMgc2Vyw6NvIHV0aWxpemFkb3MgcGFyYSBjcmlhciBjYWRhIGJhbmRhIHZlcm1lbGhhLCB2ZXJkZSBlIGF6dWwuIEVzdGEgZnVuw6fDo28gcG9kZSBzZXIgdXRpbGl6YWRhIGVtIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGRlIG1vc2FpY28uPC9kaXY+XCIsXG5cdFx0Y29sb3JtYXBOYW1lOiBcIk1hcGEgZGUgQ29yZXNcIixcblx0XHRjb2xvcm1hcFNuaXA6IFwiQWx0ZXJhIG9zIHZhbG9yZXMgZGUgcGl4ZWwgcGFyYSBleGliaXIgb3MgZGFkb3MgZG8gcmFzdGVyIGNvbW8gdW1hIGltYWdlbSBlbSB2ZXJtZWxobywgYXp1bCwgdmVyZGUgKFJHQikgb3UgZXNjYWxhIGRlIGNpbnphLCBiYXNlYWRvIGVtIHVtIG1hcGEgZGUgY29yZXMgb3UgdW1hIHJhbXBhIGRlIGNvcmVzLlwiLFxuXHRcdGNvbG9ybWFwRGVzYzogXCJBIGZ1bsOnw6NvIE1hcGEgZGUgY29yZXMgw6kgdW0gdGlwbyBkZSByZW5kZXJpemFkb3IgZGUgZGFkb3MgcmFzdGVyLiBFbGEgdHJhbnNmb3JtYSBvcyB2YWxvcmVzIGRlIHBpeGVsIHBhcmEgZXhpYmlyIG9zIGRhZG9zIHJhc3RlciBjb21vIHVtYSBpbWFnZW0gZGUgZXNjYWxhIGVtIGNpbnphIG91IFJHQiBjb20gYmFzZSBlbSB1bSBlc3F1ZW1hIGRlIGNvciBvdSBjb3JlcyBlc3BlY8OtZmljYXMgZW0gdW0gYXJxdWl2byBkZSBtYXBhIGRlIGNvcmVzLiBWb2PDqiBwb2RlIHV0aWxpemFyIHVtIG1hcGEgZGUgY29yZXMgcGFyYSByZXByZXNlbnRhciBkYWRvcyBhbmFsaXNhZG9zLCBjb21vIHVtYSBpbWFnZW0gY2xhc3NpZmljYWRhIG91IGFvIGV4aWJpciB1bSBtYXBhIHRvcG9ncsOhZmljbyAob3UgdW0gw61uZGljZSBkZSBpbWFnZW0gZXNjYW5lYWRhIGRlIGNvcikuPGRpdj48YnIvPk9zIG1hcGFzIGRlIGNvcmVzIGNvbnTDqW0gdW0gY29uanVudG8gZGUgdmFsb3JlcyBxdWUgc8OjbyBhc3NvY2lhZG9zIGNvbSBjb3JlcyB1dGlsaXphZGFzIHBhcmEgZXhpYmlyIHVtIHJhc3RlciBkZSBiYW5kYSDDum5pY2EgY29uc3RhbnRlbWVudGUgY29tIGFzIG1lc21hcyBjb3Jlcy4gQ2FkYSB2YWxvciBkZSBwaXhlbCDDqSBhc3NvY2lhZG8gY29tIHVtYSBjb3IsIGRlZmluaWRvIGNvbW8gdW0gY29uanVudG8gZGUgdmFsb3JlcyBSR0IuIE9zIG1hcGFzIGRlIGNvcmVzIHPDo28gY2FwYXplcyBkZSBzdXBvcnRhciBxdWFscXVlciBwcm9mdW5kaWRhZGUgZGUgYml0IGV4Y2V0byBvIHBvbnRvIGZsdXR1YW50ZS4gRWxlcyB0YW1iw6ltIHN1cG9ydGFtIHZhbG9yZXMgcG9zaXRpdm9zIGUgbmVnYXRpdm9zIGUgcG9kZW0gY29udGVyIHZhbG9yZXMgbWFwZWFkb3MgZGUgY29yZXMgYXVzZW50ZXMuIEFvIGV4aWJpciB1bSBjb25qdW50byBkZSBkYWRvcyBjb20gdW0gbWFwYSBkZSBjb3JlcyBjb250ZW5kbyB2YWxvcmVzIGF1c2VudGVzLCBvcyBwaXhlbHMgY29tIGVzdGVzIHZhbG9yZXMgYXVzZW50ZXMgbsOjbyBzZXLDo28gZXhpYmlkb3MuPC9kaXY+XCIsXG5cdFx0Y29tcGxleE5hbWU6IFwiQ29tcGxleG9cIixcblx0XHRjb21wbGV4U25pcDogXCJFeHRyYWkgYSBtYWduaXR1ZGUgZGUgbsO6bWVyb3MgY29tcGxleG9zLlwiLFxuXHRcdGNvbXBsZXhEZXNjOiBcIkVzdGEgZnVuw6fDo28gY29tcHV0YSBhIG1hZ25pdHVkZSBkZSB2YWxvcmVzIGNvbXBsZXhvcy48ZGl2Pjxici8+RXN0YSBmdW7Dp8OjbyDDqSBub3JtYWxtZW50ZSB1dGlsaXphZGEgY29tIGltYWdlbnMgUkFEQVIgcXVlIHRlbSB1bSB0aXBvIGRlIGRhZG9zIGNvbXBsZXhvcy4gRWxhIHBvZGUgc2VyIHV0aWxpemFkYSBlbSB1bSBjb25qdW50byBkZSBkYWRvcyBkZSBtb3NhaWNvLjwvZGl2PlwiLFxuXHRcdGNvbXBvc2l0ZUJhbmROYW1lOiBcIkJhbmRhcyBDb21wb3N0YXNcIixcblx0XHRjb21wb3NpdGVCYW5kU25pcDogXCJDb21iaW5hIG3Dumx0aXBsb3MgY29uanVudG8gZGUgZGFkb3MgZW0gdW0gcmFzdGVyIGRlIG3Dumx0aXBsYXMgYmFuZGFzLlwiLFxuXHRcdGNvbXBvc2l0ZUJhbmREZXNjOiBcIkEgZnVuw6fDo28gQmFuZGFzIENvbXBvc3RhcyBwZXJtaXRlIGEgdm9jw6ogY29tYmluYXIgdsOhcmlhcyBpbWFnZW5zIHBhcmEgZm9ybWFyIHVtYSBpbWFnZW0gZGUgbcO6bHRpcGxhcyBiYW5kYXMuXCIsXG5cdFx0Y29uTmFtZTogXCJDb25cIixcblx0XHRjb25TbmlwOiBcIkV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gY29uZGljaW9uYWwgU2UsIEVudMOjbywgT3V0cm8uIFF1YW5kbyB1bSBvcGVyYWRvciBDb24gw6kgdXRpbGl6YWRvLCBub3JtYWxtZW50ZSBzw6NvIG5lY2Vzc8OhcmlhcyBkdWFzIG91IG1haXMgZnVuw6fDtWVzIGxvY2FpcyBlbmNhZGVhZGFzLCBvbmRlIHVtYSBmdW7Dp8OjbyBkZWNsYXJhIG9zIGNyaXTDqXJpb3MgZSBhIHNlZ3VuZGEgZnVuw6fDo28gw6kgbyBvcGVyYWRvciBDb24gcXVlIHV0aWxpemEgb3MgY3JpdMOpcmlvcyBlIGRpdGEgcXVhaXMgZGV2ZW0gc2VyIGFzIHNhw61kYXMgdmVyZGFkZWlyYXMgZSBmYWxzYXMuXCIsXG5cdFx0Y29uRGVzYzogXCJBIGZ1bsOnw6NvIENvbiBjb25maWd1cmEgb3MgcGl4ZWxzIGRvIHJhc3RlciBkZSBzYcOtZGEgYmFzZWFkbyBlbSB1bWEgYXZhbGlhw6fDo28gc2VcXFxcb3V0cm8gZGUgY2FkYSBwaXhlbCBkZSBlbnRyYWRhLiBFbGEgcmV0b3JuYSB2YWxvcmVzIGRlIHBpeGVsIGRvIFJhc3RlciBWZXJkYWRlaXJvIHNlIGEgYXZhbGlhw6fDo28gY29uZGljaW9uYWwgZm9yIHZlcmRhZGVpcmEgKDEpIG91IHJldG9ybmEgb3MgdmFsb3JlcyBkZSBwaXhlbCBhIHBhcnRpciBkbyBSYXN0ZXIgRmFsc28gc2UgYSBhdmFsaWHDp8OjbyBjb25kaWNpb25hbCBmb3IgZmFsc2EgKDApLiBFc3RlcyBjcml0w6lyaW9zIHPDo28gZXNwZWNpZmljYWRvcyBwZWxhIHNhw61kYSBkZSB1bWEgZnVuw6fDo28gbWF0ZW3DoXRpY2EgbMOzZ2ljYSwgcXVlIHNlcsOhIG8gUmFzdGVyIGRlIGVudHJhZGEuXCIsXG5cdFx0Y29uc3RhbnROYW1lOiBcIkNvbnN0YW50ZVwiLFxuXHRcdGNvbnN0YW50U25pcDogXCJDcmlhIHVtIHJhc3RlciB2aXJ0dWFsIGNvbSB1bSDDum5pY28gdmFsb3IgZGUgcGl4ZWwuXCIsXG5cdFx0Y29uc3RhbnREZXNjOiBcIkVzdGEgZnVuw6fDo28gY3JpYSB1bSByYXN0ZXIgdmlydHVhbCBjb20gdW0gdmFsb3IgZGUgcGl4ZWwgw7puaWNvIHF1ZSBwb2RlIHNlciB1dGlsaXphZG8gZW0gbW9kZWxvcyBkZSBmdW7Dp8OjbyBkZSByYXN0ZXIgZSBwYXJhIHByb2Nlc3NhciB1bSBjb25qdW50byBkZSBkYWRvcyBkbyBtb3NhaWNvLjxkaXY+PGJyLz5PIHZhbG9yIGRhIGNvbnN0YW50ZSDDqSB1dGlsaXphZG8gcGFyYSBjYWRhIHZhbG9yIGRlIHBpeGVsIG5vIHJhc3Rlci48L2Rpdj5cIixcblx0XHRjb250b3VyTmFtZTogXCJDdXJ2YSBkZSBOw612ZWxcIixcblx0XHRjb250b3VyU25pcDogXCJDcmlhIGxpbmhhcyBkYSBjdXJ2YSBkZSBuw612ZWwuXCIsXG5cdFx0Y29udG91ckRlc2M6IFwiQSBmdW7Dp8OjbyBDdXJ2YSBkZSBOw612ZWwgZ2VyYSBsaW5oYXMgZGUgY29udG9ybm8ganVudGFuZG8gcG9udG9zIGNvbSBhIG1lc21hIGVsZXZhw6fDo28gYSBwYXJ0aXIgZGUgdW0gY29uanVudG8gZGUgZGFkb3MgcmFzdGVyIGRlIGVsZXZhw6fDo28uIEFzIGN1cnZhcyBkZSBuw612ZWwgc8OjbyBpc29saW5oYXMgY3JpYWRhcyBjb21vIHJhc3RlcnMgcGFyYSB2aXN1YWxpemHDp8Ojby4gT3MgcmVjdXJzb3MgY2hhdmVzIHNlZ3VpbnRlcyB0b3JuYW0gZXN0YSBmdW7Dp8OjbyBwb2Rlcm9zYTogYXMgY3VydmFzIGRlIG7DrXZlbCBzw6NvIGdlcmFkYXMgZGUgZm9ybWEgcsOhcGlkYSBlIGRpbsOibWljYSBlbSBjb25qdW50byBkZSBkYWRvcyBncmFuZGVzLCBjb21vIEVsZXZhw6fDo28gTXVuZGlhbDsgYXMgY3VydmFzIGRlIG7DrXZlbCBwb2RlIHNlciBzdWF2aXphZGFzIHBhcmEgZm9ybmVjZXIgdW1hIGFwYXLDqm5jaWEgY2FydG9ncsOhZmljYSBtYWlzIGFncmFkw6F2ZWwgZW5xdWFudG8gbWFudMOpbSBhIGV4YXRpZMOjbyBkYXMgY3VydmFzIGRlIG7DrXZlbDsgY29udHJvbGUgZGluw6JtaWNvIHNvYnJlIG8gaW50ZXJ2YWxvIGRhcyBjdXJ2YXMgZGUgbsOtdmVsIMOpIGZvcm5lY2lkbzsgYXMgb3DDp8O1ZXMgZGUgc2HDrWRhIGluY2x1ZW0gbGluaGFzIGRlIGN1cnZhcyBkZSBuw612ZWwsIGN1cnZhcyBkZSBuw612ZWwgZGUgw61uZGljZSBlIGN1cnZhcyBkZSBuw612ZWwgcHJlZW5jaGlkYXMuPGRpdj48YnIvPkEgY3JpYcOnw6NvIGRlIHVtYSBjYW1hZGEgZGUgY3VydmEgZGUgbsOtdmVsIGNvbW8gdW0gcHJvZHV0byByYXN0ZXIgw6kgdmFsaW9zYSBwYXJhIHVtYSBhbXBsYSBnYW1hIGRlIGFwbGljYcOnw7VlcywgasOhIHF1ZSBhcyBjdXJ2YXMgZGUgbsOtdmVsIHBvZGVtIHNlciBzb2JyZXBvc3RhcyBlbSB1bSBtYXBhIGUgZm9ybmVjZXIgaW5mb3JtYcOnw7VlcyBzb2JyZSBvIHRlcnJlbm8gc2VtIG9ic2N1cmVjZXIgb3MgZGFkb3Mgc3ViamFjZW50ZXMuIEVsYXMgc8OjbyDDunRlaXMgZW0gYXBsaWNhw6fDtWVzIGNvbW8gZW5nZW5oYXJpYSwgYWdyaWN1bHR1cmEgZSBnZXJlbmNpYW1lbnRvIGRlIMOhZ3VhLjwvZGl2PlwiLFxuXHRcdGNvbnRyYXN0QnJpZ2h0bmVzc05hbWU6IFwiQ29udHJhc3RlIGUgQnJpbGhvXCIsXG5cdFx0Y29udHJhc3RCcmlnaHRuZXNzU25pcDogXCJBanVzdGEgbyBjb250cmFzdGUgZSBicmlsaG8gZGUgdW0gcmFzdGVyLlwiLFxuXHRcdGNvbnRyYXN0QnJpZ2h0bmVzc0Rlc2M6IFwiQSBmdW7Dp8OjbyBDb250cmFzdGUgRSBCcmlsaG8gbWVsaG9yYSBhIGFwYXLDqm5jaWEgZGUgZGFkb3MgcmFzdGVyIG1vZGlmaWNhbmRvIG8gYnJpbGhvIG91IGNvbnRyYXN0ZSBkZW50cm8gZGEgaW1hZ2VtLiBPIGJyaWxobyBhdW1lbnRhIGEgY2xhcmlkYWRlIGdsb2JhbCBkYSBpbWFnZW3igJRwb3IgZXhlbXBsbywgdG9ybmFuZG8gY29yZXMgZXNjdXJhcyBtYWlzIGNsYXJhcyBlIGNvcmVzIGNsYXJhcyBtYWlzIGJyYW5jYeKAlGVucXVhbnRvIG8gY29udHJhc3RlIGFqdXN0YSBhIGRpZmVyZW7Dp2EgZW50cmUgYXMgY29yZXMgbWFpcyBlc2N1cmFzIGUgbWFpcyBjbGFyYXMuPGRpdj48YnIvPkEgdXRpbGl6YcOnw6NvIGRlc3RhIGZ1bsOnw6NvIGFsdGVyYSBvcyB2YWxvcmVzIGRlIHBpeGVsOyBwb3J0YW50bywgZXN0YSBmdW7Dp8OjbyBkZXZlIHNlciB1dGlsaXphZGEgcXVhbmRvIGRlc2VqYXIgcmVhbMOnYXIgYSBhcGFyw6puY2lhIGRvcyBkYWRvcyBlIG7Do28gc2Ugdm9jw6ogcHJldGVuZGVyIHV0aWxpemFyIG9zIGRhZG9zIGNvbW8gcGFydGUgZGUgdW1hIGFuw6FsaXNlIHF1ZSBleGlnaXJpYSBvcyB2YWxvcmVzIGRlIHBpeGVscyBicnV0b3MuIEVzdGEgZnVuw6fDo28gw6kgw7p0aWwgYW8gcHVibGljYXIgb3MgZGFkb3MgY29tbyB1bSBzZXJ2acOnbyBkZSBpbWFnZW0gcXVlIHBvZGUgc2VyIHV0aWxpemFkbyBlbSBhcGxpY2F0aXZvcyBzZW0gYSBoYWJpbGlkYWRlIGRlIGFsdGVyYXIgbyBjb250cmFzdGUgZSBicmlsaG8gZGEgaW1hZ2VtIG91IGFzc2VndXJhciBxdWUgZWxhIHNlamEgZXhpYmlkYSB1dGlsaXphbmRvIHN1YXMgY29uZmlndXJhw6fDtWVzIHByZWZlcmlkYXMuPC9kaXY+XCIsXG5cdFx0Y29udm9sdXRpb25OYW1lOiBcIkNvbnZvbHXDp8Ojb1wiLFxuXHRcdGNvbnZvbHV0aW9uU25pcDogXCJBcGxpY2EgdW0gZmlsdHJvIHBhcmEgbml0aWRleiwgc29tYnJlYWRvLCBkZXRlY3RhciBib3JkYXMsIHN1YXZpemHDp8OjbyBvdSB1bSBlZmVpdG8gZ3JhZGllbnRlIGF0cmF2w6lzIGRlIHVtIHJhc3Rlci5cIixcblx0XHRjb252b2x1dGlvbkRlc2M6IFwiQSBmdW7Dp8OjbyBDb252b2x1w6fDo28gZXhlY3V0YSB1bSBmaWx0cm8gbm9zIHZhbG9yZXMgZGUgcGl4ZWwgZW0gdW1hIGltYWdlbSwgcXVlIHBvZGUgc2VyIHV0aWxpemFkbyBwYXJhIGNsYXJlYXIgdW1hIGltYWdlbSwgZXNjdXJlY2VyIHVtYSBpbWFnZW0sIGRldGVjdGFyIGJvcmRhcyBkZW50cm8gZGUgdW1hIGltYWdlbSBvdSBvdXRyYXMgb3RpbWl6YcOnw7VlcyBiYXNlYWRhcyBlbSBrZXJuZWwuIE9zIGZpbHRyb3Mgc8OjbyB1dGlsaXphZG9zIHBhcmEgbWVsaG9yYXIgYSBxdWFsaWRhZGUgZGEgaW1hZ2VtIHJhc3RlciBlbGltaW5hbmRvIGRhZG9zIGVzcMO6cmlvcyBvdSBtZWxob3JhbmRvIGZlacOnw7VlcyBub3MgZGFkb3MuIEVzdGVzIGZpbHRyb3MgZGUgY29udm9sdcOnw6NvIHPDo28gYXBsaWNhZG9zIHVtIGtlcm5lbCBkZSBtdWRhbsOnYSwgc29icmVwb3Npw6fDo28gKGphbmVsYSBvdSB2aXppbmhhbsOnYSksIGNvbW8gMyBwb3IgMy4gT3MgZmlsdHJvcyBkZSBjb252b2x1w6fDo28gZnVuY2lvbmFtIGNvbSBvIGPDoWxjdWxvIGRvIHZhbG9yIGRlIHBpeGVsIGJhc2VhZG8gbm9zIHBlc29zIGRlIHNldXMgdml6aW5ob3MuXCIsXG5cdFx0Y29ycmlkb3JOYW1lOiBcIkNvcnJlZG9yXCIsXG5cdFx0Y29ycmlkb3JTbmlwOiBcIkNhbGN1bGEgYSBzb21hIGRlIGN1c3RvcyBhY3VtdWxhdGl2b3MgcGFyYSBkb2lzIHJhc3RlcnMgYWN1bXVsYXRpdm9zIGRlIGVudHJhZGEuXCIsXG5cdFx0Y29ycmlkb3JEZXNjOiBcIkEgZnVuw6fDo28gZGUgQ29ycmVkb3IgY2FsY3VsYSBhIHNvbWEgZGUgY3VzdG9zIGFjdW11bGF0aXZvcyBwYXJhIGRvaXMgcmFzdGVycyBkZSBjdXN0byBhY3VtdWxhdGl2byBkZSBlbnRyYWRhLiBFbnF1YW50byBkb2lzIHJhc3RlcnMgcG9kZW0gc2VyIHV0aWxpemFkb3MgcGFyYSBhIGVudHJhZGEsIHBhcmEgb2J0ZXIgdW0gcmVzdWx0YWRvIHNpZ25pZmljYW50ZSBlbGVzIGRldmVtIHNlciByYXN0ZXJzIGRlIHNhw61kYSBkZSBjdXN0byBhY3VtdWxhdGl2byBpbmFsdGVyYWRvLiBBIG9yZGVtIGRhcyBkdWFzIGVudHJhZGFzIMOpIGlycmVsZXZhbnRlLlwiLFxuXHRcdGNvc0hOYW1lOiBcIkNvc0hcIixcblx0XHRjb3NIU25pcDogXCJDYWxjdWxhIG8gY28tc2VubyBoaXBlcmLDs2xpY28gZGUgY8OpbHVsYXMgZW0gdW0gcmFzdGVyLlwiLFxuXHRcdGNvc0hEZXNjOiBcIkEgZnVuw6fDo28gY2FsY3VsYSBvIGNvLXNlbm8gaGlwZXJiw7NsaWNvIGRvcyBwaXhlbHMgZW0gdW0gcmFzdGVyLlwiLFxuXHRcdGNvc05hbWU6IFwiQ29zXCIsXG5cdFx0Y29zU25pcDogXCJDYWxjdWxhIG8gY28tc2VubyBkZSB1bWEgY8OpbHVsYSBlbSB1bSByYXN0ZXIuXCIsXG5cdFx0Y29zRGVzYzogXCJBIGZ1bsOnw6NvIGNhbGN1bGEgbyBjby1zZW5vIGRvcyBwaXhlbHMgZW0gdW0gcmFzdGVyLlwiLFxuXHRcdGNvc3RBbGxvY2F0aW9uTmFtZTogXCJBbG9jYcOnw6NvIGRlIEN1c3RvXCIsXG5cdFx0Y29zdEFsbG9jYXRpb25TbmlwOiBcIkNhbGN1bGEsIHBhcmEgY2FkYSBjw6lsdWxhLCBzdWEgb3JpZ2VtIGRlIG1lbm9yIGN1c3RvIGJhc2VhZGEgbm8gbWVub3IgY3VzdG8gYWN1bXVsYXRpdm8gc29icmUgdW1hIHN1cGVyZsOtY2llIGRlIGN1c3RvLlwiLFxuXHRcdGNvc3RBbGxvY2F0aW9uRGVzYzogXCJBIGZ1bsOnw6NvIEFsb2Nhw6fDo28gZGUgQ3VzdG8gY2FsY3VsYSBwYXJhIGNhZGEgY8OpbHVsYSBzdWEgZm9udGUgZGUgbWVub3IgY3VzdG8gYmFzZWFkYSBubyBtZW5vciBjdXN0byBhY3VtdWxhdGl2byBzb2JyZSB1bWEgc3VwZXJmw61jaWUgZGUgY3VzdG8uXCIsXG5cdFx0Y29zdEJhY2tMaW5rTmFtZTogXCJWw61uY3VsbyBBbnRlcmlvciBkZSBDdXN0b1wiLFxuXHRcdGNvc3RCYWNrTGlua1NuaXA6IFwiRGVmaW5lIG8gdml6aW5obyBxdWUgc2Vyw6EgYSBwcsOzeGltYSBjw6lsdWxhIG5vIG1lbm9yIGNhbWluaG8gZGUgY3VzdG8gYWN1bXVsYXRpdm8gYXTDqSBhIGZvbnRlIGRlIG1lbm9yIGN1c3RvLlwiLFxuXHRcdGNvc3RCYWNrTGlua0Rlc2M6IFwiQSBmdW7Dp8OjbyBWw61uY3VsbyBBbnRlcmlvciBkZSBDdXN0byBkZWZpbmUgbyB2aXppbmhvIHF1ZSBlc3TDoSBwcsOzeGltbyBkYSBjw6lsdWxhIG5vIGNhbWluaG8gZGUgbWVub3IgY3VzdG8gYWN1bXVsYXRpdm8gYXTDqSBhIGZvbnRlIGRlIG1lbm9yIGN1c3RvLjxkaXY+PGJyLz5PIGJhY2tsaW5rIGRvIHJhc3RlciBjb250w6ltIHZhbG9yZXMgZGUgemVybyBhIG9pdG8sIHF1ZSBkZWZpbmUgYSBkaXJlw6fDo28gb3UgaWRlbnRpZmljYSBhIHByw7N4aW1hIGPDqWx1bGEgdml6aW5oYSAoY8OpbHVsYSBiZW0gc3VjZWRpZGEpIGFvIGxvbmdvIGRvIGNhbWluaG8gZGUgY3VzdG8gbWVub3MgYWN1bXVsYXRpdm8gZGUgdW1hIGPDqWx1bGEgcGFyYSBhbGNhbsOnYXIgc3VhIG9yaWdlbSBkZSBtZW5vciBjdXN0by4gU2UgbyBjYW1pbmhvIGZvciBwYXNzYXIgbm8gdml6aW5obyBkaXJlaXRvLCBhIGPDqWx1bGEgc2Vyw6EgYXRyaWJ1w61kYSBhbyB2YWxvciAxLCAyIHBhcmEgY8OpbHVsYSBkaWFnb25hbCBkaXJlaXRhIGluZmVyaW9yIGUgY29udGludWFuZG8gw6AgZGlyZWl0YS4gTyB2YWxvciAwIMOpIHJlc2VydmFkbyBwYXJhIGPDqWx1bGFzIGRlIG9yaWdlbS48L2Rpdj5cIixcblx0XHRjb3N0RGlzdGFuY2VOYW1lOiBcIkRpc3TDom5jaWEgZGUgQ3VzdG9cIixcblx0XHRjb3N0RGlzdGFuY2VTbmlwOiBcIkNhbGN1bGEgYSBkaXN0w6JuY2lhIGRlIG1lbm9yIGN1c3RvIGFjdW11bGF0aXZvIHBhcmEgY2FkYSBjw6lsdWxhIGRlIG91IHBhcmEgYSBvcmlnZW0gZGUgbWVub3IgY3VzdG8gc29icmUgdW1hIHN1cGVyZsOtY2llIGRlIGN1c3RvLlwiLFxuXHRcdGNvc3REaXN0YW5jZURlc2M6IFwiQSBmdW7Dp8OjbyBEaXN0w6JuY2lhIGRlIEN1c3RvIGNhbGN1bGEgYSBkaXN0w6JuY2lhIGRlIG1lbm9yIGN1c3RvIGFjdW11bGF0aXZvIHBhcmEgY2FkYSBjw6lsdWxhIGRlIG91IGF0w6kgYSBmb250ZSBkZSBtZW5vciBjdXN0byBzb2JyZSB1bWEgc3VwZXJmw61jaWUgZGUgY3VzdG8uXCIsXG5cdFx0Y29zdFBhdGhOYW1lOiBcIkNhbWluaG8gZGUgQ3VzdG9cIixcblx0XHRjb3N0UGF0aFNuaXA6IFwiQ2FsY3VsYSBvIGNhbWluaG8gZGUgbWVub3IgY3VzdG8gZGEgb3JpZ2VtIGF0w6kgbyBkZXN0aW5vLlwiLFxuXHRcdGNvc3RQYXRoRGVzYzogXCJBIGZ1bsOnw6NvIENhbWluaG8gZGUgQ3VzdG8gZ2xvYmFsIGNhbGN1bGEgbyBjYW1pbmhvIGRlIG1lbm9yIGN1c3RvIGEgcGFydGlyIGRlIHVtYSBvcmlnZW0gYXTDqSB1bSBkZXN0aW5vLjxkaXY+PGJyLz5Fc3RhIGZ1bsOnw6NvIHByb2R1eiB1bSByYXN0ZXIgZGUgc2HDrWRhIHF1ZSByZWdpc3RyYSBvIGNhbWluaG8gbWVub3IgY3VzdG8gb3UgY2FtaW5ob3MgZGUgbG9jYWxpemHDp8O1ZXMgc2VsZWNpb25hZGFzIHBhcmEgYSBjw6lsdWxhIGRlIG9yaWdlbSBtYWlzIHByw7N4aW1hIGRlZmluaWRhIGRlbnRybyBkYSBzdXBlcmbDrWNpZSBkZSBjdXN0byBhY3VtdWxhdGl2bywgZW0gdGVybW9zIGRlIGRpc3TDom5jaWEgZGUgY3VzdG8uPC9kaXY+XCIsXG5cdFx0Y3VydmF0dXJlTmFtZTogXCJDdXJ2YXR1cmFcIixcblx0XHRjdXJ2YXR1cmVTbmlwOiBcIkNhbGN1bGEgYSBjdXJ2YXR1cmEgZGUgdW1hIHN1cGVyZsOtY2llIGRlIHJhc3Rlciwgb3BjaW9uYWxtZW50ZSBpbmNsdWkgcGVyZmlsIGUgY3VydmF0dXJhIHBsYW5hLlwiLFxuXHRcdGN1cnZhdHVyZURlc2M6IFwiQSBmdW7Dp8OjbyBDdXJ2YXR1cmEgZXhpYmUgYSBmb3JtYSBvdSBjdXJ2YXR1cmEgZGUgZGVjbGl2aWRhZGUuIFVtYSBwYXJ0ZSBkYSBzdXBlcmbDrWNpZSBwb2RlIHNlciBjw7RuY2F2YSBvdSBjb252ZXhhOyB2b2PDqiBwb2RlIGRpemVyIGlzdG8gb2xoYW5kbyBvIHZhbG9yIGRhIGN1cnZhdHVyYS4gQSBjdXJ2YXR1cmEgw6kgZGVmaW5pZGEgY2FsY3VsYW5kbyBhIHNlZ3VuZGEgZGVyaXZhZGEgZGEgc3VwZXJmw61jaWUuPGRpdj48YnIvPkEgc2HDrWRhIGRhIGZ1bsOnw6NvIEN1cnZhdHVyYSBwb2RlIHNlciB1dGlsaXphZGEgcGFyYSBkZXNjcmV2ZXIgYXMgY2FyYWN0ZXLDrXN0aWNhcyBmw61zaWNhcyBkZSB1bWEgYmFjaWEgZGUgZHJlbmFnZW0gZW0gdW0gZXNmb3LDp28gcGFyYSBlbnRlbmRlciBvcyBwcm9jZXNzb3MgZGUgZXJvc8OjbyBlIGVzY29hbWVudG8uIE8gdmFsb3IgZGEgY3VydmF0dXJhIHBvZGUgc2VyIHV0aWxpemFkbyBwYXJhIGVuY29udHJhciBwYWRyw7VlcyBkZSBlcm9zw6NvIGRvIHNvbG8sIGNvbW8gdGFtYsOpbSwgYSBkaXN0cmlidWnDp8OjbyBkZSDDoWd1YSBuYSB0ZXJyYS4gQSBjdXJ2YXR1cmEgZG8gcGVyZmlsIGFmZXRhIGEgYWNlbGVyYcOnw6NvIGUgZGVzYWNlbGVyYcOnw6NvIGRvIGZsdXhvIGUsIHBvcnRhbnRvLCBpbmZsdWVuY2lhIGEgZXJvc8OjbyBlIGEgZGVwb3Npw6fDo28uIEEgY3VydmF0dXJhIGRhIGZvcm1hIHBsYW5hIGluZmx1ZW5jaWEgYSBjb252ZXJnw6puY2lhIGUgZGl2ZXJnw6puY2lhIGRvIGZsdXhvLjwvZGl2PlwiLFxuXHRcdGRpdmlkZU5hbWU6IFwiRGl2aWRpclwiLFxuXHRcdGRpdmlkZVNuaXA6IFwiRGl2aWRlIG9zIHZhbG9yZXMgZGUgZG9pcyByYXN0ZXJzIGVtIHVtYSBiYXNlIGRlIGPDqWx1bGEgcG9yIGPDqWx1bGEuXCIsXG5cdFx0ZGl2aWRlRGVzYzogXCJBIGZ1bsOnw6NvIERpdmlkaXIgZGl2aWRlIG9zIHZhbG9yZXMgZGUgZG9pcyByYXN0ZXJzIGVtIHVtYSBiYXNlIGRlIHBpeGVsIGEgcGl4ZWwuXCIsXG5cdFx0ZWxldmF0aW9uVm9pZEZpbGxOYW1lOiBcIlByZWVuY2hpbWVudG8gZGUgRWxldmHDp8OjbyBOdWxhXCIsXG5cdFx0ZWxldmF0aW9uVm9pZEZpbGxTbmlwOiBcIkNyaWEgcGl4ZWxzIG9uZGUgdGl2ZXIgdmF6aW9zIGVtIHNldXMgZGFkb3MgZGUgZWxldmHDp8Ojby5cIixcblx0XHRlbGV2YXRpb25Wb2lkRmlsbERlc2M6IFwiQSBmdW7Dp8OjbyBQcmVlbmNoaW1lbnRvIGRlIEVsZXZhw6fDo28gTnVsYSDDqSB1dGlsaXphZGEgcGFyYSBjcmlhciBwaXhlbHMgb25kZSB0aXZlciB2YXppb3MgZW0gc3VhIGVsZXZhw6fDo28uPGRpdj48YnIvPk9zIHZhemlvcyBvY29ycmVtIHF1YW5kbyBuw6NvIGjDoSBwb250b3MgY29sZXRhZG9zIGRlbnRybyBkYSDDoXJlYSByZXByZXNlbnRhZGEgcG9yIHVtIHBpeGVsIG5vIHJhc3RlciByZXN1bHRhbnRlLiBPcyB2YXppb3Mgc8OjbyBmcmVxdWVudGVtZW50ZSBjYXVzYWRvcyBwb3IgY29ycG9zIGQnw6FndWEsIHNlbGXDp8OjbyBkbyB0aXBvIGRlIGNsYXNzZSBvdSBleGNsdXPDo28uIE8gcHJlZW5jaGltZW50byBkbyB2YXppbyDDqSBtYWlzIGNvbXVtZW50ZSB1dGlsaXphZG8gYW8gZ2VyYXIgdW1hIHN1cGVyZsOtY2llLjwvZGl2PlwiLFxuXHRcdGVxdWFsVG9OYW1lOiBcIklndWFsIEFcIixcblx0XHRlcXVhbFRvU25pcDogXCJFeGVjdXRhIHVtYSBvcGVyYcOnw6NvIG7Do28taWd1YWwtYSBSZWxhY2lvbmFsIGVtIGR1YXMgZW50cmFkYXMgZW0gdW1hIGJhc2UgY8OpbHVsYSBhIGPDqWx1bGEuIFJldG9ybmEgMSBwYXJhIGPDqWx1bGFzIG9uZGUgbyBwcmltZWlybyByYXN0ZXIgw6kgaWd1YWwgYW8gc2VndW5kbyBkYWRvIHJhc3RlciBlIDAgcGFyYSBjw6lsdWxhcyBvbmRlIG7Do28gw6kuXCIsXG5cdFx0ZXF1YWxUb0Rlc2M6IFwiQSBmdW7Dp8OjbyBleGVjdXRhIHVtYSBvcGVyYcOnw6NvIGlndWFsLWEgZW0gZG9pcyByYXN0ZXIgZW0gdW1hIGJhc2UgcGl4ZWwgYSBwaXhlbC4gUmV0b3JuYSB1bSB2YWxvciBkZSAxIGRlIHBpeGVscyBvbmRlIG8gcHJpbWVpcm8gcmFzdGVyIMOpIGlndWFsIGFvIHNlZ3VuZG8gcmFzdGVyIGUgdW0gdmFsb3IgZGUgMCBwYXJhIHBpeGVscyBvbmRlIGVsZXMgbsOjbyBzw6NvIGlndWFpcy5cIixcblx0XHRldWNBbGxvY2F0aW9uTmFtZTogXCJBbG9jYcOnw6NvIEV1Y2xpZGlhbmFcIixcblx0XHRldWNBbGxvY2F0aW9uU25pcDogXCJDYWxjdWxhIGEgb3JpZ2VtIG1haXMgcHLDs3hpbWEgcGFyYSBjYWRhIGPDqWx1bGEgYmFzZWFkYSBuYSBkaXN0w6JuY2lhIEV1Y2xpZGlhbmEuXCIsXG5cdFx0ZXVjQWxsb2NhdGlvbkRlc2M6IFwiQSBmdW7Dp8OjbyBBbG9jYcOnw6NvIEV1Y2xpZGlhbmEgY2FsY3VsYSwgcGFyYSBjYWRhIGPDqWx1bGEsIGEgb3JpZ2VtIG1haXMgcHLDs3hpbWEgY29tIGJhc2UgbmEgZGlzdMOibmNpYSBFdWNsaWRpYW5hLlwiLFxuXHRcdGV1Y0RpcmVjdGlvbk5hbWU6IFwiRGlyZcOnw6NvIEV1Y2xpZGlhbmFcIixcblx0XHRldWNEaXJlY3Rpb25TbmlwOiBcIkNhbGN1bGEsIHBhcmEgY2FkYSBjw6lsdWxhLCBhIGRpcmXDp8OjbywgZW0gZ3JhdXMsIGRhIG9yaWdlbSBtYWlzIHByw7N4aW1hLlwiLFxuXHRcdGV1Y0RpcmVjdGlvbkRlc2M6IFwiQSBmdW7Dp8OjbyBEaXJlw6fDo28gRXVjbGlkaWFuYSBjYWxjdWxhLCBwYXJhIGNhZGEgY8OpbHVsYSwgYSBkaXJlw6fDo28gZW0gZ3JhdXMgYXTDqSBhIG9yaWdlbSBtYWlzIHByw7N4aW1hLiA8ZGl2Pjxici8+QSBkaXJlw6fDo28gw6kgY2FsY3VsYWRhIGEgcGFydGlyIGRlIGNhZGEgY2VudHJvIGRhIGPDqWx1bGEgcGFyYSBvIGNlbnRybyBkYSBjw6lsdWxhIGRlIG9yaWdlbSBxdWUgZXN0w6EgbWFpcyBwcsOzeGltbyBkZWxhLiBBIGZhaXhhIGRlIHZhbG9yZXMgw6kgZGUgMCBncmF1cyBhIDM2MCBncmF1cywgY29tIDAgcmVzZXJ2YWRvIHBhcmEgYXMgY8OpbHVsYXMgZGUgb3JpZ2VtLiBEZXZpZG8gYW8gbGVzdGUgKGRpcmVpdGEpIMOpIDkwIGUgb3MgdmFsb3JlcyBhdW1lbnRhbSDDoCBkaXJlaXRhICgxODAgw6kgc3VsLCAyNzAgw6kgb2VzdGUgZSAzNjAgw6kgbm9ydGUpLjwvZGl2PlwiLFxuXHRcdGV1Y0Rpc3RhbmNlTmFtZTogXCJEaXN0w6JuY2lhIEV1Y2xpZGlhbmFcIixcblx0XHRldWNEaXN0YW5jZVNuaXA6IFwiQ2FsY3VsYSwgcGFyYSBjYWRhIGPDqWx1bGEsIGEgZGlzdMOibmNpYSBFdWNsaWRpYW5hIHBhcmEgYSBvcmlnZW0gbWFpcyBwcsOzeGltYS5cIixcblx0XHRldWNEaXN0YW5jZURlc2M6IFwiQSBmdW7Dp8OjbyBEaXN0w6JuY2lhIEV1Y2xpZGlhbmEgY2FsY3VsYSwgcGFyYSBjYWRhIGPDqWx1bGEsIGEgZGlzdMOibmNpYSBFdWNsaWRpYW5hIGF0w6kgYSBvcmlnZW0gbWFpcyBwcsOzeGltYS5cIixcblx0XHRleHAxME5hbWU6IFwiRXhwMTBcIixcblx0XHRleHAxMFNuaXA6IFwiQ2FsY3VsYSBhIGJhc2UgZGUgZXhwb25lbmNpYWwgMTAgZGFzIGPDqWx1bGFzIGVtIHVtIHJhc3Rlci5cIixcblx0XHRleHAxMERlc2M6IFwiQSBmdW7Dp8OjbyBFeHAgMTAgY2FsY3VsYSBhIGJhc2UgMTAgZXhwb25lbmNpYWwgZG9zIHBpeGVscyBlbSB1bSByYXN0ZXIuXCIsXG5cdFx0ZXhwMk5hbWU6IFwiRXhwMlwiLFxuXHRcdGV4cDJTbmlwOiBcIkNhbGN1bGEgYSBiYXNlIGRlIGV4cG9uZW5jaWFsIDIgZGFzIGPDqWx1bGFzIGVtIHVtIHJhc3Rlci5cIixcblx0XHRleHAyRGVzYzogXCJBIGZ1bsOnw6NvIGNhbGN1bGEgYSBiYXNlIDIgZXhwb25lbmNpYWwgZG9zIHBpeGVscyBlbSB1bSByYXN0ZXIuXCIsXG5cdFx0ZXhwTmFtZTogXCJFeHBcIixcblx0XHRleHBTbmlwOiBcIkNhbGN1bGUgYSBiYXNlIGUgZXhwb25lbmNpYWwgZGFzIGPDqWx1bGFzIGVtIHVtIHJhc3Rlci5cIixcblx0XHRleHBEZXNjOiBcIkVzdGEgZnVuw6fDo28gY2FsY3VsYSBhIGJhc2UgZSBleHBvbmVuY2lhbCBkb3MgcGl4ZWxzIGVtIHVtIHJhc3Rlci5cIixcblx0XHRleHRyYWN0QmFuZE5hbWU6IFwiRXh0cmFpciBGYWl4YXNcIixcblx0XHRleHRyYWN0QmFuZFNuaXA6IFwiRXNwZWNpZmljYSBjb20gcXVhaXMgYmFuZGFzIHRyYWJhbGhhciBhbyB1dGlsaXphciBjb25qdW50b3MgZGUgZGFkb3MgZGUgbcO6bHRpcGxhcyBiYW5kYXMuXCIsXG5cdFx0ZXh0cmFjdEJhbmREZXNjOiBcIiBBIGZ1bsOnw6NvIGV4dHJhaXIgQmFuZGFzIHBlcm1pdGUgYSB2b2PDqiBleHRyYWlyIHVtYSBvdSBtYWlzIGJhbmRhcyBkZSB1bSByYXN0ZXIgb3UgcG9kZSByZW9yZGVuYXIgYXMgYmFuZGFzIGVtIHVtIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3RlciBkZSBtw7psdGlwbGFzIGJhbmRhcy48ZGl2Pjxici8+Vm9jw6ogcG9kZSB1dGlsaXphciBhIGZ1bsOnw6NvIEV4dHJhaXIgQmFuZGFzIGFudGVzIGRlIG91dHJhcyBmdW7Dp8O1ZXMsIGNvbW8gQXJpdG3DqXRpY2EsIHBhcmEgY29udHJvbGFyIHF1YWlzIGJhbmRhcyBzw6NvIHV0aWxpemFkYXMgY29tbyBlbnRyYWRhIG5hIHByw7N4aW1hIGZ1bsOnw6NvLjwvZGl2PlwiLFxuXHRcdGZpbGxOYW1lOiBcIlByZWVuY2hpbWVudG9cIixcblx0XHRmaWxsU25pcDogXCJQcmVlbmNoZSBhcyBkZXByZXNzw7VlcyBuYSBzdXBlcmbDrWNpZSBkbyByYXN0ZXIgcGFyYSByZW1vdmVyIHBlcXVlbmFzIGltcGVyZmVpw6fDtWVzIG5vcyBkYWRvcy5cIixcblx0XHRmaWxsRGVzYzogXCJBIGZ1bsOnw6NvIFByZWVuY2hlciBnbG9iYWwgbG9jYWxpemEgZSBwcmVlbmNoZSBkZXByZXNzw7VlcyBlIGN1bWVzIGVtIHVtIHJhc3RlciBkZSBzdXBlcmbDrWNpZSBkZSBlbGV2YcOnw6NvIHBhcmEgcmVtb3ZlciBpbXBlcmZlacOnw7VlcyBwZXF1ZW5hcyBub3MgZGFkb3MuIEEgZnVuw6fDo28gcHJlZW5jaGVyw6EgdW0gcHJvY2Vzc28gaXRlcmF0aXZvIGF0w6kgcXVlIHRvZGFzIGFzIGRlcHJlc3PDtWVzIHNlamFtIHByZWVuY2hpZGFzIGRlbnRybyBkbyBMaW1pdGUgWiBlc3BlY2lmaWNhZG8uPGRpdj48YnIvPlF1YW5kbyB1bWEgc3VwZXJmw61jaWUgZGUgZWxldmHDp8OjbyBmb3IgY3JpYWRhIGNvbSBmZXJyYW1lbnRhcyBkZSBNYXBlYW1lbnRvIGRlIE9ydG9mb3RvcyBvdSBwb3Igb3V0cm9zIG1laW9zLCBow6EgZnJlcXVlbnRlbWVudGUgcGVxdWVub3MgZXJyb3Mgc2lnbmlmaWNhbnRlcyBubyBmb3JtdWzDoXJpbyBkZSBkZXByZXNzw7VlcyBlIGN1bWVzIG5vcyBkYWRvcy4gRW0gZm90b2dyYW1ldHJpYSwgZGVwcmVzc8O1ZXMgZSBjdW1lcyBzw6NvIGZyZXF1ZW50ZW1lbnRlIGNoYW1hZG8gZGUgYnVyYWNvcyBlIHBpY29zLiBkZXZpZG8gYW8gZmF0byBkb3MgZGFkb3MgZGUgc3VwZXJmw61jaWUgc2VyZW0gZnJlcXVlbnRlbWVudGUgdXRpbGl6YWRvcyBlbSBtb2RlbGFnZW0sIGNvbW8gbW9kZWxhZ2VtIGhpZHJvbMOzZ2ljYSwgw6kgaW1wb3J0YW50ZSBjb3JyaWdpciBlc3RlcyBlcnJvcyBkZSBkZXByZXNzw7VlcyBlIGN1bWVzIGF0w6kgY2VydG8gcG9udG8gY29uc2lzdGVudGUgY29tIG9zIGRhZG9zIGNpcmN1bmRhbnRlcy48L2Rpdj5cIixcblx0XHRmbG9hdE5hbWU6IFwiUmVhbFwiLFxuXHRcdGZsb2F0U25pcDogXCJDb252ZXJ0ZSBjYWRhIHZhbG9yIGRlIGPDqWx1bGEgZGUgdW0gcmFzdGVyIGVtIHVtYSByZXByZXNlbnRhw6fDo28gZGUgcG9udG8gZmx1dHVhbnRlLlwiLFxuXHRcdGZsb2F0RGVzYzogXCJBIGZ1bsOnw6NvIEZsdXR1YW50ZSBjb252ZXJ0ZSBjYWRhIHZhbG9yIGRlIHBpeGVsIGRlIHVtIHJhc3RlciBlbSB1bWEgcmVwcmVzZW50YcOnw6NvIGRlIHBvbnRvIGZsdXR1YW50ZS5cIixcblx0XHRmbG93QWNjdW11bGF0aW9uTmFtZTogXCJBY3VtdWxhw6fDo28gZGUgRmx1eG9cIixcblx0XHRmbG93QWNjdW11bGF0aW9uU25pcDogXCJDcmlhIHVtIHJhc3RlciBkZSBmbHV4byBhY3VtdWxhZG8gZW0gY2FkYSBjw6lsdWxhLiBVbSBmYXRvciBkZSBwZXNvIHBvZGUgb3BjaW9uYWxtZW50ZSBzZXIgYXBsaWNhZG8uXCIsXG5cdFx0Zmxvd0FjY3VtdWxhdGlvbkRlc2M6IFwiQSBmdW7Dp8OjbyBBY3VtdWxhw6fDo28gZGUgRmx1eG8gZ2xvYmFsIGNyaWEgdW0gcmFzdGVyIGRlIGZsdXhvIGFjdW11bGFkbyBlbSBjYWRhIHBpeGVsLCBjb21vIGRldGVybWluYWRvIHBlbG8gYWPDum11bG8gZG8gcGVzbyBkZSB0b2RvcyBvcyBwaXhlbHMgcXVlIGZsdWVtIGVtIGNhZGEgcGl4ZWwgZGUgZGVjbGl2aWRhZGUuIFNlIG5lbmh1bSBwZXNvIGRlIHJhc3RlciBmb3IgZm9ybmVjaWRvLCB1bSBwZXNvIGRlIDEgw6kgYXBsaWNhZG8gYSBjYWRhIHBpeGVsIGUgbyB2YWxvciBkb3MgcGl4ZWxzIG5vIHJhc3RlciBkZSBzYcOtZGEgZm9yIG8gbsO6bWVybyBkZSBwaXhlbHMgcXVlIGZsdWVtIGVtIGNhZGEgcGl4ZWwuPGRpdj48YnIvPk9zIHBpeGVscyBkZSBzYcOtZGEgY29tIHVtYSBhY3VtdWxhw6fDo28gZGUgZmx1eG8gYWx0YSBzw6NvIMOhcmVhcyBkZSBmbHV4b3MgY29uY2VudHJhZG9zIGUgcG9kZW0gc2VyIHV0aWxpemFkb3MgcGFyYSBpZGVudGlmaWNhciBjYW5haXMgZGUgcmlvcy4gT3MgcGl4ZWxzIGRlIHNhw61kYSBjb20gdW1hIGFjdW11bGHDp8OjbyBkZSBmbHV4byBkZSB6ZXJvIHPDo28gbG9jYWlzIHRvcG9ncsOhZmljb3MgYWx0b3MgZSBwb2RlbSBzZXIgdXRpbGl6YWRvcyBwYXJhIGlkZW50aWZpY2FyIGN1bWVzLjwvZGl2PlwiLFxuXHRcdGZsb3dEaXJlY3Rpb25OYW1lOiBcIkRpcmXDp8OjbyBkbyBGbHV4b1wiLFxuXHRcdGZsb3dEaXJlY3Rpb25TbmlwOiBcIkNyaWEgdW0gcmFzdGVyIGRhIGRpcmXDp8OjbyBkZSBmbHV4byBkZSBjYWRhIGPDqWx1bGEgYXTDqSBvIHZpemluaG8gZGUgbWFpb3IgZGVjbGl2aWRhZGUuXCIsXG5cdFx0Zmxvd0RpcmVjdGlvbkRlc2M6IFwiVW1hIGRhcyBjaGF2ZXMgcGFyYSBkZXJpdmFyIGNhcmFjdGVyw61zdGljYXMgaGlkcm9sw7NnaWNhcyBkZSB1bWEgc3VwZXJmw61jaWUgw6kgYSBoYWJpbGlkYWRlIGRlIGRldGVybWluYXIgYSBkaXJlw6fDo28gZGUgZmx1eG8gZGUgY2FkYSBwaXhlbCBubyByYXN0ZXIuIEEgZnVuw6fDo28gZGUgcmFzdGVyIERpcmXDp8OjbyBkZSBGbHV4byB1dGlsaXphIHVtYSBzdXBlcmbDrWNpZSBjb21vIGVudHJhZGEgZSBjcmlhIHVtIHJhc3RlciBkZSBkaXJlw6fDo28gZGUgZmx1eG8gYSBwYXJ0aXIgZGUgY2FkYSBwaXhlbCBwYXJhIHNldSB2aXppbmhvIGRlIGRlY2xpdmlkYWRlIG1haXMgw61uZ3JlbWUuIEEgZnVuw6fDo28gRGlyZcOnw6NvIGRlIEZsdXhvIHN1cG9ydGEgdHLDqnMgbcOpdG9kb3MgZGUgbW9kZWxhZ2VtIGRlIGZsdXhvOiBvIEQ4IChvaXRvIGRpcmXDp8O1ZXMpLCBEaXJlw6fDo28gZGUgRmx1eG8gTcO6bHRpcGxvIChNRkQpLCBlIEQtSW5maW5pdHkgKERJTkYpLiBcIixcblx0XHRmbG93RGlzdGFuY2VOYW1lOiBcIkRpc3TDom5jaWEgZG8gRmx1eG9cIixcblx0XHRmbG93RGlzdGFuY2VTbmlwOiBcIkNhbGN1bGEsIHBhcmEgY2FkYSBjw6lsdWxhLCBhIGRpc3TDom5jaWEgdmVydGljYWwgb3UgaG9yaXpvbnRhbCBtw61uaW1hIGRlIGRlY2xpdmlkYWRlIHBhcmEgY8OpbHVsYXMgZW0gdW0gZmx1eG8gb3UgcmlvIG5vIHF1YWwgZmx1ZW0uXCIsXG5cdFx0Zmxvd0Rpc3RhbmNlRGVzYzogXCJQYXJhIGNhZGEgcGl4ZWwsIGEgZnVuw6fDo28gaXLDoSBjYWxjdWxhciBhIGRpc3TDom5jaWEgbcOtbmltYSB2ZXJ0aWNhbCBvdSBob3Jpem9udGFsIGRlIGRlY2xpdmlkYWRlIHBhcmEgcGl4ZWxzIGVtIHVtIGZsdXhvIG91IHJpbyBlbSBlbGVzIGZsdWVtLiBTZSB1bSByYXN0ZXIgZGUgZGlyZcOnw6NvIGRlIGZsdXhvIG9wY2lvbmFsIGZvciBmb3JuZWNpZG8sIGEgZGlyZcOnw6NvIGRlIGRlY2xpdmlkYWRlIHNlcsOhIGxpbWl0YWRhIHBhcmEgb3MgZGVmaW5pZG9zIHBlbG8gcmFzdGVyIGRlIGRpcmXDp8OjbyBkZSBmbHV4byBkZSBlbnRyYWRhLiBBIHNhw61kYSDDqSB1bSByYXN0ZXIgZGUgZGlzdMOibmNpYSBkZSBmbHV4by5cIixcblx0XHRmb2NhbE5hbWU6IFwiRXN0YXTDrXN0aWNhIEZvY2FsXCIsXG5cdFx0Zm9jYWxTbmlwOiBcIkNhbGN1bGEgYSBlc3RhdMOtc3RpY2EgZm9jYWwgcGFyYSBjYWRhIHBpeGVsIGRlIHVtYSBpbWFnZW0gYmFzZWFkbyBlbSB1bWEgdml6aW5oYW7Dp2EgZm9jYWwgZGVmaW5pZGEuXCIsXG5cdFx0Zm9jYWxEZXNjOiBcIkEgZnVuw6fDo28gRXN0YXTDrXN0aWNhcyBGb2NhbCBjYWxjdWxhIGEgZXN0YXTDrXN0aWNhIGZvY2FsIGRlIGNhZGEgcGl4ZWwgYSBwYXJ0aXIgZGUgdW1hIGltYWdlbSBiYXNlYWRvIGVtIHVtYSB2aXppbmhhbsOnYSBmb2NhbCBkZWZpbmlkYS5cIixcblx0XHRnZW9tZXRyaWNOYW1lOiBcIkdlb23DqXRyaWNvXCIsXG5cdFx0Z2VvbWV0cmljU25pcDogXCJBdW1lbnRhIGEgcHJlY2lzw6NvIHBvc2ljaW9uYWwgZGUgdW0gY29uanVudG8gZGUgZGFkb3MgYW8gcmVwcmVzZW50YXIgYSBlbGV2YcOnw6NvLlwiLFxuXHRcdGdlb21ldHJpY0Rlc2M6IFwiQSBmdW7Dp8OjbyBHZW9tw6l0cmljYSBwcm9kdXogdW1hIGltYWdlbSBvcnRvcnJldGlmaWNhZGEgYmFzZWFkbyBlbSB1bWEgZGVmaW5pw6fDo28gZGUgc2Vuc29yIGUgdW0gbW9kZWxvIGRlIHRlcnJlbm8uIEF1bWVudGEgYSBwcmVjaXPDo28gcG9zaWNpb25hbCBkZSB1bSBjb25qdW50byBkZSBkYWRvcyBhbyByZXByZXNlbnRhciBhIGVsZXZhw6fDo28uXCIsXG5cdFx0Z3JheXNjYWxlTmFtZTogXCJFc2NhbGEgZGUgY2luemFcIixcblx0XHRncmF5c2NhbGVTbmlwOiBcIkNvbnZlcnRlIHVtYSBpbWFnZW0gZGUgYmFuZGEgbcO6bHRpcGxhIGVtIHVtYSBpbWFnZW0gZGUgZXNjYWxhIGRlIGNpbnphIGRlIMO6bmljYSBiYW5kYS5cIixcblx0XHRncmF5c2NhbGVEZXNjOiBcIkVzdGEgZnVuw6fDo28gY29udmVydGUgdW1hIGltYWdlbSBkZSBtw7psdGlwbGFzIGJhbmRhcyBlbSB1bWEgaW1hZ2VtIGRlIGVzY2FsYSBkZSBjaW56YSBkZSDDum5pY2EgYmFuZGEuPGRpdj48YnIvPkVzdGEgZnVuw6fDo28gc2UgYXBsaWNhIGVtIHBlc29zIGVzcGVjaWZpY2Fkb3MgcGFyYSBjYWRhIGJhbmRhIGRlIGVudHJhZGEgZSBub3JtYWxpemEgYSBpbWFnZW0gZGUgc2HDrWRhLiBPcyBwZXNvcyBlc3TDo28gZnJlcXVlbnRlbWVudGUgYXBsaWNhZG9zIGRldmlkbyBhbGd1bWFzIGJhbmRhcyB0ZXJlbSBpbXBvcnTDom5jaWEgZGUgdmFyacOhdmVsIGRlcGVuZGVuZG8gZG8gYXBsaWNhdGl2by4gUG9yIGV4ZW1wbG8sIGEgYmFuZGEgYXp1bCBmcmVxdWVudGVtZW50ZSBjb250w6ltIG1haXMgcnXDrWRvIHF1ZSBvdXRyYXMgYmFuZGFzLjwvZGl2PlwiLFxuXHRcdGdyZWF0ZXJUaGFuRXF1YWxOYW1lOiBcIk1haW9yIHF1ZSBJZ3VhbFwiLFxuXHRcdGdyZWF0ZXJUaGFuRXF1YWxTbmlwOiBcIkV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gbWFpb3ItcXVlLWlndWFsLWEgUmVsYWNpb25hbCBlbSBkdWFzIGVudHJhZGFzIGVtIHVtYSBiYXNlIGPDqWx1bGEgYSBjw6lsdWxhLiBSZXRvcm5hIDEgcGFyYSBjw6lsdWxhcyBvbmRlIHVtIHJhc3RlciDDqSBtYWlvciBxdWUgb3UgaWd1YWwgYW8gc2VndW5kbyByYXN0ZXIgZSAwIHNlIG7Do28gZm9yIG1haW9yLlwiLFxuXHRcdGdyZWF0ZXJUaGFuRXF1YWxEZXNjOiBcIkEgZnVuw6fDo28gZXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBtYWlvci1xdWUtb3UtaWd1YWwtYSBSZWxhY2lvbmFsIGVtIGR1YXMgZW50cmFkYXMgZW0gdW1hIGJhc2UgcGl4ZWwgYSBwaXhlbC4gUmV0b3JuYSB1bSB2YWxvciBkZSAxIHBhcmEgcGl4ZWxzIG9uZGUgbyBwcmltZWlybyByYXN0ZXIgw6kgbWFpb3IgcXVlIG8gc2VndW5kbyByYXN0ZXIgZSB1bSB2YWxvciBkZSAwIHBhcmEgcGl4ZWxzIG9uZGUgbyBwcmltZWlybyByYXN0ZXIgbsOjbyDDqSBtYWlvciBvdSBpZ3VhbCBhbyBzZWd1bmRvIHJhc3Rlci5cIixcblx0XHRncmVhdGVyVGhhbk5hbWU6IFwiTWFpb3IgUXVlXCIsXG5cdFx0Z3JlYXRlclRoYW5TbmlwOiBcIkV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gbWFpb3ItcXVlIFJlbGFjaW9uYWwgZW0gZHVhcyBlbnRyYWRhcyBlbSB1bWEgYmFzZSBjw6lsdWxhIGEgY8OpbHVsYS4gUmV0b3JuYSAxIHBhcmEgY8OpbHVsYXMgZW0gcXVlIG8gcHJpbWVpcm8gZGFkbyByYXN0ZXIgw6kgbWFpb3IgcXVlIG8gc2VndW5kbyBlIDAgcGFyYSBjw6lsdWxhcyBlbSBuw6NvIMOpLlwiLFxuXHRcdGdyZWF0ZXJUaGFuRGVzYzogXCJBIGZ1bsOnw6NvIGV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gbWFpb3ItcXVlIFJlbGFjaW9uYWwgZW0gZHVhcyBlbnRyYWRhcyBlbSB1bWEgYmFzZSBwaXhlbCBhIHBpeGVsLiBSZXRvcm5hIHVtIHZhbG9yIGRlIDEgcGFyYSBwaXhlbHMgb25kZSBvIHByaW1laXJvIHJhc3RlciDDqSBtYWlvciBxdWUgbyBzZWd1bmRvIHJhc3RlciBlIHVtIHZhbG9yIGRlIDAgcGFyYSBwaXhlbHMgb25kZSBvIHByaW1laXJvIHJhc3RlciBuw6NvIMOpIG1haW9yIHF1ZSBvIHNlZ3VuZG8gcmFzdGVyLlwiLFxuXHRcdGhlYXRJbmRleE5hbWU6IFwiw41uZGljZSBkZSBBcXVlY2ltZW50b1wiLFxuXHRcdGhlYXRJbmRleFNuaXA6IFwiQ29tYmluYSB0ZW1wZXJhdHVyYSBkbyBhbWJpZW50ZSBlIHVtaWRhZGUgcmVsYXRpdmEgw6AgdW1pZGFkZSBwYXJhIHJldG9ybmFyIHVtYSB0ZW1wZXJhdHVyYSBhcGFyZW50ZS5cIixcblx0XHRoZWF0SW5kZXhEZXNjOiBcIkVzdGEgZnVuw6fDo28gY2FsY3VsYSBhIHRlbXBlcmF0dXJhIGFwYXJlbnRlIGJhc2VhZG8gbmEgdGVtcGVyYXR1cmEgYW1iaWVudGUgZSB1bWlkYWRlIHJlbGF0aXZhLiBBIHRlbXBlcmF0dXJhIGFwYXJlbnRlIMOpIGZyZXF1ZW50ZW1lbnRlIGRlc2NyaXRhIGNvbW8gcXXDo28gcXVlbnRlIGVsZSDDqSBwYXJhIG8gY29ycG8gaHVtYW5vLjxkaXY+PGJyLz5Fc3RlIMOtbmRpY2UgcG9kZSBzZXIgw7p0aWwgcGFyYSBjYWxjdWxhciBvcyBwZXJpZ29zIHJlbGFjaW9uYWRvcyBwYXJhIHByb2JsZW1hcyBtw6lkaWNvcyBjb21vIGPDo2licmFzIG11c2N1bGFyZXMsIGRlc2lkcmF0YcOnw6NvLCBleGF1c3TDo28gZGUgY2Fsb3Igb3UgaW5zb2xhw6fDo28gbWFpcyBzw6lyaWEgZW0gZGlhcyBxdWVudGVzIGUgw7ptaWRvcy4gUXVhbmRvIGEgdW1pZGFkZSByZWxhdGl2YSBlc3RpdmVyIGFsdGEsIGVsYSBzZSB0b3JuYSBtYWlzIGRpZsOtY2lsIHBhcmEgbyBzdW9yIGRvIGNvcnBvIGV2YXBvcmFyLCBkZWl4YW5kbyBpbmRpdsOtZHVvcyBzZW0gdW0gY2FtaW5obyBuYXR1cmFsIGVmZXRpdm8gcGFyYSBzZSByZWZyZXNjYXIuIE1hcGFzIGRlIGFxdWVjaW1lbnRvIG91IGF2aXNvcyBzw6NvIGZyZXF1ZW50ZW1lbnRlIHVtIHByb2R1dG8gZGUgcmVjbGFzc2lmaWNhw6fDo28gZG8gcmVzdWx0YWRvIGRlIMOtbmRpY2UgZGUgYXF1ZWNpbWVudG8gZW0gY2xhc3Nlcywgb25kZSBxdWFudG8gbWFpb3IgbyB2YWxvciBkZSDDrW5kaWNlLCBtYWlzIHByb3bDoXZlbCBkZWxlIHNlIHRvcm5hciB1bSBhbGVydGEgYW8gaW52w6lzIGRlIGFwZW5hcyB1bSBhdmlzby48L2Rpdj5cIixcblx0XHRoaWxsc2hhZGVOYW1lOiBcIlJlbGV2byBTb21icmVhZG9cIixcblx0XHRoaWxsc2hhZGVTbmlwOiBcIkNyaWEgdW1hIHJlcHJlc2VudGHDp8OjbyAzRCBkYSBzdXBlcmbDrWNpZSwgbGV2YW5kbyBlbSBjb250YSBhIHBvc2nDp8OjbyByZWxhdGl2YSBkbyBzb2wgcGFyYSBzb21icmVhbWVudG8gZGEgaW1hZ2VtLlwiLFxuXHRcdGhpbGxzaGFkZURlc2M6IFwiQSBmdW7Dp8OjbyBSZWxldm8gU29tYnJlYWRvIHByb2R1eiB1bWEgcmVwcmVzZW50YcOnw6NvIDNEIGRhIHN1cGVyZsOtY2llIGRvIHRlcnJlbm8gZW0gZXNjYWxhIGRlIGNpbnphLCBsZXZhbmRvIGVtIGNvbnRhIGEgcG9zacOnw6NvIHJlbGF0aXZhIGRvIFNvbCBwYXJhIHNvbWJyZWFtZW50byBkYSBpbWFnZW0uIDxkaXY+PGJyLz5PIFJlbGV2byBTb21icmVhZG8gw6kgdW1hIHTDqWNuaWNhIHBhcmEgdmlzdWFsaXphciBvIHRlcnJlbm8gZGV0ZXJtaW5hZG8gcG9yIHVtYSBmb250ZSBkZSBsdXosIGUgYSBkZWNsaXZpZGFkZSBlIGFzcGVjdG8gZGEgc3VwZXJmw61jaWUgZGUgZWxldmHDp8Ojby4gw4kgdW0gbcOpdG9kbyBxdWFsaXRhdGl2byBwYXJhIHZpc3VhbGl6YXIgdG9wb2dyYWZpYSBlIG7Do28gZm9ybmVjZSB2YWxvcmVzIGRlIGVsZXZhw6fDo28gYWJzb2x1dG9zLiA8L2Rpdj5cIixcblx0XHRpbnROYW1lOiBcIkludFwiLFxuXHRcdGludFNuaXA6IFwiQ29udmVydGUgY2FkYSB2YWxvciBkYSBjw6lsdWxhIGRlIHVtIHJhc3RlciBwYXJhIHVtIG7Dum1lcm8gaW50ZWlybyB1dGlsaXphbmRvIGEgZnVuw6fDo28gVHJ1bmNhci5cIixcblx0XHRpbnREZXNjOiBcIkEgZnVuw6fDo28gSW50IGNvbnZlcnRlIGNhZGEgdmFsb3IgZGEgcGl4ZWwgZGUgdW0gcmFzdGVyIHBhcmEgdW0gbsO6bWVybyBpbnRlaXJvIHBvciB0cnVuY2FtZW50by5cIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFOYW1lOiBcIkludGVycG9sYXIgRGFkb3MgSXJyZWd1bGFyZXNcIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFTbmlwOiBcIkludGVycG9sYSBkZSBudXZlbnMgZGUgcG9udG8gb3UgZ3JhZGVzIGlycmVndWxhcmVzLlwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YURlc2M6IFwiQWxndW5zIGNvbmp1bnRvcyBkZSBkYWRvcyBuZXRDREYgb3UgSERGIGFybWF6ZW5hbSBzdWEgbG9jYWxpemHDp8OjbyBnZW9ncsOhZmljYSBjb21vIGNvbmp1bnRvcyBpcnJlZ3VsYXJtZW50ZSBlc3Bhw6dhZG9zIGRlIHBpeGVscyBvdSBkYWRvcyBkZSBwb250b3MuIEFvIGFkaWNpb25hciBlc3RlcyBjb25qdW50byBkZSBkYWRvcyBwYXJhIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGRvIG1vc2FpY28sIGEgZnVuw6fDo28gaXJyZWd1bGFyIGludGVycG9sYXIgZGFkb3MgdXRpbGl6YSBhIGlycmVndWxhcm1lbnRlIGRvcyBkYWRvcyBkYSBncmFkZSBlIG9zIHJlYW1vc3RyYSBkZSBmb3JtYSBxdWUgY2FkYSBwaXhlbCBzZWphIGRlIHRhbWFuaG8gdW5pZm9ybWUgZSBzZWphIHF1YWRyYWRvLjxkaXY+PGJyLz5BbyBhZGljaW9uYXIgdmFyacOhdmVpcyBkZSBuZXRDREYgb3UgSERGIGEgdW0gY29uanVudG8gZGUgZGFkb3MgZGUgbW9zYWljbywgZWxhIHZlcmlmaWNhcsOhIGF1dG9tYXRpY2FtZW50ZSBzZSBvcyBkYWRvcyBlc3TDo28gZGlzcG9zdG9zIHJlZ3VsYXJtZW50ZS4gQ2FzbyBjb250csOhcmlvLCBhIGZ1bsOnw6NvIEludGVycG9sYXIgRGFkb3MgSXJyZWd1bGFyZXMgcG9kZSBzZXIgdXRpbGl6YWRhIHBhcmEgY29udmVydGVyIG9zIGRhZG9zIGlycmVndWxhcmVzIGVtIHVtIHJhc3RlciBkZSBncmFkZSByZWd1bGFyLiBWb2PDqiBwb2RlIGFsdGVyYXIgbyBtw6l0b2RvIGRlIGludGVycG9sYcOnw6NvIGUgbyB0YW1hbmhvIGRhIGPDqWx1bGEgdXRpbGl6YWRvcyBuYSBmdW7Dp8OjbyBJbnRlcnBvbGFyIERhZG9zIElycmVndWxhcmVzIGRvIHJhc3Rlci4gUGFyYSBkYWRvcyByYXN0ZXIgZGUgZXNwYcOnYW1lbnRvIHJlZ3VsYXIsIG5lbmh1bWEgaW50ZXJwb2xhw6fDo28gc2Vyw6EgYXBsaWNhZGEgZSBvcyBkYWRvcyBzZXLDo28gbGlkb3MgY29tbyBlc3TDo28uPC9kaXY+XCIsXG5cdFx0aXNOdWxsTmFtZTogXCJOdWxvXCIsXG5cdFx0aXNOdWxsU25pcDogXCJEZXRlcm1pbmEgcXVhaXMgdmFsb3JlcyBkb3MgcmFzdGVycyBkZSBlbnRyYWRhIHPDo28gZGUgTm9EYXRhIGVtIHVtYSBiYXNlIGRlIGPDqWx1bGEgYSBjw6lsdWxhLiBSZXRvcm5hIHVtIHZhbG9yIGRlIDEgc2Ugb3MgdmFsb3JlcyBkZSBlbnRyYWRhIGZvciBOb0RhdGEgZSAwIHBhcmEgY8OpbHVsYXMgcXVlIG7Do28gZm9yZW0uXCIsXG5cdFx0aXNOdWxsRGVzYzogXCJBIGZ1bsOnw6NvIMOJIE51bG8gZGV0ZXJtaW5hIHF1YWlzIHZhbG9yZXMgZG8gcmFzdGVyIGRlIGVudHJhZGEgc8OjbyBOb0RhdGEgZW0gdW1hIGJhc2UgZGUgcGl4ZWwgZSBwaXhlbC4gUmV0b3JuYSB1bSB2YWxvciBkZSAxIHNlIG8gdmFsb3IgZGUgZW50cmFkYSBmb3IgTm9EYXRhIGUgbyB2YWxvciBkZSAwIHBhcmEgcGl4ZWxzIHF1ZSBuw6NvIHPDo28gTm9EYXRhLlwiLFxuXHRcdGtlcm5lbERlbnNpdHlOYW1lOiBcIkRlbnNpZGFkZSBkZSBLZXJuZWxcIixcblx0XHRrZXJuZWxEZW5zaXR5U25pcDogXCJDYWxjdWxhIHVtYSDDoXJlYSBkZSBtYWduaXR1ZGUgcG9yIHVuaWRhZGUgYSBwYXJ0aXIgZGFzIGZlacOnw7VlcyBkZSBwb2xpbGluaGEgb3UgbGluaGEgdXRpbGl6YW5kbyB1bWEgZnVuw6fDo28gZGUgS2VybmVsIHBhcmEgYWp1c3RhciB1bWEgc3VwZXJmw61jaWUgc3VhdmVtZW50ZSBjb2JlcnRhIHBhcmEgY2FkYSBwb2xpbGluaGEgb3UgcG9udG8uXCIsXG5cdFx0a2VybmVsRGVuc2l0eURlc2M6IFwiRXN0YSBmdW7Dp8OjbyBjYWxjdWxhIHVtYSDDoXJlYSBkZSB1bmlkYWRlIHBvciBtYWduaXR1ZGUgYSBwYXJ0aXIgZGUgZmVpw6fDtWVzIGRlIHBvbnRvIG91IGRlIHBvbGlsaW5oYSB1dGlsaXphbmRvIHVtYSBmdW7Dp8OjbyBkZSBrZXJuZWwgcGFyYSBhanVzdGFyIHVtYSBzdXBlcmbDrWNpZSBzdWF2ZW1lbnRlIGNvYmVydGEgcGFyYSBjYWRhIHBvbnRvIG91IHBvbGlsaW5oYS5cIixcblx0XHRrZXlNZXRhZGF0YU5hbWU6IFwiUHJpbmNpcGFpcyBNZXRhZGFkb3NcIixcblx0XHRrZXlNZXRhZGF0YVNuaXA6IFwiU3Vic3RpdHVpIG91IGluc2VyZSBtZXRhZGFkb3MtY2hhdmVzIGRlIHVtIHJhc3RlciBlbSB1bWEgY2FkZWlhIGRlIGZ1bsOnw6NvLlwiLFxuXHRcdGtleU1ldGFkYXRhRGVzYzogXCJFc3RhIGZ1bsOnw6NvIHBlcm1pdGUgcXVlIHZvY8OqIGluc2lyYSBvdSBzdWJzdGl0dWEgbWV0YWRhZG9zIGNoYXZlcyBkZSB1bWEgcmFzdGVyLjxkaXY+PGJyLz5BcyBpbmZvcm1hw6fDtWVzIG5vcyBtZXRhZGFkb3MgY2hhdmUgw6kgdXRpbGl6YWRvIHBhcmEgYWp1ZGFyIG8gYXBsaWNhdGl2byBjb20gYWxndW0gcHJvY2Vzc2FtZW50byBlIHJlbmRlcml6YcOnw6NvLCBpbmNsdWluZG8gZm9ybmVjZXIgYWxndW1hcyBpbmZvcm1hw6fDtWVzIMO6dGVpcyBjb21vIG8gbm9tZSBkbyBzZW5zb3IsIG5vbWVzIGRlIGJhbmRhcyBvdSBjb2JlcnR1cmEgZGUgbnV2ZW0gYXNzb2NpYWRvIGNvbSBhIGltYWdlbS48L2Rpdj5cIixcblx0XHRzaG9ydGVzdFBhdGhOYW1lOiBcIkNhbWluaG9zIGRlIE1lbm9yIEN1c3RvXCIsXG5cdFx0c2hvcnRlc3RQYXRoU25pcDogXCJFeGVjdXRhIHVtYSBhbsOhbGlzZSBkYSBkaXN0w6JuY2lhIGRlIGN1c3RvIHV0aWxpemFuZG8gZW50cmFkYXMgZGUgb3JpZ2VtIGUgZGVzdGlubywgcXVlIHPDo28gdXRpbGl6YWRhcyBwYXJhIGRldGVybWluYXIgbyBjYW1pbmhvIGRlIG1lbm9yIGN1c3RvIGRlIHVtYSBvcmlnZW0gYXTDqSB1bSBkZXN0aW5vLlwiLFxuXHRcdHNob3J0ZXN0UGF0aERlc2M6IFwiQSBmdW7Dp8OjbyBDYW1pbmhvIGRlIE1lbm9yIEN1c3RvIGdsb2JhbCBjYWxjdWxhIG8gY2FtaW5obyBkZSBtZW5vciBjdXN0byBhIHBhcnRpciBkZSB1bWEgb3JpZ2VtIGF0w6kgdW0gZGVzdGluby4gQSBkaXN0w6JuY2lhIGRlIG1lbm9yIGN1c3RvIGFjdW11bGF0aXZvIMOpIGNhbGN1bGFkbyBwYXJhIGNhZGEgcGl4ZWwgc29icmUgdW1hIHN1cGVyZsOtY2llIGRlIGN1c3RvLCBwYXJhIGEgb3JpZ2VtIG1haXMgcHLDs3hpbWEuIEVzdGEgZnVuw6fDo28gcHJvZHV6IHVtIHJhc3RlciBkZSBzYcOtZGEgcXVlIHJlZ2lzdHJhIG8gY2FtaW5obyBtZW5vciBjdXN0byBvdSBjYW1pbmhvcyBkZSBsb2NhbGl6YcOnw7VlcyBzZWxlY2lvbmFkYXMgcGFyYSBvcyBwaXhlbHMgZGUgb3JpZ2VtIG1haXMgcHLDs3hpbW9zIGRlZmluaWRvcyBkZW50cm8gZGEgc3VwZXJmw61jaWUgZGUgY3VzdG8gYWN1bXVsYXRpdm8sIGVtIHRlcm1vcyBkZSBkaXN0w6JuY2lhIGRlIGN1c3RvLjxkaXY+PGJyLz5DYWRhIGNhbWluaG8gZGUgbWVub3IgY3VzdG8gw6kgYXRyaWJ1w61kbyB1bSB2YWxvciBxdWFuZG8gZW5jb250cm91IG5vIHByb2Nlc3NvIGRlIGVzY2FuZWFtZW50by4gTyBwaXhlbCBmaW5hbCBubyBSYXN0ZXIgZGUgT3JpZ2VtIGRlIHVtIGNhbWluaG8gZGUgY3VzdG8gcmVjZWJlIHVtIHZhbG9yIGRlIDEuIE8gcHJpbWVpcm8gY2FtaW5obyByZWNlYmUgdW0gdmFsb3IgZGUgMywgbyBzZWd1bmRvIDQgZSBhc3NpbSBwb3IgZGlhbnRlLiBRdWFuZG8gY2FtaW5ob3MgbcO6bHRpcGxvcyBzZSBqdW50YW0gZSBzZWd1ZW0gYSBkaXN0w6JuY2lhIHJlc3RhbnRlIGRlIHZvbHRhIHBhcmEgdW1hIG9yaWdlbSBuYSBtZXNtYSByb3RhLCBvIHNlZ21lbnRvIG9uZGUgb3MgZG9pcyBjYW1pbmhvcyB2aWFqYW0ganVudG9zIMOpIGF0cmlidcOtZG8gdW0gdmFsb3IgZGUgMi4gQSBwb3LDp8OjbyBqdW50YWRhIGRvIGNhbWluaG8gbsOjbyBwb2RlIHNlciBhdHJpYnXDrWRvIGFvIHZhbG9yIGRlIHVtIGRvcyBjYW1pbmhvcywgasOhIHF1ZSBhIHBvcsOnw6NvIGp1bnRhZGEgcGVydGVuY2UgYSBhbWJhcyBhcyByb3Rhcy48L2Rpdj5cIixcblx0XHRsZXNzVGhhbkVxdWFsTmFtZTogXCJNZW5vciBxdWUgSWd1YWxcIixcblx0XHRsZXNzVGhhbkVxdWFsU25pcDogXCJFeGVjdXRhIHVtYSBvcGVyYcOnw6NvIG1lbm9yLXF1ZS1vdS1pZ3VhbC1hIFJlbGFjaW9uYWwgZW0gZHVhcyBlbnRyYWRhcyBlbSB1bWEgYmFzZSBjw6lsdWxhIGEgY8OpbHVsYS4gUmV0b3JuYSAxIHBhcmEgY8OpbHVsYXMgb25kZSBvIHByaW1laXJvIHJhc3RlciBmb3IgbWVub3Igb3UgaWd1YWwgYW8gc2VndW5kbyByYXN0ZXIgZSAwIG9uZGUgbsOjbyBmb3IgbWFpb3IuXCIsXG5cdFx0bGVzc1RoYW5FcXVhbERlc2M6IFwiQSBmdW7Dp8OjbyBleGVjdXRhIHVtYSBvcGVyYcOnw6NvIG1lbm9yLXF1ZS1vdS1pZ3VhbC1hIFJlbGFjaW9uYWwgZW0gZHVhcyBlbnRyYWRhcyBlbSB1bWEgYmFzZSBwaXhlbCBhIHBpeGVsLiBSZXRvcm5hIHVtIHZhbG9yIGRlIDEgcGFyYSBwaXhlbHMgb25kZSBvIHByaW1laXJvIHJhc3RlciDDqSBtZW5vciBvdSBpZ3VhbCBhbyBzZWd1bmRvIHJhc3RlciBlIHVtIHZhbG9yIGRlIDAgb25kZSBlbGUgbsOjbyDDqSBtZW5vciBvdSBpZ3VhbCBhbyBzZWd1bmRvIHJhc3Rlci5cIixcblx0XHRsZXNzVGhhbk5hbWU6IFwiTWVub3IgUXVlXCIsXG5cdFx0bGVzc1RoYW5TbmlwOiBcIkV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gbWVub3ItcXVlIFJlbGFjaW9uYWwgZW0gZHVhcyBlbnRyYWRhcyBlbSB1bWEgYmFzZSBjw6lsdWxhIGEgY8OpbHVsYS4gUmV0b3JuYSAxIHBhcmEgY8OpbHVsYXMgb25kZSBvIHByaW1laXJvIHJhc3RlciDDqSBtZW5vciBxdWUgbyBzZWd1bmRvIHJhc3RlciBlIDAgc2UgbsOjbyBmb3IuXCIsXG5cdFx0bGVzc1RoYW5EZXNjOiBcIkEgZnVuw6fDo28gZXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBtZW5vci1xdWUgUmVsYWNpb25hbCBlbSBkdWFzIGVudHJhZGFzIGVtIHVtYSBiYXNlIHBpeGVsIGEgcGl4ZWwuIFJldG9ybmEgdW0gdmFsb3IgZGUgMSBwYXJhIHBpeGVscyBvbmRlIG8gcHJpbWVpcm8gcmFzdGVyIMOpIG1lbm9yIHF1ZSBvIHNlZ3VuZG8gcmFzdGVyIGUgdW0gdmFsb3IgZGUgMCBzZSBlbGUgbsOjbyBmb3IgbWVub3IgcXVlIG8gc2VndW5kbyByYXN0ZXIuXCIsXG5cdFx0bG5OYW1lOiBcIkxuXCIsXG5cdFx0bG5TbmlwOiBcIkNhbGN1bGEgbyBsb2dhcml0bW8gbmF0dXJhbCAoYmFzZSBlKSBkZSBjw6lsdWxhcyBlbSB1bSByYXN0ZXIuXCIsXG5cdFx0bG5EZXNjOiBcIkEgZnVuw6fDo28gTG4gY2FsY3VsYSBvIGxvZ2FyaXRtbyBuYXR1cmFsIChiYXNlIGUpIGRlIGNhZGEgcGl4ZWwgZW0gdW0gcmFzdGVyLlwiLFxuXHRcdGxvZzEwTmFtZTogXCJMb2cxMFwiLFxuXHRcdGxvZzEwU25pcDogXCJDYWxjdWxhIGEgYmFzZSBkZSBsb2dhcml0bW8gMTAgZGFzIGPDqWx1bGFzIGVtIHVtIHJhc3Rlci5cIixcblx0XHRsb2cxMERlc2M6IFwiQSBmdW7Dp8OjbyBMb2cxMCBjYWxjdWxhIGEgYmFzZSBkZSBsb2dhcml0bW8gMTAgZGUgY2FkYSBwaXhlbCBlbSB1bSByYXN0ZXIuXCIsXG5cdFx0bG9nMk5hbWU6IFwiTG9nMlwiLFxuXHRcdGxvZzJTbmlwOiBcIkNhbGN1bGEgYSBiYXNlIGRlIGxvZ2FyaXRtbyAyIGRhcyBjw6lsdWxhcyBlbSB1bSByYXN0ZXIuXCIsXG5cdFx0bG9nMkRlc2M6IFwiQSBmdW7Dp8OjbyBMb2cyIGNhbGN1bGEgYSBiYXNlIGRlIGxvZ2FyaXRtbyAyIGRlIGNhZGEgcGl4ZWwgZW0gdW0gcmFzdGVyLlwiLFxuXHRcdGxvb2t1cE5hbWU6IFwiUGVzcXVpc2FyXCIsXG5cdFx0bG9va3VwU25pcDogXCJDcmlhIHVtIG5vdm8gcmFzdGVyIHBlc3F1aXNhbmRvIHZhbG9yZXMgZW5jb250cmFkb3MgZW0gb3V0cm8gY2FtcG8gbmEgdGFiZWxhIGRvIHJhc3RlciBkZSBlbnRyYWRhLlwiLFxuXHRcdGxvb2t1cERlc2M6IFwiQSBmdW7Dp8OjbyBjcmlhIHVtIG5vdm8gcmFzdGVyIHBlc3F1aXNhbmRvIHZhbG9yZXMgZW5jb250cmFkb3MgZW0gb3V0cm8gY2FtcG8gbmEgdGFiZWxhIGRvIHJhc3RlciBkZSBlbnRyYWRhXCIsXG5cdFx0bWxDbGFzc2lmeU5hbWU6IFwiQ2xhc3NpZmljYcOnw6NvIE1MXCIsXG5cdFx0bWxDbGFzc2lmeVNuaXA6IFwiQ2xhc3NpZmljYSBhIGltYWdlbSB1dGlsaXphbmRvIHVtYSBhYm9yZGFnZW0gcG9yIHBpeGVsLiBPcyBwaXhlbHMgbWlzdHVyYWRvcyBzw6NvIGF0cmlidcOtZG9zIHBhcmEgYSBmZWnDp8OjbyBjb20gYSBwb3JjZW50YWdlbSBtYWlzIGFsdGEgbmVzdGUgcGl4ZWwuXCIsXG5cdFx0bWxDbGFzc2lmeURlc2M6IFwiQSBmdW7Dp8OjbyBDbGFzc2lmaWNhw6fDo28gTUwgcGVybWl0ZSBhIHZvY8OqIGV4ZWN1dGFyIHVtYSBjbGFzc2lmaWNhw6fDo28gc3VwZXJ2aXNpb25hZGEgdXRpbGl6YW5kbyBvIGFsZ29yaXRtbyBkZSBjbGFzc2lmaWNhw6fDo28gZGUgbcOheGltYSBwcm9iYWJpbGlkYWRlLCBlbSB1bSBjb25qdW50byBkZSBkYWRvcyByYXN0ZXIgb3UgY29uanVudG8gZGUgZGFkb3MgZG8gbW9zYWljby4gRXN0YSBmdW7Dp8OjbyBleGlnZSB1bSBhcnF1aXZvIGRlIGFzc2luYXR1cmEgZGUgY2xhc3NpZmljYcOnw6NvLlwiLFxuXHRcdG1hc2tOYW1lOiBcIk3DoXNjYXJhXCIsXG5cdFx0bWFza1NuaXA6IFwiQ29uZmlndXJhIG9zIHZhbG9yZXMgcXVlIHZvY8OqIG7Do28gZGVzZWphIGV4aWJpci5cIixcblx0XHRtYXNrRGVzYzogXCJFc3RhIGZ1bsOnw6NvIGRlIHJhc3RlciBkZWZpbmUgb3MgdmFsb3JlcyBxdWUgdm9jw6ogbsOjbyBkZXNlamEgcGFyYSBleGliaXIgZW0gc2V1IHJhc3Rlci4gQ29tIGEgdXRpbGl6YcOnw6NvIGRhIGZ1bsOnw6NvIE1hc2NhcmFyLCB2b2PDqiBlc3BlY2lmaWNhcsOhIHVtIG91IG1haXMgdmFsb3JlcyBOb0RhdGEgb3UgdW1hIGZhaXhhIGRlIHZhbG9yZXMgZGUgcGl4ZWxzIHbDoWxpZGFzLiBcIixcblx0XHRtaW51c05hbWU6IFwiU3VidHJhaXJcIixcblx0XHRtaW51c1NuaXA6IFwiU3VidHJhaSBvIHZhbG9yIGRvIHNlZ3VuZG8gcmFzdGVyIGRlIGVudHJhZGEgZG8gdmFsb3IgZG8gcHJpbWVpcm8gcmFzdGVyIGRlIGVudHJhZGEgZW0gdW1hIGJhc2UgZGUgY8OpbHVsYSBwb3IgY8OpbHVsYS5cIixcblx0XHRtaW51c0Rlc2M6IFwiQSBmdW7Dp8OjbyBNZW5vcyBzdWJ0cmFpIG8gdmFsb3IgZG8gc2VndW5kbyByYXN0ZXIgZGUgZW50cmFkYSBkbyB2YWxvciBkbyBwcmltZWlybyByYXN0ZXIgZGUgZW50cmFkYSBlbSB1bWEgYmFzZSBkZSBwaXhlbCBhIHBpeGVsLlwiLFxuXHRcdG1vZE5hbWU6IFwiTW9kXCIsXG5cdFx0bW9kU25pcDogXCJFbmNvbnRyYSBvIHJlbWFuZXNjZW50ZSAobcOzZHVsbykgZG8gcHJpbWVpcm8gcmFzdGVyIHF1YW5kbyBkaXZpZGlkbyBwZWxvIHNlZ3VuZG8gcmFzdGVyIGVtIHVtYSBiYXNlIGRlIGPDqWx1bGEgcG9yIGPDqWx1bGEuXCIsXG5cdFx0bW9kRGVzYzogXCJBIGZ1bsOnw6NvIE1vZCBsb2NhbGl6YSBvIHJlbWFuZXNjZW50ZSAobcOzZHVsbykgZG8gcHJpbWVpcm8gcmFzdGVyIHF1YW5kbyBkaXZpZGlkbyBwZWxvIHNlZ3VuZG8gcmFzdGVyIGVtIHVtYSBiYXNlIGRlIHBpeGVsIGEgcGl4ZWwuIEEgb3JkZW0gZGFzIGVudHJhZGFzIMOpIGltcG9ydGFudGUgZSBhZmV0YSBvIHJlc3VsdGFkbyBkZSBzYcOtZGEuXCIsXG5cdFx0bW9zYWljUmFzdGVyc05hbWU6IFwiUmFzdGVycyBkbyBNb3NhaWNvXCIsXG5cdFx0bW9zYWljUmFzdGVyc1NuaXA6IFwiTGlnYSBvcyBwb250b3MgZG9zIGNvbmp1bnRvcyBkZSBkYWRvcyByYXN0ZXJzIHBhcmEgY3JpYXIgdW0gY29uanVudG8gZGUgZGFkb3MuXCIsXG5cdFx0bW9zYWljUmFzdGVyc0Rlc2M6IFwiQSBmdW7Dp8OjbyBSYXN0ZXJzIGRvIE1vc2FpY28gY3JpYSB1bWEgaW1hZ2VtIGRlIG1vc2FpY28gYSBwYXJ0aXIgZGUgbcO6bHRpcGxhcyBpbWFnZW5zLiBRdWFuZG8gaG91dmVyIHNvYnJlcG9zacOnw6NvIGVudHJlIGFzIGltYWdlbnMsIGjDoSBkaXZlcnNvcyBtw6l0b2RvcyBxdWUgdm9jw6ogcG9kZSBlc2NvbGhlciBwYXJhIGRldGVybWluYXIgcXVhaXMgaW1hZ2VucyBzw6NvIGV4aWJpZGFzLlwiLFxuXHRcdG5kdmlDb2xvcml6ZWROYW1lOiBcIk5EVkkgQ29sb3JpemFkb1wiLFxuXHRcdG5kdmlDb2xvcml6ZWRTbmlwOiBcIkNyaWEgdW0gY29uanVudG8gZGUgZGFkb3MgZGUgbcO6bHRpcGxhcyBiYW5kYXMgcXVlIHJlcHJlc2VudGEgYSBzYcO6ZGUgZGUgdmVnZXRhw6fDo28sIGJhc2VhZG8gbmEgZGlmZXJlbsOnYSBlbnRyZSBhcyBiYW5kYXMgZG8gdmVybWVsaG8gZSBpbmZyYXZlcm1lbGhvIHByw7N4aW1hcy5cIixcblx0XHRuZHZpQ29sb3JpemVkRGVzYzogXCJBIGZ1bsOnw6NvIE5EVkkgQ29sb3JpemFkbyBhcGxpY2EgYSBmdW7Dp8OjbyBORFZJIG5hIGltYWdlbSBkZSBlbnRyYWRhIGUgZW50w6NvIHV0aWxpemEgdW0gbWFwYSBkZSBjb3JlcyBvdSByYW1wYSBkZSBjb3JlcyBwYXJhIGV4aWJpciBvIHJlc3VsdGFkby5cIixcblx0XHRuZHZpTmFtZTogXCJORFZJXCIsXG5cdFx0bmR2aVNuaXA6IFwiw41uZGljZSBkZSBWZWdldGHDp8OjbyBkZSBEaWZlcmVuw6dhIE5vcm1hbGl6YWRhIChORFZJKVwiLFxuXHRcdG5kdmlEZXNjOiBcIkEgZnVuw6fDo28gTkRWSSBjcmlhIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGRlIG3Dumx0aXBsYXMgYmFuZGFzIHF1ZSByZXByZXNlbnRhIGEgc2HDumRlIGRlIHZlZ2V0YcOnw6NvLCBiYXNlYWRvIG5hIGRpZmVyZW7Dp2EgZW50cmUgYXMgYmFuZGFzIGRvIHZlcm1lbGhvIGUgaW5mcmF2ZXJtZWxobyBwcsOzeGltYXMuPGRpdj48YnIvPk5EVkkgw6kgdW0gw61uZGljZSBwYWRyb25pemFkbyBwZXJtaXRpbmRvIGEgdm9jw6ogZ2VyYXIgdW1hIGltYWdlbSBleGliaW5kbyB2ZXJkZSwgY29uaGVjaWRvIHRhbWLDqW0gY29tbyBiaW9tYXNzYSByZWxhdGl2YS4gRXN0ZSDDrW5kaWNlIGFwcm92ZWl0YSBvIGNvbnRyYXN0ZSBkYXMgY2FyYWN0ZXLDrXN0aWNhcyBkZSBkdWFzIGJhbmRhcyBkZSB1bSBjb25qdW50byBkZSBkYWRvcyByYXN0ZXIgbXVsdGllc3BlY3RyYWw6IGFic29yw6fDtWVzIGRlIHBpZ21lbnRvIGRhIGNsb3JvZmlsYSBuYSBiYW5kYSB2ZXJtZWxoYSBlIGEgYWx0YSByZWZsZXRpdmlkYWRlIGRlIG1hdGVyaWFpcyB2ZWdldGFpcyBuYSBiYW5kYSBkZSBpbmZyYXZlcm1lbGhvIHByw7N4aW1vIChOSVIpLiBPcyB2YWxvcmVzIGRlIE5EVkkgZXh0cmVtYW1lbnRlIGJhaXhvcyBvdSBuZWdhdGl2b3MgcmVwcmVzZW50YW0gw6FyZWFzIHNlbSB2ZWdldGHDp8OjbywgdGFpcyBjb21vLCBudXZlbSwgw6FndWEgb3UgY2h1dmlzY28uIE9zIHZhbG9yZXMgbXVpdG8gYmFpeG9zIHJlcHJlc2VudGFtIMOhcmVhcyBkZSBwZXF1ZW5hcyBzZW0gdmVnZXRhw6fDo28sIHRhaXMgY29tbywgY29uY3JldG8sIHBlZHJhIG91IHNvbG8gYnJ1dG8uIE9zIHZhbG9yZXMgbW9kZXJhZG9zIHJlcHJlc2VudGFtIMOhcmVhcyBkZSBhcmJ1c3RvcyBlIHBhc3RhZ2Vucy4gT3MgdmFsb3JlcyBhbHRvcyByZXByZXNlbnRhbSDDoXJlYXMgZGUgZmxvcmVzdGEgZSB2ZWdldGHDp8OjbyBleHViZXJhbnRlLjwvZGl2PlwiLFxuXHRcdG5lZ2F0ZU5hbWU6IFwiTmVnYXRpdm9cIixcblx0XHRuZWdhdGVTbmlwOiBcIkFsdGVyYSBvIHNpbmFsIChtdWx0aXBsaWNhIHBvciAtMSkgZG9zIHZhbG9yZXMgZGUgY8OpbHVsYSBkbyByYXN0ZXIgZGUgZW50cmFkYSBlbSB1bWEgYmFzZSBkZSBjw6lsdWxhIHBvciBjw6lsdWxhLlwiLFxuXHRcdG5lZ2F0ZURlc2M6IFwiQSBmdW7Dp8OjbyBOZWdhdGl2byBhbHRlcmEgbyBzaW5hbCAobXVsdGlwbGljYSBwb3IgLTEpIGRvcyB2YWxvcmVzIGRlIHBpeGVsIGRvIHJhc3RlciBkZSBlbnRyYWRhIGVtIHVtIHBpeGVsIFwiLFxuXHRcdG5pYmJsZU5hbWU6IFwiRXh0cmFpciBwb3IgUGFydGVzXCIsXG5cdFx0bmliYmxlU25pcDogXCJTdWJzdGl0dWkgYXMgY8OpbHVsYXMgZGUgdW0gcmFzdGVyIGNvcnJlc3BvbmRlbmRvIMOgIG3DoXNjYXJhIGNvbSBvcyB2YWxvcmVzIGRvcyB2aXppbmhvcyBtYWlzIHByw7N4aW1vcy5cIixcblx0XHRuaWJibGVEZXNjOiBcIkEgZnVuw6fDo28gZ2xvYmFsIE5pYmJsZSBwZXJtaXRlIMOhcmVhcyBzZWxlY2lvbmFkYXMgZGUgdW0gcmFzdGVyIHBhcmEgc2VyIGF0cmlidcOtZG8gbyB2YWxvciBkZSBzZXUgdml6aW5obyBtYWlzIHByw7N4aW1vLiBJc3RvIMOpIMO6dGlsIHBhcmEgw6FyZWFzIGRlIGVkacOnw6NvIGRlIHVtIHJhc3RlciBvbmRlIG9zIGRhZG9zIHBvZGVtIGFwcmVzZW50YXIgZXJyb3MuXCIsXG5cdFx0bm90RXF1YWxOYW1lOiBcIk7Do28gSWd1YWxcIixcblx0XHRub3RFcXVhbFNuaXA6IFwiRXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBuw6NvLWlndWFsLWEgUmVsYWNpb25hbCBlbSBkdWFzIGVudHJhZGFzIGVtIHVtYSBiYXNlIGPDqWx1bGEgYSBjw6lsdWxhLiBSZXRvcm5hIDEgcGFyYSBjw6lsdWxhcyBvbmRlIG8gcHJpbWVpcm8gcmFzdGVyIG7Do28gw6kgaWd1YWwgYW8gc2VndW5kbyByYXN0ZXIgZSAwIG9uZGUgw6kgaWd1YWwuXCIsXG5cdFx0bm90RXF1YWxEZXNjOiBcIkEgZnVuw6fDo28gZXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBuw6NvLWlndWFsLWEgUmVsYWNpb25hbCBlbSBkdWFzIGVudHJhZGFzIGVtIHVtYSBiYXNlIHBpeGVsIGEgcGl4ZWwuIFJldG9ybmEgdW0gdmFsb3IgZGUgMSBkZSBwaXhlbHMgb25kZSBvIHByaW1laXJvIHJhc3RlciBuw6NvIMOpIGlndWFsIGFvIHNlZ3VuZG8gcmFzdGVyIGUgdW0gdmFsb3IgZGUgMCBwYXJhIHBpeGVscyBvbmRlIGVsZSDDqSBpZ3VhbCBhbyBzZWd1bmRvIHJhc3Rlci5cIixcblx0XHRwYW5zaGFycGVuaW5nTmFtZTogXCJOaXRpZGV6IFBhbmNyb23DoXRpY2FcIixcblx0XHRwYW5zaGFycGVuaW5nU25pcDogXCJSZWFsw6dhIGFydGlmaWNpYWxtZW50ZSBhIHJlc29sdcOnw6NvIGVzcGFjaWFsIGRlIHVtYSBpbWFnZW0gZGUgbcO6bHRpcGxhcyBiYW5kYXMgZnVuZGluZG8gY29tIHVtYSBpbWFnZW0gcGFuY3JvbcOhdGljYSBkZSByZXNvbHXDp8OjbyBtYWlzIGFsdGEuXCIsXG5cdFx0cGFuc2hhcnBlbmluZ0Rlc2M6IFwiQSBmdW7Dp8OjbyBOaXRpZGV6IFBhbmNyb23DoXRpY2EgdXRpbGl6YSB1bWEgaW1hZ2VtIHBhbmNyb23DoXRpY2EgZGUgYWx0YSByZXNvbHXDp8OjbyBvdSB1bWEgYmFuZGEgZGUgcmFzdGVyIHBhcmEgc2UgZnVuZGlyIGNvbSB1bSBjb25qdW50byBkZSBkYWRvcyByYXN0ZXIgZGUgbcO6bHRpcGxhcyBiYW5kYXMsIGRlIG1lbm9yIHJlc29sdcOnw6NvIHBhcmEgYXVtZW50YXIgYSByZXNvbHXDp8OjbyBlc3BhY2lhbCBkYSBpbWFnZW0gZGUgbcO6bHRpcGxhcyBiYW5kYXMuPGRpdj48YnIvPk8gcHJvcMOzc2l0byBkYSBuaXRpZGV6IHBhbmNyb23DoXRpY2Egw6kgY3JpYXIgdW1hIGltYWdlbSB2aXN1YWwgZGUgbWVsaG9yIHF1YWxpZGFkZS4gSsOhIHF1ZSBhcyB0w6ljbmljYXMgYWx0ZXJhbSBhIHJhZGlvbWV0cmlhIGUgYXMgY2FyYWN0ZXLDrXN0aWNhcyBlc3BlY3RyYWlzIGRhIGltYWdlbSBkZSBtw7psdGlwbGFzIGJhbmRhcywgYSBpbWFnZW0gcGFuY3JvbcOhdGljYSBwcmVjaXNhIHNlciB1dGlsaXphZGEgY29tIGNhdXRlbGEgcGFyYSBwcm9ww7NzaXRvcyBkZSBzZW5zb3JpYW1lbnRvIHJlbW90byBhbmFsw610aWNvLjwvZGl2PlwiLFxuXHRcdHBhdGhBbGxvY2F0aW9uTmFtZTogXCJBbG9jYcOnw6NvIGRhIERpc3TDom5jaWEgZG8gQ2FtaW5ob1wiLFxuXHRcdHBhdGhBbGxvY2F0aW9uU25pcDogXCJDYWxjdWxhIGEgZm9udGUgZGUgbWVub3IgY3VzdG8gcGFyYSBjYWRhIGPDqWx1bGEgYmFzZWFkYSBubyBtZW5vciBjdXN0byBhY3VtdWxhdGl2byBzb2JyZSB1bWEgc3VwZXJmw61jaWUgZGUgY3VzdG8sIGFvIHJlc3BvbmRlciBwZWxhIGRpc3TDom5jaWEgZGEgc3VwZXJmw61jaWUganVudG8gY29tIGZhdG9yZXMgZGUgY3VzdG8gaG9yaXpvbnRhaXMgZSB2ZXJ0aWNhaXMuXCIsXG5cdFx0cGF0aEFsbG9jYXRpb25EZXNjOiBcIkEgZnVuw6fDo28gQWxvY2HDp8OjbyBkYSBEaXN0w6JuY2lhIGRvIENhbWluaG8gY2FsY3VsYSBhIGZvbnRlIG1haXMgcHLDs3hpbWEgcGFyYSBjYWRhIGPDqWx1bGEgY29tIGJhc2Ugbm8gbWVub3IgY3VzdG8gYWN1bXVsYXRpdm8gc29icmUgdW1hIHN1cGVyZsOtY2llIGRlIGN1c3RvLCBlbnF1YW50byBjb25zaWRlcmEgYSBkaXN0w6JuY2lhIGUgb3MgZmF0b3JlcyBkZSBjdXN0byB2ZXJ0aWNhbCBlIGhvcml6b250YWwuXCIsXG5cdFx0cGF0aEJhY2tMaW5rTmFtZTogXCJWw61uY3VsbyBBbnRlcmlvciBkZSBEaXN0w6JuY2lhIGRvIENhbWluaG9cIixcblx0XHRwYXRoQmFja0xpbmtTbmlwOiBcIkRlZmluZSBvIHZpemluaG8gcXVlIGVzdMOhIHByw7N4aW1vIGRhIGPDqWx1bGEgbm8gY2FtaW5obyBkZSBtZW5vciBjdXN0byBhY3VtdWxhdGl2byBhdMOpIGEgZm9udGUgZGUgbWVub3IgY3VzdG8sIGFvIHJlc3BvbmRlciBwZWxhIGRpc3TDom5jaWEgZGEgc3VwZXJmw61jaWUganVudG8gY29tIGZhdG9yZXMgZGUgY3VzdG8gaG9yaXpvbnRhaXMgZSB2ZXJ0aWNhaXMuXCIsXG5cdFx0cGF0aEJhY2tMaW5rRGVzYzogXCJBIGZ1bsOnw6NvIFbDrW5jdWxvIEFudGVyaW9yIGRlIERpc3TDom5jaWEgZG8gQ2FtaW5obyBpZGVudGlmaWNhIGEgZGlyZWNpb25hbGlkYWRlIGRvIHZpemluaG8gcXVlIMOpIGEgcHLDs3hpbWEgY8OpbHVsYSBubyBjYW1pbmhvIGRlIG1lbm9yIGN1c3RvIGFjdW11bGF0aXZvIGF0w6kgYSBmb250ZSBtYWlzIHByw7N4aW1hLCBlbnF1YW50byBjb25zaWRlcmEgYSBkaXN0w6JuY2lhIGRlIHN1cGVyZsOtY2llIGUgZmF0b3JlcyBkZSBjdXN0byBob3Jpem9udGFpcyBlIHZlcnRpY2Fpcy5cIixcblx0XHRwYXRoRGlzdGFuY2VOYW1lOiBcIkRpc3TDom5jaWEgZG8gQ2FtaW5ob1wiLFxuXHRcdHBhdGhEaXN0YW5jZVNuaXA6IFwiQ2FsY3VsYSwgcGFyYSBjYWRhIGPDqWx1bGEsIGEgZGlzdMOibmNpYSBkZSBtZW5vciBjdXN0byBhY3VtdWxhdGl2byBkZSBvdSBhdMOpIGEgZm9udGUgZGUgbWVub3IgY3VzdG8sIGFvIHJlc3BvbmRlciBwZWxhIGRpc3TDom5jaWEgZGEgc3VwZXJmw61jaWUganVudG8gY29tIGZhdG9yZXMgZGUgY3VzdG8gaG9yaXpvbnRhaXMgZSB2ZXJ0aWNhaXMuXCIsXG5cdFx0cGF0aERpc3RhbmNlRGVzYzogXCJBIGZ1bsOnw6NvIERpc3TDom5jaWEgZG8gQ2FtaW5obyBjYWxjdWxhLCBwYXJhIGNhZGEgY8OpbHVsYSwgYSBkaXN0w6JuY2lhIGRlIG1lbm9yIGN1c3RvIGFjdW11bGF0aXZvIGF0w6kgYSBmb250ZSBtYWlzIHByw7N4aW1hLCBlbnF1YW50byBjb25zaWRlcmEgYSBkaXN0w6JuY2lhIGRlIHN1cGVyZsOtY2llIGUgb3MgZmF0b3JlcyBkZSBjdXN0byBob3Jpem9udGFsIGUgdmVydGljYWwuXCIsXG5cdFx0cGx1c05hbWU6IFwiUGx1c1wiLFxuXHRcdHBsdXNTbmlwOiBcIkFkaWNpb25hIChzb21hcykgb3MgdmFsb3JlcyBkZSBkb2lzIHJhc3RlcnMgZW0gdW1hIGJhc2UgZGUgY8OpbHVsYSBwb3IgY8OpbHVsYS5cIixcblx0XHRwbHVzRGVzYzogXCJBIGZ1bsOnw6NvIEFkacOnw6NvIGFkaWNpb25hIChzb21hcykgb3MgdmFsb3JlcyBkZSBkb2lzIHJhc3RlcnMgZW0gdW1hIGJhc2UgZGUgcGl4ZWwgYSBwaXhlbC5cIixcblx0XHRwb3dlck5hbWU6IFwiUG90w6puY2lhXCIsXG5cdFx0cG93ZXJTbmlwOiBcIkVsZXZhIG9zIHZhbG9yZXMgZGUgY8OpbHVsYSBlbSB1bSByYXN0ZXIgcGFyYSBhIHBvdMOqbmNpYSBkb3MgdmFsb3JlcyBlbmNvbnRyYWRvcyBlbSBvdXRybyByYXN0ZXIuXCIsXG5cdFx0cG93ZXJEZXNjOiBcIkEgZnVuw6fDo28gUG90w6puY2lhIGVsZXZhIG9zIHZhbG9yZXMgZGUgcGl4ZWwgZW0gdW0gcmFzdGVyIMOgIHBvdMOqbmNpYSBkb3MgdmFsb3JlcyBsb2NhbGl6YWRvcyBlbSBvdXRybyByYXN0ZXIuXCIsXG5cdFx0cmFkYXJDYWxpYnJhdGlvbk5hbWU6IFwiQ2FsaWJyYcOnw6NvIGRlIFJhZGFyXCIsXG5cdFx0cmFkYXJDYWxpYnJhdGlvblNuaXA6IFwiQ29udmVydGUgUkFEQVJTQVQtMiBiYWNrc2NhdHRlci5cIixcblx0XHRyYWRhckNhbGlicmF0aW9uRGVzYzogXCJFc3RhIGZ1bsOnw6NvIHBvZGUgc2VyIHV0aWxpemFkYSBwYXJhIGNhbGlicmFyIGltYWdlbSBSQURBUlNBVC0yIGVtIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGRvIG1vc2FpY28gb3UgY29tbyB1bSBwcm9kdXRvIGRlIHJhc3Rlci4gQSBjYWxpYnJhw6fDo28gw6kgZXhlY3V0YWRhIGVtIGltYWdlbSBkZSByYWRhciBkZSBmb3JtYSBxdWUgb3MgdmFsb3JlcyBkZSBwaXhlbCBzZWphbSB1bWEgcmVwcmVzZW50YcOnw6NvIHZlcmRhZGVpcmEgZG8gcmFkYXIgYmFja3NjYXR0ZXIuXCIsXG5cdFx0cmFzdGVySW5mb05hbWU6IFwiUmFzdGVySW5mb1wiLFxuXHRcdHJhc3RlckluZm9TbmlwOiBcIk1vZGlmaWNhIHByb3ByaWVkYWRlcyBkbyByYXN0ZXIsIGNvbW8gdGFtYW5obyBkZSBiaXQsIHVtIHZhbG9yIGRlIE5vRGF0YSwgdGFtYW5obyBkYSBjw6lsdWxhLCBlIGFzc2ltIHBvciBkaWFudGUuXCIsXG5cdFx0cmFzdGVySW5mb0Rlc2M6IFwiTyBwYXLDom1ldHJvIEluZm8gZG8gUmFzdGVyIGluY2x1aSB1bSBkacOhbG9nbyBjb20gcHJvcHJpZWRhZGVzIGRvIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3RlciwgY29tbyBvIG7Dum1lcm8gZGUgY29sdW5hcyBlIGxpbmhhcywgbyBuw7ptZXJvIGRlIGJhbmRhcywgbyB0aXBvIGRlIHBpeGVsLCBhIGV4dGVuc8OjbyBlIGEgcmVmZXLDqm5jaWEgZXNwYWNpYWwuIFZvY8OqIHBvZGUgZWRpdGFyIGVzdGFzIHByb3ByaWVkYWRlcyBzZWxlY2lvbmFuZG8gdW0gY29uanVudG8gZGUgZGFkb3MgcmFzdGVyIHBhcmEgdXRpbGl6YXIgY29tbyB1bSBtb2RlbG8uIFwiLFxuXHRcdHJhc3Rlcml6ZUF0dHJpYnV0ZXNOYW1lOiBcIlJhc3Rlcml6YXIgQXRyaWJ1dG9zXCIsXG5cdFx0cmFzdGVyaXplQXR0cmlidXRlc1NuaXA6IFwiRW5yaXF1ZWNlIHVtIHJhc3RlciBwb3IgYmFuZGFzIGFkaWNpb25haXMgZGVyaXZhZGFzIGRvcyB2YWxvcmVzIGRlIGF0cmlidXRvcyBlc3BlY2lmaWNhZG9zIGRlIHVtIHNlcnZpw6dvIGRhIGZlacOnw6NvIG91IHRhYmVsYSBleHRlcm5hLlwiLFxuXHRcdHJhc3Rlcml6ZUF0dHJpYnV0ZXNEZXNjOiBcIkEgZnVuw6fDo28gUmFzdGVyaXphciBBdHJpYnV0byBlbnJpcXVlY2UgdW0gcmFzdGVyIGFvIGFkaWNpb25hciBiYW5kYXMgZGVyaXZhZGFzIGRvcyB2YWxvcmVzIGRlIGF0cmlidXRvcyBlc3BlY2lmaWNhZG9zIGRlIHVtIHNlcnZpw6dvIGRhIGZlacOnw6NvIG91IHRhYmVsYSBleHRlcm5hLiBPcGNpb25hbG1lbnRlLCB2b2PDqiBwb2RlIGVzcGVjaWZpY2FyIHVtIHJhc3RlciBkZSB6b25hIGUgbyBhdHJpYnV0byBkZSBJRCBkYSB6b25hIGFzc29jaWFkYSBwYXJhIGhhYmlsaXRhciBhIGNvbnN1bHRhIGJhc2VhZGEgbmEgcmVnacOjby5cIixcblx0XHRyYXN0ZXJpemVGZWF0dXJlQ2xhc3NOYW1lOiBcIkZlacOnw7VlcyBSYXN0ZXJpemFkYXNcIixcblx0XHRyYXN0ZXJpemVGZWF0dXJlQ2xhc3NTbmlwOiBcIkNvbnZlcnRlIGZlacOnw7VlcyBwYXJhIHJhc3Rlci5cIixcblx0XHRyYXN0ZXJpemVGZWF0dXJlQ2xhc3NEZXNjOiBcIkVzdGEgZnVuw6fDo28gY29udmVydGUgZGFkb3MgZGEgY2xhc3NlIGRlIGZlacOnw6NvIGRlIHBvbMOtZ29ubywgcG9saWxpbmhhIGUgcG9udG8gcGFyYSB1bWEgY2FtYWRhIHJhc3Rlci48ZGl2Pjxici8+QXMgZmVpw6fDtWVzIHPDo28gdmFsb3JlcyBkZSBwaXhlbCBhdHJpYnXDrWRvcyBjb20gYmFzZSBubyBPQkpFQ1RJRCAocGFkcsOjbykgZGEgZmVpw6fDo28uIE9wY2lvbmFsbWVudGUsIG9zIHZhbG9yZXMgZGUgcGl4ZWwgcG9kZW0gc2VyIGJhc2VhZG9zIGVtIHVtIGNhbXBvIGRlIHZhbG9yIGRlZmluaWRvIHBlbG8gdXN1w6FyaW8gbmEgdGFiZWxhIGRlIGF0cmlidXRvcyBkYSBmZWnDp8OjbyBkZSBlbnRyYWRhLjwvZGl2PlwiLFxuXHRcdHJlY2FzdE5hbWU6IFwiUmVtb2RlbGFyXCIsXG5cdFx0cmVjYXN0U25pcDogXCJNb2RpZmljYSBvcyBwYXLDom1ldHJvcyBkZSB1bWEgY2FkZWlhIGRlIGZ1bsOnw6NvIGVtIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGRvIG1vc2FpY28gb3Ugc2VydmnDp28gZGUgaW1hZ2VtLiBJc3RvIMOpIG5vcm1hbG1lbnRlIHV0aWxpemFkbyBjb20gY29uanVudG9zIGRlIGRhZG9zIExBUyBwYXJhIGV2aXRhciBkZSB0ZXIgcXVlIGNyaWFyIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGRvIG1vc2FpY28gc2VwYXJhZG8gcGFyYSBkaWZlcmVudGVzIHJlcHJlc2VudGHDp8O1ZXMgZG8gdGVycmVuby5cIixcblx0XHRyZWNhc3REZXNjOiBcIkEgZnVuw6fDo28gUmVtb2RlbGFyIMOpIHV0aWxpemFkYSBwYXJhIG1vZGlmaWNhciBvIHBhcsOibWV0cm8gZGUgZnVuw6fDo28gdXRpbGl6YWRvIGVtIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGRvIG1vc2FpY28gb3Ugc2VydmnDp28gZGUgaW1hZ2VtIGRpbmFtaWNhbWVudGUgc2VtIHBlcnNpc3RpciBmaXNpY2FtZW50ZSBuYXMgYWx0ZXJhw6fDtWVzLlwiLFxuXHRcdHJlZ2lvbkdyb3VwTmFtZTogXCJBZ3J1cGFyIHBvciBSZWdpw7Vlc1wiLFxuXHRcdHJlZ2lvbkdyb3VwU25pcDogXCJQYXJhIGNhZGEgY8OpbHVsYSBuYSBzYcOtZGEsIGEgaWRlbnRpZGFkZSBkYSByZWdpw6NvIGNvbmVjdGFkYSBuYSBxdWFsIGEgY8OpbHVsYSBwZXJ0ZW5jZSDDqSByZWdpc3RyYWRhLiBVbSDDum5pY28gbsO6bWVybyDDqSBhdHJpYnXDrWRvIHBhcmEgY2FkYSByZWdpw6NvLlwiLFxuXHRcdHJlZ2lvbkdyb3VwRGVzYzogXCJBIGZ1bsOnw6NvIEFncnVwYXIgcG9yIFJlZ2nDtWVzIGdsb2JhbCByZWdpc3RyYSBlbSBjYWRhIGPDqWx1bGEgbmEgc2HDrWRhLCBhIGlkZW50aWRhZGUgZGEgcmVnacOjbyBjb25lY3RhZGEgbmEgcXVhbCBhIGPDqWx1bGEgcGVydGVuY2UuIFVtIMO6bmljbyBuw7ptZXJvIMOpIGF0cmlidcOtZG8gcGFyYSBjYWRhIHJlZ2nDo28uPGRpdj48YnIvPkEgcHJpbWVpcm8gcmVnacOjbyBlc2NhbmVhZGEgcmVjZWJlIG8gdmFsb3IgdW0sIGEgc2VndW5kYSBkb2lzLCBlIGFzc2ltIHBvciBkaWFudGUsIGF0w6kgcXVlIHRvZGFzIGFzIHJlZ2nDtWVzIHRlbmhhbSB1bSB2YWxvciBhdHJpYnXDrWRvLiBPIGVzY2FuZWFtZW50byBtb3ZlIGRhIGVzcXVlcmRhIHBhcmEgZGlyZWl0YSwgZGEgcGFydGUgc3VwZXJpb3IgcGFyYSBwYXJ0ZSBpbmZlcmlvci4gT3MgdmFsb3JlcyBhdHJpYnXDrWRvcyDDoHMgem9uYXMgZGUgc2HDrWRhIHPDo28gYmFzZWFkb3MgcXVhbmRvIGVsZXMgZm9yZW0gZW5jb250cmFkb3Mgbm8gcHJvY2Vzc28gZGUgZXNjYW5lYW1lbnRvLjwvZGl2PlwiLFxuXHRcdHJlZ2lvbkdyb3dOYW1lOiBcIlJlZ2nDo28gZGUgQ3Jlc2NpbWVudG9cIixcblx0XHRyZWdpb25Hcm93U25pcDogXCJSZWdpw7VlcyBkZSBjcmVzY2ltZW50byBkb3MgcG9udG9zIGRlIG9yaWdlbS5cIixcblx0XHRyZWdpb25Hcm93RGVzYzogXCJBIGZ1bsOnw6NvIENyZXNjaW1lbnRvIGRlIFJlZ2nDo28gYWdydXBhIHBpeGVscyB2aXppbmhvcyBlbSBncnVwb3MgZGVwZW5kZW5kbyBkbyByYWlvIGVzcGVjaWZpY2FkbyBhIHBhcnRpciBkbyBwb250byBkZSBvcmlnZW0uIE8gZ3J1cG8gZGUgcGl4ZWxzIG91IG9iamV0byByZWNlYmUgdW0gdmFsb3IgZGUgcHJlZW5jaGltZW50byBlc3BlY2lmaWNhZG8uXCIsXG5cdFx0cmVtYXBOYW1lOiBcIlJlbWFwZWFyXCIsXG5cdFx0cmVtYXBTbmlwOiBcIkFsdGVyYSBvcyB2YWxvcmVzIGRvIHBpeGVsIGF0cmlidWluZG8gbm92b3MgdmFsb3JlcyBwYXJhIGludGVydmFsb3MgZGUgdmFsb3JlcyBkbyBwaXhlbCBvdSB1dGlsaXphbmRvIHVtYSB0YWJlbGEgZXh0ZXJuYS5cIixcblx0XHRyZW1hcERlc2M6IFwiQSBmdW7Dp8OjbyBSZW1hcGVhciBwZXJtaXRlIGEgdm9jw6ogYWx0ZXJhciBvdSByZWNsYXNzaWZpY2FyIG9zIHZhbG9yZXMgZGUgcGl4ZWxzIGRvcyBkYWRvcyByYXN0ZXIuIElzdG8gcG9kZSBzZXIgZmVpdG8gZXNwZWNpZmljYW5kbyB1bWEgZmFpeGEgZGUgdmFsb3JlcyBkZSBwaXhlbHMgcGFyYSBtYXBlYXIgdW0gdmFsb3IgZGUgcGl4ZWwgZGUgc2HDrWRhIG91IHV0aWxpemFuZG8gdW1hIHRhYmVsYSBwYXJhIG1hcGVhciBvcyB2YWxvcmVzIGRlIHBpeGVsIHBhcmEgbyB2YWxvciBkZSBwaXhlbCBkZSBzYcOtZGEuXCIsXG5cdFx0cmVwcm9qZWN0TmFtZTogXCJSZXByb2pldGFyXCIsXG5cdFx0cmVwcm9qZWN0U25pcDogXCJNb2RpZmljYSBhIHByb2plw6fDo28gZGUgdW0gY29uanVudG8gZGUgZGFkb3MgcmFzdGVyLCB1bSBjb25qdW50byBkZSBkYWRvcyBkZSBtb3NhaWNvIG91IHVtIGl0ZW0gZG8gcmFzdGVyIGVtIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGRlIG1vc2FpY28uIFRhbWLDqW0gcG9kZSByZWFtb3N0cmFyIG9zIGRhZG9zIHBhcmEgdW0gbm92byB0YW1hbmhvIGRlIGPDqWx1bGEgZSBkZWZpbmlyIHVtYSBvcmlnZW0uXCIsXG5cdFx0cmVwcm9qZWN0RGVzYzogXCJBIGZ1bsOnw6NvIFJlcHJvamV0YXIgbW9kaWZpY2EgYSBwcm9qZcOnw6NvIGRlIHVtIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3RlciwgdW0gY29uanVudG8gZGUgZGFkb3MgZGUgbW9zYWljbyBvdSB1bSBpdGVtIGRvIHJhc3RlciBlbSB1bSBjb25qdW50byBkZSBkYWRvcyBkZSBtb3NhaWNvLiBUYW1iw6ltIHBvZGUgcmVhbW9zdHJhciBvcyBkYWRvcyBwYXJhIHVtIG5vdm8gdGFtYW5obyBkZSBjw6lsdWxhIGUgZGVmaW5pciB1bWEgb3JpZ2VtLjxkaXY+PGJyLz5BIGZ1bsOnw6NvIFJlcHJvamV0YXIgcG9kZSBzZXIgdXRpbGl6YWRhIGFvIGNyaWFyIHVtIGNhY2hlIGEgcGFydGlyIGRlIHVtIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3RlciBvdSBkZSBtb3NhaWNvIHF1ZSBuw6NvIGVzdGVqYSBuYSBwcm9qZcOnw6NvIGV4aWdpZGEuIFBvciBleGVtcGxvLCBhbyBjcmlhciB1bSBzZXJ2acOnbyBkZSBpbWFnZW0gY29tIGNhY2hlIHF1ZSBwb2RlIHNlciBpbnRlZ3JhZG8gcG9yIGFwbGljYXRpdm9zIGNvbSBvdXRyb3Mgc2VydmnDp29zIGNvbSBjYWNoZSwgw6kgaW1wb3J0YW50ZSBxdWUgdG9kb3MgZXN0ZWphbSBuYSBtZXNtYSBwcm9qZcOnw6NvLiBJc3RvIGdlcmFsbWVudGUgw6kgdW1hIHByb2plw6fDo28gV2ViIE1lcmNhdG9yLiBKw6EgcXVlIG8gY29uanVudG8gZGUgZGFkb3MgZGUgbW9zYWljbyBuw6NvIHBvZGUgc2VyIHJlcHJvamV0YWRvLCB2b2PDqiBwb2RlIGZhemVyIHVtYSBkYXMgZHVhcyBjb2lzYXPigJRjcmlhciB1bSBjb25qdW50byBkZSBkYWRvcyBkZSBtb3NhaWNvIHJlZmVyZW5jaWFkbyBhIHBhcnRpciBkbyBzZXUgY29uanVudG8gZGUgZGFkb3MgZGUgbW9zYWljbyBuYSBwcm9qZcOnw6NvIG5lY2Vzc8OhcmlhIG91IGFkaWNpb25hciBhIGZ1bsOnw6NvIFJlcHJvamV0YXIgw6AgY2FkZWlhIGRlIGZ1bsOnw6NvIGRvIGNvbmp1bnRvIGRlIGRhZG9zIGRlIG1vc2FpY28uIE91dHJvIGV4ZW1wbG8gdXRpbGl6YSBlc3RhIGZ1bsOnw6NvIG5vIGl0ZW0gZG8gcmFzdGVyIGVtIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGRlIG1vc2FpY28uIEFvIHV0aWxpemFyIGEgZnVuw6fDo28gUmFzdGVyIENvbSBDYWNoZSwgdm9jw6ogcG9kZSBkZXNlamFyIGEgaW5zZXLDp8OjbyBkYSBmdW7Dp8OjbyBSZXByb2pldGFyIHBhcmEgcXVlIG8gY2FjaGUgc2VqYSBjcmlhZG8gbmEgbm92YSBwcm9qZcOnw6NvLiBPcyBpdGVucyBkbyByYXN0ZXIgZW0gdW0gY29uanVudG8gZGUgZGFkb3MgZGUgbW9zYWljbyBwb2RlbSBzZXIgYXJtYXplbmFkb3MgZW0gY2FjaGUgcXVhbmRvIG8gcHJvY2Vzc2FtZW50byDDqSBpbnRlbnNvIGUgdm9jw6ogZXN0w6EgdGVudGFuZG8gcHVibGljYXIgdW0gc2VydmnDp28gZGUgaW1hZ2VtIHLDoXBpZG8sIHNlbSBhcm1hemVuYXIgZW0gY2FjaGUgbyBzZXJ2acOnbyBkZSBpbWFnZW0gaW50ZWlyby48L2Rpdj5cIixcblx0XHRyZXNhbXBsZU5hbWU6IFwiUmVhbW9zdHJhclwiLFxuXHRcdHJlc2FtcGxlU25pcDogXCJBbHRlcmEgbyB0YW1hbmhvIGRlIGPDqWx1bGEgZGUgdW0gcmFzdGVyLlwiLFxuXHRcdHJlc2FtcGxlRGVzYzogXCJBIGZ1bsOnw6NvIFJlYW1vc3RyYXIgYWx0ZXJhIG8gdGFtYW5obyBkZSBjw6lsdWxhLCB0aXBvIGRlIHJlYW1vc3RyYWdlbSBvdSBhbWJvcy48ZGl2Pjxici8+QSBmdW7Dp8OjbyBSZWFtb3N0cmFyIGRldmUgc29tZW50ZSBzZXIgdXRpbGl6YWRhIGNvbSByZXF1aXNpdG9zIGRlIGNvbXB1dGHDp8OjbyBlc3BlY8OtZmljb3M7IHBvciBleGVtcGxvLCBxdWFuZG8gdm9jw6ogZXN0aXZlciBjb21wdXRhbmRvIG8gdmVudG8gb3UgZGlyZcOnw6NvIGRlIG1hZ25pdHVkZSBhdHVhbCBxdWUgZXhpZ2UgYSByZWFtb3N0cmFnZW0gZGEgcmVzb2x1w6fDo28gZGUgb3JpZ2VtLjwvZGl2PlwiLFxuXHRcdHJvdW5kRG93bk5hbWU6IFwiQXJyZWRvbmRhciBwYXJhIE1lbm9zXCIsXG5cdFx0cm91bmREb3duU25pcDogXCJSZXRvcm5hIG8gcHLDs3hpbW8gdmFsb3IgaW50ZWlybyBtYWlzIGJhaXhvLCBhcGVuYXMgcmVwcmVzZW50YWRvIGNvbW8gdW0gcG9udG8gZmx1dHVhbnRlLCBwYXJhIGNhZGEgY8OpbHVsYSBlbSB1bSByYXN0ZXIuXCIsXG5cdFx0cm91bmREb3duRGVzYzogXCJBIGZ1bsOnw6NvIEFycmVkb25kYXIgcGFyYSBNZW5vcyByZXRvcm5hIG8gcHLDs3hpbW8gdmFsb3IgaW50ZWlybyBtYWlzIGJhaXhvLCBjb21vIHVtIHZhbG9yIGRlIHBvbnRvIGZsdXR1YW50ZSBkZSBjYWRhIHBpeGVsIGVtIHVtIHJhc3Rlci5cIixcblx0XHRyb3VuZFVwTmFtZTogXCJBcnJlZG9uZGFyIHBhcmEgbWFpc1wiLFxuXHRcdHJvdW5kVXBTbmlwOiBcIlJldG9ybmEgbyBwcsOzeGltbyB2YWxvciBpbnRlaXJvIG1haXMgYWx0bywgYXBlbmFzIHJlcHJlc2VudGFkbyBjb21vIHVtIHBvbnRvIGZsdXR1YW50ZSwgcGFyYSBjYWRhIGPDqWx1bGEgZW0gdW0gcmFzdGVyLlwiLFxuXHRcdHJvdW5kVXBEZXNjOiBcIkEgZnVuw6fDo28gQXJyZWRvbmRhciBwYXJhIG1haXMsIHJldG9ybmEgbyBwcsOzeGltbyB2YWxvciBpbnRlaXJvIG1haXMgYWx0bywgY29tbyB1bSB2YWxvciBkZSBwb250byBmbHV0dWFudGUsIHBhcmEgY2FkYSBwaXhlbCBlbSB1bSByYXN0ZXIuXCIsXG5cdFx0c2VnbWVudE1lYW5TaGlmdE5hbWU6IFwiRGVzbG9jYW1lbnRvIE3DqWRpbyBkbyBTZWdtZW50b1wiLFxuXHRcdHNlZ21lbnRNZWFuU2hpZnRTbmlwOiBcIkFncnVwYSBwaXhlbHMgdml6aW5ob3MgY29tIGNhcmFjdGVyw61zdGljYXMgZXNwZWN0cmFpcyBzZW1lbGhhbnRlcyBlbSBzZWdtZW50b3MuXCIsXG5cdFx0c2VnbWVudE1lYW5TaGlmdERlc2M6IFwiQSBmdW7Dp8OjbyBpZGVudGlmaWNhIG9iamV0b3MsIGZlacOnw7VlcyBvdSBzZWdtZW50b3MgbmEgc3VhIGltYWdlbSBhZ3J1cGFuZG8gcGl4ZWxzIGFkamFjZW50ZXMgY29tIGNhcmFjdGVyw61zdGljYXMgZXNwZWN0cmFpcyBzZW1lbGhhbnRlcy4gVm9jw6ogcG9kZSBjb250cm9sYXIgYSBxdWFudGlkYWRlIGRlIHN1YXZpemHDp8OjbyBlc3BlY3RyYWwgZSBlc3BhY2lhbCBwYXJhIGFqdWRhciBhIGRlcml2YXIgYXMgZmVpw6fDtWVzIGRlIGludGVyZXNzZS5cIixcblx0XHRzMVJhZGlvbWV0cmljQ2FsaWJyYXRpb25OYW1lOiBcIkNhbGlicmHDp8OjbyBSYWRpb23DqXRyaWNhIGRvIFNlbnRpbmVsLTFcIixcblx0XHRzMVJhZGlvbWV0cmljQ2FsaWJyYXRpb25TbmlwOiBcIkV4ZWN1dGEgZGlmZXJlbnRlcyB0aXBvcyBkZSBjYWxpYnJhw6fDo28gcmFkaW9tw6l0cmljYSBlbSBjb25qdW50b3MgZGUgZGFkb3MgZG8gU2VudGluZWwtMS5cIixcblx0XHRzMVJhZGlvbWV0cmljQ2FsaWJyYXRpb25EZXNjOiBcIkVzdGEgZnVuw6fDo28gZGUgcmFzdGVyIGV4ZWN1dGEgdHLDqnMgY2FsaWJyYcOnw7VlcyBkaWZlcmVudGVzIHByYSBjb25qdW50byBkZSBkYWRvcyBTZW50aW5lbCAxLCBpbmNsdWluZG8gYmV0YSB6ZXJvIGUgZ2FtYSwgZSBnZXJhIGEgc2HDrWRhIGRvIGNvbmp1bnRvIGRlIGRhZG9zIGNhbGlicmFkby4gTyBvYmpldGl2byBkZSBjYWxpYnJhw6fDo28gZGUgU0FSIMOpIGZvcm5lY2VyIGltYWdlbSBlbSBxdWFpcyB2YWxvcmVzIGRlIHBpeGVscyBwb2RlbSBzZXIgZGlyZXRhbWVudGUgcmVsYWNpb25hZG9zIMOgIHJldHJvZGlzcGVyc8OjbyBkbyByYWRhciBkYSBjZW5hLiBFbnRyZXRhbnRvIGEgaW1hZ2VtIFNBUiBuw6NvIGNhbGlicmFkYSDDqSBzdWZpY2llbnRlIHBhcmEgdXNvIHF1YWxpdGF0aXZvLCBhcyBpbWFnZW5zIGRlIFNBUiBjYWxpYnJhZGFzIHPDo28gZXNzZW5jaWFpcyBwYXJhIHVzbyBxdWFudGl0YXRpdm8gZG9zIGRhZG9zIGRlIFNBUi48ZGl2Pjxici8+TyBwcm9jZXNzYW1lbnRvIGRlIGRhZG9zIGRlIFNBUiB0w61waWNvLCBxdWUgcHJvZHV6IGltYWdlbnMgZGUgTsOtdmVsIDEsIG7Do28gaW5jbHVpIGNvcnJlw6fDtWVzIHJhZGlvbcOpdHJpY2FzIGUgbyBkZXN2aW8gc2lnbmlmaWNhbnRlIHJhZGlvbcOpdHJpY28gcGVybWFuZWNlLiBQb3J0YW50bywgw6kgbmVjZXNzw6FyaW8gc2UgYXBsaWNhciBjb3JyZcOnw6NvIHJhZGlvbcOpdHJpY2EgcGFyYSBpbWFnZW5zIGRlIFNBUiBkZSBmb3JtYSBxdWUgb3MgdmFsb3JlcyBkZSBwaXhlbCBkYXMgaW1hZ2VucyByZXByZXNlbnRhbSB2ZXJkYWRlaXJhbWVudGUgYSByZXRyb2Rpc3BlcnPDo28gZG8gcmFkYXIgZGEgc3VwZXJmw61jaWUgcmVmbGV0aWRhLiBBIGNvcnJlw6fDo28gcmFkaW9tw6l0cmljYSB0YW1iw6ltIMOpIG5lY2Vzc8OhcmlhIHBhcmEgYSBjb21wYXJhw6fDo28gZGUgaW1hZ2VucyBTQVIgYWRxdWlyaWRhcyBjb20gc2Vuc29yZXMgZGlmZXJlbnRlcyBvdSBhZHF1aXJpZGFzIGEgcGFydGlyIGRvIG1lc21vIHNlbnNvciBlbSB0ZW1wb3MgZGlmZXJlbnRlcywgZW0gbW9kb3MgZGlmZXJlbnRlcyBvdSBwcm9jZXNzYWRhcyBwb3IgcHJvY2Vzc2Fkb3JlcyBkaWZlcmVudGVzLjwvZGl2PlwiLFxuXHRcdHMxVGhlcm1hbE5vaXNlUmVtb3ZhbE5hbWU6IFwiUmVtb8Onw6NvIGRlIFJ1w61kbyBUw6lybWljbyBkbyBTZW50aW5lbC0xXCIsXG5cdFx0czFUaGVybWFsTm9pc2VSZW1vdmFsU25pcDogXCJSZW1vdmUgcnXDrWRvIHTDqXJtaWNvIGRlIGRhZG9zIGRvIFNlbnRpbmVsLTEuXCIsXG5cdFx0czFUaGVybWFsTm9pc2VSZW1vdmFsRGVzYzogXCJBIGNvcnJlw6fDo28gZGUgcnXDrWRvIHTDqXJtaWNvIHBvZGUgc2VyIGFwbGljYWRhIGFvcyBwcm9kdXRvcyBTZW50aW5lbC0xIExldmVsLTEgU2luZ2xlIExvb2sgQ29tcGxleCAoU0xDKSBjb21vIHRhbWLDqW0gcHJvZHV0b3MgTGV2ZWwtMSBHcm91bmQgUmFuZ2UgRGV0ZWN0aW9uIChHUkQpIHF1ZSBqw6EgbsOjbyBmb3JhbSBjb3JyaWdpZG9zLiBPIG9wZXJhZG9yIHRhbWLDqW0gcG9kZSByZW1vdmVyIGVzdGEgY29ycmXDp8OjbyBiYXNlYWRhIG5hcyBhbm90YcOnw7VlcyBkZSBwcm9kdXRvIHBhcmEgcmUtaW50cm9kdXppciBvIHNpbmFsIGRlIHJ1w61kbyBxdWUgZm9pIHJlbW92aWRvIHBhcmEgcHJvZHV6aXIgbyBwcm9kdXRvIG9yaWdpbmFsLiBBcyBhbm90YcOnw7VlcyBkZSBwcm9kdXRvIHNlcsOjbyBjb25zZXF1ZW50ZW1lbnRlIGF0dWFsaXphZGFzIHBhcmEgcGVybWl0aXIgYSByZS1hcGxpY2HDp8OjbyBkYSBjb3JyZcOnw6NvLiBcIixcblx0XHRzZXROdWxsTmFtZTogXCJEZWZpbmlyIE51bG9cIixcblx0XHRzZXROdWxsU25pcDogXCJDb25maWd1cmFyIHBhcmEgTnVsbyBkZWZpbmUgbG9jYWxpemHDp8O1ZXMgZGUgY8OpbHVsYSBpZGVudGlmaWNhZGFzIHBhcmEgTm9EYXRhIGJhc2VhZG8gZW0gY3JpdMOpcmlvcyBlc3BlY2lmaWNhZG9zLiBFbGUgcmV0b3JuYSBOb0RhdGEgc2UgdW1hIGF2YWxpYcOnw6NvIGNvbmRpY2lvbmFsIGZvciB2ZXJkYWRlaXJhIGUgcmV0b3JuYSBvIHZhbG9yIGVzcGVjaWZpY2FkbyBwb3Igb3V0cm8gZGFkbyByYXN0ZXIgc2UgZmFsc2EuXCIsXG5cdFx0c2V0TnVsbERlc2M6IFwiQSBmdW7Dp8OjbyBDb25maWd1cmFyIHBhcmEgTnVsbyBkZWZpbmUgb3MgcGl4ZWxzIGlkZW50aWZpY2Fkb3MgcGFyYSBOb0RhdGEgYmFzZWFkbyBlbSBjcml0w6lyaW9zIGVzcGVjw61maWNvcy4gRWxlIHJldG9ybmEgTm9EYXRhIHNlIHVtYSBhdmFsaWHDp8OjbyBjb25kaWNpb25hbCBmb3IgdmVyZGFkZWlyYSAoMSkgZSByZXRvcm5hIG8gdmFsb3IgZXNwZWNpZmljYWRvIG5vIFJhc3RlciBGYWxzbyBzZSBhdmFsaWHDp8OjbyBjb25kaWNpb25hbCBmb3IgZmFsc2EgKDApLiBFc3RlcyBjcml0w6lyaW9zIHPDo28gZXNwZWNpZmljYWRvcyBwZWxhIHNhw61kYSBkZSB1bWEgZnVuw6fDo28gbWF0ZW3DoXRpY2EgbMOzZ2ljYSwgcXVlIHNlcsOhIG8gUmFzdGVyIGRlIGVudHJhZGEuXCIsXG5cdFx0c2hhZGVkUmVsaWVmTmFtZTogXCJSZWxldm8gU29tYnJlYWRvXCIsXG5cdFx0c2hhZGVkUmVsaWVmU25pcDogXCJDcmlhIHVtYSByZXByZXNlbnRhw6fDo28gZGEgc3VwZXJmw61jaWUgM0QsIGRlIGNvcmVzIGNvZGlmaWNhZGFzLCBkZSBtw7psdGlwbGFzIGJhbmRhcywgbGV2YW5kbyBlbSBjb250YSBhIHBvc2nDp8OjbyByZWxhdGl2YSBkbyBzb2wgcGFyYSBzb21icmFtZW50byBkYSBpbWFnZW0uXCIsXG5cdFx0c2hhZGVkUmVsaWVmRGVzYzogXCJBIGZ1bsOnw6NvIFJlbGV2byBTb21icmVhZG8gY3JpYSB1bWEgcmVwcmVzZW50YcOnw6NvIGRlIGNvciAzRCBkbyB0ZXJyZW5vIHF1ZSDDqSBjcmlhZG8ganVudGFuZG8gYXMgaW1hZ2VucyBkb3MgbcOpdG9kb3MgZGUgZWxldmHDp8OjbyBlIHJlbGV2byBzb21icmVhZG8gY29kaWZpY2Fkb3MuIEVzdGEgZnVuw6fDo28gdXRpbGl6YSBhIGFsdGl0dWRlIGUgcHJvcHJpZWRhZGVzIGRlIGF6aW11dGUgcGFyYSBlc3BlY2lmaWNhciBhIHBvc2nDp8OjbyBkbyBzb2wuPGRpdj48YnIvPjwvZGl2PlwiLFxuXHRcdHNpbkhOYW1lOiBcIlNlbkhcIixcblx0XHRzaW5IU25pcDogXCJDYWxjdWxhIG8gc2VubyBoaXBlcmLDs2xpY28gZGUgY8OpbHVsYXMgZW0gdW0gcmFzdGVyLlwiLFxuXHRcdHNpbkhEZXNjOiBcIkEgZnVuw6fDo28gY2FsY3VsYSBvIHNlbm8gaGlwZXJiw7NsaWNvIGRvcyBwaXhlbHMgZW0gdW0gcmFzdGVyLlwiLFxuXHRcdHNpbk5hbWU6IFwiU2VuXCIsXG5cdFx0c2luU25pcDogXCJDYWxjdWxhIG8gc2VubyBkYXMgY8OpbHVsYXMgZW0gdW0gcmFzdGVyLlwiLFxuXHRcdHNpbkRlc2M6IFwiQSBmdW7Dp8OjbyBjYWxjdWxhIG8gc2VubyBkb3MgcGl4ZWxzIGVtIHVtIHJhc3Rlci5cIixcblx0XHRzbG9wZU5hbWU6IFwiRGVjbGl2aWRhZGVcIixcblx0XHRzbG9wZVNuaXA6IFwiQ2FsY3VsYSBhIHRheGEgZGUgYWx0ZXJhw6fDo28gZGUgdW0gdmFsb3IgZGUgcGl4ZWwgcGFyYSBzZXVzIHZpemluaG9zLlwiLFxuXHRcdHNsb3BlRGVzYzogXCJFc3RhIGZ1bsOnw6NvIGRlIHJhc3RlciBjYWxjdWxhIGEgZGVjbGl2aWRhZGUgcXVlIMOpIGEgdGF4YSBkZSBtdWRhbsOnYSBkZSBlbGV2YcOnw6NvIGRlIGNhZGEgY8OpbHVsYSBkbyBtb2RlbG8gZGUgZWxldmHDp8OjbyBkaWdpdGFsIChERU0pLiDDiSBvIHByaW1laXJvIGRlcml2YWRvIGRlIHVtIERFTS48ZGl2Pjxici8+RXN0YSBmdW7Dp8OjbyB1dGlsaXphIHVtYSBmdW7Dp8OjbyBhY2VsZXJhZGEgYXRhbigpLiDDiSBzZWlzIHZlemVzIG1haXMgcsOhcGlkbyBlIG8gZXJybyBkZSBhcHJveGltYcOnw6NvIMOpIHNlbXByZSBtZW5vcyBxdWUgMC4zIGdyYXVzLjwvZGl2PlwiLFxuXHRcdHNwZWNrbGVOYW1lOiBcIk1hbmNoYXJcIixcblx0XHRzcGVja2xlU25pcDogXCJGb3JuZWNlIGZpbHRyb3MgcGFyYSByZXRpcmFyIHJ1w61kbyBkb3MgY29uanVudG9zIGRlIGRhZG9zIGRvIHJhZGEgZGUgYWJlcnR1cmEgc2ludMOpdGljYS5cIixcblx0XHRzcGVja2xlRGVzYzogXCJNYW5jaGFyLCDDqSBvIHJ1w61kbyBkZSBhbHRhLWZyZXF1w6puY2lhIGVtIGRhZG9zIGRlIHJhZGFyLiBBcyBpbWFnZW5zIGdlcmFkYXMgcG9yIHNpc3RlbWFzIGRlIHJhZGFyIGRlIGFiZXJ0dXJhIHNpbnTDqXRpY2EgKFNBUikgc8OjbyBhbHRhbWVudGUgc3VqZWl0byBhIGVmZWl0b3MgZGUgbWFuY2hhcyBkZXZpZG8gYW8gcHJvY2Vzc2FtZW50byBkZSBzaW5haXMgZGlzcGVyc29zIGUgaW50ZXJmZXLDqm5jaWEgZGUgb25kYXMgZGUgZWxldHJvbWFnbsOpdGljbyBkaXNwZXJzb3MgZGUgc3VwZXJmw61jaWVzIG91IG9iamV0b3MuIEVzdGEgZnVuw6fDo28gTWFuY2hhciBmaWx0cmEgbyBjb25qdW50byBkZSBkYWRvcyBkZSByYWRhciBtYW5jaGFkbyBlIHN1YXZpemEgbyBydcOtZG8gYW8gcmV0ZXIgYXMgYm9yZGFzIG91IGZlacOnw7VlcyBuw610aWRhcyBuYSBpbWFnZW0uXCIsXG5cdFx0c3BlY3RyYWxDb252ZXJzaW9uTmFtZTogXCJDb252ZXJzw6NvIEVzcGVjdHJhbFwiLFxuXHRcdHNwZWN0cmFsQ29udmVyc2lvblNuaXA6IFwiQXBsaWNhIHVtYSBtYXRyaXogcGFyYSB1bWEgaW1hZ2VtIGRlIG3Dumx0aXBsYXMgYmFuZGFzLlwiLFxuXHRcdHNwZWN0cmFsQ29udmVyc2lvbkRlc2M6IFwiQSBmdW7Dp8OjbyBDb252ZXJzw6NvIEVzcGVjdHJhbCBhcGxpY2EgdW1hIG1hdHJpeiBwYXJhIHVtYSBpbWFnZW0gZGUgYmFuZGFzIG3Dumx0aXBsYXMgcGFyYSBhZmV0YXIgb3MgdmFsb3JlcyBkZSBjb3JlcyBkYSBzYcOtZGEuPGRpdj48YnIvPkFsZ3VucyBzZW5zb3JlcyBuw6NvIGNvbGV0YW0gYmFuZGFzIGF6dWlzIHBvciBjYXVzYSBkZSB1bWEgc2luYWwgYmFpeG8gcGFyYSB0YXhhIGRlIHJ1w61kby4gSXN0byBwb2RlIHNlciB1dGlsaXphZG8sIHBvciBleGVtcGxvLCBwYXJhIGNvbnZlcnRlciB1bWEgaW1hZ2VtIGluZnJhdmVybWVsaGEgZmFsc2EgcGFyYSB1bWEgaW1hZ2VtIGRlIGNvciBuYXR1cmFsLjwvZGl2PlwiLFxuXHRcdHNxdWFyZVJvb3ROYW1lOiBcIlJhaXogUXVhZHJhZGFcIixcblx0XHRzcXVhcmVSb290U25pcDogXCJDYWxjdWxhIGEgcmFpeiBxdWFkcmFkYSBkb3MgdmFsb3JlcyBkYSBjw6lsdWxhIGVtIHVtIHJhc3Rlci5cIixcblx0XHRzcXVhcmVSb290RGVzYzogXCJBIGZ1bsOnw6NvIFJhaXogUXVhZHJhZGEgY2FsY3VsYSBhIHJhaXogcXVhZHJhZGEgZG9zIHZhbG9yZXMgZGUgcGl4ZWwgZW0gdW0gcmFzdGVyLlwiLFxuXHRcdHNxdWFyZU5hbWU6IFwiUXVhZHJhZG9cIixcblx0XHRzcXVhcmVTbmlwOiBcIkNhbGN1bGUgYSBlcXVhw6fDo28gZG9zIHZhbG9yZXMgZGUgY8OpbHVsYSBlbSB1bSByYXN0ZXIuXCIsXG5cdFx0c3F1YXJlRGVzYzogXCJBIGZ1bsOnw6NvIFF1YWRyYWRvIGNhbGN1bGUgbyBxdWFkcmFkbyBkb3MgdmFsb3JlcyBkZSBwaXhlbCBlbSB1bSByYXN0ZXIuXCIsXG5cdFx0c3RhdGlzdGljc0hpc3RvZ3JhbU5hbWU6IFwiRXN0YXTDrXN0aWNhcyBlIEhpc3RvZ3JhbWFcIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtU25pcDogXCJEZWZpbmUgb3UgYXNzb2NpYSBhIGVzdGF0w61zdGljYXMgZSBoaXN0b2dyYW1hLlwiLFxuXHRcdHN0YXRpc3RpY3NIaXN0b2dyYW1EZXNjOiBcIkEgZnVuw6fDo28gRXN0YXTDrXN0aWNhIGUgSGlzdG9ncmFtYSDDqSB1dGlsaXphZGEgcGFyYSBkZWZpbmlyIGEgZXN0YXTDrXN0aWNhIGUgaGlzdG9ncmFtYSBkZSB1bSByYXN0ZXIuIFZvY8OqIHBvZGUgaW5zZXJpciBlc3RhIGZ1bsOnw6NvIG5vIGZpbmFsIGRhIGNhZGVpYSBkZSBmdW7Dp8OjbyBwYXJhIGRlc2NyZXZlciBhIGVzdGF0w61zdGljYSBlIGhpc3RvZ3JhbWEgZGUgdW0gbW9kZWxvIGRlIGZ1bsOnw6NvIGRvIHJhc3RlciAoUkZUKS4gSXN0byBwb2RlIHNlciBuZWNlc3PDoXJpbyBwYXJhIGNvbnRyb2xhciBhIHZpc3VhbGl6YcOnw6NvIHBhZHLDo28gZG8gcmVzdWx0YWRvIGRlIHByb2Nlc3NhbWVudG8sIGVzcGVjaWFsbWVudGUgYW8gZGVmaW5pciB1bWEgY2FkZWlhIGRlIGZ1bsOnw6NvIHF1ZSBjb250w6ltIG11aXRhcyBmdW7Dp8O1ZXMuPGRpdj48YnIvPlZvY8OqIHBvZGUgZGVmaW5pciBlc3RhdMOtc3RpY2FzIGRpZ2l0YW5kbyBvcyB2YWxvcmVzIG91IGltcG9ydGFuZG8gZGUgdW0gY29uanVudG8gZGUgZGFkb3MgcmFzdGVyIG91IHVtIGFycXVpdm8gWE1MLiBPcyBoaXN0b2dyYW1hcyBwb2RlbSBzb21lbnRlIHNlciBkZWZpbmlkb3MgaW1wb3J0YW5kbyB1bSBhcnF1aXZvLjwvZGl2PlwiLFxuXHRcdHN0YXRpc3RpY3NOYW1lOiBcIkVzdGF0w61zdGljYVwiLFxuXHRcdHN0YXRpc3RpY3NTbmlwOiBcIkNhbGN1bGEgYSBlc3RhdMOtc3RpY2EgZm9jYWwgcGFyYSBjYWRhIHBpeGVsIGRlIHVtYSBpbWFnZW0gYmFzZWFkbyBlbSB1bWEgdml6aW5oYW7Dp2EgZm9jYWwgZGVmaW5pZGEuXCIsXG5cdFx0c3RhdGlzdGljc0Rlc2M6IFwiQSBmdW7Dp8OjbyBFc3RhdMOtc3RpY2EgY2FsY3VsYSBhIGVzdGF0w61zdGljYSBmb2NhbCBwYXJhIGNhZGEgcGl4ZWwgZGUgdW1hIGltYWdlbSBiYXNlYWRvIGVtIHVtYSB2aXppbmhhbsOnYSBmb2NhbCBkZWZpbmlkYS48ZGl2Pjxici8+QSBmdW7Dp8OjbyBFc3RhdMOtc3RpY2EgcG9kZSBzZXIgdXRpbGl6YWRhIHBhcmEgcHJlZW5jaGVyIGxpbmhhcyBkZXNjYXJ0YWRhcyBlbSB1bWEgaW1hZ2VtLiBBcyBsaW5oYXMgZGVzY2FydGFkYXMgZXN0w6NvIGZyZXF1ZW50ZW1lbnRlIGNhdXNhZGFzIHBvciBwcm9ibGVtYXMgbm8gc2Vuc29yIG9uZGUgb3MgZGFkb3MgbsOjbyBzw6NvIGNvbGV0YWRvcy4gSXN0byBvY29ycmV1IGVtIHNlbnNvcmVzIGNvbW8gTGFuZHNhdCA3J3MgRW5oYW5jZWQgVGhlbWF0aWMgTWFwcGVyIFBsdXMgKEVUTSspLiBFc3RlcyBwcm9ibGVtYXMgY2F1c2FtIHBlcmRhIGRlIGRhZG9zIHBhcmEgYW7DoWxpc2UgZSB0YW1iw6ltIHF1YW5kbyB2aXN1YWxpemFyIGEgaW1hZ2VtLiBIw6EgcG91Y28gcXVlIHBvZGUgc2VyIGZlaXRvIGFvIHV0aWxpemFyIGEgaW1hZ2VtIHBhcmEgYW7DoWxpc2U7IGVudHJldGFudG8sIHNlIGhvdXZlciB1bWEgaW1hZ2VtIGRlIHNvYnJlcG9zacOnw6NvLCBwb2RlIHNlciB1dGlsaXphZG8gbm8gbHVnYXIgZG8gY29udGXDumRvIHBlcmRpZG8uIE8gbWVzbW8gcG9kZSBzZXIgZmVpdG8gc2UgYSBpbWFnZW0gZXN0aXZlciBzZW5kbyB1dGlsaXphZGEgcGFyYSB2aXN1YWxpemHDp8Ojby4gRW50cmV0YW50bywgbsOjbyBow6Egc2VtcHJlIHVtYSBpbWFnZW0gZXh0cmEgcGFyYSBwcmVlbmNoZXIgbyBjb250ZcO6ZG8gcGVyZGlkbywgZW50w6NvIGVsZSBkZXZlIHNlciBvYnRpZG8gYSBwYXJ0aXIgZGUgZGFkb3MgZXhpc3RlbnRlcy48L2Rpdj5cIixcblx0XHRzdHJlYW1MaW5rTmFtZTogXCJMaW5rIGRvIEZsdXhvXCIsXG5cdFx0c3RyZWFtTGlua1NuaXA6IFwiQXRyaWJ1aSB2YWxvcmVzIMO6bmljb3MgcGFyYSBzZcOnw7VlcyBkYSByZWRlIGxpbmVhciBkbyByYXN0ZXIgZW50cmUgaW50ZXJzZcOnw7Vlcy5cIixcblx0XHRzdHJlYW1MaW5rRGVzYzogXCJBIGZ1bsOnw6NvIExpbmsgZG8gRmx1eG8gZ2xvYmFsIGF0cmlidWkgdmFsb3JlcyDDum5pY29zIHBhcmEgc2XDp8O1ZXMgZGEgcmVkZSBsaW5lYXIgZG8gcmFzdGVyIGVudHJlIGludGVyc2Vjw6fDtWVzLjxkaXY+PGJyLz5MaW5rcyBzw6NvIGFzIHNlw6fDtWVzIGRlIHVtIGNhbmFsIGRlIGZsdXhvIGNvbmVjdGFuZG8gZHVhcyBqdW7Dp8O1ZXMgc3VjZXNzaXZhcywgdW1hIGp1bsOnw6NvIGUgYSBzYcOtZGEsIG91IHVtYSBqdW7Dp8OjbyBlIGEgZGl2aXPDo28gZGUgZHJlbmFnZW0uIEVtIGhpZHJvbG9naWEsIGVzdGVzIHNlZ21lbnRvcyBkZSBmbHV4byBzw6NvIGNoYW1hZG9zIGRlIGFsY2FuY2VzLiBVbWEganVuw6fDo28gw6kgcmVsYWNpb25hZGEgYSB1bSBwb250byBkZSBlc2NvYW1lbnRvIGUgYWp1ZGEgZGVsaW5lYXIgdW1hIGJhY2lhIG91IGxpbWl0ZSBkZSBkcmVuYWdlbSBkZSBzdWItYmFjaWEuPC9kaXY+XCIsXG5cdFx0c3RyZXRjaE5hbWU6IFwiQ29udHJhc3RlXCIsXG5cdFx0c3RyZXRjaFNuaXA6IFwiTWVsaG9yYSB1bWEgaW1hZ2VtIGFqdXN0YW5kbyBhIGZhaXhhIGRlIHZhbG9yZXMgZXhpYmlkb3MuIElzdG8gbsOjbyBhbHRlcmEgb3MgdmFsb3JlcyBkZSBwaXhlbCBzdWJqYWNlbnRlcy4gU2UgdW0gcGl4ZWwgdGl2ZXIgdW0gdmFsb3IgZm9yYSBkYSBmYWl4YSBlc3BlY2lmaWNhZGEsIGVsZSBhcGFyZWNlcsOhIGNvbW8gbyB2YWxvciBtw61uaW1vIG91IG3DoXhpbW8uXCIsXG5cdFx0c3RyZXRjaERlc2M6IFwiQSBmdW7Dp8OjbyBDb250cmFzdGUgbWVsaG9yYSB1bWEgaW1hZ2VtIHBlbGEgYWx0ZXJhw6fDo28gZGFzIHByb3ByaWVkYWRlcywgdGFsIGNvbW8sIGJyaWxobywgY29udHJhc3RlIGUgZ2FtYSBhdHJhdsOpcyBkZSB2w6FyaW9zIHRpcG9zIGRlIGNvbnRyYXN0ZS4gRXN0YSBmdW7Dp8OjbyB1dGlsaXphIGEgZXN0YXTDrXN0aWNhIGRvcyByYXN0ZXJzIGRlbnRybyBkbyBjb25qdW50byBkZSBkYWRvcyBkbyBtb3NhaWNvOyBwb3J0YW50bywgc2Ugdm9jw6ogdXRpbGl6YXIgZXN0YSBmdW7Dp8Ojbywgdm9jw6ogZGV2ZSBjZXJ0aWZpY2FyLXNlIHF1ZSBhcyBlc3RhdMOtc3RpY2FzIGZvcmFtIGNhbGN1bGFkYXMuPGRpdj48YnIvPk8gdGlwbyBkZSBjb250cmFzdGUgZGVmaW5lIHVtIGNvbnRyYXN0ZSBkZSBoaXN0b2dyYW1hIHF1ZSBzZXLDoSBhcGxpY2FkbyBhb3MgcmFzdGVycyBwYXJhIG1lbGhvcmFyIHN1YSBhcGFyw6puY2lhLiBPIGNvbnRyYXN0ZSBtZWxob3JhIGEgYXBhcsOqbmNpYSBkb3MgZGFkb3MgZXNwYWxoYW5kbyBvcyB2YWxvcmVzIGRlIHBpeGVsIGFvIGxvbmdvIGRlIHVtIGhpc3RvZ3JhbWEgYSBwYXJ0aXIgZGUgdmFsb3JlcyBtw61uaW1vcyBlIG3DoXhpbW9zIGRlZmluaWRvcyBwb3Igc3VhIHByb2Z1bmRpZGFkZSBkZSBiaXQuIDwvZGl2PlwiLFxuXHRcdHN3YXRoTmFtZTogXCJGaWxlaXJhXCIsXG5cdFx0c3dhdGhTbmlwOiBcIkludGVycG9sYSBkZSBncmFkZXMgaXJyZWd1bGFyZXMgb3UgZGFkb3MgZGUgZmlsZWlyYS5cIixcblx0XHRzd2F0aERlc2M6IFwiQWxndW5zIGNvbmp1bnRvIGRlIGRhZG9zIG5ldENERiBvdSBIREYgYXJtYXplbmFtIHN1YSBsb2NhbGl6YcOnw6NvIGdlb2dyw6FmaWNhIGNvbW8gdmV0b3JlcyBlc3Bhw6dhZG9zIGlycmVndWxhcm1lbnRlLiBBbyBhZGljaW9uYXIgZXN0ZXMgY29uanVudG8gZGUgZGFkb3MgcGFyYSB1bSBjb25qdW50byBkZSBkYWRvcyBkbyBtb3NhaWNvLCBhIGZ1bsOnw6NvIGRlIGZpbGVpcmEgdXRpbGl6YSBvcyBkYWRvcyBpcnJlZ3VsYXJtZW50ZSBuYSBncmFkZSBlIHJlYW1vc3RyYSBkZSBmb3JtYSBxdWUgY2FkYSBwaXhlbCDDqSBkZSB0YW1hbmhvIHVuaWZvcm1lIGUgw6kgcXVhZHJhZG8uPGRpdj48YnIvPkFvIGFkaWNpb25hciB2YXJpw6F2ZWlzIGRlIG5ldENERiBvdSBIREYgYSB1bSBjb25qdW50byBkZSBkYWRvcyBkZSBtb3NhaWNvLCBlbGEgdmVyaWZpY2Fyw6EgYXV0b21hdGljYW1lbnRlIHNlIG9zIGRhZG9zIGVzdMOjbyBkaXNwb3N0b3MgcmVndWxhcm1lbnRlLiBTZSBlbGEgbsOjbyBmb3IsIGEgZnVuw6fDo28gZGUgZmlsZWlyYSDDqSBhdXRvbWF0aWNhbWVudGUgYXBsaWNhZG8gcGFyYSBjb252ZXJ0ZXIgbyByYXN0ZXIgaXJyZWd1bGFyIGVtIHBvbnRvcyBlIGVudMOjbyBwYXJhIHVtYSByYXN0ZXIgcmVndWxhcm1lbnRlIG5hIGdyYWRlLiBWb2PDqiBwb2RlIGFsdGVyYXIgbyBtw6l0b2RvIGRlIGludGVycG9sYcOnw6NvIGUgdGFtYW5obyBkZSBjw6lsdWxhIHV0aWxpemFkbyBuYSBmdW7Dp8OjbyBkZSByYXN0ZXIgZGUgZmlsZWlyYS4gUGFyYSBkYWRvcyByYXN0ZXIgZXNwYcOnYWRvIGRlIGZvcm1hIHJlZ3VsYXIsIG5lbmh1bWEgaW50ZXJwb2xhw6fDo28gc2Vyw6EgYXBsaWNhZGEsIG9zIGRhZG9zIHNlcsOjbyBsaWRvcyBjb21vIGVzdMOjby48L2Rpdj5cIixcblx0XHR0YW5ITmFtZTogXCJUYW5IXCIsXG5cdFx0dGFuSFNuaXA6IFwiQ2FsY3VsYSBhIHRhbmdlbnRlIGhpcGVyYsOzbGljYSBkZSBjw6lsdWxhcyBlbSB1bSByYXN0ZXIuXCIsXG5cdFx0dGFuSERlc2M6IFwiQSBmdW7Dp8OjbyBjYWxjdWxhIGEgdGFuZ2VudGUgaGlwZXJiw7NsaWNhIGRvcyBwaXhlbHMgZW0gdW0gcmFzdGVyLlwiLFxuXHRcdHRhbk5hbWU6IFwiVGFuZ2VudGVcIixcblx0XHR0YW5TbmlwOiBcIkNhbGN1bGEgYSB0YW5nZW50ZSBkZSBjw6lsdWxhcyBlbSB1bSByYXN0ZXIuXCIsXG5cdFx0dGFuRGVzYzogXCJBIGZ1bsOnw6NvIGNhbGN1bGEgYSB0YW5nZW50ZSBkb3MgcGl4ZWxzIGVtIHVtIHJhc3Rlci4gXCIsXG5cdFx0dGFzc2VsZWRDYXBOYW1lOiBcIlRhc3NlbGVkIENhcCAoS2F1dGgtVGhvbWFzKVwiLFxuXHRcdHRhc3NlbGVkQ2FwU25pcDogXCJDYWxjdWxhIG7DrXZlaXMgZGUgdmVnZXRhw6fDo28sIHVtaWRhZGUgZSBicmlsaG8uIEVzdGEgdMOpY25pY2EgY29udGEgY29tIGNvZWZpY2llbnRlcyBxdWUgZGV2ZW0gc2VyIGVzcGVjaWZpY2FtZW50ZSBjYWxjdWxhZG9zIHBhcmEgdW0gc2Vuc29yLlwiLFxuXHRcdHRhc3NlbGVkQ2FwRGVzYzogXCJBIHRyYW5zZm9ybWHDp8OjbyBUYXNzZWxlZCBDYXAgKEthdXRoLVRob21hcykgw6kgcHJvamV0YWRhIHBhcmEgYW5hbGlzYXIgZSBtYXBlYXIgYSBmZW5vbWVub2xvZ2lhIGRlIHZlZ2V0YcOnw6NvIGUgYWx0ZXJhw6fDtWVzIGRlIGRlc2Vudm9sdmltZW50byB1cmJhbm8gZGV0ZWN0YWRhcyBwb3IgdsOhcmlvcyBzaXN0ZW1hcyBkZSBzZW5zb3IgZG8gc2F0w6lsaXRlLiDDiSBjb25oZWNpZGEgY29tbyBhIHRyYW5zZm9ybWHDp8OjbyBUYXNzZWxlZCBDYXAgZGV2aWRvIMOgIGZvcm1hIGRhIGRpc3RyaWJ1acOnw6NvIGdyw6FmaWNhIGRvcyBkYWRvcy4gQSB0cmFuc2Zvcm1hw6fDo28gZm9ybmVjZXUgdW1hIHJhesOjbyBwYXJhIG9zIHBhZHLDtWVzIGxvY2FsaXphZG9zIGVtIGRhZG9zIGRlIExhbmRzYXQgTVNTIGRlIGNhbXBvcyBhZ3LDrWNvbGEgY29tbyB1bWEgZnVuw6fDo28gZG8gY2ljbG8gdml0YWzDrWNpbyBkYSBjb2xoZWl0YS4gRXNzZW5jaWFsbWVudGUsIMOgIG1lZGlkYSBxdWUgYXMgY29saGVpdGFzIGNyZXNjZW0gZGEgc2VtZW50ZSDDoCBtYXR1cmlkYWRlLCBow6EgdW0gYXVtZW50byBsw61xdWlkbyBubyBpbmZyYXZlcm1lbGhvIHByw7N4aW1vIGUgdW1hIGRpbWludWnDp8OjbyBuYSByZWZsZXTDom5jaWEgZG8gdmVybWVsaG8gY29tIGJhc2UgbmEgY29yIGRvIHNvbG88ZGl2Pjxicj5PIHV0aWxpdMOhcmlvIGRlc3RhIHRyYW5zZm9ybWHDp8OjbyBleHBhbmRpdSBhIHBhcnRpciBkbyBtb25pdG9yYW1lbnRvIGRlIGNvbGhlaXRhcyBwYXJhIGFuYWxpc2FyIGUgbWFwZWFyIGEgdmVnZXRhw6fDo28gcGFyYSBzdXBvcnRhciB1bWEgdmFyaWVkYWRlIGRlIGFwbGljYcOnw7VlcywgdGFpcyBjb21vLCBzaWx2aWN1bHR1cmEsIGdlcmVuY2lhbWVudG8gZGUgdmVnZXRhw6fDo28gaW5kdXN0cmlhbCwgbWFwZWFtZW50byBlIGdlcmVuY2lhbWVudG8gZGUgZWNvc3Npc3RlbWEsIGludmVudMOhcmlvIGUgbW9uaXRvcmFtZW50byBkbyBpc29sYW1lbnRvIGRlIGNhcmJvbm8gZSBjcsOpZGl0b3MsIGRlc2Vudm9sdmltZW50byB1cmJhbm8gZSBtYWlzLiBUYW1iw6ltIGV4cGFuZGl1IGEgcGFydGlyIGRvIHN1cG9ydGUgZG8gTGFuZHNhdCBNU1MgcGFyYSBpbmNsdWlyIG91dHJvcyBzaXN0ZW1hcyBkZSBzYXTDqWxpdGVzIHBvcHVsYXJlcywgY29tbyBzZW5zb3JlcyBtdWx0aWVzcGVjdHJhaXMgZG8gTGFuZHNhdCBUTSwgTGFuZHNhdCBFVE0rLCBMYW5kc2F0IDgsIElLT05PUywgUXVpY2tCaXJkLCBXb3JsZFZpZXctMiBlIFJhcGlkRXllLjwvZGl2PlwiLFxuXHRcdHRpbWVzTmFtZTogXCJNdWx0aXBsaWNhclwiLFxuXHRcdHRpbWVzU25pcDogXCJNdWx0aXBsaWNhIG9zIHZhbG9yZXMgZGUgZG9pcyByYXN0ZXJzIGVtIHVtYSBiYXNlIGRlIGPDqWx1bGEgcG9yIGPDqWx1bGEuXCIsXG5cdFx0dGltZXNEZXNjOiBcIkEgZnVuw6fDo28gTXVsdGlwbGljYXIgZGl2aWRlIG9zIHZhbG9yZXMgZGUgZG9pcyByYXN0ZXJzIGVtIHVtYSBiYXNlIGRlIHBpeGVsIGEgcGl4ZWwuXCIsXG5cdFx0dHJhbnNwb3NlQml0c05hbWU6IFwiVHJhbnNwb3J0YXIgQml0c1wiLFxuXHRcdHRyYW5zcG9zZUJpdHNTbmlwOiBcIkRlc2NvbXBhY3RhIG9zIGJpdHMgZG8gcGl4ZWwgZGUgZW50cmFkYSBlIG1hcGVpZS1vcyBwYXJhIGJpdHMgZXNwZWNpZmljYWRvcyBubyBwaXhlbCBkZSBzYcOtZGEuIE8gcHJvcMOzc2l0byBkZXN0YSBmdW7Dp8OjbyDDqSBtYW5pcHVsYXIgYml0cyBkZSBhbGd1bWFzIGVudHJhZGFzLCBjb21vIHByb2R1dG9zIGRlIGJhbmRhIGRhIHF1YWxpZGFkZSBMYW5kc2F0IDguXCIsXG5cdFx0dHJhbnNwb3NlQml0c0Rlc2M6IFwiQSBmdW7Dp8OjbyBUcmFuc3BvcnRhciBCaXRzIGRlc2NvbXBhY3RhIG9zIGJpdHMgZG8gcGl4ZWwgZGUgZW50cmFkYSBlIG1hcGVpZS1vcyBwYXJhIGJpdHMgZXNwZWNpZmljYWRvcyBubyBwaXhlbCBkZSBzYcOtZGEuIE8gcHJvcMOzc2l0byBkZXN0YSBmdW7Dp8OjbyDDqSBtYW5pcHVsYXIgYml0cyBkZSBhbGd1bWFzIGVudHJhZGFzLCBjb21vIHByb2R1dG9zIGRlIGJhbmRhIGRhIHF1YWxpZGFkZSBMYW5kc2F0IDguXCIsXG5cdFx0dW5pdENvbnZlcnNpb25OYW1lOiBcIkNvbnZlcnPDo28gZGEgVW5pZGFkZVwiLFxuXHRcdHVuaXRDb252ZXJzaW9uU25pcDogXCJBbHRlcmEgdmFsb3JlcyBkZSB1bWEgdW5pZGFkZSBkZSBtZWRpw6fDo28gcGFyYSBvdXRyYS5cIixcblx0XHR1bml0Q29udmVyc2lvbkRlc2M6IFwiRXN0YSBmdW7Dp8OjbyBjb252ZXJ0ZSBwaXhlbHMgZGUgdW1hIHVuaWRhZGUgYXTDqSBvdXRyYS4gU3Vwb3J0YSBjb252ZXJzw6NvIGRlIGRpc3TDom5jaWEsIHZlbG9jaWRhZGUgZSB0ZW1wZXJhdHVyYS5cIixcblx0XHR2ZWN0b3JGaWVsZE5hbWU6IFwiQ2FtcG8gZGUgVmV0b3JcIixcblx0XHR2ZWN0b3JGaWVsZFNuaXA6IFwiRXhpYmUgY29uanVudG9zIGRlIGRhZG9zIGNvbSBhbWJhcyBhIG1hZ25pdHVkZSAodSkgZSBkaXJlw6fDo28gKHYpIGNvbW8gc2V0YXMgb25kZSBhIG1hZ25pdHVkZSDDqSByZXByZXNlbnRhZGEgcGVsbyB0YW1hbmhvIGUgYSBkaXJlw6fDo28gw6kgcmVwcmVzZW50YWRhIHBlbG8gw6JuZ3VsbyBkYSBzZXRhLlwiLFxuXHRcdHZlY3RvckZpZWxkRGVzYzogXCJBIGZ1bsOnw6NvIENhbXBvIGRlIFZldG9yIMOpIHV0aWxpemFkYSBwYXJhIGNvbXBvciBlIGNvbnZlcnRlciBkb2lzIHJhc3RlcnMgZW0gdW0gcmFzdGVyIGRlIGR1YXMgYmFuZGFzIHF1ZSDDqSBkbyB0aXBvIGRlIGRhZG9zIERpcmXDp8OjbyBkZSBNYWduaXR1ZGUgb3UgdGlwbyBkZSBkYWRvcyBVLVYuPGRpdj48YnIvPk8gdmFsb3IgVSDDqSDDoHMgdmV6ZXMgY2hhbWFkbyBkYSB2ZWxvY2lkYWRlIHpvbmFsIGUgdmFsb3IgViDDqSDDoHMgdmV6ZXMgY2hhbWFkbyBkZSB2ZWxvY2lkYWRlIG1lcmlkaW9uYWwuPC9kaXY+XCIsXG5cdFx0dmlld3NoZWQyTmFtZTogXCJQYW5vcmFtYVwiLFxuXHRcdHZpZXdzaGVkMlNuaXA6IFwiRGV0ZXJtaW5hIG9zIGxvY2FpcyBkZSBzdXBlcmbDrWNpZSBkbyByYXN0ZXIgdmlzw612ZWlzIHBhcmEgdW0gY29uanVudG8gZGUgZmVpw6fDtWVzIGRvIG9ic2VydmFkb3IsIHV0aWxpemFuZG8gbcOpdG9kb3MgZ2VvZMOpc2ljb3MuXCIsXG5cdFx0dmlld3NoZWQyRGVzYzogXCJBIGZ1bsOnw6NvIFBhbm9yYW1hIGRldGVybWluYXMgYXMgbG9jYWxpemHDp8O1ZXMgdmlzw612ZWlzIGRhIHN1cGVyZsOtY2llIGRvIHJhc3RlciBwYXJhIHVtIGNvbmp1bnRvIGRlIGZlacOnw7VlcyBkbyBvYnNlcnZhZG9yIHV0aWxpemFuZG8gbcOpdG9kb3MgZ2VvZMOpc2ljb3M8ZGl2Pjxici8+QSB2aXNpYmlsaWRhZGUgZGUgY2FkYSBjZW50cm8gZG8gcGl4ZWwgw6kgZGV0ZXJtaW5hZG8gcG9yIHVtIHRlc3RlIGRlIGxpbmhhLWRlLXZpc2FkYSBlbnRyZSBvIGFsdm8gZSBjYWRhIG9ic2VydmFkb3IuIFNlIHVtIG9ic2VydmFkb3IgcG9kZSB2aXN1YWxpemFyIG8gYWx2byBubyBjZW50cm8gZG8gcGl4ZWwsIG8gcGl4ZWwgw6kgY29uc2lkZXJhZG8gdmlzw612ZWwuIEVzdGEgZmVycmFtZW50YSBzZW1wcmUgY29uc2lkZXJhIGEgY3VydmF0dXJhIGRhIFRlcnJhIHF1YW5kbyBhIHZpc2liaWxpZGFkZSDDqSBkZXRlcm1pbmFkYS48L2Rpdj5cIixcblx0XHR3YXRlcnNoZWROYW1lOiBcIlZlcnRlbnRlXCIsXG5cdFx0d2F0ZXJzaGVkU25pcDogXCJEZXRlcm1pbmEgYSDDoXJlYSBkZSBjb250cmlidWnDp8OjbyBzb2JyZSB1bSBjb25qdW50byBkZSBjw6lsdWxhcyBlbSB1bSByYXN0ZXIuXCIsXG5cdFx0d2F0ZXJzaGVkRGVzYzogXCJBIGZ1bsOnw6NvIFZlcnRlbnRlIGdsb2JhbCBkZXRlcm1pbmEgYSBjb250cmlidWnDp8OjbyBkZSDDoXJlYSBzb2JyZSB1bSBjb25qdW50byBkZSBwaXhlbHMgZW0gdW0gcmFzdGVyLiBBcyB2ZXJ0ZW50ZXMgc8OjbyBkZWxpbmVhZGFzIGEgcGFydGlyIGRlIHVtIHJhc3RlciBkZSBkaXJlw6fDo28gZGUgZmx1eG8gcXVlIGlkZW50aWZpY2EgYSBkaXJlw6fDo28gZGUgZmx1eG8gZGUgY2FkYSBwaXhlbC5cIixcblx0XHR3ZWlnaHRlZE92ZXJsYXlOYW1lOiBcIlNvYnJlcG9zacOnw6NvIFBvbmRlcmFkYVwiLFxuXHRcdHdlaWdodGVkT3ZlcmxheVNuaXA6IFwiU29icmVww7VlIGRpdmVyc29zIGRhZG9zIHJhc3RlciB1dGlsaXphbmRvIHVtYSBlc2NhbGEgZGUgbWVkaWRhIGNvbXVtIGUgcGVzYSBjYWRhIHVtIGRlIGFjb3JkbyBjb20gc3VhIGltcG9ydMOibmNpYS5cIixcblx0XHR3ZWlnaHRlZE92ZXJsYXlEZXNjOiBcIkVzdGEgZnVuw6fDo28gcGVybWl0ZSBhIHZvY8OqIHNvYnJlcG9yIGRpdmVyc29zIHJhc3RlcnMgdXRpbGl6YW5kbyB1bWEgZXNjYWxhIGRlIG1lZGlkYSBjb211bSBlIHBlc29zLCBjYWRhIHVtIGRlIGFjb3JkbyBjb20gc3VhIGltcG9ydMOibmNpYS5cIixcblx0XHR3ZWlnaHRlZFN1bU5hbWU6IFwiU29tYSBQb25kZXJhZGFcIixcblx0XHR3ZWlnaHRlZFN1bVNuaXA6IFwiUGVzYSBlIGFkaWNpb25hIHVtIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3RlcnMgZW0gdW1hIGJhc2UgZGUgY8OpbHVsYSBhIGPDqWx1bGEuXCIsXG5cdFx0d2VpZ2h0ZWRTdW1EZXNjOiBcIkEgZnVuw6fDo28gU29tYSBQb25kZXJhZGEgcGVybWl0ZSBhIHZvY8OqIHNvYnJlcG9yIHbDoXJpb3MgcmFzdGVycywgbXVsdGlwbGljYW5kbyBjYWRhIHVtIHBlbG8gc2V1IHBlc28gZSBzb21hbmRvLW9zIGp1bnRvcy5cIixcblx0XHR3aW5kY2hpbGxOYW1lOiBcIlZlbnRvIEZyaW9cIixcblx0XHR3aW5kY2hpbGxTbmlwOiBcIkNvbWJpbmEgdGVtcGVyYXR1cmEgZG8gYW1iaWVudGUgZSB2ZWxvY2lkYWRlIGRvIHZlbnRvIHBhcmEgY2FsY3VsYXIgYSBzZW5zYcOnw6NvIHTDqXJtaWNhLlwiLFxuXHRcdHdpbmRjaGlsbERlc2M6IFwiQSBmdW7Dp8OjbyBkZSBWZW50byBGcmlvIMOpIMO6dGlsIHBhcmEgaWRlbnRpZmljYXIgY29uZGnDp8O1ZXMgcGVyaWdvc2FzIGRlIGludmVybm8gcXVlLCBkZXBlbmRlbmRvIGRvcyB0ZW1wb3MgZGUgZXhwb3Npw6fDo28gYW9zIGVsZW1lbnRvcywgcG9kZSByZXN1bHRhciBlbSB1bGNlcmHDp8OjbyBvdSBhdMOpIGhpcG90ZXJtaWEuIE8gdmVudG8gZnJpbyDDqSB1bWEgZm9ybWEgcGFyYSBtZWRpciBvIHF1YW50byBlc3TDoSBmcmlvIHF1YW5kbyBvIHZlbnRvIMOpIGxldmFkbyBlbSBjb250YSBjb20gdGVtcGVyYXR1cmFzIGrDoSBiYWl4YXMuIFF1YW50byBtYWlzIHLDoXBpZGEgYSB2ZWxvY2lkYWRlIGRvIHZlbnRvLCBvIGNvcnBvIHBlcmRlcsOhIGNhbG9yIG1haXMgcmFwaWRhbWVudGUgZSBtYWlzIGZyaW8gZWxlcyBzZW50aXLDo28uXCIsXG5cdFx0em9uYWxSZW1hcE5hbWU6IFwiUmVtYXBlYW1lbnRvIFpvbmFsXCIsXG5cdFx0em9uYWxSZW1hcFNuaXA6IFwiUmVtYXBlaWEgcGl4ZWxzIGVtIHVtIHJhc3RlciBiYXNlYWRvIGVtIHpvbmFzIGRlZmluaWRhcyBwb3Igb3V0cm8gcmFzdGVyIGUgdW0gbWFwZWFtZW50byBkZSB2YWxvcmVzIGRlcGVuZGVudGUgZGUgem9uYSBkZWZpbmlkbyBlbSB1bWEgdGFiZWxhLlwiLFxuXHRcdHpvbmFsUmVtYXBEZXNjOiBcIkVzdGEgw6kgdW1hIGZ1bsOnw6NvIHF1ZSBwZXJtaXRlIGEgdm9jw6ogcmVtYXBlYXIgcGl4ZWxzIGVtIHVtIHJhc3RlciBiYXNlYWRvIGVtIHpvbmFzIGRlZmluaWRhcyBwb3Igb3V0cm8gcmFzdGVyIGUgdW0gbWFwZWFtZW50byBkZSB2YWxvcmVzIGRlcGVuZGVudGUgZGUgem9uYSBkZWZpbmlkbyBlbSB1bWEgdGFiZWxhLlwiLFxuXHRcdHpvbmFsU3RhdGlzdGljc05hbWU6IFwiRXN0YXTDrXN0aWNhIFpvbmFsXCIsXG5cdFx0em9uYWxTdGF0aXN0aWNzU25pcDogXCJDYWxjdWxhIGEgZXN0YXTDrXN0aWNhIGVtIHZhbG9yZXMgZGUgdW0gcmFzdGVyIGRlbnRybyBkYXMgem9uYXMgZGUgb3V0cm8gY29uanVudG8gZGUgZGFkb3MuXCIsXG5cdFx0em9uYWxTdGF0aXN0aWNzRGVzYzogXCJBIGZ1bsOnw6NvIGNhbGN1bGEgYSBlc3RhdMOtc3RpY2EgZW0gdmFsb3JlcyBkZSB1bSByYXN0ZXIgZGVudHJvIGRhcyB6b25hcyBkZSBvdXRybyBjb25qdW50byBkZSBkYWRvcy4gQSB6b25hIMOpIGRlZmluaWRhIHBvciB0b2RvcyBvcyBsb2NhaXMgbmEgZW50cmFkYSBxdWUgdGVuaGFtIG8gbWVzbW8gdmFsb3IuIEVzdGFzIMOhcmVhcyBuw6NvIHTDqm0gcXVlIHNlciBjb250w61ndWFzLiBRdWFuZG8gYSB6b25hIGUgZW50cmFkYXMgZGUgdmFsb3JlcyBzw6NvIGFtYm9zIHJhc3RlcnMgZGEgbWVzbWEgcmVzb2x1w6fDo28sIGVsZXMgc2Vyw6NvIGRpcmV0YW1lbnRlIHV0aWxpemFkb3MuIFNlIGFzIHJlc29sdcOnw7VlcyBmb3JlbSBkaWZlcmVudGVzLCB1bWEgcmVhbW9zdHJhZ2VtIGludGVybmEgw6kgYXBsaWNhZGEgcGFyYSBjb3JyZXNwb25kZXIgw6BzIHJlc29sdcOnw7VlcyBhbnRlcyBkYSBvcGVyYcOnw6NvIHpvbmFsIHNlciBleGVjdXRhZGEuXCIsXG5cdFx0Zmxvd0xlbmd0aE5hbWU6IFwiQ29tcHJpbWVudG8gZG8gRmx1eG9cIixcblx0XHRmbG93TGVuZ3RoU25pcDogXCJDYWxjdWxhIGEgZGlzdMOibmNpYSBhIG1vbnRhbnRlIG91IGEganVzYW50ZSwgb3UgYSBkaXN0w6JuY2lhIHBvbmRlcmFkYSwgYW8gbG9uZ28gZG8gY2FtaW5obyBkbyBmbHV4byBwYXJhIGNhZGEgY8OpbHVsYS5cIixcblx0XHRmbG93TGVuZ3RoRGVzYzogXCJFc3RhIMOpIHVtYSBmdW7Dp8OjbyBkZSByYXN0ZXIgZ2xvYmFsIC4gRXN0YSBmdW7Dp8OjbyBjcmlhIHVtYSBjYW1hZGEgZGUgcmFzdGVyIGRhIGRpc3TDom5jaWEgZGUgbW9udGFudGUgb3UganVzYW50ZSwgb3UgZGlzdMOibmNpYSBwb25kZXJhZGEsIGFvIGxvbmdvIGRvIHRyYWpldG8gZGUgZmx1eG8gcGFyYSBjYWRhIGPDqWx1bGEuPGRpdj48YnIvPlVtIHVzbyBpbXBvcnRhbnRlIGRhIGZ1bsOnw6NvIENvbXByaW1lbnRvIGRvIEZsdXhvIMOpIGNhbGN1bGFyIG8gY29tcHJpbWVudG8gZGUgdHJhamV0byBkbyBmbHV4byBtYWlzIGxvbmdvIGRlbnRybyBkZSB1bWEgZGV0ZXJtaW5hZGEgYmFjaWEuIEVzdGEgbWVkaWRhIMOpIG5vcm1hbG1lbnRlIHV0aWxpemFkYSBwYXJhIGNhbGN1bGFyIG8gdGVtcG8gZGUgY29uY2VudHJhw6fDo28gZGUgdW1hIGJhY2lhLiBJc3RvIMOpIGNvbmNsdcOtZG8gY29tIG8gdXNvIGRhIG9ww6fDo28gTW9udGFudGUuIEEgZnVuw6fDo28gdGFtYsOpbSBwb2RlIHNlciB1dGlsaXphZGEgcGFyYSBjcmlhciBkaWFncmFtYXMgZGUgw6FyZWEtZGlzdMOibmNpYSBkZSBldmVudG9zIGhpcG90w6l0aWNvcyBkZSBwcmVjaXBpdGHDp8OjbyBlIGVzY29hbWVudG8gdXRpbGl6YW5kbyB1bSByYXN0ZXIgZGUgcGVzbyBjb21vIHVtYSBpbXBlZMOibmNpYSBhbyBtb3ZpbWVudG8gZGUgZGVjbGl2aWRhZGUuPC9kaXY+XCIsXG5cdFx0c3RyZWFtT3JkZXJOYW1lOiBcIk9yZGVtIGRvIEZsdXhvXCIsXG5cdFx0c3RyZWFtT3JkZXJTbmlwOiBcIkF0cmlidWkgdW1hIG9yZGVtIG51bcOpcmljYSBhb3Mgc2VnbWVudG9zIGRvIHJhc3RlciByZXByZXNlbnRhbmRvIHJhbWlmaWNhw6fDtWVzIGRlIHVtYSByZWRlIGxpbmVhclwiLFxuXHRcdHN0cmVhbU9yZGVyRGVzYzogXCJFc3RhIMOpIHVtYSBmdW7Dp8OjbyBkZSByYXN0ZXIgZ2xvYmFsIC4gRXN0YSBmdW7Dp8OjbyBjcmlhIHVtYSBjYW1hZGEgZGUgcmFzdGVyIHF1ZSBhdHJpYnVpIHVtYSBvcmRlbSBudW3DqXJpY2EgcGFyYSBzZWdtZW50b3MgZGUgdW0gcmFzdGVyIHJlcHJlc2VudGFuZG8gcmFtaWZpY2HDp8O1ZXMgZGUgdW1hIHJlZGUgbGluZWFyLjxkaXY+PGJyLz5BIHNhw61kYSBkYSBmdW7Dp8OjbyBPcmRlbSBkbyBGbHV4byBzZXLDoSBkZSBxdWFsaWRhZGUgc3VwZXJpb3Igc2UgYSBjYW1hZGEgZGUgcmFzdGVyIGRvIGZsdXhvIGRlIGVudHJhZGEgZSBhIGNhbWFkYSBkZSByYXN0ZXIgZGEgZGlyZcOnw6NvIGRvIGZsdXhvIGRlIGVudHJhZGEgZm9yZW0gZGVyaXZhZGFzIGRhIG1lc21hIHN1cGVyZsOtY2llLiBTZSBvIHJhc3RlciBkZSBmbHV4byBmb3IgZGVyaXZhZG8gZGUgdW0gY29uanVudG8gZGUgZGFkb3MgZGUgZmx1eG9zIHJhc3Rlcml6YWRvcywgYSBzYcOtZGEgcG9kZXLDoSBuw6NvIHNlciB1dGlsaXrDoXZlbCwgcG9pcywgZW0gdW1hIGJhc2UgZGUgY8OpbHVsYSBwb3IgY8OpbHVsYSwgYSBkaXJlw6fDo28gbsOjbyBjb3JyZXNwb25kZXLDoSDDoCBsb2NhbGl6YcOnw6NvIGRhcyBjw6lsdWxhcyBkbyBmbHV4by4gT3MgcmVzdWx0YWRvcyBkYSBmdW7Dp8OjbyBBY3VtdWxhw6fDo28gZGUgRmx1eG8gcG9kZW0gc2VyIHV0aWxpemFkb3MgcGFyYSBjcmlhciB1bWEgcmVkZSBkZSBmbHV4byBkbyByYXN0ZXIsIGFwbGljYW5kbyB1bSB2YWxvciBsaW1pdGUgcGFyYSBzZWxlY2lvbmFyIGPDqWx1bGFzIGNvbSBhbHRvIGZsdXhvIGFjdW11bGFkby4gUG9yIGV4ZW1wbG8sIGPDqWx1bGFzIHF1ZSB0w6ptIG1haXMgZGUgMTAwIGPDqWx1bGFzIGZsdWluZG8gcGFyYSBkZW50cm8gZGVsYXMgc8OjbyB1dGlsaXphZGFzIHBhcmEgZGVmaW5pciBhIHJlZGUgZGUgZmx1eG8uIFV0aWxpemUgYSBmdW7Dp8OjbyBDb24gb3UgRGVmaW5pciBOdWxvIHBhcmEgY3JpYXIgdW0gcmFzdGVyIGRhIHJlZGUgZGUgZmx1eG8gbmEgcXVhbCB2YWxvcmVzIGRlIGFjdW11bGHDp8OjbyBkbyBmbHV4byBkZSAxMDAgb3UgbWFpb3JlcyB2w6NvIHBhcmEgdW0sIGUgbyByZXN0YW50ZSDDqSBjb2xvY2FkbyBlbSBzZWd1bmRvIHBsYW5vIChOb0RhdGEpLiBBIHJlZGUgZGUgZmx1eG8gcmVzdWx0YW50ZSBwb2RlIHNlciB1dGlsaXphZGEgbmEgZnVuw6fDo28gT3JkZW0gZG8gRmx1eG8uIEVzdGEgZnVuw6fDo28gc3Vwb3J0YSBzb21lbnRlIHVtYSBjYW1hZGEgZGUgcmFzdGVyIGRlIGVudHJhZGEgZGEgZGlyZcOnw6NvIGRlIGZsdXhvIEQ4LiBBcyBkaXJlw6fDtWVzIGRlIGZsdXhvIEQ4IHBvZGVtIHNlciBjcmlhZGFzIHV0aWxpemFuZG8gYSBmdW7Dp8OjbyBEaXJlw6fDo28gZG8gRmx1eG8gZSBleGVjdXRhZGFzIGNvbSBvIHRpcG8gZGUgZGlyZcOnw6NvIGRlIGZsdXhvIEQ4IHBhZHLDo28uPC9kaXY+XCIsXG5cdFx0c25hcFBvdXJQb2ludE5hbWU6IFwiQWp1c3RhciBQb250byBkZSBFc2NvYW1lbnRvXCIsXG5cdFx0c25hcFBvdXJQb2ludFNuaXA6IFwiQWp1c3RhIHBvbnRvcyBkZSBlc2NvYW1lbnRvIHBhcmEgYSBjw6lsdWxhIGRlIG1haW9yIGFjdW11bGHDp8OjbyBkZSBmbHV4byBkZW50cm8gZGUgdW1hIGRpc3TDom5jaWEgZXNwZWNpZmljYWRhXCIsXG5cdFx0c25hcFBvdXJQb2ludERlc2M6IFwiRXN0YSDDqSB1bWEgZnVuw6fDo28gZGUgcmFzdGVyIGdsb2JhbCAuIEVzdGEgZnVuw6fDo28gYWp1c3RhIG9zIHBvbnRvcyBkZSBlc2NvYW1lbnRvIG5hIGPDqWx1bGEgZGUgbWFpb3IgYWN1bXVsYcOnw6NvIGRlIGZsdXhvIGRlbnRybyBkZSB1bWEgZGlzdMOibmNpYSBlc3BlY2lmaWNhZGEuPGRpdj48YnIvPkEgZnVuw6fDo28gQWp1c3RhciBQb250byBkZSBFc2NvYW1lbnRvIMOpIHV0aWxpemFkYSBwYXJhIGdhcmFudGlyIGEgc2VsZcOnw6NvIGRlIHBvbnRvcyBkZSBhbHRvIGZsdXhvIGFjdW11bGFkbyBhbyBkZWxpbmVhciBiYWNpYXMgZGUgZHJlbmFnZW0gdXRpbGl6YW5kbyBhIGZ1bsOnw6NvIFZlcnRlbnRlLiBBanVzdGFyIFBvbnRvIGRlIEVzY29hbWVudG8gYnVzY2Fyw6EgYSB1bWEgZGlzdMOibmNpYSBkZSBhanVzdGUgZW0gdG9ybm8gZG9zIHBvbnRvcyBkZSBlc2NvYW1lbnRvIGVzcGVjaWZpY2Fkb3MgcGFyYSBhIGPDqWx1bGEgZGUgbWFpb3IgZmx1eG8gYWN1bXVsYWRvIGUgbW92ZXLDoSBvIHBvbnRvIGRlIGVzY29hbWVudG8gcGFyYSBlc3RlIGxvY2FsLiBBIHNhw61kYSDDqSB1bWEgY2FtYWRhIGRlIHJhc3RlciBpbnRlaXJhIHF1YW5kbyBvcyBsb2NhaXMgb3JpZ2luYWlzIGRvIHBvbnRvIGRlIGVzY29hbWVudG8gZm9yYW0gYWp1c3RhZG9zIGFvcyBsb2NhaXMgY29tIG1haW9yIGZsdXhvIGFjdW11bGFkby48L2Rpdj5cIixcblx0XHRzaW5rTmFtZTogXCJDb2xldG9yXCIsXG5cdFx0c2lua1NuaXA6IFwiQ3JpYSB1bSByYXN0ZXIgaWRlbnRpZmljYW5kbyB0b2RvcyBvcyBjb2xldG9yZXMgb3Ugw6FyZWFzIGRlIGRyZW5hZ2VtIGludGVybmFcIixcblx0XHRzaW5rRGVzYzogXCJFc3RhIMOpIHVtYSBmdW7Dp8OjbyBkZSByYXN0ZXIgZ2xvYmFsIC4gRXN0YSBmdW7Dp8OjbyBjcmlhIHVtYSBjYW1hZGEgZGUgcmFzdGVyIGlkZW50aWZpY2FuZG8gdG9kb3Mgb3MgY29sZXRvcmVzIG91IMOhcmVhcyBkZSBkcmVuYWdlbSBpbnRlcm5hLiBVbSBjb2xldG9yIMOpIHVtYSBjw6lsdWxhIG91IGNvbmp1bnRvIGRlIGPDqWx1bGFzIGNvbmVjdGFkYXMgZXNwYWNpYWxtZW50ZSBjb20gdW1hIGRpcmXDp8OjbyBkZSBmbHV4byBxdWUgbsOjbyBwb2RlIHNlciBhdHJpYnXDrWRhIGEgdW0gZG9zIG9pdG8gdmFsb3JlcyB2w6FsaWRvcyBlbSB1bSByYXN0ZXIgZGUgZGlyZcOnw6NvIGRvIGZsdXhvLiBJc3RvIHBvZGUgb2NvcnJlciBxdWFuZG8gdG9kYXMgYXMgY8OpbHVsYXMgdml6aW5oYXMgc8OjbyBtYWlzIGFsdGFzIHF1ZSBhIGPDqWx1bGEgZGUgcHJvY2Vzc2FtZW50byBvdSBxdWFuZG8gZHVhcyBjw6lsdWxhcyBmbHVlbSB1bWEgcGFyYSBhIG91dHJhLCBjcmlhbmRvIHVtIGxvb3AgZGUgZHVhcyBjw6lsdWxhcy48ZGl2Pjxici8+QSBmdW7Dp8OjbyBDb2xldG9yIHN1cG9ydGEgc29tZW50ZSB1bWEgY2FtYWRhIGRlIHJhc3RlciBkZSBlbnRyYWRhIGRhIGRpcmXDp8OjbyBkZSBmbHV4byBEOC4gQXMgZGlyZcOnw7VlcyBkZSBmbHV4byBEOCBwb2RlbSBzZXIgY3JpYWRhcyB1dGlsaXphbmRvIGEgZnVuw6fDo28gRGlyZcOnw6NvIGRvIEZsdXhvIGUgZXhlY3V0YWRhcyBjb20gbyB0aXBvIGRlIGRpcmXDp8OjbyBkZSBmbHV4byBEOCBwYWRyw6NvLiBBIHNhw61kYSBkYSBmdW7Dp8OjbyBDb2xldG9yIMOpIHVtIHJhc3RlciBpbnRlaXJvLCBjb20gY2FkYSBjb2xldG9yIHNlbmRvIGF0cmlidcOtZG8gYSB1bSB2YWxvciDDum5pY28uIEVzdGVzIHZhbG9yZXMgw7puaWNvcyB0w6ptIHVtIGludGVydmFsbyBlbnRyZSB1bSBlIG8gbsO6bWVybyB0b3RhbCBkZSBjb2xldG9yZXMuIFBvciBleGVtcGxvLCBzZSBvIG7Dum1lcm8gdG90YWwgZGUgY29sZXRvcmVzIGZvciAxMDAwLCBvcyB2YWxvcmVzIMO6bmljb3MgdmFyaWFtIGRlIDEgYSAxMDAwLjwvZGl2PlwiLFxuXHRcdGFnZ3JlZ2F0ZU5hbWU6IFwiQWdyZWdhclwiLFxuXHRcdGFnZ3JlZ2F0ZVNuaXA6IFwiR2VyYSB1bWEgdmVyc8OjbyBkZSByZXNvbHXDp8OjbyByZWR1emlkYSBkZSB1bSByYXN0ZXIuXCIsXG5cdFx0YWdncmVnYXRlRGVzYzogXCJBIGZ1bsOnw6NvIEFncmVnYXIgcmVhbW9zdHJhIHVtIHJhc3RlciBkZSBlbnRyYWRhIHBhcmEgdW1hIHJlc29sdcOnw6NvIG1haXMgZ3Jvc3NlaXJhIGJhc2VhZG8gZW0gdW1hIGVzdHJhdMOpZ2lhIGRlIGFncmVnYcOnw6NvIGVzcGVjaWZpY2FkYS4gQ2FkYSBjw6lsdWxhIGRlIHNhw61kYSBjb250w6ltIGEgU29tYSwgTcOtbmltbywgTcOheGltbywgTcOpZGlhIG91IE1lZGlhbm8gZGFzIGPDqWx1bGFzIGRlIGVudHJhZGEgcXVlIHPDo28gY2VyY2FkYXMgcGVsYSBleHRlbnPDo28gZGVzdGEgY8OpbHVsYS48ZGl2Pjxici8+Vm9jw6ogcG9kZSBlc3BlY2lmaWNhciBvIGZhdG9yIHBlbG8gcXVhbCBtdWx0aXBsaWNhciBvIHRhbWFuaG8gZGEgY8OpbHVsYSBkbyByYXN0ZXIgZGUgZW50cmFkYS4gUG9yIGV4ZW1wbG8sIHVtIHZhbG9yIGRlIGZhdG9yIGRhIGPDqWx1bGEgZGUgMyByZXN1bHRhcmlhIGVtIHVtIHRhbWFuaG8gZGUgY8OpbHVsYSBkZSBzYcOtZGEgdHLDqnMgdmV6ZXMgbWFpb3IgcXVlIG8gZG8gcmFzdGVyIGRlIGVudHJhZGEuIFZvY8OqIHBvZGUgZGVmaW5pciBjb21vIG1hbmlwdWxhciBhIGV4dGVuc8OjbyBkYSBzYcOtZGEgc2UgbyBuw7ptZXJvIGRlIGxpbmhhcyBvdSBjb2x1bmFzIG5hIGVudHJhZGEgbsOjbyBmb3IgdW0gbcO6bHRpcGxvIGV4YXRvIGRvIGZhdG9yIGRhIGPDqWx1bGEuIFBvciBwYWRyw6NvLCBvcyBsaW1pdGVzIGRhIGRpcmVpdGEgZSBzdXBlcmlvciBzZXLDo28gZXhwYW5kaWRvcyBwYXJhIGNvYnJpciB1bWEgZXh0ZW5zw6NvIGVzcGFjaWFsIG1haW9yIHF1ZSBvIHJhc3RlciBkZSBlbnRyYWRhLCBhIGZpbSBkZSBhc3NlZ3VyYXIgcXVlIHRvZGFzIGFzIGPDqWx1bGFzIGRlIGVudHJhZGEgc2VqYW0gcHJvY2Vzc2FkYXMuIEFsdGVybmF0aXZhbWVudGUsIG9zIGxpbWl0ZXMgZGEgZGlyZWl0YSBlIHN1cGVyaW9yIHBvZGVtIHNlciByZWR1emlkb3MgcGFyYSBjb2JyaXIgdW1hIGV4dGVuc8OjbyBwZXF1ZW5hLCBkZSBmb3JtYSBxdWUgbyBuw7ptZXJvIGRlIGxpbmhhcyBlIGNvbHVuYXMgcHJvY2Vzc2FkYXMgc2VqYW0gdW0gbcO6bHRpcGxvIGV4YXRvIGRvIGZhdG9yIGRhIGPDqWx1bGEuIFZvY8OqIHBvZGUgZGVmaW5pciBjb21vIGFzIGPDqWx1bGFzIE5vRGF0YSBzw6NvIG1hbmlwdWxhZGFzIHBlbG8gY8OhbGN1bG8gZGUgYWdyZWdhw6fDo28uIE8gbWVjYW5pc21vIHBhZHLDo28gw6kgcXVlIGFzIGPDqWx1bGFzIE5vRGF0YSBkZSBlbnRyYWRhIHF1ZSBjYWVtIG5hIGV4dGVuc8OjbyBlc3BhY2lhbCBkZSB1bWEgY8OpbHVsYSBtYWlvciBubyByYXN0ZXIgZGUgc2HDrWRhIHNlcsOjbyBpZ25vcmFkYXMgYW8gZGV0ZXJtaW5hciBvIHZhbG9yIGRlc3RhIGPDqWx1bGEgZGUgc2HDrWRhLiBBbHRlcm5hdGl2YW1lbnRlLCB2b2PDqiBwb2RlIGVzcGVjaWZpY2FyIHF1ZSwgc2UgaG91dmVyIHVtYSDDum5pY2EgY8OpbHVsYSBOb0RhdGEgZGUgZW50cmFkYSBuYSBleHRlbnPDo28gZXNwYWNpYWwgZGUgdW1hIGPDqWx1bGEgZGUgc2HDrWRhLCBlc3RhIGPDqWx1bGEgc2Vyw6EgTm9EYXRhIG5vIHJhc3RlciBkZSBzYcOtZGEuPC9kaXY+XCIsXG5cdFx0Y2NkY05hbWU6IFwiQW7DoWxpc2UgZGUgQ0NEQ1wiLFxuXHRcdGNjZGNTbmlwOiBcIkF2YWxpYSBhcyBhbHRlcmHDp8O1ZXMgdmFsb3JlcyBkZSBwaXhlbHMgY29tIG8gcGFzc2FyIGRvIHRlbXBvIHV0aWxpemFuZG8gbyBhbGdvcml0bW8gRGV0ZWPDp8OjbyBkZSBBbHRlcmHDp8OjbyBDb250w61udWEgZSBDbGFzc2lmaWNhw6fDo28gKENDREMpIGUgZ2VyYSByZXN1bHRhZG9zIGRlIG1vZGVsby5cIixcblx0XHRjY2RjRGVzYzogXCJBIGZ1bsOnw6NvIEFuw6FsaXNlIENDREMgYXZhbGlhIGFzIGFsdGVyYcOnw7VlcyB2YWxvcmVzIGRlIHBpeGVscyBjb20gbyBwYXNzYXIgZG8gdGVtcG8gdXRpbGl6YW5kbyBvIGFsZ29yaXRtbyBEZXRlY8Onw6NvIGRlIEFsdGVyYcOnw6NvIENvbnTDrW51YSBlIENsYXNzaWZpY2HDp8OjbyAoQ0NEQykgZSBnZXJhIHVtIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGNvbnRlbmRvIG9zIHJlc3VsdGFkb3MgZG8gbW9kZWxvLiDDiSBzb21lbnRlIHN1cG9ydGFkbyBqdW50byBjb20gYSBmdW7Dp8OjbyBEZXRlY3RhciBBbHRlcmHDp8OjbyBVdGlsaXphbmRvIEFsdGVyYXIgQW7DoWxpc2UgZW0gdW0gbW9kZWxvIGRlIGZ1bsOnw6NvIHJhc3Rlci4gUGFyYSBwcm9kdXppciB1bWEgc2HDrWRhIGRlIHJhc3RlciAsIGNvbmVjdGUgYSBmdW7Dp8OjbyBBbsOhbGlzZSBkZSBDQ0RDIGNvbSBhIGZ1bsOnw6NvIERldGVjdGFyIEFsdGVyYcOnw6NvIFV0aWxpemFuZG8gQWx0ZXJhciBBbsOhbGlzZSwgc2FsdmFyIGNvbW8gdW0gbW9kZWxvIGRlIGZ1bsOnw6NvIGRvIHJhc3RlciBlIGV4ZWN1dGUgQW7DoWxpc2UgUmFzdGVyIGNvbSBvIG1vZGVsbyBkZSBmdW7Dp8Ojby48ZGl2Pjxici8+SXN0byBmdW7Dp8OjbyB1dGlsaXphIG8gYWxnb3JpdG1vIERldGVjdGFyIEFsdGVyYcOnw6NvIENvbnTDrW51YSBlIENsYXNzaWZpY2HDp8OjbyAoQ0NEQykgcGFyYSBhdmFsaWFyIGFsdGVyYcOnw7VlcyBlbSB2YWxvcmVzIGRlIHBpeGVscyBjb20gbyBwYXNzYXIgZG8gdGVtcG8gcGFyYSB1bWEgcGlsaGEgZGUgaW1hZ2Vucy4gRW0gdW1hIHPDqXJpZSBkZSB0ZW1wbyBkZSBpbWFnZW5zIMOzcHRpY2FzIG91IGRlcml2YWRvcyBkZSBpbWFnZW5zIChwb3IgZXhlbXBsbywgTkRWSSksIG9zIHZhbG9yZXMgZGUgcGl4ZWxzIHBvZGVtIGZsdXR1YXIgcG9yIGRpdmVyc2FzIHJhesO1ZXM6IDEuIEFsdGVyYcOnw7VlcyBzYXpvbmFpcyAtLSBBcyBhbHRlcmHDp8O1ZXMgZGUgdmFsb3JlcyBkbyBwaXhlbCByZWZsZXRlbSBhbHRlcmHDp8O1ZXMgZW0gdmVnZXRhw6fDo28gZGV2aWRvIGEgdmFyaWFiaWxpZGFkZSBzYXpvbmFsIGRlIHRlbXBlcmF0dXJhIGUgcHJlY2lwaXRhw6fDo28uIE5vIEhlbWlzZsOpcmlvIE5vcnRlLCBwb3IgZXhlbXBsbywgbsOzcyBlc3BlcmFtb3MgdmVyIGRlbnNpZGFkZSBtYWlzIGFsdGEgZGUgdmVnZXRhw6fDo28gdmVyZGUgbm8gdmVyw6NvIGNvbXBhcmFkbyBhbyBpbnZlcm5vOyAyLiBBbHRlcmHDp8OjbyBncmFkdWFsIC0tIEFzIGFsdGVyYcOnw7VlcyBkZSB2YWxvcmVzIGRvIHBpeGVsIHJlZmxldGVtIHRlbmTDqm5jaWFzIGVtIHZlZ2V0YcOnw6NvIG91IMOhZ3VhIGRlIHN1cGVyZsOtY2llIGRldmlkbyBhIHZhcmlhYmlsaWRhZGUgZGUgY2xpbWEgb3UgcHLDoXRpY2FzIGRlIGdlcmVuY2lhbWVudG8gZGUgc29sbyBhIGxvbmdvIHByYXpvLiBQb3IgZXhlbXBsbywgbyBzb2xvIGJydXRvIHBvZGUgZ3JhZHVhbG1lbnRlIGF1bWVudGFyIGVtIMOhcmVhIGRldmlkbyBhIGRlY2zDrW5pbyBhIGxvbmdvIHByYXpvIGVtIHByZWNpcGl0YcOnw6NvOyBlIDMuIEFsdGVyYcOnw6NvIGFicnVwdGEgLS0gQXMgYWx0ZXJhw6fDtWVzIGRlIHZhbG9yZXMgZG8gcGl4ZWwgcmVmbGV0ZW0gYWx0ZXJhw6fDtWVzIGRlIGNvYmVydHVyYSBkZSBzb2xvIHF1ZSBvY29ycmUgZGUgcmVwZW50ZSBkZXZpZG8gYW8gZGVzbWF0YW1lbnRvLCBkZXNlbnZvbHZpbWVudG8gdXJiYW5vLCBkZXNhc3RyZSBuYXR1cmFsIGUgYXNzaW0gcG9yIGRpYW50ZS4gTyBhbGdvcml0bW8gZGUgQ0NEQyBpZGVudGlmaWNhIHRvZG9zIG9zIHRyw6pzIHRpcG9zIGRlIGFsdGVyYcOnw6NvIGNvbSBvIHByb3DDs3NpdG8gcHJpbcOhcmlvIGRlIGlkZW50aWZpY2FyIGEgYWx0ZXJhw6fDo28gYWJydXB0YS4gQSByZWdyZXNzw6NvIGUgbW9kZWxvcyBkZSB0ZW5kw6puY2lhIGhhcm3DtG5pY29zIHPDo28gYWp1c3RhZG9zIGFvcyBkYWRvcyBwYXJhIGVzdGltYXIgYWx0ZXJhw6fDo28gc2F6b25hbCBlIGdyYWR1YWwsIGUgZGl2ZXJnw6puY2lhcyBzw7piaXRhcyBhIHBhcnRpciBkZSBtb2RlbG9zIGRlIHRlbmTDqm5jaWFzIG1vZGVsb3MgcXVlIHPDo28gaW5kaWNhw6fDtWVzIGRlIGFsdGVyYcOnw6NvIGFicnVwdGEuPGRpdj48YnIvPk8gYWxnb3JpdG1vIENDREMgZm9pIG9yaWdpbmFsbWVudGUgcHJvamV0YWRvIHBhcmEgTGFuZHNhdCBUTSwgTGFuZHNhdCBFVE0rIGUgUmVmbGVjdMOibmNpYSBkZSBTdXBlcmbDrWNpZSBkZSBkYWRvcyBMYW5kc2F0IE9MSSBvdSBkYWRvcyBkZSBUZW1wZXJhdHVyYSBkZSBCcmlsaG8uIEVudHJldGFudG8sIGEgZnVuw6fDo28gRGV0ZWN0YXIgQWx0ZXJhw6fDo28gVXRpbGl6YW5kbyBBbsOhbGlzZSBkZSBBbHRlcmHDp8OjbyBqdW50byBjb20gZXN0YSBmdW7Dp8OjbyBpcsOhIGRldGVjdGFyIGFsdGVyYcOnw6NvIGRhcyBpbWFnZW5zIGRlIGJhbmRhcyBtw7psdGlwbGFzIGRlIHF1YWxxdWVyIHNlbnNvciBzdXBvcnRhZG8sIGFzc2ltIGNvbW8gaW1hZ2VucyBkZSBiYW5kYSDDum5pY2Egc8OjbyBkZXJpdmFkYXMgY29tbyDDrW5kaWNlcyBkZSBiYW5kYXMuIFBvciBleGVtcGxvLCB2b2PDqiBwb2RlIGV4ZWN1dGFyIGRldGVjw6fDo28gZGUgYWx0ZXJhw6fDo28gY29udMOtbnVhIGVtIHVtIHJhc3RlciBOb3JtYWxpemFyIMONbmRpY2UgZGUgVmVnZXRhw6fDo28gZGUgRGlmZXJlbsOnYSAoTkRWSSksIHBvaXMgYXMgYWx0ZXJhw6fDtWVzIGFicnVwdGFzIG5vIE5EVkkgcG9kZSBzZXIgaW5kaWNhdGl2byBkZSBkZXNtYXRhbWVudG8uPC9kaXY+XCIsXG5cdFx0Y29tcHV0ZUNoYW5nZU5hbWU6IFwiQ29tcHV0YXIgQWx0ZXJhw6fDo29cIixcblx0XHRjb21wdXRlQ2hhbmdlU25pcDogXCJDb21wdXRhIGEgZGlmZXJlbsOnYSBlbnRyZSBkb2lzIGNvbmp1bnRvcyBkZSBkYWRvcyByYXN0ZXIgY2F0ZWfDs3JpY28gb3UgY29udMOtbnVvLlwiLFxuXHRcdGNvbXB1dGVDaGFuZ2VEZXNjOiBcIkEgZnVuw6fDo28gZGUgQ29tcHV0YXIgQWx0ZXJhw6fDo28gcG9kZSBzZXIgdXRpbGl6YWRhIHBhcmEgZW51bWVyYXIgYXMgZGlmZXJlbsOnYXMgZW50cmUgZG9pcyByYXN0ZXJzIGNsYXNzaWZpY2Fkb3MgcGFyYSBhbsOhbGlzZSBkZSBhbHRlcmHDp8OjbyBkZSBjb2JlcnR1cmEgZG8gc29sbywgb3UgZWxlIHBvZGUgc2VyIHV0aWxpemFkbyBwYXJhIGV4YW1pbmFyIGFsdGVyYcOnw7VlcyBlbnRyZSBkb2lzIHJhc3RlcnMgZGUgYmFuZGEgw7puaWNhIGNvbnTDrW51bywgdGFpcyBjb21vLCBlbGV2YcOnw6NvLCB0ZW1wZXJhdHVyYSwgY29iZXJ0dXJhIGRlIGNvcGEgZGEgw6Fydm9yZSBlIGFzc2ltIHBvciBkaWFudGUuXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlTmFtZTogXCJEZXRlY3RhciBBbHRlcmHDp8OjbyBVdGlsaXphbmRvIEFuw6FsaXNlIGRlIEFsdGVyYcOnw6NvXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlU25pcDogXCJHZXJhIHVtYSBjYW1hZGEgZGUgcmFzdGVyIGNvbnRlbmRvIGluZm9ybWHDp8O1ZXMgZGUgYWx0ZXJhw6fDo28gZGUgcGl4ZWwgdXRpbGl6YW5kbyBvIHJhc3RlciBkZSBhbsOhbGlzZSBkZSBhbHRlcmHDp8OjbyBkZSBzYcOtZGEuXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlRGVzYzogXCI8ZGl2PkEgZnVuw6fDo28gRGV0ZWN0YXIgQWx0ZXJhw6fDo28gVXRpbGl6YW5kbyBBbsOhbGlzZSBkZSBBbHRlcmHDp8OjbyBnZXJhIHVtYSBjYW1hZGEgZGUgcmFzdGVyIGNvbnRlbmRvIGluZm9ybWHDp8O1ZXMgZGUgYWx0ZXJhw6fDo28gZGUgZGF0YSBkbyBwaXhlbCB1dGlsaXphbmRvIG8gcmFzdGVyIGRlIGFuw6FsaXNlIGRlIGFsdGVyYcOnw6NvLiBPIHJhc3RlciBkZSBhbsOhbGlzZSBkZSBhbHRlcmHDp8OjbyBkZXZlIHNlciBnZXJhZG8gcGVsYSBmZXJyYW1lbnRhIEFuYWxpc2FyIEFsdGVyYcOnw7VlcyBVdGlsaXphbmRvIENDREMgb3UgQW5hbGlzYXIgQWx0ZXJhw6fDtWVzIFV0aWxpemFuZG8gTGFuZFRyZW5kciwgb3UgYSBmdW7Dp8OjbyBkbyByYXN0ZXIgQW7DoWxpc2UgZGUgQ0NEQyBvdSBBbsOhbGlzZSBkZSBMYW5kVHJlbmRyLjwvZGl2Pjxicj48ZGl2PkVzdGEgZnVuw6fDo28gZG8gcmFzdGVyIHBvZGUgc2VyIGNvbWJpbmFkYSBjb20gYSBmdW7Dp8OjbyBkbyByYXN0ZXIgQW7DoWxpc2UgZGUgQ0NEQyBvdSBhIGZ1bsOnw6NvIGRvIHJhc3RlciBBbsOhbGlzZSBkZSBMYW5kVHJlbmRyIGVtIHVtIG1vZGVsbyBkZSBmdW7Dp8OjbyBkbyByYXN0ZXIuIFBhcmEgcHJvZHV6aXIgdW1hIHNhw61kYSBkZSByYXN0ZXIgcGVybWFuZW50ZSwgY29uZWN0ZSBhIHNhw61kYSBkYSBmdW7Dp8OjbyBBbsOhbGlzZSBkZSBDQ0RDIG91IEFuw6FsaXNlIGRlIExhbmRUcmVuZHIgw6AgZnVuw6fDo28gRGV0ZWN0YXIgQWx0ZXJhw6fDo28gVXRpbGl6YW5kbyBBbsOhbGlzZSBkZSBBbHRlcmHDp8Ojbywgc2FsdmUgY29tbyB1bSBtb2RlbG8gZGUgZnVuw6fDo28gZG8gcmFzdGVyIGUgZXhlY3V0ZSBhIEFuw6FsaXNlIGRlIFJhc3RlciBjb20gbyBtb2RlbG8uPC9kaXY+PGJyPjxkaXY+TyBwYXLDom1ldHJvIDxzdHJvbmc+VGlwbyBkZSBBbHRlcmHDp8Ojbzwvc3Ryb25nPiBpbmRpY2EgYXMgaW5mb3JtYcOnw7VlcyBxdWUgc8OjbyBnZXJhZGFzLiBBcyBpbmZvcm1hw6fDtWVzIHPDo28gZXh0cmHDrWRhcyBkbyByYXN0ZXIgZGEgYW7DoWxpc2UgZGUgYWx0ZXJhw6fDo28uIEFvIGV4ZWN1dGFyIGVzdGEgZnVuw6fDo28gbmEgc2HDrWRhIGRhIGZ1bsOnw6NvL2ZlcnJhbWVudGEgQ0NEQywgdm9jw6ogcG9kZSBlc2NvbGhlciBlbnRyZSBhcyBzZWd1aW50ZXMgb3DDp8O1ZXM6PC9kaXY+PHVsPjxsaT48c3Ryb25nPkhvcmEgZGEgYWx0ZXJhw6fDo28gbWFpcyByZWNlbnRlPC9zdHJvbmc+LS1BIGRhdGEgZSBob3JhIG1haXMgcmVjZW50ZSBuYSBxdWFsIHVtIHBpeGVsIGZvaSBzaW5hbGl6YWRvIGNvbW8gc2VuZG8gYWx0ZXJhZG8uPC9saT48bGk+PHN0cm9uZz5Ib3JhIGRhIGFsdGVyYcOnw6NvIG1haXMgYW50aWdhPC9zdHJvbmc+LS1BIGRhdGEgZSBob3JhIG1haXMgYW50aWdhcyBuYSBxdWFsIHVtIHBpeGVsIGZvaSBzaW5hbGl6YWRvIGNvbW8gc2VuZG8gYWx0ZXJhZG8uPC9saT48bGk+PHN0cm9uZz5Ib3JhIGRhIG1haW9yIGFsdGVyYcOnw6NvPC9zdHJvbmc+LS1BIGRhdGEgZSBob3JhIG5hIHF1YWwgYSBhbHRlcmHDp8OjbyBjYWxjdWxhZGEgZm9pIGEgbWFpcyBzaWduaWZpY2F0aXZhIHBhcmEgdW0gcGl4ZWwuPC9saT48bGk+IDxzdHJvbmc+TsO6bWVybyBkZSBhbHRlcmHDp8O1ZXM8L3N0cm9uZz4tLU8gbsO6bWVybyB0b3RhbCBkZSB2ZXplcyBxdWUgbyBwaXhlbCBhbHRlcm91LjwvbGk+PC91bD48ZGl2PkFvIGV4ZWN1dGFyIGVzdGEgZnVuw6fDo28gbmEgc2HDrWRhIGRhIGZ1bsOnw6NvL2ZlcnJhbWVudGEgTGFuZFRyZW5kciwgYXMgc2VndWludGVzIG9ww6fDtWVzIGFkaWNpb25haXMgZXN0w6NvIGRpc3BvbsOtdmVpczo8L2Rpdj48dWw+PGxpPjxzdHJvbmc+SG9yYSBkYSBhbHRlcmHDp8OjbyBtYWlzIGxvbmdhPC9zdHJvbmc+LS1BIGRhdGEgbmEgcXVhbCB1bSBwaXhlbCBmb2kgc2luYWxpemFkbyBjb21vIHNlbmRvIGFsdGVyYWRvLCBubyBpbsOtY2lvIG91IG5vIGZpbmFsIGRvIHBlcsOtb2RvIG1haXMgbG9uZ28gZGUgYWx0ZXJhw6fDo28uPC9saT48bGk+PHN0cm9uZz5Ib3JhIGRhIGFsdGVyYcOnw6NvIG1haXMgY3VydGE8L3N0cm9uZz4tLUEgZGF0YSBuYSBxdWFsIHVtIHBpeGVsIGZvaSBzaW5hbGl6YWRvIGNvbW8gc2VuZG8gYWx0ZXJhZG8sIG5vIGluw61jaW8gb3Ugbm8gZmluYWwgZG8gcGVyw61vZG8gbWFpcyBjdXJ0byBkZSBhbHRlcmHDp8Ojby48L2xpPjxsaT48c3Ryb25nPkhvcmEgZGEgYWx0ZXJhw6fDo28gbWFpcyByw6FwaWRhPC9zdHJvbmc+LS1BIGRhdGEgbmEgcXVhbCB1bSBwaXhlbCBmb2kgc2luYWxpemFkbyBjb21vIHNlbmRvIGFsdGVyYWRvLCBubyBpbsOtY2lvIG91IG5vIGZpbmFsIGRvIHBlcsOtb2RvIG1haXMgcsOhcGlkbyBkZSBhbHRlcmHDp8Ojby48L2xpPjxsaT48c3Ryb25nPkhvcmEgZGEgYWx0ZXJhw6fDo28gbWFpcyBsZW50YTwvc3Ryb25nPi0tQSBkYXRhIG5hIHF1YWwgdW0gcGl4ZWwgZm9pIHNpbmFsaXphZG8gY29tbyBzZW5kbyBhbHRlcmFkbywgbm8gaW7DrWNpbyBvdSBubyBmaW5hbCBkbyBwZXLDrW9kbyBtYWlzIGxlbnRvIGRlIGFsdGVyYcOnw6NvLjwvbGk+PC91bD48ZGl2Pk8gcmFzdGVyIGRlIHNhw61kYSDDqSB1bSByYXN0ZXIgZGUgbcO6bHRpcGxhcyBiYW5kYXMgbm8gcXVhbCBjYWRhIGJhbmRhIGNvbnTDqW0gaW5mb3JtYcOnw7VlcyBkZSBhbHRlcmHDp8OjbyBkZXBlbmRlbmRvIGRvIHRpcG8gZGUgYWx0ZXJhw6fDo28gc2VsZWNpb25hZG8gZSBkbyBuw7ptZXJvIG3DoXhpbW8gZGUgYWx0ZXJhw6fDtWVzIGVzcGVjaWZpY2Fkby4gUG9yIGV4ZW1wbG8sIHNlIDxzdHJvbmc+VGlwbyBkZSBBbHRlcmHDp8Ojbzwvc3Ryb25nPiBlc3RpdmVyIGRlZmluaWRvIHBhcmEgPHN0cm9uZz5Ib3JhIGRlIEFsdGVyYcOnw6NvIE1haXMgQW50aWdhPC9zdHJvbmc+IGUgPHN0cm9uZz5Ow7ptZXJvIE3DoXhpbW8gZGUgQWx0ZXJhw6fDtWVzPC9zdHJvbmc+IGVzdGl2ZXIgZGVmaW5pZG8gY29tbyAyLCBhIGZ1bsOnw6NvIGNhbGN1bGFyw6EgYXMgZHVhcyBwcmltZWlyYXMgZGF0YXMgbmFzIHF1YWlzIGEgYWx0ZXJhw6fDo28gb2NvcnJldSBhbyBsb25nbyBkYSBzw6lyaWUgZGUgdGVtcG8gcGFyYSBjYWRhIHBpeGVsLiBPIHJlc3VsdGFkbyDDqSB1bSByYXN0ZXIgbm8gcXVhbCBhIHByaW1laXJhIGJhbmRhIGNvbnTDqW0gYXMgZGF0YXMgZGEgcHJpbWVpcmEgYWx0ZXJhw6fDo28gcG9yIHBpeGVsIGUgYSBzZWd1bmRhIGJhbmRhIGNvbnTDqW0gYXMgZGF0YXMgZGEgc2VndW5kYSBhbHRlcmHDp8OjbyBtYWlzIGFudGlnYSBwb3IgcGl4ZWwuPC9kaXY+PGJyPjxkaXY+QW8gYXBsaWNhciBlc3RhIGZ1bsOnw6NvIG5hIHNhw61kYSBkYXMgZmVycmFtZW50YXMgTGFuZFRyZW5kciwgdm9jw6ogcG9kZSBlc2NvbGhlciBzZSBkZXNlamEgZXh0cmFpciBhIGRhdGEgcXVlIG1hcmNhIG8gaW7DrWNpbyBvdSBvIGZpbSBkZSB1bWEgYWx0ZXJhw6fDo28gdXNhbmRvIG8gcGFyw6JtZXRybyA8c3Ryb25nPkRhdGEgZG8gU2VnbWVudG88L3N0cm9uZz4gLiBQb3IgZXhlbXBsbywgcGFyYSBlbnRlbmRlciBjb21vIGEgYWx0ZXJhw6fDo28gbWFpcyByZWNlbnRlIG5hIHPDqXJpZSBkZSB0ZW1wbyBjb21lw6dvdSwgZGVmaW5hIG8gPHN0cm9uZz5UaXBvIGRlIEFsdGVyYcOnw6NvPC9zdHJvbmc+IHBhcmEgPHN0cm9uZz5Ib3JhIGRhIMO6bHRpbWEgYWx0ZXJhw6fDo288L3N0cm9uZz4gZSBhIDxzdHJvbmc+RGF0YSBkbyBTZWdtZW50bzwvc3Ryb25nPiBwYXJhIDxzdHJvbmc+SW7DrWNpbyBkbyBzZWdtZW50bzwvc3Ryb25nPi48L2Rpdj48YnI+PGRpdj5Vc2Ugb3Mgc2VndWludGVzIHBhcsOibWV0cm9zIGRlIGZpbHRyYWdlbSBwYXJhIGV4dHJhaXIgZGF0YXMgbWFpcyBlc3BlY8OtZmljYXMgZGUgYWx0ZXJhw6fDtWVzIGRvIHNldSByYXN0ZXIgZGEgYW7DoWxpc2UgZGUgYWx0ZXJhw6fDo286PC9kaXY+PHVsPjxsaT48c3Ryb25nPkZpbHRyYXIgcG9yIGFubzwvc3Ryb25nPi0tSWRlbnRpZmlxdWUgYWx0ZXJhw6fDtWVzIHF1ZSBvY29ycmVyYW0gZGVudHJvIGRlIHVtIHBlcsOtb2RvIGRlIHRlbXBvIGVzcGVjw61maWNvLCBwb3IgZXhlbXBsbywgc2Ugdm9jw6ogZXN0aXZlciBwcm9jdXJhbmRvIHBvciBhbHRlcmHDp8O1ZXMgcXVlIG9jb3JyZXJhbSBlbSB1bWEgcGFpc2FnZW0gZHVyYW50ZSBjaW5jbyBhbm9zIGRlIHNlY2EuPC9saT48bGk+PHN0cm9uZz5GaWx0cmFyIHBvciBkdXJhw6fDo288L3N0cm9uZz4tLUlkZW50aWZpcXVlIGFsdGVyYcOnw7VlcyBxdWUgb2NvcnJlcmFtIGFvIGxvbmdvIGRlIHVtIGRldGVybWluYWRvIGludGVydmFsbyBkZSBhbm9zLCBwb3IgZXhlbXBsbywgc2Ugdm9jw6ogZXN0aXZlciBwcm9jdXJhbmRvIGFwZW5hcyBhbHRlcmHDp8O1ZXMgYWJydXB0YXMgcXVlIG9jb3JyZXJhbSBhbyBsb25nbyBkZSAxIG91IDIgYW5vcy4gVm9jw6ogcG9kZSBjYWxjdWxhciBhIGR1cmHDp8OjbyBkZSBzZXUgaW50ZXJlc3NlIHVzYW5kbyBhIGbDs3JtdWxhPHN0cm9uZz5hbm8gZmluYWwgLSBhbm8gaW5pY2lhbCArMTwvc3Ryb25nPi4gT3MgaW50ZXJ2YWxvIG5hIHPDqXJpZSBkZSB0ZW1wbyBzZXLDo28gaW5jbHXDrWRvcy48L2xpPjxsaT48c3Ryb25nPkZpbHRyYXIgcG9yIG1hZ25pdHVkZTwvc3Ryb25nPi0tSWRlbnRpZmljYSBhbHRlcmHDp8O1ZXMgZGUgdW1hIGRldGVybWluYWRhIG1hZ25pdHVkZSwgcG9yIGV4ZW1wbG8sIHNlIHZvY8OqIGVzdGl2ZXIgcHJvY3VyYW5kbyBhcGVuYXMgZ3JhbmRlcyBhbHRlcmHDp8O1ZXMgbm8gw61uZGljZSBkZSB2ZWdldGHDp8OjbyBORFZJLiBNYWduaXR1ZGUgw6kgdW0gdmFsb3IgYWJzb2x1dG8sIHBvcnRhbnRvLCBvcyB2YWxvcmVzIG3DrW5pbW8gZSBtw6F4aW1vIG7Do28gcG9kZW0gc2VyIG5lZ2F0aXZvcy4gUGFyYSBlc3BlY2lmaWNhciBhbHRlcmHDp8OjbyBkaXJlY2lvbmFsLCB1c2UgbyBwYXLDom1ldHJvIDxzdHJvbmc+QWx0ZXJhciBEaXJlw6fDo288L3N0cm9uZz4gLjwvbGk+PC91bD5cIixcblx0XHRkaXN0YW5jZUFjY3VtdWxhdGlvbk5hbWU6IFwiQWN1bXVsYcOnw6NvIGRlIERpc3TDom5jaWFcIixcblx0XHRkaXN0YW5jZUFjY3VtdWxhdGlvblNuaXA6IFwiQ2FsY3VsYSBhIGRpc3TDom5jaWEgYWN1bXVsYWRhIGRlIGNhZGEgY8OpbHVsYSBwYXJhIG9yaWdlbnMsIHBlcm1pdGluZG8gZGlzdMOibmNpYSBkZSBsaW5oYSBkaXJldGEsIGRpc3TDom5jaWEgZGUgY3VzdG8sIGRpc3TDom5jaWEgZGUgc3VwZXJmw61jaWUgdmVyZGFkZWlyYSwgY29tbyB0YW1iw6ltIGZhdG9yZXMgZGUgY3VzdG8gdmVydGljYWwgZSBob3Jpem9udGFsLlwiLFxuXHRcdGRpc3RhbmNlQWNjdW11bGF0aW9uRGVzYzogXCJBY3VtdWxhw6fDo28gZGUgRGlzdMOibmNpYSBjYWxjdWxhIGEgZGlzdMOibmNpYSBwYXJhIGNhZGEgbG9jYWxpemHDp8OjbyBuYSDDoXJlYSBkZSBlc3R1ZG8gcGFyYSBhIG9yaWdlbSBtYWlzIHByw7N4aW1hIG91IGRlIG1lbm9zIGN1c3RvLiBTZSBzb21lbnRlIGFzIG9yaWdlbnMgZm9yZW0gZm9ybmVjaWRhcyBwYXJhIGVudHJhZGEsIGVudMOjbyB1bWEgZGlzdMOibmNpYSBkZSBsaW5oYSByZXRhIMOpIGNhbGN1bGFkYSBwYXJhIGNhZGEgbG9jYWxpemHDp8OjbyBuYSDDoXJlYSBkZSBlc3R1ZG8uIFNlIGFtYmFzIGFzIG9yaWdlbnMgZSBiYXJyZWlyYXMgZm9yZW0gdXRpbGl6YWRhcyBjb21vIGVudHJhZGEsIGVudMOjbyBBY3VtdWxhw6fDo28gZGUgRGlzdMOibmNpYSBjYWxjdWxhIGEgZGlzdMOibmNpYSBkZSBsaW5oYSByZXRhIGFvIHJlZG9yIGRlIGJhcnJlaXJhcy4gUGFyYSBhbWJvcyByYXN0ZXIgZGUgb3JpZ2VtIGUgbyByYXN0ZXIgZGUgYmFycmVpcmEsIG8gdmFsb3IgZGUgcGxhbm8gZGUgZnVuZG8gZGV2ZSBzZXIgTm9EYXRhLCBlbnF1YW50byBvcmlnZW5zIGUgYmFycmVpcmFzIHPDo28gcmVwcmVzZW50YWRhcyBjb20gdmFsb3JlcyBkZSBjw6lsdWxhIHbDoWxpZG9zLiBPcyB2YWxvcmVzIHbDoWxpZG9zIGluY2x1ZW0gemVyby4gPGRpdj48YnIvPlF1YW5kbyB1bSByYXN0ZXIgZGUgc3VwZXJmw61jaWUgZm9yIGZvcm5lY2lkbyBjb21vIGVudHJhZGEsIGVudMOjbyBhIGRpc3TDom5jaWEgZGUgc3VwZXJmw61jaWUgcmVhbCBlbnRyZSBhcyBjw6lsdWxhcyBzZXLDoSBjYWxjdWxhZGEuIFBhcmEgZXhlY3V0YXIgYW7DoWxpc2UgZGUgY3VzdG8gdXRpbGl6YW5kbyBBY3VtdWxhw6fDo28gZGUgRGlzdMOibmNpYSwgdW1hIHN1cGVyZsOtY2llIGRlIGN1c3RvIMOpIHByZWNpc2Fkby4gU2UgdW1hIHN1cGVyZsOtY2llIGRlIGN1c3RvIGZvciBmb3JuZWNpZGEsIG8gcmVzdWx0YWRvIHNlcsOhIHVtIHJhc3RlciBkZSBkaXN0w6JuY2lhIGRlIGN1c3RvIGFjdW11bGFkby4gUXVhbmRvIGZhdG9yZXMgaG9yaXpvbnRhaXMgZSB2ZXJ0aWNhaXMgc8OjbyBmb3JuZWNpZG9zLCBlbnTDo28gYSBkaXJlY2lvbmFsaWRhZGUgw6kgY29uc2lkZXJhZGEgY29uZm9ybWUgbyBjdXN0byDDqSBhY3VtdWxhZG8uIEjDoSBxdWF0cm8gY2FyYWN0ZXLDrXN0aWNhcyBkZSBvcmlnZW0gcXVlIHBvZGVtIHNlciB1dGlsaXphZGFzLiBFc3RhcyBjYXJhY3RlcsOtc3RpY2FzLCBxdWUgcG9kZSBzZXIgZGEgb3JpZ2VtIG91IG1vdmVkb3JlcyBhIHBhcnRpciBkYSBvcmlnZW0sIHPDo28gY29udHJvbGFkb3MgcG9yIHBhcsOibWV0cm9zIGVzcGVjw61maWNvczogMS4gQWN1bXVsYcOnw6NvIGluaWNpYWw64oCvZGVmaW5lIG8gY3VzdG8gaW5pY2lhbCBhbnRlcyBkbyBtb3ZpbWVudG8gaW5pY2lhci4gMi4gQWN1bXVsYcOnw6NvIG3DoXhpbWE64oCvZXNwZWNpZmljYSBxdWFudG8gbyBjdXN0byBkZSB1bWEgZm9udGUgcG9kZSBhY3VtdWxhciBhbnRlcyBkZSBhbGNhbsOnYXIgc2V1IGxpbWl0ZS4gMy4gTXVsdGlwbGljYWRvciBwYXJhIGFwbGljYXIgYW9zIGN1c3RvczrigK9lc3BlY2lmaWNhIG8gbW9kbyBkZSB2aWFnZW0gb3UgbWFnbml0dWRlIG5hIG9yaWdlbS4gNC4gQSBkaXJlw6fDo28gZGUgdmlhZ2VtOuKAr2lkZW50aWZpY2Egc2UgbyB0cmFuc3BvcnRhZG9yIGVzdMOhIGluaWNpYW5kbyBlbSB1bWEgb3JpZ2VtIGUgbXVkYW5kbyBwYXJhIGxvY2FsaXphw6fDtWVzIGRlIG7Do28gb3JpZ2VtLCBvdSBlc3TDoSBpbmljaWFuZG8gZW0gbG9jYWxpemHDp8O1ZXMgZGUgbsOjbyBvcmlnZW0gZSBtb3ZlbmRvIGRlIHZvbHRhIHBhcmEgdW1hIG9yaWdlbS48ZGl2Pjxici8+UG9yIHBhZHLDo28sIG8gcmVzdWx0YWRvIGRhIEFjdW11bGHDp8OjbyBkZSBEaXN0w6JuY2lhIMOpIHVtYSBiYW5kYSDDum5pY2EsIHF1ZSDDqSBvIHJhc3RlciBkZSBhY3VtdWxhw6fDo28gZGUgZGlzdMOibmNpYS4gRW50cmV0YW50bywgdW1hIHNlZ3VuZGEgYmFuZGEgdGFtYsOpbSBwb2RlIHNlciBjcmlhZGEsIGEgYmFuZGEgZGUgZGlyZcOnw6NvIGRlIHZvbHRhLiAgRXN0YSBiYW5kYSBpbmRpY2EgY2FkYSBsb2NhbGl6YcOnw6NvIG5hIMOhcmVhIGRlIGVzdHVkbywgcXVlIGRpcmXDp8OjbyBzZWd1aXIgcGFyYSBvYnRlciBhIG9yaWdlbSBkZSBtZW5vciBjdXN0by4gIEFtYmFzIGFzIGJhbmRhcyBzZXLDo28gbmVjZXNzw6FyaWFzIHBhcmEgZGV0ZXJtaW5hciBjYW1pbmhvcyBmYXZvcsOhdmVpcyBkZW50cm8gZGEgw6FyZWEgZGUgZXN0dWRvLiBQYXJhIGdlcmFyIHVtIGNhbWluaG8sIHByaW1laXJvIHV0aWxpemUgYSBmdW7Dp8OjbyBFeHRyYWlyIEJhbmRhIHBhcmEgZXh0cmFpciBvIHJhc3RlciBkZSBhY3VtdWxhw6fDo28gZGUgZGlzdMOibmNpYSBlIG8gcmFzdGVyIGRlIGRpcmXDp8OjbyBkZSB2b2x0YS4gVXRpbGl6ZSBlc3RhcyBjYW1hZGFzIGNvbW8gZW50cmFkYSBwYXJhIGEgZnVuw6fDo28gQ2FtaW5obyBkZSBDdXN0by4gTmEgZnVuw6fDo28sIHV0aWxpemUgbyByYXN0ZXIgZGUgYWN1bXVsYcOnw6NvIGRlIGRpc3TDom5jaWEgY29tbyBlbnRyYWRhIGRvIFJhc3RlciBkYSBEaXN0w6JuY2lhIGRlIEN1c3RvIGUgbyByYXN0ZXIgZGUgZGlyZcOnw6NvIGRlIHZvbHRhIGNvbW8gYSBlbnRyYWRhIGRvIFJhc3RlciBkZSBWw61uY3VsbyBkZSBSZXRvcm5vIGRlIEN1c3RvLjwvZGl2PlwiLFxuXHRcdGRpc3RhbmNlQWxsb2NhdGlvbk5hbWU6IFwiQWxvY2HDp8OjbyBkZSBEaXN0w6JuY2lhXCIsXG5cdFx0ZGlzdGFuY2VBbGxvY2F0aW9uU25pcDogXCJDYWxjdWxhIGEgYWxvY2HDp8OjbyBkZSBkaXN0w6JuY2lhIGRlIGNhZGEgY8OpbHVsYSBwYXJhIG9yaWdlbnMgZm9ybmVjaWRhcyBjb20gYmFzZSBlbSBkaXN0w6JuY2lhIGRlIGxpbmhhIGRpcmV0YSwgZGlzdMOibmNpYSBkZSBjdXN0bywgZGlzdMOibmNpYSBkZSBzdXBlcmbDrWNpZSB2ZXJkYWRlaXJhLCBjb21vIHRhbWLDqW0gZmF0b3JlcyBkZSBjdXN0byB2ZXJ0aWNhbCBlIGhvcml6b250YWwuXCIsXG5cdFx0ZGlzdGFuY2VBbGxvY2F0aW9uRGVzYzogXCJBbG9jYcOnw6NvIGRlIERpc3TDom5jaWEgY2FsY3VsYSBxdWFsIG9yaWdlbSBjYWRhIGxvY2FsaXphw6fDo28gbmEgw6FyZWEgZGUgZXN0dWRvIMOpIGFsb2NhZG8uIFNlIHNvbWVudGUgYXMgb3JpZ2VucyBmb3JlbSBmb3JuZWNpZGFzIHBhcmEgZW50cmFkYSwgZW50w6NvIGFzIGxvY2FsaXphw6fDtWVzIHPDo28gYWxvY2FkYXMgdXRpbGl6YW5kbyB1bWEgZGlzdMOibmNpYSBkZSBsaW5oYSByZXRhIHBhcmEgYSBvcmlnZW0gbWFpcyBwcsOzeGltYS4gU2UgYW1iYXMgYXMgb3JpZ2VucyBlIGJhcnJlaXJhcyBmb3JlbSB1dGlsaXphZGFzIGNvbW8gZW50cmFkYSwgZW50w6NvIEFsb2Nhw6fDo28gZGUgRGlzdMOibmNpYSBjYWxjdWxhIGEgZGlzdMOibmNpYSBkZSBsaW5oYSByZXRhIGFvIHJlZG9yIGRlIGJhcnJlaXJhcyBwYXJhIGRldGVybWluYXIgcXVhbCBvcmlnZW0gdW1hIGxvY2FsaXphw6fDo28gZXN0w6EgYWxvY2FkYS4gUGFyYSBhbWJvcyByYXN0ZXIgZGUgb3JpZ2VtIGUgbyByYXN0ZXIgZGUgYmFycmVpcmEsIG8gdmFsb3IgZGUgcGxhbm8gZGUgZnVuZG8gZGV2ZSBzZXIgTm9EYXRhLCBlbnF1YW50byBvcmlnZW5zIGUgYmFycmVpcmFzIHPDo28gcmVwcmVzZW50YWRhcyBjb20gdmFsb3JlcyBkZSBjw6lsdWxhIHbDoWxpZG9zLiBPcyB2YWxvcmVzIHbDoWxpZG9zIGluY2x1ZW0gemVyby48ZGl2Pjxici8+UGFyYSBleGVjdXRhciBhbsOhbGlzZSBkZSBjdXN0byB1dGlsaXphbmRvIEFsb2Nhw6fDo28gZGUgRGlzdMOibmNpYSwgdW1hIHN1cGVyZsOtY2llIGRlIGN1c3RvIMOpIHByZWNpc2Fkby4gU2UgdW1hIHN1cGVyZsOtY2llIGRlIGN1c3RvIGZvciBmb3JuZWNpZGEsIGVudMOjbyBvIHJlc3VsdGFkbyBzZXLDoSB1bSByYXN0ZXIgZGUgYWxvY2HDp8OjbyBiYXNlYWRvIGVtIGN1c3RvIGFjdW11bGF0aXZvLCBuw6NvIGVtIHVtYSBkaXN0w6JuY2lhIGRlIGxpbmhhIHJldGEuIFF1YW5kbyBmYXRvcmVzIGhvcml6b250YWlzIGUgdmVydGljYWlzIHPDo28gZm9ybmVjaWRvcywgZW50w6NvIGEgZGlyZWNpb25hbGlkYWRlIMOpIGNvbnNpZGVyYWRhIGNvbmZvcm1lIG8gY3VzdG8gw6kgYWN1bXVsYWRvLiBRdWFuZG8gdW0gcmFzdGVyIGRlIHN1cGVyZsOtY2llIGZvciBmb3JuZWNpZG8gY29tbyBlbnRyYWRhLCBlbnTDo28gYSBkaXN0w6JuY2lhIGRlIHN1cGVyZsOtY2llIHJlYWwgY29iZXJ0YSBhbyBwYXNzYXIgZW50cmUgY8OpbHVsYXMgw6kgY2FsY3VsYWRvIHF1YW5kbyBhIGFsb2Nhw6fDo28gZm9yIGRldGVybWluYWRhLiBIw6EgcXVhdHJvIGNhcmFjdGVyw61zdGljYXMgZGUgb3JpZ2VtIHF1ZSBwb2RlbSBzZXIgdXRpbGl6YWRhcy4gRXN0YXMgY2FyYWN0ZXLDrXN0aWNhcywgcXVlIHBvZGUgc2VyIGRhIG9yaWdlbSBvdSBtb3ZlZG9yZXMgYSBwYXJ0aXIgZGEgb3JpZ2VtLCBzw6NvIGNvbnRyb2xhZG9zIHBvciBwYXLDom1ldHJvcyBlc3BlY8OtZmljb3M6IDEuIEFjdW11bGHDp8OjbyBpbmljaWFsOuKAr2RlZmluZSBvIGN1c3RvIGluaWNpYWwgYW50ZXMgZG8gbW92aW1lbnRvIGluaWNpYXIuIDIuIEFjdW11bGHDp8OjbyBtw6F4aW1hOuKAr2VzcGVjaWZpY2EgcXVhbnRvIG8gY3VzdG8gZGUgdW1hIGZvbnRlIHBvZGUgYWN1bXVsYXIgYW50ZXMgZGUgYWxjYW7Dp2FyIHNldSBsaW1pdGUuIDMuIE11bHRpcGxpY2Fkb3IgcGFyYSBhcGxpY2FyIGFvcyBjdXN0b3M64oCvZXNwZWNpZmljYSBvIG1vZG8gZGUgdmlhZ2VtIG91IG1hZ25pdHVkZSBuYSBvcmlnZW0uIDQuIEEgZGlyZcOnw6NvIGRlIHZpYWdlbTrigK9pZGVudGlmaWNhIHNlIG8gdHJhbnNwb3J0YWRvciBlc3TDoSBpbmljaWFuZG8gZW0gdW1hIG9yaWdlbSBlIG11ZGFuZG8gcGFyYSBsb2NhbGl6YcOnw7VlcyBkZSBuw6NvIG9yaWdlbSwgb3UgZXN0w6EgaW5pY2lhbmRvIGVtIGxvY2FsaXphw6fDtWVzIGRlIG7Do28gb3JpZ2VtIGUgbW92ZW5kbyBkZSB2b2x0YSBwYXJhIHVtYSBvcmlnZW0uPGRpdj48YnIvPlBvciBwYWRyw6NvLCBvIHJlc3VsdGFkbyBkYSBBbG9jYcOnw6NvIGRlIERpc3TDom5jaWEgw6kgdW1hIGJhbmRhIMO6bmljYSwgcXVlIMOpIG8gcmFzdGVyIGRlIGFsb2Nhw6fDo28gZGUgZGlzdMOibmNpYS4gTWFyY2FyIGEgb3DDp8OjbyBCb29sZWFubywgR2VyYXIgbGluaGEgZSBjb2x1bmEgZGUgb3JpZ2VtIGNvbW8gYmFuZGFzIGFkaWNpb25haXMgbmEgc2HDrWRhIHJlc3VsdGFyw6EgZW0gdW0gcmFzdGVyIGRlIGJhbmRhcyBtw7psdGlwbGFzIGNvbnNpc3RpbmRvIGVtIHRyw6pzIGJhbmRhcy4gQSBwcmltZWlyYSBiYW5kYSDDqSBhIGJhbmRhIGRlIGFsb2Nhw6fDo28gZGUgZGlzdMOibmNpYSwgYSBzZWd1bmRhIGJhbmRhIGNvbnTDqW0gdW0gw61uZGljZSBkZSBsaW5oYSBlIGEgdGVyY2VpcmEgYmFuZGEgY29udMOpbSB1bSDDrW5kaWNlIGRlIGNvbHVuYS4gRXN0ZXMgw61uZGljZXMgaWRlbnRpZmljYW0gbyBsb2NhbCBkYSBjw6lsdWxhIGRlIG9yaWdlbSBxdWUgw6kgYSBtZW5vciBkaXN0w6JuY2lhIGRlIGN1c3RvIGFjdW11bGFkYS4gTyDDrW5kaWNlIGRlIGxpbmhhIGRlIG9yaWdlbSBlIMOtbmRpY2UgZGUgY29sdW5hIGRlIG9yaWdlbSBwb2RlIHNlciB1dGlsaXphZG8ganVudG8gcGFyYSBleGVjdXRhciBvIG1hcGVhbWVudG8gZGUgaW50ZW5zaWRhZGUuIFNlIHZvY8OqIGNvbnN1bHRhciBxdWFscXVlciBsb2NhbGl6YcOnw6NvIGVtIHN1YSDDoXJlYSBkZSBlc3R1ZG8gYXRyYXbDqXMgZGFzIGJhbmRhcyBkdWFzIGUgdHLDqnMsIHZvY8OqIHNhYmVyw6EgYSBsaW5oYSBlIGNvbHVuYSBkYSBvcmlnZW0gZGUgbWVub3IgY3VzdG8gcGFyYSBlc3RhIGxvY2FsaXphw6fDo28uPC9kaXY+XCIsXG5cdFx0ZXVjQmFja0RpcmVjdGlvbk5hbWU6IFwiRGlyZcOnw6NvIEV1Y2xpZGlhbmEgZGUgUmV0b3Jub1wiLFxuXHRcdGV1Y0JhY2tEaXJlY3Rpb25TbmlwOiBcIkNhbGN1bGEsIHBhcmEgY2FkYSBjw6lsdWxhLCBhIGRpcmXDp8OjbywgZW0gZ3JhdXMsIGF0w6kgYSBjw6lsdWxhIHZpemluaGEgYW8gbG9uZ28gZG8gY2FtaW5obyBtYWlzIGN1cnRvIGRlIHZvbHRhIMOgIGZvbnRlIG1haXMgcHLDs3hpbWEsIGV2aXRhbmRvIGJhcnJlaXJhcy5cIixcblx0XHRldWNCYWNrRGlyZWN0aW9uRGVzYzogXCJBIGZ1bsOnw6NvIERpcmXDp8OjbyBkZSBWb2x0YSBFdWNsaWRlYW5hIHJlc3VsdGEgZW0gdW0gcmFzdGVyIGRlIHBvbnRvIGZsdXR1YW50ZSBjb250w61udW8gcXVlIHJlcHJlc2VudGEgYSBkaXJlw6fDo28gZW0gZ3JhdXMgZGUgdm9sdGEgcGFyYSBhIG9yaWdlbSBtYWlzIHByw7N4aW1hIGVucXVhbnRvIGV2aXRhIGJhcnJlaXJhcywgc2UgYmFycmVpcmFzIGZvcmVtIGZvcm5lY2lkYXMuPGRpdj48YnIvPkFzIGVudHJhZGFzIHBhcmEgRGlyZcOnw6NvIGRlIFZvbHRhIEV1Y2xpZGVhbmEgc8OjbyBhIG9yaWdlbSBxdWUgYSBkaXJlw6fDo28gc2Vyw6EgY2FsY3VsYWRhLiBVbWEgZW50cmFkYSBvcGNpb25hbCDDqSB1bSByYXN0ZXIgcXVlIHJlcHJlc2VudGEgYmFycmVpcmFzIGRlbnRybyBkYSDDoXJlYSBkZSBlc3R1ZG8uIFBhcmEgYW1ib3MgcmFzdGVyIGRlIG9yaWdlbSBlIG8gcmFzdGVyIGRlIGJhcnJlaXJhLCBvIHZhbG9yIGRlIHBsYW5vIGRlIGZ1bmRvIGRldmUgc2VyIE5vRGF0YSwgZW5xdWFudG8gb3JpZ2VucyBlIGJhcnJlaXJhcyBzw6NvIHJlcHJlc2VudGFkYXMgY29tIHZhbG9yZXMgdsOhbGlkb3MuIE9zIHZhbG9yZXMgdsOhbGlkb3MgaW5jbHVlbSB6ZXJvLiBQb3IgcGFkcsOjbywgbyBjw6FsY3VsbyBpcsOhIHByb2Nlc3NhciBuYSBleHRlbnPDo28gY29tYmluYWRhIGRhcyBvcmlnZW5zIGUgYmFycmVpcmFzLCBtYWlzIDIgbGluaGFzIGUgY29sdW5hcy4gU2UgYSBhbsOhbGlzZSBmb3Igc29tZW50ZSBuZWNlc3PDoXJpYSBkZW50cm8gZGUgdW1hIGRpc3TDom5jaWEgZXNwZWNpZmljYWRhIGEgcGFydGlyIGRhcyBvcmlnZW5zLCBlbnTDo28gbyBwYXLDom1ldHJvIERpc3TDom5jaWEgTcOheGltYSBwb2RlIHNlciB1dGlsaXphZGEuIERpcmXDp8OjbyBkZSBWb2x0YSBFdWNsaWRlYW5hIHN1cG9ydGEgYW1ib3MgdW0gbcOpdG9kbyBQbGFubyBlIHVtIG3DqXRvZG8gR2VvZMOpc2ljbyBubyBjw6FsY3Vsby4gTyBjw6FsY3VsbyBkbyBtw6l0b2RvIFBsYW5hciBzZXLDoSBleGVjdXRhZG8gZW0gdW0gcGxhbm8gcHJvamV0YWRvIHV0aWxpemFuZG8gdW0gc2lzdGVtYSBkZSBjb29yZGVuYWRhcyBDYXJ0ZXNpYW5hcyAyRC4gTyBjw6FsY3VsbyBkZSBtw6l0b2RvIEdlb2TDqXNpY28gc2Vyw6EgZXhlY3V0YWRvIG5vIGVsaXBzw7NpZGUsIG8gcXVhbCBzaWduaWZpY2EgcXVlIG7Do28gaW1wb3J0YW5kbyBhIHByb2plw6fDo28gZGUgZW50cmFkYSBvdSBzYcOtZGEsIG9zIHJlc3VsdGFkb3MgbsOjbyBhbHRlcmFtLjxkaXY+PGJyLz5PIHJlc3VsdGFkbyBkYSBmdW7Dp8OjbyBEaXJlw6fDo28gZGUgVm9sdGEgRXVjbGlkZWFuYSBwb2RlIHNlciB1dGlsaXphZG8ganVudG8gY29tIG8gcmVzdWx0YWRvIGRhIGZ1bsOnw6NvIERpc3TDom5jaWEgRXVjbGlkZWFuYSBwYXJhIGRldGVybWluYXIgb3MgbWVub3JlcyBjYW1pbmhvcyBkZSBsb2NhbGl6YcOnw7VlcyBkZW50cm8gZGEgw6FyZWEgZGUgZXN0dWRvIGRlIHZvbHRhIHBhcmEgYSBvcmlnZW0uIEFtYm9zIG9zIHJlc3VsdGFkb3MgZGUgRGlyZcOnw6NvIGRlIFZvbHRhIEV1Y2xpZGVhbmEgZSBEaXN0w6JuY2lhIEV1Y2xpZGVhbmEgc8OjbyB1dGlsaXphZGFzIG5hIGZ1bsOnw6NvIENhbWluaG8gZGUgQ3VzdG8ganVudG8gY29tIGRlc3Rpbm9zIHBhcmEgZ2VyYXIgb3MgbWVub3JlcyBjYW1pbmhvcy48L2Rpdj5cIixcblx0XHRleHBhbmROYW1lOiBcIkV4cGFuZGlyXCIsXG5cdFx0ZXhwYW5kU25pcDogXCJFeHBhbmRlIHpvbmFzIHNlbGVjaW9uYWRhcyBkZSB1bSByYXN0ZXIgcG9yIHpvbmFzLCBwb3IgdW0gbsO6bWVybyBkZSBjw6lsdWxhcyBlc3BlY8OtZmljby5cIixcblx0XHRleHBhbmREZXNjOiBcIkNvbSBhIGZ1bsOnw6NvIGdsb2JhbCBFeHBhbmRpciwgdm9jw6ogcG9kZSBnZW5lcmFsaXphciBvdSBzaW1wbGlmaWNhciByYXN0ZXJzIGNyaWFuZG8gem9uYXMgcGFydGljdWxhcmVzIG1haW9yZXMuIFZvY8OqIHRhbWLDqW0gcG9kZSBjb250cm9sYXIgYSBxdWFudGlhIGRlIGdlbmVyYWxpemHDp8OjbyBxdWUgb2NvcnJlcsOhLjxkaXY+PGJyLz5BcyB6b25hcyBxdWUgdm9jw6ogc2VsZWNpb25hIGF1bWVudGFyw6EgZW0gdGFtYW5obyBleHBhbmRpbmRvIGVtIG91dHJhcyB6b25hcy4gQ29uY2VpdHVhbG1lbnRlLCBvcyBWYWxvcmVzIGRlIFpvbmEgc2VsZWNpb25hZG9zIHBvZGVtIHNlciB2aXN1YWxpemFkb3MgY29tbyB6b25hcyBkZSBwcmltZWlybyBwbGFubywgZW5xdWFudG8gb3Mgb3V0cm9zIHZhbG9yZXMgcGVybWFuZWNlbSB6b25hcyBkZSBwbGFubyBkZSBmdW5kby4gQXMgem9uYXMgZGUgcHJpbWVpcm8gcGxhbm8gcG9kZW0gZXhwYW5kaXIgbmFzIHpvbmFzIGRlIHBsYW5vIGRlIGZ1bmRvLjxkaXY+PGJyLz5BIHF1YW50aWEgZGUgZ2VuZXJhbGl6YcOnw6NvIHBvZGUgc2VyIGNvbnRyb2xhZGEgY29tIG8gcGFyw6JtZXRybyBOw7ptZXJvIGRlIEPDqWx1bGFzLiBQb3IgcGFkcsOjbywgZXN0ZSB2YWxvciDDqSAxLCBxdWUgc2lnbmlmaWNhIHF1ZSBhcyB6b25hcyBzZWxlY2lvbmFkYXMgZXhwYW5kaXLDoSBwZWxhIHF1YW50aWEgY29ycmVzcG9uZGVuZG8gcGFyYSB1bSB0YW1hbmhvIGRhIGPDqWx1bGEuIFBhcmEgYXVtZW50YXIgbyBncmF1IGRlIGdlbmVyYWxpemHDp8Ojbywgdm9jw6ogcG9kZSBlc3BlY2lmaWNhciB1bSB2YWxvciBtYWlvciBwYXJhIGVzdGUgcGFyw6JtZXRyby4gQ29uY2VpdHVhbG1lbnRlLCDDqSBjb21vIGV4ZWN1dGFyIGEgZmVycmFtZW50YSB0YW50b3MgcXVhbnRvIG8gbsO6bWVybyBlc3BlY2lmaWNhZG8sIGNvbSBvcyByZXN1bHRhZG9zIGRvcyBhbnRlcmlvcmVzIG5hIGV4ZWN1w6fDo28gc2VuZG8gYSBlbnRyYWRhIG5hIGludGVyYcOnw6NvIHN1YnNlcXVlbnRlLjwvZGl2PlwiLFxuXHRcdHRyZW5kQW5hbHlzaXNOYW1lOiBcIkdlcmFyIFRlbmTDqm5jaWFcIixcblx0XHR0cmVuZEFuYWx5c2lzU25pcDogXCJFc3RpbWEgYSB0ZW5kw6puY2lhIGRlIGNhZGEgcGl4ZWwgYW8gbG9uZ28gZGUgdW1hIGRpbWVuc8OjbyBwYXJhIHVtIG91IG1haXMgdmFyacOhdmVpcyBlbSB1bSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbC5cIixcblx0XHR0cmVuZEFuYWx5c2lzRGVzYzogXCI8ZGl2PkVzdGEgZnVuw6fDo28gcG9kZSBzZXIgdXNhZGEgcGFyYSBhanVzdGFyIG9zIGRhZG9zIGFvIGxvbmdvIGRlIHVtYSBsaW5oYSBkZSB0ZW5kw6puY2lhIGxpbmVhciwgaGFybcO0bmljYSBvdSBwb2xpbm9taWFsLCBvdSBwb2RlIHNlciB1c2FkYSBwYXJhIHJlYWxpemFyIGEgZGV0ZWPDp8OjbyBkZSB0ZW5kw6puY2lhIHVzYW5kbyBvIHRlc3RlIGRlIE1hbm4tS2VuZGFsbCBvdSBTYXpvbmFsLUtlbmRhbGwuPC9kaXY+PGJyPjxkaXY+TyByYXN0ZXIgZGUgdGVuZMOqbmNpYSBkZSBzYcOtZGEgZ2VyYWRvIGNvbSBlc3RhIGZ1bsOnw6NvIMOpIHVzYWRvIGNvbW8gZW50cmFkYSBwYXJhIGEgZnVuw6fDo28gPHN0cm9uZz5QcmV2ZXIgVXRpbGl6YW5kbyBUZW5kw6puY2lhPC9zdHJvbmc+IC48L2Rpdj48YnI+PGRpdj5PcyB0ZXN0ZXMgZGUgTWFubi1LZW5kYWxsIGUgU2Vhc29uYWwtS2VuZGFsbCBzw6NvIHVzYWRvcyBwYXJhIGRldGVybWluYXIgc2UgaMOhIHVtYSB0ZW5kw6puY2lhIG1vbm90w7RuaWNhIG5vcyBkYWRvcy4gRWxlcyBzw6NvIG7Do28gcGFyYW3DqXRyaWNvcywgbyBxdWUgc2lnbmlmaWNhIHF1ZSBuw6NvIGFzc3VtZW0gdW1hIGRpc3RyaWJ1acOnw6NvIGVzcGVjw61maWNhIGRlIGRhZG9zLiBPIHRlc3RlIGRlIE1hbm4tS2VuZGFsbCBuw6NvIGNvbnNpZGVyYSBjb3JyZWxhw6fDo28gc2VyaWFsIG91IGVmZWl0b3Mgc2F6b25haXMuIFNlIG9zIGRhZG9zIGZvcmVtIHNhem9uYWlzLCBvIHRlc3RlIGRlIFNhem9uYWwtS2VuZGFsbCBzZXLDoSBtYWlzIGFwcm9wcmlhZG8uPC9kaXY+PGJyPjxkaXY+U2UgYSBmZXJyYW1lbnRhIGZvciB1c2FkYSBwYXJhIHJlYWxpemFyIG8gdGVzdGUgZGUgTWFubi1LZW5kYWxsIG91IFNhem9uYWwtS2VuZGFsbCwgYSBzYcOtZGEgc2Vyw6EgdW0gcmFzdGVyIGRlIGNpbmNvIGJhbmRhcyBjb21vIHNlZ3VlOjwvZGl2Pjx1bD48bGk+QmFuZGEgMSA9IGRlY2xpdmlkYWRlIGRlIFNlbjwvbGk+PGxpPkJhbmRhIDIgPSB2YWxvciBwPC9saT48bGk+QmFuZGEgMyA9IHBvbnR1YcOnw6NvIChTKSBkZSBNYW5uLUtlbmRhbGw8L2xpPjxsaT5CYW5kYSA0ID0gVmFyacOibmNpYSBTPC9saT48bGk+QmFuZGEgNCA9IFZhcmnDom5jaWEgUzwvbGk+PGxpPkJhbmRhIDUgPSBwb250dWHDp8OjbyBaPC9saT48L3VsPjxkaXY+QXMgc2HDrWRhcyBkbyB0ZXN0ZSBkZSBNYW5uLUtlbmRhbGwgb3UgU2F6b25hbC1LZW5kYWxsIHBvZGVtIHNlciB1c2FkYXMgcGFyYSBkZXRlcm1pbmFyIHF1YWlzIHBpeGVscyBlbSBzdWEgc8OpcmllIGRlIHRlbXBvIG11bHRpZGltZW5zaW9uYWwgdMOqbSB1bWEgdGVuZMOqbmNpYSBlc3RhdGlzdGljYW1lbnRlIHNpZ25pZmljYXRpdmEuIFZvY8OqIHBvZGUgdXNhciBlc3RhcyBpbmZvcm1hw6fDtWVzIGVtIGNvbmp1bnRvIGNvbSBhIGFuw6FsaXNlIGRlIHRlbmTDqm5jaWEgbGluZWFyLCBoYXJtw7RuaWNhIG91IHBvbGlub21pYWwgcGFyYSBleHRyYWlyIHRlbmTDqm5jaWFzIHNpZ25pZmljYXRpdmFzIGVtIHN1YSBzw6lyaWUgZGUgdGVtcG8uIFZvY8OqIHBvZGUgZ2VyYXIgdW1hIG3DoXNjYXJhIGluY2x1aW5kbyBwaXhlbHMgY29tIHZhbG9yZXMgcCBzaWduaWZpY2F0aXZvcywgYXBsaWNhciBhIG3DoXNjYXJhIGFvIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGUgdXNhciBlc3RlIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIG1hc2NhcmFkbyBjb21vIGVudHJhZGEgcGFyYSBhIGZlcnJhbWVudGEgcGFyYSByZWFsaXphciBhbsOhbGlzZXMgZGUgdGVuZMOqbmNpYSBsaW5lYXIsIGhhcm3DtG5pY2Egb3UgcG9saW5vbWlhbC48L2Rpdj48YnI+PGRpdj5Iw6EgdHLDqnMgb3DDp8O1ZXMgZGUgbGluaGEgZGUgdGVuZMOqbmNpYSBwYXJhIGFqdXN0YXIgdW1hIHRlbmTDqm5jaWEgYW9zIHZhbG9yZXMgZGUgdmFyacOhdmVpcyBhbyBsb25nbyBkZSB1bWEgZGltZW5zw6NvOiBsaW5lYXIsIHBvbGlub21pYWwgZSBoYXJtw7RuaWNvLjwvZGl2Pjxicj48ZGl2PlBhcmEgYW7DoWxpc2UgZGUgdGVuZMOqbmNpYSBsaW5lYXIsIGEgc2HDrWRhIMOpIHVtIHJhc3RlciBkZSB0csOqcyBiYW5kYXMgY29tbyBzZWd1ZTo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBEZWNsaXZpZGFkZTwvbGk+PGxpPkJhbmRhIDIgPSBJbnRlcmNlcHRhcjwvbGk+PGxpPkJhbmRhIDMgPSBFcnJvIE3DqWRpbyBRdWFkcsOhdGljbyAoUk1TRSkgb3UgbyBlcnJvIGVtIHRvcm5vIGRhIGxpbmhhIGRlIG1lbGhvciBhanVzdGU8L2xpPjwvdWw+PGRpdj5QYXJhIGFuw6FsaXNlIGRlIHRlbmTDqm5jaWEgcG9saW5vbWlhbCwgbyBuw7ptZXJvIGRlIGJhbmRhcyBuYSBzYcOtZGEgZGVwZW5kZSBkYSBvcmRlbSBwb2xpbm9taWFsLiBPIGFqdXN0ZSBwb2xpbm9taWFsIGRlIHNlZ3VuZGEgb3JkZW0gcHJvZHV6IHVtIHJhc3RlciBkZSBxdWF0cm8gYmFuZGFzIGNvbW8gc2VndWU6PC9kaXY+PHVsPjxsaT5CYW5kYSAxID0gUG9seW5vbWlhbF8yPC9saT48bGk+QmFuZGEgMiA9IFBvbHlub21pYWxfMTwvbGk+PGxpPkJhbmRhIDMgPSBQb2x5bm9taWFsXzA8L2xpPjxsaT5CYW5kYSA0ID0gUk1TRTwvbGk+PC91bD48ZGl2Pk8gYWp1c3RlIHBvbGlub21pYWwgZGUgdGVyY2VpcmEgb3JkZW0gcHJvZHV6IHVtIHJhc3RlciBkZSBjaW5jbyBiYW5kYXMgY29tbyBzZWd1ZTo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBQb2x5bm9taWFsXzM8L2xpPjxsaT5CYW5kYSAyID0gUG9seW5vbWlhbF8yPC9saT48bGk+QmFuZGEgMyA9IFBvbHlub21pYWxfMTwvbGk+PGxpPkJhbmRhIDQgPSBQb2x5bm9taWFsXzA8L2xpPjxsaT5CYW5kYSA1ID0gUk1TRTwvbGk+PC91bD48ZGl2PlBhcmEgYW7DoWxpc2UgZGUgdGVuZMOqbmNpYSBoYXJtw7RuaWNhLCBvIG7Dum1lcm8gZGUgYmFuZGFzIG5hIHNhw61kYSBkZXBlbmRlIGRhIGZyZXF1w6puY2lhIGhhcm3DtG5pY2EuIFF1YW5kbyBhIGZyZXF1w6puY2lhIMOpIGRlZmluaWRhIGNvbW8gMSwgYSBzYcOtZGEgw6kgdW0gcmFzdGVyIGRlIGNpbmNvIGJhbmRhcyBjb21vIHNlZ3VlOjwvZGl2Pjx1bD48bGk+QmFuZGEgMSA9IERlY2xpdmlkYWRlPC9saT48bGk+QmFuZGEgMiA9IEludGVyY2VwdGFyPC9saT48bGk+QmFuZGEgMyA9IEhhcm1vbmljX3NpbjE8L2xpPjxsaT5CYW5kYSA0ID0gSGFybW9uaWNfY29zMTwvbGk+PGxpPkJhbmRhIDUgPSBSTVNFPC9saT48L3VsPjxkaXY+UXVhbmRvIGEgZnJlcXXDqm5jaWEgw6kgZGVmaW5pZGEgY29tbyAyLCBhIHNhw61kYSDDqSB1bSByYXN0ZXIgZGUgc2V0ZSBiYW5kYXMgY29tbyBzZWd1ZTo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBEZWNsaXZpZGFkZTwvbGk+PGxpPkJhbmRhIDIgPSBJbnRlcmNlcHRhcjwvbGk+PGxpPkJhbmRhIDMgPSBIYXJtb25pY19zaW4xPC9saT48bGk+QmFuZGEgNCA9IEhhcm1vbmljX2NvczE8L2xpPjxsaT5CYW5kYSA1ID0gSGFybW9uaWNfc2luMjwvbGk+PGxpPkJhbmRhIDYgPSBIYXJtb25pY19jb3MyPC9saT48bGk+QmFuZGEgNyA9IFJNU0U8L2xpPjwvdWw+PGRpdj5PIHBhcsOibWV0cm8gPHN0cm9uZz5Db21wcmltZW50byBkbyBDaWNsbzwvc3Ryb25nPiBwYXJhIGFuw6FsaXNlIGRlIHRlbmTDqm5jaWEgaGFybcO0bmljYSDDqSB1c2FkbyBwYXJhIGluZGljYXIgbyBuw7ptZXJvIGUgYSBkdXJhw6fDo28gZG9zIGNpY2xvcyBxdWUgdm9jw6ogZXNwZXJhIHZpc3VhbGl6YXIgZW0gc2V1cyBkYWRvcyBhbyBsb25nbyBkZSB1bSBkaWEgb3UgYW5vLiBQb3IgZXhlbXBsbywgc2Ugdm9jw6ogZXNwZXJhIHF1ZSBzZXVzIGRhZG9zIHBhc3NlbSBwb3IgZG9pcyBjaWNsb3MgZGUgdmFyaWHDp8OjbyBlbSB1bSBhbm8sIGEgZHVyYcOnw6NvIGRvIGNpY2xvIHNlcsOhIGRlIDE4Mi41IGRpYXMgb3UgMC41IGFub3MuIFNlIHZvY8OqIHRpdmVyIGRhZG9zIGRlIHRlbXBlcmF0dXJhIGNvbGV0YWRvcyBhIGNhZGEgdHLDqnMgaG9yYXMgZSBob3V2ZXIgdW0gY2ljbG8gZGUgdmFyaWHDp8OjbyBwb3IgZGlhLCBhIGR1cmHDp8OjbyBkbyBjaWNsbyBzZXLDoSBkZSB1bSBkaWEuPC9kaXY+PGJyPjxkaXY+TyBwYXLDom1ldHJvIDxzdHJvbmc+RnJlcXXDqm5jaWE8L3N0cm9uZz4gcGFyYSBhbsOhbGlzZSBkZSB0ZW5kw6puY2lhIGhhcm3DtG5pY2Egw6kgdXNhZG8gcGFyYSBkZXNjcmV2ZXIgbyBtb2RlbG8gaGFybcO0bmljbyBwYXJhIHNlIGFqdXN0YXIgYW9zIGRhZG9zLiBTZSBhIGZyZXF1w6puY2lhIGZvciBkZWZpbmlkYSBjb21vIDEsIHVtYSBjb21iaW5hw6fDo28gZGEgY3VydmEgbGluZWFyIGUgZGEgY3VydmEgaGFybcO0bmljYSBkZSBwcmltZWlyYSBvcmRlbSBzZXLDoSB1c2FkYSBwYXJhIGFqdXN0YXIgbyBtb2RlbG8uIFNlIGEgZnJlcXXDqm5jaWEgZm9yIDIsIHVtYSBjb21iaW5hw6fDo28gZGUgY3VydmEgaGFybcO0bmljYSBsaW5lYXIgZGUgcHJpbWVpcmEgb3JkZW0gZSBjdXJ2YSBoYXJtw7RuaWNhIGRlIHNlZ3VuZGEgb3JkZW0gc2Vyw6EgdXNhZGEgcGFyYSBhanVzdGFyIG9zIGRhZG9zLiBTZSBhIGZyZXF1w6puY2lhIGZvciAzLCB1bWEgY3VydmEgaGFybcO0bmljYSBkZSB0ZXJjZWlyYSBvcmRlbSBhZGljaW9uYWwgc2Vyw6EgdXNhZGEgcGFyYSBtb2RlbGFyIG9zIGRhZG9zLCBlIGFzc2ltIHBvciBkaWFudGUuPC9kaXY+PGJyPjxkaXY+QXMgZXN0YXTDrXN0aWNhcyBkZSBhanVzdGUgcGVyZmVpdG8gZG8gbW9kZWxvIHBvZGVtIHNlciBnZXJhZGFzIGNvbW8gc2HDrWRhcyBvcGNpb25haXMuIEEgcmFpeiBkbyBlcnJvIHF1YWRyw6F0aWNvIG3DqWRpbyAoUk1TRSksIFItcXVhZHJhZG8gZSBvIHZhbG9yIHAgZGEgaW5jbGluYcOnw6NvIGRhIHRlbmTDqm5jaWEgcG9kZW0gc2VyIGNhbGN1bGFkb3MgZSBzaW1ib2xpemFkb3MuIFNpbWJvbGl6ZSBhIGNhbWFkYSBkZSByYXN0ZXIgZGUgdGVuZMOqbmNpYSBkZSBzYcOtZGEgdXNhbmRvIGEgc2ltYm9sb2dpYSA8c3Ryb25nPlJHQjwvc3Ryb25nPiBlIGVzcGVjaWZpcXVlIGFzIGVzdGF0w61zdGljYXMgY29tbyBhcyBiYW5kYXMgdmVybWVsaGEsIHZlcmRlIGUgYXp1bC48L2Rpdj48YnI+XCIsXG5cdFx0c3BlY3RyYWxVbm1peGluZ05hbWU6IFwiU2VwYXJhciBMaW5lYXIgRXNwZWN0cmFsXCIsXG5cdFx0c3BlY3RyYWxVbm1peGluZ1NuaXA6IFwiRXhlY3V0YSBjbGFzc2lmaWNhw6fDo28gZGUgc3VicGl4ZWwgZSBjYWxjdWxhIGEgYWJ1bmTDom5jaWEgZnJhY2lvbsOhcmlhIGRlIHRpcG9zIGRlIGNvYmVydHVyYSBkZSBzb2xvIGRpZmVyZW50ZXMgcGFyYSBwaXhlbHMgaW5kaXZpZHVhaXMuXCIsXG5cdFx0c3BlY3RyYWxVbm1peGluZ0Rlc2M6IFwiQSBmdW7Dp8OjbyBTZXBhcmFyIExpbmVhciBFc3BlY3RyYWwgY2FsY3VsYSBhIGNvYmVydHVyYSBmcmFjaW9uw6FyaWEgZGUgcGl4ZWxzIGluZGl2aWR1YWlzIHF1ZSBjb250ZW5oYW0gdGlwb3MgZGUgY29iZXJ0dXJhIGRlIHNvbG8gbcO6bHRpcGxvcy4gRWxhIGdlcmEgdW1hIGNhbWFkYSBkZSBiYW5kYXMgbcO6bHRpcGxhcywgb25kZSBjYWRhIGJhbmRhIGNvcnJlc3BvbmRlIMOgIGFidW5kw6JuY2lhIGZyYWNpb27DoXJpYSBkZSBjYWRhIGNsYXNzZSBkZSBjb2JlcnR1cmEgZGUgc29sby4gUG9yIGV4ZW1wbG8sIHZvY8OqIHBvZGUgdXRpbGl6w6EtbGEgdG8gZXhlY3V0YXIgY2xhc3NpZmljYcOnw6NvIGRlIGNvYmVydHVyYSBkZSBzb2xvIGVtIHVtYSBpbWFnZW0gbXVsdGllc3BlY3RyYWwgcGFyYSBpZGVudGlmaWNhciB2ZWdldGHDp8OjbyBmb3Rvc3NpbnTDqXRpY2EsIHNvbG8gYnJ1dG8gZSB2ZWdldGHDp8OjbyBtb3J0YSBvdSBuw6NvIGZvdG9zc2ludMOpdGljYS48ZGl2Pjxici8+QSBvcmRlbSBkbyByYXN0ZXIgZGUgYmFuZGFzIG3Dumx0aXBsYXMgZGUgc2HDrWRhIHNlZ3VlIGEgb3JkZW0gZG8gcGVyZmlsIGRlIGVudHJhZGEgZXNwZWN0cmFsLiBPIG7Dum1lcm8gZGUgY2xhc3NlcyBuw6NvIHBvZGUgZXhjZWRlciBvIG7Dum1lcm8gZGUgYmFuZGFzIG5vIHJhc3RlciBkZSBlbnRyYWRhLiBQb3IgZXhlbXBsbywgdm9jw6ogbsOjbyBwb2RlIGV4dHJhaXIgaW5mb3JtYcOnw7VlcyBzb2JyZSBtYWlzIGRlIDggY2xhc3NlcyBkZSByYXN0ZXIgZGUgOC1iYW5kYXMuPC9kaXY+XCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbEZpbHRlck5hbWU6IFwiRmlsdHJvIE11bHRpZGltZW5zaW9uYWxcIixcblx0XHRpbnRlcnBvbGF0ZVJhc3RlckJ5RGltZW5zaW9uRnVuY3Rpb25OYW1lOiBcIkludGVycG9sYXIgUmFzdGVyIHBvciBEaW1lbnPDo29cIixcblx0XHRpbnRlcnBvbGF0ZVJhc3RlckJ5RGltZW5zaW9uRnVuY3Rpb25TbmlwOiBcIkludGVycG9sYSB1bSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBlbSB2YWxvcmVzIGRlIGRpbWVuc8OjbyBlc3BlY2lmaWNhZG9zIHVzYW5kbyBkaXZpc8O1ZXMgYWRqYWNlbnRlcy5cIixcblx0XHRpbnRlcnBvbGF0ZVJhc3RlckJ5RGltZW5zaW9uRnVuY3Rpb25EZXNjOiBcIjxwPkVzdGEgZnVuw6fDo28gcGVybWl0ZSBlc3RpbWFyIHZhbG9yZXMgZGUgcGl4ZWwgcGFyYSB1bWEgZGl2aXPDo28gZGUgZGltZW5zw6NvIGluZGVmaW5pZGEgZW0gdW0gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwuIFBvciBleGVtcGxvLCBzZSB2b2PDqiB0ZW0gdW0gY29uanVudG8gZGUgZGFkb3MgY29udGVuZG8gYSB0ZW1wZXJhdHVyYSBkbyBvY2Vhbm8gYW8gbsOtdmVsIGRhIHN1cGVyZsOtY2llIGUgYSAxMDAgbWV0cm9zIGFiYWl4byBkbyBuw612ZWwgZG8gbWFyIGUgZGVzZWphIGVzdGltYXIgYSB0ZW1wZXJhdHVyYSBhIDUwIG1ldHJvcyBhYmFpeG8gZG8gbsOtdmVsIGRvIG1hciwgdm9jw6ogcG9kZSB1c2FyIGVzdGEgZnVuw6fDo28gcGFyYSBvYnRlciB1bWEgZXN0aW1hdGl2YSBuZXNzYSBwcm9mdW5kaWRhZGUgdXNhbmRvIG8gYm90w6NvIFBvciBkZWZpbmnDp8OjbyBkZSBkaW1lbnPDo28gZGUgdmFsb3Jlcy48L3A+PHA+Vm9jw6ogdGFtYsOpbSBwb2RlIHJlZHV6aXIgYSBhbW9zdHJhIGRlIHVtIGNvbmp1bnRvIGRlIGRhZG9zIG1lbnNhbCBlbSB1bSBjb25qdW50byBkZSBkYWRvcyBkacOhcmlvIHVzYW5kbyBhIGRlZmluacOnw6NvIGRlIGRpbWVuc8OjbyBQb3IgaW50ZXJ2YWxvIGUgZXNwZWNpZmljYW5kbyBvIHZhbG9yIGRvIHBhcsOibWV0cm8gRXRhcGEgY29tbyAxIGUgbyB2YWxvciBkbyBwYXLDom1ldHJvIFVuaWRhZGUgY29tbyBEaWFzLjwvcD48cD5Vc2UgYSBvcMOnw6NvIERlZmluacOnw6NvIGRlIGRpbWVuc8OjbyBwb3IgUmFzdGVyIGRlIERlc3Rpbm8gcGFyYSBlc3RpbWFyIG8gdmFsb3IgZG8gUmFzdGVyIGRlIERlc3Rpbm8uPC9wPlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxGaWx0ZXJTbmlwOiBcIkNyaWEgdW1hIGNhbWFkYSByYXN0ZXIgYSBwYXJ0aXIgZGUgdW0gY29uanVudG8gZGUgZGFkb3MgcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgb3UgY2FtYWRhIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGRpdmlkaW5kbyBvcyBkYWRvcyBhbyBsb25nbyBkZSB2YXJpw6F2ZWlzIGUgZGltZW5zw7VlcyBkZWZpbmlkYXMuXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbEZpbHRlckRlc2M6IFwiTyBGaWx0cm8gTXVsdGlkaW1lbnNpb25hbCBjcmlhIHVtYSBjYW1hZGEgcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgZmlsdHJhbmRvIGUgZXh0cmFpbmRvIHVtIHN1YmNvbmp1bnRvIGRlIHZhcmnDoXZlaXMgZGUgdW0gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwuIFBvciBleGVtcGxvLCB2b2PDqiB0ZW0gdW0gY29uanVudG8gZGUgZGFkb3MgbXVsdGlkaW1lbnNpb25hbCBxdWUgY29udMOpbSAzMCBhbm9zIGRlIGRhZG9zIGRlIHByZWNpcGl0YcOnw6NvIG1lbnNhbCBlIGRlc2VqYSBleHRyYWlyIGRhZG9zIGRlIGNhZGEgSmFuZWlybyBwYXJhIHZlcmlmaWNhciBjb21vIGEgcHJlY2lwaXRhw6fDo28gZm9pIGFsdGVyYWRhIHBhcmEgZXN0ZSBtw6pzLjxkaXY+PGJyLz5VdGlsaXplIG8gcGFyw6JtZXRybyBEZWZpbmnDp8OjbyBkZSBEaW1lbnPDo28gcGFyYSBkaXZpZGlyIGRpbWVuc8O1ZXMgdXRpbGl6YW5kbyB1bSBpbnRlcnZhbG8sIHVtIHZhbG9yIG91IHVtIGludGVydmFsbyBkZSB2YWxvcmVzLiBQb3IgZXhlbXBsbywgc2Ugdm9jw6ogdGl2ZXIgMTAgYW5vcyBkZSBkYWRvcyBkZSBzYWxpbmlkYWRlIGRvIG9jZWFubywgY29sZXRhZG9zIG1lbnNhbG1lbnRlIGUgYSBjYWRhIDIgbWV0cm9zIGRlIHByb2Z1bmRpZGFkZSBhdMOpIDUwMCBtZXRyb3MsIHBvZGVyw6EgdXRpbGl6YXIgYXMgZGlmZXJlbnRlcyBvcMOnw7VlcyBkYSBkZWZpbmnDp8OjbyBkZSBkaW1lbnPDo28gcGFyYSBvcyBzZWd1aW50ZXMgY2Vuw6FyaW9zLiBDZW7DoXJpbyAxOiBFeHRyYWlyIGRhZG9zIGRlIHNhbGluaWRhZGUgcGFyYSBvIG3DqnMgZGUgSmFuZWlybyBkdXJhbnRlIG8gcGVyw61vZG8gZGUgMTAgYW5vcy4gRXNjb2xoYSBQb3IgVmFsb3JlcywgZGVmaW5hIERpbWVuc8OjbyBwYXJhIFN0ZFRpbWUgZSBkZWZpbmEgVmFsb3JlcyBwYXJhIEphbmVpcm8uIENlbsOhcmlvIDI6IERpdmlkaXIgZGFkb3MgZGUgc2FsaW5pZGFkZSBlbSB1bSBpbnRlcnZhbG8gZGUgcHJvZnVuZGlkYWRlIGRlIDAgYSAxNTAgbWV0cm9zLiBFc2NvbGhhIFBvciBJbnRlcnZhbG9zLCBkZWZpbmEgRGltZW5zw6NvIHBhcmEgU3RkWiBlIGRlZmluYSBWYWxvciBNw61uaW1vIHBhcmEgLTE1MCBlIFZhbG9yIE3DoXhpbW8gcGFyYSAwLiBDZW7DoXJpbyAzOiBFeHRyYWlyIGRhZG9zIGRlIHNhbGluaWRhZGUgZG9zIDEwIHByaW1laXJvcyBkaWFzIGRlIGNhZGEgSmFuZWlybywgZHVyYW50ZSB1bSBwZXLDrW9kbyBkZSAxMCBhbm9zLiBFc2NvbGhhIFBvciBJdGVyYcOnw6NvLCBkZWZpbmEgRGltZW5zw6NvIHBhcmEgU3RkVGltZSwgZGVmaW5hIG8gSW7DrWNpbyBkYSBwcmltZWlyYSBpdGVyYcOnw6NvIGUgVMOpcm1pbm8gZGEgcHJpbWVpcmEgaXRlcmHDp8OjbyBwYXJhIG8gaW7DrWNpbyBlIG8gdMOpcm1pbm8gY29ycmVzcG9uZGVudGVzIGRvIHBlcsOtb2RvIGRhIGl0ZXJhw6fDo28sIGRlZmluYSBFdGFwYSBwYXJhIDEgZSBkZWZpbmEgVW5pZGFkZSBwYXJhIEFub3MuPC9kaXY+XCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbFJhc3Rlck5hbWU6IFwiUmFzdGVyIE11bHRpZGltZW5zaW9uYWxcIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsUmFzdGVyU25pcDogXCJBZGljaW9uYSBkYWRvcyBtdWx0aWRpbWVuc2lvbmFpcyBhIHVtIG1hcGEgY29tbyB1bWEgY2FtYWRhIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsLlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxSYXN0ZXJEZXNjOiBcIkEgZnVuw6fDo28gUmFzdGVyIE11bHRpZGltZW5zaW9uYWwgYWRpY2lvbmEgZGFkb3MgbXVsdGlkaW1lbnNpb25haXMgYSB1bSBtYXBhIGNvbW8gdW1hIGNhbWFkYSBtdWx0aWRpbWVuc2lvbmFsLiBFc3NhIGZ1bsOnw6NvIMOpIMO6dGlsIGFvIGV4ZWN1dGFyIGZsdXhvcyBkZSB0cmFiYWxobyBkYSBhbsOhbGlzZSBkZSByYXN0ZXIgdXRpbGl6YW5kbyB1bWEgY2FkZWlhIGRlIGZ1bsOnw7Vlcy48ZGl2Pjxici8+T3MgY29uanVudG9zIGRlIGRhZG9zIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFpcyBzdXBvcnRhZG9zIGluY2x1ZW0gbmV0Q0RGLCBHUklCLCBIREYgZSBDUkYgZGEgRXNyaS4gQ29uanVudG9zIGRlIGRhZG9zIGRlIG1vc2FpY28gbXVsdGlkaW1lbnNpb25haXMgdGFtYsOpbSBzw6NvIHN1cG9ydGFkb3MuPC9kaXY+XCIsXG5cdFx0b3B0aW1hbFBhdGhBc1Jhc3Rlck5hbWU6IFwiQ2FtaW5obyBGYXZvcsOhdmVsIGNvbW8gUmFzdGVyXCIsXG5cdFx0b3B0aW1hbFBhdGhBc1Jhc3RlclNuaXA6IFwiQ2FsY3VsYSBvIGNhbWluaG8gZGUgbWVub3IgY3VzdG8gZGEgb3JpZ2VtIGF0w6kgbyBkZXN0aW5vLlwiLFxuXHRcdG9wdGltYWxQYXRoQXNSYXN0ZXJEZXNjOiBcIkVzdGEgZnVuw6fDo28gZ2xvYmFsIHByb2R1eiB1bSByYXN0ZXIgZGUgc2HDrWRhIHF1ZSByZWdpc3RyYSBvIGNhbWluaG8gZmF2b3LDoXZlbCBvdSBjYW1pbmhvcyBkZSBsb2NhbGl6YcOnw7VlcyBzZWxlY2lvbmFkYXMgcGFyYSBhIGPDqWx1bGEgZGUgb3JpZ2VtIG1haXMgcHLDs3hpbWEgZGVmaW5pZGEgZGVudHJvIGRhIHN1cGVyZsOtY2llIGRlIGN1c3RvIGFjdW11bGF0aXZvLCBlbSB0ZXJtb3MgZGUgZGlzdMOibmNpYSBkZSBjdXN0by48ZGl2Pjxici8+VW1hIG91IG1haXMgZnVuw6fDtWVzIGRlIGN1c3RvIHBvbmRlcmFkbyAoQWN1bXVsYcOnw6NvIGRlIERpc3TDom5jaWEgb3UgQWxvY2HDp8OjbyBkZSBEaXN0w6JuY2lhKSBzw6NvIGdlcmFsbWVudGUgZXhpZ2lkYXMgYW50ZXMgZGUgZXhlY3V0YXIgYSBmdW7Dp8OjbyBDYW1pbmhvIEZhdm9yw6F2ZWwgY29tbyBmdW7Dp8OjbyBSYXN0ZXIgcGFyYSBjcmlhciBhIGFjdW11bGHDp8OjbyBkYSBkaXN0w6JuY2lhIGRlIGVudHJhZGEgZSBvcyByYXN0ZXJzIGRhIGRpcmXDp8OjbyBkZSByZXRvcm5vLiBFc3RhcyBzw6NvIGNhbWFkYXMgcmFzdGVyIGRlIGVudHJhZGEgb2JyaWdhdMOzcmlhcyBwYXJhIGEgZnVuw6fDo28gQ2FtaW5obyBGYXZvcsOhdmVsLiBPcyB2YWxvcmVzIG5vIGNhbWluaG8gZmF2b3LDoXZlbCBkZSBzYcOtZGEgcmVwcmVzZW50YW0gbyBuw7ptZXJvIGRlIGNhbWluaG9zIGVtIHVtIGRldGVybWluYWRvIGxvY2FsLiBFbSBtdWl0b3MgY2Fzb3MsIG9zIGNhbWluaG9zIHNlZ3VlbSBhIG1lc21hIHJvdGEsIGRlaXhhbmRvIHVtYSBmb250ZSBlIGVudMOjbyBkaXZlcmdpbmRvIHBhcmEgaXIgYXTDqSBkaWZlcmVudGVzIGRlc3Rpbm9zLiBQb3IgZXhlbXBsbywgbyB2YWxvciBkZSB1bSBpbmRpY2EgcXVlIGV4aXN0ZSBzb21lbnRlIHVtIGNhbWluaG8gZmF2b3LDoXZlbCBlbSB1bSBkZXRlcm1pbmFkbyBsb2NhbCwgZW5xdWFudG8gdW0gdmFsb3IgZGUgY2luY28gc2lnbmlmaWNhIHF1ZSBuZXN0ZSBsb2NhbCBow6EgY2luY28gY2FtaW5ob3MgZmF2b3LDoXZlaXMgcGFzc2FuZG8gcG9yIGVzdGEgY8OpbHVsYSBuYSDDoXJlYSBkZSBlc3R1ZG8uPGRpdj48YnIvPk9zIGRhZG9zIGRlIGRlc3Rpbm8gZGUgZW50cmFkYSBkZXZlbSBzZXIgdW1hIGNhbWFkYSByYXN0ZXIuIE8gY29uanVudG8gZGUgY8OpbHVsYXMgZGUgZGVzdGlubyBjb25zaXN0ZSBlbSB0b2RhcyBhcyBjw6lsdWxhcyBubyByYXN0ZXIgZGUgZW50cmFkYSBxdWUgdGVtIHZhbG9yZXMgdsOhbGlkb3MuIEFzIGPDqWx1bGFzIGNvbSB2YWxvcmVzIE5vRGF0YSBuw6NvIHPDo28gaW5jbHXDrWRhcyBubyBjb25qdW50by4gTyB2YWxvciBkZSB6ZXJvIMOpIGNvbnNpZGVyYWRvIHVtIGRlc3Rpbm8gbGVnw610aW1vLiBVbSByYXN0ZXIgZGUgZGVzdGlubyBwb2RlIHNlciBjcmlhZG8gdXRpbGl6YW5kbyBhcyBmZXJyYW1lbnRhcyBkZSBleHRyYcOnw6NvLiBTZSB2b2PDqiB0aXZlciBmZWnDp8O1ZXMgZGUgb3JpZ2VtIG91IGRlc3Rpbm8sIHBvZGVyw6EgY29udmVydMOqLWxhcyBlbSByYXN0ZXIgdXRpbGl6YW5kbyBhIGZ1bsOnw6NvIFJhc3Rlcml6YXIgRmVpw6fDtWVzLiBVdGlsaXplIG8gcmFzdGVyIGRlIGFjdW11bGHDp8OjbyBkZSBkaXN0w6JuY2lhIG91IGRpcmXDp8OjbyBkZSB2b2x0YSBjb21vIGVudHJhZGEgZG8gUmFzdGVyIHBhcmEgYSBmdW7Dp8OjbyBkZSByYXN0ZXJpemHDp8Ojby4gSXN0byBnYXJhbnRpcsOhIHF1ZSBhIGZlacOnw6NvIHNlamEgcmFzdGVyaXphZGEgdXRpbGl6YW5kbyBvIG1lc21vIHRhbWFuaG8gZGUgY8OpbHVsYSwgZXh0ZW5zw6NvIGUgcmVmZXLDqm5jaWEgZXNwYWNpYWwgcXVlIG9zIG91dHJvcyByYXN0ZXJzIHF1ZSBlbnRyYW0gbmEgZnVuw6fDo28gQ2FtaW5obyBGYXZvcsOhdmVsIGNvbW8gUmFzdGVyLiBBIGZ1bsOnw6NvIENhbWluaG8gRmF2b3LDoXZlbCBjb21vIFJhc3RlciB0YW1iw6ltIHBvZGUgc2VyIHV0aWxpemFkYSBwYXJhIGRlcml2YXIgbyBjYW1pbmhvIGRlIG1lbm9yIHJlc2lzdMOqbmNpYSBlbSB1bSBtb2RlbG8gZGUgZWxldmHDp8OjbyBkaWdpdGFsIChERU0pLiBOZXN0ZSBjYXNvLCB1dGlsaXplIG8gREVNIHBhcmEgbyByYXN0ZXIgZGUgYWN1bXVsYcOnw6NvIGRhIGRpc3TDom5jaWEgZGUgZW50cmFkYSBlIGEgc2HDrWRhIGRhIGZ1bsOnw6NvIERpcmXDp8OjbyBkbyBGbHV4byBwYXJhIG8gUmFzdGVyIGRhIGRpcmXDp8OjbyBkZSB2b2x0YS48L2Rpdj5cIixcblx0XHR0cmVuZE5hbWU6IFwiUHJldmVyIFV0aWxpemFuZG8gVGVuZMOqbmNpYVwiLFxuXHRcdHRyZW5kU25pcDogXCJDYWxjdWxhIHVtYSBjYW1hZGEgcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgcHJldmlzdGEgdXRpbGl6YW5kbyBvIHJhc3RlciBkZSB0ZW5kw6puY2lhIGRlIHNhw61kYSBkYSBmdW7Dp8OjbyBHZXJhciBUZW5kw6puY2lhIG91IGRhIGZlcnJhbWVudGEgZGUgZ2VvcHJvY2Vzc2FtZW50byBHZXJhciBSYXN0ZXIgZGUgVGVuZMOqbmNpYS5cIixcblx0XHR0cmVuZERlc2M6IFwiQSBmdW7Dp8OjbyBQcmV2ZXIgVXRpbGl6YW5kbyBUZW5kw6puY2lhIGNhbGN1bGEgdW1hIGNhbWFkYSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBwcmV2aXN0YSB1dGlsaXphbmRvIG8gcmFzdGVyIGRlIHRlbmTDqm5jaWEgZGUgc2HDrWRhIGRhIGZ1bsOnw6NvIEdlcmFyIFRlbmTDqm5jaWEgb3UgZGEgZmVycmFtZW50YSBkZSBnZW9wcm9jZXNzYW1lbnRvIEdlcmFyIFJhc3RlciBkZSBUZW5kw6puY2lhLlwiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25OYW1lOiBcIlByb2Nlc3NhciBDb2xlw6fDo28gZGUgUmFzdGVyXCIsXG5cdFx0cmFzdGVyQ29sbGVjdGlvblNuaXA6IFwiUHJvY2Vzc2EgY2FkYSBwYXJ0ZSBkZSB1bSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBvdSBjYWRhIGl0ZW0gZW0gdW0gcmFzdGVyIGRlIG1vc2FpY28uIEVzdGEgZnVuw6fDo28gdGFtYsOpbSBwb2RlIGFncmVnYXIgZGl2aXPDtWVzIG3Dumx0aXBsYXMgZW0gdW1hIGRpdmlzw6NvIMO6bmljYS5cIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uRGVzYzogXCJBIGZ1bsOnw6NvIFByb2Nlc3NhciBDb2xlw6fDo28gZGUgUmFzdGVyIHByb2Nlc3NhIGNhZGEgcGFydGUgZW0gdW0gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgb3UgY2FkYSBpdGVtIGVtIHVtIHJhc3RlciBkZSBtb3NhaWNvLiBFc3RhIGZ1bsOnw6NvIHRhbWLDqW0gcG9kZSBhZ3JlZ2FyIGRpdmlzw7VlcyBtw7psdGlwbGFzIGVtIHVtYSBkaXZpc8OjbyDDum5pY2EuPGRpdj48YnIvPkVzdGEgZnVuw6fDo28gcHJvY2Vzc2EgY2FkYSBwYXJ0ZSBubyByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBvdSByYXN0ZXIgZGUgbW9zYWljbyB1dGlsaXphbmRvIHVtIG1vZGVsbyBkZSBmdW7Dp8OjbyBkbyByYXN0ZXIuIEVzdGEgZnVuw6fDo28gc3Vwb3J0YSBhcyBzZWd1aW50ZXMgb3DDp8O1ZXM6IDEuIEVzcGVjaWZpY2FyIHVtIG1vZGVsbyBkZSBmdW7Dp8OjbyByYXN0ZXIgcGFyYSBGdW7Dp8OjbyBJdGVtLiBQb3IgZXhlbXBsbywgdm9jw6ogdGVtIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGRlIG1vc2FpY28gcXVlIGNvbnTDqW0gMjAgYW5vcyBkZSBpbWFnZW5zIGRvIExhbmRzYXQgZSBkZXNlamEgY2FsY3VsYXIgbyBORFZJIHBhcmEgY2FkYSBjZW5hIG5hIHPDqXJpZSB0ZW1wb3JhbC4gUGFyYSBGdW7Dp8OjbyBJdGVtLCBlc3BlY2lmaXF1ZSB1bSBtb2RlbG8gZGUgZnVuw6fDo28gZG8gcmFzdGVyIHF1ZSBjb250ZW5oYSBhIGZ1bsOnw6NvIGRlIHJhc3RlciBkbyBORFZJLiBFc3BlY2lmaWNhciB1bSBtb2RlbG8gZGUgZnVuw6fDo28gZG8gcmFzdGVyIHBhcmEgYSBGdW7Dp8OjbyBBZ3JlZ2HDp8Ojby4gUG9yIGV4ZW1wbG8sIHZvY8OqIHRlbSB1bSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBxdWUgY29udMOpbSAxMCBhbm9zIGRlIGRhZG9zIGRpw6FyaW9zIGRlIHRlbXBlcmF0dXJhIGUgZGVzZWphIGNhbGN1bGFyIGEgdGVtcGVyYXR1cmEgbcOheGltYSBwYXJhIGNhZGEgYW5vLiBOYSBGdW7Dp8OjbyBBZ3JlZ2HDp8OjbywgZXNwZWNpZmlxdWUgdW0gbW9kZWxvIGRlIGZ1bsOnw6NvIGRvIHJhc3RlciBxdWUgY29udGVuaGEgYSBmdW7Dp8OjbyBFc3RhdMOtc3RpY2FzIGRhIEPDqWx1bGEsIGNvbSBhIG9wZXJhw6fDo28gZGVmaW5pZGEgY29tbyBNw6F4aW1vLiBFbSBEZWZpbmnDp8OjbyBkZSBBZ3JlZ2HDp8OjbywgZGVmaW5hIERpbWVuc8OjbyBwYXJhIFN0ZFRpbWUsIGRlZmluYSBUaXBvIHBhcmEgUGFsYXZyYS1DaGF2ZSBkbyBJbnRlcnZhbG8gZSBkZWZpbmEgbyBJbnRlcnZhbG8gZGEgUGFsYXZyYXMtQ2hhdmUgcGFyYSBBbnVhbC4gTm90ZSBxdWUsIHNlIG8gY29uanVudG8gZGUgZGFkb3MgZGUgbW9zYWljbyBkZSBlbnRyYWRhIG7Do28gZm9yIG11bHRpZGltZW5zaW9uYWwsIGEgZnVuw6fDo28gZGUgYWdyZWdhw6fDo28gbsOjbyByZXNwZWl0YXLDoSBhIGRlZmluacOnw6NvIGRlIGFncmVnYcOnw6NvLiBBIGZ1bsOnw6NvIGRlIGFncmVnYcOnw6NvIGFncmVnYXLDoSB0b2RvcyBvcyBpdGVucyBvdSBjYWRhIGdydXBvIGVtIHVtLCBzZSBlbGVzIGVzdGl2ZXJlbSBkZWZpbmlkb3Mgbm8gbW9kZWxvIGRlIGZ1bsOnw6NvIGRlIGFncmVnYcOnw6NvLiBQYXJhIG1haXMgaW5mb3JtYcOnw7VlcyBzb2JyZSBvIHVzbyBkZSBncnVwb3MgZW0gdW0gY29uanVudG8gZGUgZGFkb3MgZGUgbW9zYWljbywgY29uc3VsdGUgVXRpbGl6YW5kbyBpdGVucyBkbyBjb25qdW50byBkZSBkYWRvcyBkZSBtb3NhaWNvIGVtIG1vZGVsb3MgZGUgZnVuw6fDo28gZG8gcmFzdGVyLiBFc3BlY2lmaWNhciB1bSBtb2RlbG8gZGUgZnVuw6fDo28gZG8gcmFzdGVyIHBhcmEgYSBGdW7Dp8OjbyBQcm9jZXNzYW1lbnRvLiBBIGZ1bsOnw6NvIG91IGNhZGVpYSBkZSBmdW7Dp8O1ZXMgbmVzdGUgbW9kZWxvIMOpIHV0aWxpemFkYSBwYXJhIGV4aWJpciBvIG5vdm8gcmFzdGVyIHByb2Nlc3NhZG8uIFBvciBleGVtcGxvLCBlc3BlY2lmaXF1ZSB1bSBtb2RlbG8gZGUgZnVuw6fDo28gZG8gcmFzdGVyIHF1ZSBjb250ZW5oYSBhIGZ1bsOnw6NvIE1hcGEgZGUgQ29yZXMgcGFyYSBhbHRlcmFyIGNvbW8gYSBjYW1hZGEgcmFzdGVyIHByb2Nlc3NhZGEgw6kgZXhpYmlkYS4gTm90ZSBxdWUsIHNlIGEgZW50cmFkYSBmb3IgdW0gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwsIGEgZnVuw6fDo28gZGUgcHJvY2Vzc2FtZW50byBzZXLDoSBhcGxpY2FkYSDDoCBwYXJ0ZSBkZSBleGliacOnw6NvIGF0dWFsLiBTZSBhIGVudHJhZGEgZm9yIHVtYSBjYW1hZGEgb3UgY29uanVudG8gZGUgZGFkb3MgZGUgbW9zYWljbywgYSBmdW7Dp8OjbyBkZSBwcm9jZXNzYW1lbnRvIHNlcsOhIGFwbGljYWRhIGFvIHJhc3RlciBkZSBtb3NhaWNvIHV0aWxpemFuZG8gbyBtw6l0b2RvIFByaW1laXJvIHBhcmEgcmVzb2x2ZXIgc29icmVwb3Npw6fDtWVzLiAzLiBFc3BlY2lmaWNhciBtb2RlbG9zIHBhcmEgcXVhbHF1ZXIgY29tYmluYcOnw6NvIGRhcyB0csOqcyBmdW7Dp8O1ZXMuIFBvciBleGVtcGxvLCB2b2PDqiB0ZW0gdW0gY29uanVudG8gZGUgZGFkb3MgZGUgbW9zYWljbyBxdWUgY29udMOpbSBpbWFnZW5zIGRvIExhbmRzYXQgZGUgc8OpcmllcyB0ZW1wb3JhaXMgZSBkZXNlamEgZ2VyYXIgdW1hIGltYWdlbSBjb21wb3N0YSBjb20gbyBtw6F4aW1vIGRlIE5EVkkuIFBhcmEgRnVuw6fDo28gSXRlbSwgZXNwZWNpZmlxdWUgdW0gbW9kZWxvIGRlIGZ1bsOnw6NvIGRvIHJhc3RlciBxdWUgY29udGVuaGEgYSBmdW7Dp8OjbyBkZSByYXN0ZXIgZG8gTkRWSS4gUGFyYSBhIEZ1bsOnw6NvIEFncmVnYcOnw6NvLCBlc3BlY2lmaXF1ZSB1bSBtb2RlbG8gZGUgZnVuw6fDo28gZG8gcmFzdGVyIHF1ZSBjb250ZW5oYSBhIGZ1bsOnw6NvIEVzdGF0w61zdGljYXMgZGEgQ8OpbHVsYSwgY29tIGEgb3BlcmHDp8OjbyBkZWZpbmlkYSBwYXJhIE3DoXhpbW8uIFBhcmEgYSBGdW7Dp8OjbyBQcm9jZXNzYW1lbnRvLCBlc3BlY2lmaXF1ZSB1bSBtb2RlbG8gZGUgZnVuw6fDo28gZG8gcmFzdGVyIHF1ZSBjb250ZW5oYSBhIGZ1bsOnw6NvIE1hcGEgZGUgQ29yZXMuIE5vdGUgcXVlIGEgb3JkZW0gZGUgcHJvY2Vzc2FtZW50byBkYSBmdW7Dp8OjbyBzZWd1ZSBhIG9yZGVtIGRvcyBwYXLDom1ldHJvcyBkZSBlbnRyYWRhLiBQb3IgZXhlbXBsbywgYSBGdW7Dp8OjbyBJdGVtIHNlcsOhIHByb2Nlc3NhZGEgcHJpbWVpcm8uPC9kaXY+XCIsXG5cdFx0cmFuZG9tTmFtZTogXCJBbGVhdMOzcmlvXCIsXG5cdFx0cmFuZG9tU25pcDogXCJDcmlhIHVtIHJhc3RlciBjb20gdmFsb3JlcyBkZSBwaXhlbCBhbGVhdMOzcmlvcyBleHRyYcOtZG9zIGRlIHVtYSBkaXN0cmlidWnDp8OjbyBwc2V1ZG8tYWxlYXTDs3JpYS4gRGl2ZXJzYXMgZGlzdHJpYnVpw6fDtWVzIGUgZ2VyYWRvcmVzIGRlIG7Dum1lcm9zIGFsZWF0w7NyaW9zIHPDo28gc3Vwb3J0YWRvcy5cIixcblx0XHRyYW5kb21EZXNjOiBcIkEgZnVuw6fDo28gQWxlYXTDs3JpbyBjcmlhIHVtIHJhc3RlciBjb20gdmFsb3JlcyBkZSBwaXhlbCBhbGVhdMOzcmlvcyBxdWUgcG9kZW0gc2VyIHV0aWxpemFkb3MgZW0gbW9kZWxvcyBkZSBmdW7Dp8OjbyBkbyByYXN0ZXIgb3UgY29uanVudG9zIGRlIGRhZG9zIGRlIG1vc2FpY28uPGRpdj48YnIvPkVtYm9yYSBtdWl0YXMgZnVuw6fDtWVzIGZ1bmNpb25lbSBlbSB1bWEgb3UgbWFpcyBmb250ZXMgZGUgZW50cmFkYSwgYSBmdW7Dp8OjbyBBbGVhdMOzcmlvIG7Do28gZXhpZ2UgdW0gcmFzdGVyIGRlIGVudHJhZGEuIElzdG8gc2lnbmlmaWNhIHF1ZSBlbGUgc2UgY29tcG9ydGEgbWFpcyBjb21vIHVtIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3RlciBkbyBxdWUgY29tbyB1bWEgZnVuw6fDo28sIHBvcnRhbnRvLCBkZXZlLXNlIHRvbWFyIGN1aWRhZG8gZXNwZWNpYWwgYW8gYWRpY2lvbsOhLWxvIG91IHJlbW92w6otbG8gZGEgY2FkZWlhIGRlIGZ1bsOnw7Vlcy48L2Rpdj5cIixcblx0XHRzaHJpbmtOYW1lOiBcIlJlZHV6aXJcIixcblx0XHRzaHJpbmtTbmlwOiBcIkRpbWludWkgYXMgem9uYXMgc2VsZWNpb25hZGFzIHBvciB1bSBuw7ptZXJvIGVzcGVjaWZpY2FkbyBkZSBjw6lsdWxhcyBzdWJzdGl0dWluZG8tYXMgY29tIG8gdmFsb3IgZGEgY8OpbHVsYSBxdWUgw6kgbWFpcyBmcmVxdWVudGUgZW0gc3VhIHZpemluaGFuw6dhLlwiLFxuXHRcdHNocmlua0Rlc2M6IFwiQ29tIGEgZnVuw6fDo28gZ2xvYmFsIFJlZHV6aXIsIHZvY8OqIHBvZGUgZ2VuZXJhbGl6YXIgb3Ugc2ltcGxpZmljYXIgcmFzdGVycywgZGltaW51aW5kbyB6b25hcyBlc3BlY8OtZmljYXMuIFZvY8OqIHRhbWLDqW0gcG9kZSBjb250cm9sYXIgYSBxdWFudGlhIGRlIGdlbmVyYWxpemHDp8OjbyBxdWUgb2NvcnJlcsOhLjxkaXY+PGJyLz5BcyB6b25hcyBxdWUgdm9jw6ogc2VsZWNpb25hIGVuY29saGVyw6NvIG91IHJlZHV6aXLDo28gZGUgdGFtYW5obywgZmF6ZW5kbyBjb20gcXVlIGFzIGPDqWx1bGFzIGRhcyB6b25hcyBjaXJjdW5kYW50ZXMgc2UgZXhwYW5kYW0gcGFyYSBlbGFzLiBDb25jZWl0dWFsbWVudGUsIG9zIFZhbG9yZXMgZGUgWm9uYSBzZWxlY2lvbmFkb3MgcG9kZW0gc2VyIHZpc3VhbGl6YWRvcyBjb21vIHpvbmFzIGRlIHByaW1laXJvIHBsYW5vLCBlbnF1YW50byBvcyBvdXRyb3MgdmFsb3JlcyBwZXJtYW5lY2VtIHpvbmFzIGRlIHBsYW5vIGRlIGZ1bmRvLiBBcyBjw6lsdWxhcyBuYXMgem9uYXMgZGUgcHJpbWVpcm8gcGxhbm8gcG9kZW0gc2VyIHN1YnN0aXR1w61kYXMgcG9yIGPDqWx1bGFzIG5hcyB6b25hcyBkZSBzZWd1bmRvIHBsYW5vLiBJbGhhcyBmaW5hcyBkZW50cm8gZGUgdW1hIHpvbmEsIHF1ZSBwb2RlbSBzZXIgdmlzdWFsaXphZGFzIGNvbW8gbGltaXRlcyBkZSBjb21wYXJ0aWxoYW1lbnRvIGNvbSBhIHpvbmEsIHRhbWLDqW0gcG9kZW0gc2VyIHN1YnN0aXR1w61kYXMuPGRpdj48YnIvPkEgcXVhbnRpYSBkZSBnZW5lcmFsaXphw6fDo28gcG9kZSBzZXIgY29udHJvbGFkYSBjb20gbyBwYXLDom1ldHJvIE7Dum1lcm8gZGUgQ8OpbHVsYXMuIFBvciBwYWRyw6NvLCBlc3RlIHZhbG9yIMOpIDEsIG8gcXVlIHNpZ25pZmljYSBxdWUgYXMgem9uYXMgc2VsZWNpb25hZGFzIHNlcsOjbyByZWR1emlkYXMgcGVsYSBxdWFudGlkYWRlIGNvcnJlc3BvbmRlbnRlIGFvIHRhbWFuaG8gZGUgdW1hIGPDqWx1bGEuIFBhcmEgYXVtZW50YXIgbyBncmF1IGRlIGdlbmVyYWxpemHDp8Ojbywgdm9jw6ogcG9kZSBlc3BlY2lmaWNhciB1bSB2YWxvciBtYWlvciBwYXJhIGVzdGUgcGFyw6JtZXRyby4gQ29uY2VpdHVhbG1lbnRlLCDDqSBjb21vIGV4ZWN1dGFyIGEgZmVycmFtZW50YSB0YW50b3MgcXVhbnRvIG8gbsO6bWVybyBlc3BlY2lmaWNhZG8sIGNvbSBvcyByZXN1bHRhZG9zIGRvcyBhbnRlcmlvcmVzIG5hIGV4ZWN1w6fDo28gc2VuZG8gYSBlbnRyYWRhIG5hIGludGVyYcOnw6NvIHN1YnNlcXVlbnRlLjwvZGl2PlwiLFxuXHRcdHRyZW5kVG9SR0JOYW1lOiBcIlRlbmTDqm5jaWEgcGFyYSBSR0JcIixcblx0XHR0cmVuZFRvUkdCU25pcDogXCJDb252ZXJ0ZSB1bSByYXN0ZXIgZGUgdGVuZMOqbmNpYSBlbSB1bSByYXN0ZXIgZGUgdHLDqnMgYmFuZGFzICh2ZXJtZWxobywgdmVyZGUgZSBhenVsKS5cIixcblx0XHR0cmVuZFRvUkdCRGVzYzogXCJBIGZ1bsOnw6NvIFRlbmTDqm5jaWEgcGFyYSBSR0IgY29udmVydGUgdW0gcmFzdGVyIGRlIHRlbmTDqm5jaWEgcGFyYSB1bSByYXN0ZXIgZGUgdHLDqnMgYmFuZGFzICh2ZXJtZWxobywgdmVyZGUgZSBhenVsKS4gTyByYXN0ZXIgZGUgdGVuZMOqbmNpYSDDqSBnZXJhZG8gYSBwYXJ0aXIgZGEgZnVuw6fDo28gZG8gcmFzdGVyIEdlcmFyIFRlbmTDqm5jaWEgb3UgZGEgZnVuw6fDo28gZG8gcmFzdGVyIEFuw6FsaXNlIGRlIENDREMuPGRpdj48YnIvPkVzdGEgZnVuw6fDo28gw6kgw7p0aWwgcGFyYSB2aXN1YWxpemFyIGRhZG9zIGRlIGNvZWZpY2llbnRlIGRvIG1vZGVsbyBhIHBhcnRpciBkYSBmdW7Dp8OjbyBHZXJhciBUZW5kw6puY2lhIG91IGRhIGZ1bsOnw6NvIEFuw6FsaXNlIGRlIENDREMuIEFtYmFzIGFzIGZ1bsOnw7VlcyBlc3RpbWFtIHRlbmTDqm5jaWFzIG5hIGFsdGVyYcOnw6NvIGRvcyB2YWxvcmVzIGRlIHBpeGVsLCBtYXMgb3MgcmVzdWx0YWRvcyBkYXMgZnVuw6fDtWVzIHPDo28gZGlmw61jZWlzIGRlIGludGVycHJldGFyIGRpcmV0YW1lbnRlLjxkaXY+PGJyLz5Db21vIG11aXRhcyBmdW7Dp8O1ZXMgZG8gcmFzdGVyLCB0YWx2ZXogc2VqYSBuZWNlc3PDoXJpbyB1dGlsaXphciBvIEFqdXN0ZSBkZSBJbnRlcnZhbG8gRGluw6JtaWNvIChEUkEpIHBhcmEgZXhpYmlyIG1lbGhvciBvcyByZXN1bHRhZG9zIGRlc3RhIGZ1bsOnw6NvLjwvZGl2PlwiLFxuXHRcdGxhbmRUcmVuZHJOYW1lOiBcIkFuw6FsaXNlIExhbmRUcmVuZHJcIixcblx0XHRsYW5kVHJlbmRyU25pcDogXCJBdmFsaWEgYWx0ZXJhw6fDtWVzIGVtIHZhbG9yZXMgZGUgcGl4ZWwgY29tIG8gcGFzc2FyIGRvIHRlbXBvIHVzYW5kbyBhIGRldGVjw6fDo28gZGUgdGVuZMOqbmNpYXMgYmFzZWFkYSBlbSBMYW5kc2F0IG5vIG1ldMOzZG8gZGUgcGVydHVyYmHDp8OjbyBlIHJlY3VwZXJhw6fDo28gKExhbmRUcmVuZHIpIGUgZ2VyYSB1bSByYXN0ZXIgZGUgYW7DoWxpc2UgZGUgYWx0ZXJhw6fDo28gY29udGVuZG8gb3MgcmVzdWx0YWRvcyBkbyBtb2RlbG8uXCIsXG5cdFx0bGFuZFRyZW5kckRlc2M6IFwiRXN0YSBmdW7Dp8OjbyBkbyByYXN0ZXIgcG9kZSBzZXIgdXNhZGEgc29tZW50ZSBjb21vIGVudHJhZGEgcGFyYSBhIGZ1bsOnw6NvIGRvIHJhc3RlciBEZXRlY3RhciBBbHRlcmHDp8OjbyBVdGlsaXphbmRvIEFuw6FsaXNlIGRlIEFsdGVyYcOnw6NvLiBQYXJhIGdlcmFyIHVtYSBzYcOtZGEgZGUgcmFzdGVyLCBjb25lY3RlIGEgZnVuw6fDo28gQW7DoWxpc2UgZGUgTGFuZFRyZW5kciDDoCBmdW7Dp8OjbyBEZXRlY3RhciBBbHRlcmHDp8OjbyBVdGlsaXphbmRvIEFuw6FsaXNlIGRlIEFsdGVyYcOnw6NvIGVtIHVtIG1vZGVsbyBkZSBmdW7Dp8OjbyBkbyByYXN0ZXIgZSB1c2UgbyBtb2RlbG8gY29tbyBlbnRyYWRhIG5hIGZlcnJhbWVudGEgZGUgZ2VvcHJvY2Vzc2FtZW50byBHZXJhciBSYXN0ZXIgZGUgRnVuw6fDo28gZG8gUmFzdGVyLiBPIHJlc3VsdGFkbyDDqSB1bSByYXN0ZXIgY29udGVuZG8gaW5mb3JtYcOnw7VlcyBzb2JyZSBvIG1vbWVudG8gbm8gcXVhbCBvcyB2YWxvcmVzIGRlIHBpeGVsIG11ZGFyYW0uPGRpdj48YnI+TyBvYmpldGl2byBkZXN0YSBmdW7Dp8OjbyBkbyByYXN0ZXIgw6kgZXh0cmFpciBhbHRlcmHDp8O1ZXMgZW0gdW1hIGZlacOnw6NvIG9ic2VydmFkYSwgZGUgbW9kbyBxdWUgYSBpbWFnZW0gbXVsdGlkaW1lbnNpb25hbCBkZSBlbnRyYWRhIGlkZWFsIGRldmUgY2FwdHVyYXIgdW1hIG9ic2VydmHDp8OjbyBjb25zaXN0ZW50ZSBhbyBsb25nbyBkbyB0ZW1wbyBlIG7Do28gZGV2ZSBpbmNsdWlyIGludGVyZmVyw6puY2lhcyBhdG1vc2bDqXJpY2FzIG91IGRlIHNlbnNvcmVzLCBudXZlbnMgb3Ugc29tYnJhIGRlIG51dmVtLiBBIG1lbGhvciBwcsOhdGljYSDDqSB1c2FyIGRhZG9zIHF1ZSBmb3JhbSBub3JtYWxpemFkb3MgZSBwb2RlbSBzZXIgbWFzY2FyYWRvcyB1c2FuZG8gdW1hIGJhbmRhIGRlIFFBLCBwb3IgZXhlbXBsbywgcHJvZHV0b3MgTGFuZHNhdCBDb2xsZWN0aW9uIDEgU3VyZmFjZSBSZWZsZWN0YW5jZSBjb20gdW1hIG3DoXNjYXJhIGRlIG51dmVtLjxkaXY+PGJyPkEgZnVuw6fDo28gZXhlY3V0YSBhIGFuw6FsaXNlIGVtIHVtYSBpbWFnZW0gcG9yIGFubywgZSBvIG7Dum1lcm8gZGUgZGl2aXPDtWVzIGFudWFpcyBkZXZlIHNlciBpZ3VhbCBvdSBtYWlvciBxdWUgbyB2YWxvciBlc3BlY2lmaWNhZG8gbm8gcGFyw6JtZXRybyA8c3Ryb25nPk7Dum1lcm8gTcOtbmltbyBkZSBPYnNlcnZhw6fDtWVzPC9zdHJvbmc+IC4gw4kgcmVjb21lbmRhZG8gcXVlIHZvY8OqIHRlbmhhIHBlbG8gbWVub3Mgc2VpcyBhbm9zIGRlIGRhZG9zLjxkaXY+PGJyPlNlIHZvY8OqIHRpdmVyIGRhZG9zIG1lbnNhaXMsIHNlbWFuYWlzIG91IGRpw6FyaW9zLCDDqSByZWNvbWVuZGFkbyBxdWUgdm9jw6ogc2VsZWNpb25lIHbDoXJpYXMgaW1hZ2VucyBkZSBjYWRhIGFubyAoZGUgcHJlZmVyw6puY2lhIGRhIG1lc21hIGVzdGHDp8OjbyksIHJlbW92YSBudXZlbnMgZSBzb21icmFzIGRlIG51dmVucyBlIGNvbWJpbmUgYXMgaW1hZ2VucyBwYXJhIGdlcmFyIHVtYSDDum5pY2EgaW1hZ2VtIHF1ZSBjYXB0dXJlIGJlbSBhIG9ic2VydmHDp8Ojby4gU2UgZGFkb3MgbWVuc2Fpcywgc2VtYW5haXMgb3UgZGnDoXJpb3MgZm9yZW0gZm9ybmVjaWRvcyBjb21vIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGRlIGVudHJhZGEsIGEgZnVuw6fDo28gaWRlbnRpZmljYXLDoSB1bWEgZGl2aXPDo28gcGFyYSBhbsOhbGlzZSBjb20gYmFzZSBuYSBkYXRhIG1haXMgcHLDs3hpbWEgZGFxdWVsYSBmb3JuZWNpZGEgbm8gcGFyw6JtZXRybyA8c3Ryb25nPkFqdXN0YXIgRGF0YTwvc3Ryb25nPiAuPGRpdj48YnI+VW1hIGZlacOnw6NvIGVtIHVtYSBwYWlzYWdlbSBnZXJhbG1lbnRlIGxldmEgdGVtcG8gcGFyYSBzZSByZWN1cGVyYXIgZGUgdW1hIG11ZGFuw6dhIG7Do28gcGVybWFuZW50ZSwgY29tbyB1bSBpbmPDqm5kaW8gZmxvcmVzdGFsIG91IHVtYSBpbmZlc3Rhw6fDo28gZGUgaW5zZXRvcy4gUGFyYSBjb250cm9sYXIgYSB0YXhhIGRlIHJlY3VwZXJhw6fDo28gcmVjb25oZWNpZGEgcGVsbyBtb2RlbG8sIGRlZmluYSBvIHBhcsOibWV0cm8gTGltaXRlIGRlIFJlY3VwZXJhw6fDo28uIFVtIHNlZ21lbnRvIGRpc3RpbnRvIG7Do28gcG9kZSB0ZXIgdW1hIHRheGEgZGUgcmVjdXBlcmHDp8OjbyBtYWlzIHLDoXBpZGEgZG8gcXVlIDEvbGltaXRlIGRlIHJlY3VwZXJhw6fDo28uPGRpdj48YnI+QSByZWN1cGVyYcOnw6NvIGRlIHVtYSBtdWRhbsOnYSBuYSBwYWlzYWdlbSBwb2RlIG9jb3JyZXIgbmEgZGlyZcOnw6NvIHBvc2l0aXZhIG91IG5lZ2F0aXZhLiBQb3IgZXhlbXBsbywgcXVhbmRvIHVtYSBwYWlzYWdlbSBzb2ZyZSBwZXJkYSBkZSBmbG9yZXN0YSwgdW1hIHPDqXJpZSB0ZW1wb3JhbCBkZSB2YWxvcmVzIGRvIMOtbmRpY2UgZGUgdmVnZXRhw6fDo28gbW9zdHJhIHVtYSBxdWVkYSBub3MgdmFsb3JlcyBkZSDDrW5kaWNlIGUgYSByZWN1cGVyYcOnw6NvIG1vc3RyYSB1bSBhdW1lbnRvIGdyYWR1YWwgbm9zIHZhbG9yZXMgZG8gw61uZGljZSBkZSB2ZWdldGHDp8OjbyBvdSB1bWEgdGVuZMOqbmNpYSBkZSByZWN1cGVyYcOnw6NvIHBvc2l0aXZhLiBFc3BlY2lmaXF1ZSBhIGRpcmXDp8OjbyBkYSB0ZW5kw6puY2lhIGRlIHJlY3VwZXJhw6fDo28gY29tIG8gcGFyw6JtZXRybzxzdHJvbmc+QSBSZWN1cGVyYcOnw6NvIFRlbSBUZW5kw6puY2lhIGRlIEF1bWVudGFyPC9zdHJvbmc+IC5cIixcblx0XHRhZ2dyZWdhdGVNdWx0aWRpbWVuc2lvbmFsTmFtZTogXCJBZ3JlZ2FyIE11bHRpZGltZW5zaW9uYWxcIixcblx0XHRhZ2dyZWdhdGVNdWx0aWRpbWVuc2lvbmFsU25pcDogXCJDb21iaW5hIGRhZG9zIGRlIHZhcmnDoXZlbCBkbyByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBleGlzdGVudGVzIGFvIGxvbmdvIGRlIHVtYSBkaW1lbnPDo28uXCIsXG5cdFx0YWdncmVnYXRlTXVsdGlkaW1lbnNpb25hbERlc2M6IFwiQSBmdW7Dp8OjbyBBZ3JlZ2FyIE11bHRpZGltZW5zaW9uYWwgY3JpYSB1bWEgY2FtYWRhIGRlIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGNvbWJpbmFuZG8gZGFkb3MgZGEgdmFyacOhdmVsIGRlIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGV4aXN0ZW50ZXMgYW8gbG9uZ28gZGUgdW1hIGRpbWVuc8Ojby48ZGl2Pjxicj5Vc2UgbyA8c3Ryb25nPnBhcsOibWV0cm8gRGVmaW5pw6fDo28gZGEgRGltZW5zw6NvPC9zdHJvbmc+IHBhcmEgZmlsdHJhciBwcmltZWlybyBvcyBkYWRvcyBkZSBlbnRyYWRhIHF1ZSBkZXNlamEgYWdyZWdhci4gUG9yIGV4ZW1wbG8sIHNlIHZvY8OqIHRpdmVyIDMwIGFub3MgZGUgZGFkb3MgbWVuc2FpcywgbWFzIGRlc2VqYSBjcmlhciBhcGVuYXMgdW1hIGNhbWFkYSBhZ3JlZ2FkYSBwYXJhIG9zIHByaW1laXJvcyAxNSBhbm9zLCBwb2RlcsOhIHVzYXIgbyBwYXLDom1ldHJvwqA8c3Ryb25nPkRlZmluacOnw6NvIGRhIERpbWVuc8Ojbzwvc3Ryb25nPiBwYXJhIGVzcGVjaWZpY2FyIG9zIGFub3MgcGFyYSBpbmNsdWlyIG5hIGFuw6FsaXNlLjxkaXY+PGJyPjx1bD48bGk+RXh0cmFpYSBvcyBkYWRvcyBkZSBzYWxpbmlkYWRlIGRvIG3DqnMgZGUgSmFuZWlybyBkdXJhbnRlIG8gcGVyw61vZG8gZGUgMTAgYW5vcy4gRXNjb2xoYcKgPHN0cm9uZz5Qb3IgVmFsb3Jlczwvc3Ryb25nPiwgZGVmaW5hwqA8c3Ryb25nPkRpbWVuc8Ojbzwvc3Ryb25nPiBwYXJhwqA8c3Ryb25nPlN0ZFRpbWU8L3N0cm9uZz4sIGUgZGVmaW5hwqA8c3Ryb25nPlZhbG9yZXM8L3N0cm9uZz5wYXJhwqA8c3Ryb25nPkphbmVpcm88L3N0cm9uZz4uPC9saT48bGk+RGl2aWRhIG9zIGRhZG9zIGRlIHNhbGluaWRhZGUgZW0gdW1hIGZhaXhhIGRlIHByb2Z1bmRpZGFkZSBkZSAwIGEgMTUwIG1ldHJvcy4gRXNjb2xoYcKgPHN0cm9uZz5Qb3IgSW50ZXJ2YWxvczwvc3Ryb25nPiwgZGVmaW5hwqA8c3Ryb25nPkRpbWVuc8Ojbzwvc3Ryb25nPiBwYXJhwqA8c3Ryb25nPlN0ZFo8L3N0cm9uZz4sIGUgZGVmaW5hwqA8c3Ryb25nPlZhbG9yIE3DrW5pbW88L3N0cm9uZz4gcGFyYcKgPHN0cm9uZz4tMTUwPC9zdHJvbmc+IGXCoDxzdHJvbmc+VmFsb3IgTcOheGltbzwvc3Ryb25nPiBwYXJhwqA8c3Ryb25nPjA8L3N0cm9uZz4uPC9saT48bGk+RXh0cmFpYSBkYWRvcyBkZSBzYWxpbmlkYWRlIHBhcmEgb3MgcHJpbWVpcm9zIDEwIGRpYXMgZGUgY2FkYSBKYW5laXJvIGR1cmFudGUgdW0gcGVyw61vZG8gZGUgMTAgYW5vcy4gRXNjb2xoYcKgPHN0cm9uZz5Qb3IgSW50ZXJhw6fDo288L3N0cm9uZz4sIGRlZmluYcKgPHN0cm9uZz5EaW1lbnPDo288L3N0cm9uZz4gcGFyYcKgPHN0cm9uZz5TdGRUaW1lPC9zdHJvbmc+LCBkZWZpbmHCoDxzdHJvbmc+Q29tZcOnbyBkYSBwcmltZWlybyBpdGVyYcOnw6NvPC9zdHJvbmc+IGXCoDxzdHJvbmc+RmluYWwgZGEgcHJpbWVpcm8gaXRlcmHDp8Ojbzwvc3Ryb25nPiBwYXJhIG8gaW7DrWNpbyBlIGZpbSBjb3JyZXNwb25kZW50ZXMgZG8gcGVyw61vZG8gZGUgaXRlcmHDp8OjbywgZGVmaW5hwqA8c3Ryb25nPkV0YXBhPC9zdHJvbmc+IHBhcmHCoDxzdHJvbmc+MTwvc3Ryb25nPiwgZSBkZWZpbmHCoDxzdHJvbmc+VW5pZGFkZTwvc3Ryb25nPiBwYXJhwqA8c3Ryb25nPkFub3M8L3N0cm9uZz4uPC9saT48L3VsPjxkaXY+PGJyPlVzZSBvIHBhcsOibWV0cm/CoDxzdHJvbmc+RGVmaW5pw6fDo28gZGUgQWdyZWdhw6fDo288L3N0cm9uZz4gcGFyYSBlc2NvbGhlciBhIGRpbWVuc8OjbyBhIHNlciBhdmFsaWFkYSBlIG8gaW50ZXJ2YWxvIGRlIGFncmVnYcOnw6NvIHVzYW5kbyB1bWEgcGFsYXZyYS1jaGF2ZSwgdW0gdmFsb3Igb3UgdW0gaW50ZXJ2YWxvIGRlIHZhbG9yZXMuIFBvciBleGVtcGxvLCBzZSB2b2PDqiB0aXZlciAzMCBhbm9zIGRlIGRhZG9zIGRlIHRlbXBlcmF0dXJhIGRhIHN1cGVyZsOtY2llIGRvIG1hciwgY29sZXRhZG9zIGRpYXJpYW1lbnRlIGUgYSBjYWRhIDUgbWV0cm9zIGRlIHByb2Z1bmRpZGFkZSBhdMOpIDEwMCBtZXRyb3MsIHBvZGVyw6EgdXNhciBhcyBkaWZlcmVudGVzIG9ww6fDtWVzIGRlIGludGVydmFsbyBwYXJhIG9zIHNlZ3VpbnRlcyBjZW7DoXJpb3M6IDxkaXY+PGJyPjx1bD48bGk+QWdyZWd1ZSBkYWRvcyBkacOhcmlvcyBkZSB0ZW1wZXJhdHVyYSBlbSBkYWRvcyBtZW5zYWlzLCBvbmRlIG8gcmVzdWx0YWRvIMOpIHVtIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGNvbSAxMiBkaXZpc8O1ZXMgZGUgdGVtcG8sIGUgY2FkYSBkaXZpc8OjbyDDqSBvIGFncmVnYWRvIGRlIGNhZGEgbcOqcyBhbyBsb25nbyBkb3MgYW5vcy4gRXNjb2xoYcKgPHN0cm9uZz5QYWxhdnJhLUNoYXZlIGRlIEludGVydmFsbzwvc3Ryb25nPiBlIGRlZmluYSBhIHBhbGF2cmEtY2hhdmUgcGFyYcKgPHN0cm9uZz5NZW5zYWwgUmVjb3JyZW50ZTwvc3Ryb25nPi48L2xpPjxsaT5BZ3JlZ3VlIGRhZG9zIGRlIHRlbXBlcmF0dXJhIGRpw6FyaW9zIGVtIGRhZG9zIG1lbnNhaXMsIG9uZGUgbyByZXN1bHRhZG8gw6kgdW0gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgY29tIDM2MCBkaXZpc8O1ZXMsIG91IDEyIGRpdmlzw7VlcyBkZSB0ZW1wbyBwb3IgYW5vICgzMCBhbm9zIHggMTIgbWVzZXMgPSAzNjAgZGl2aXPDtWVzKS4gRXNjb2xoYSA8c3Ryb25nPlBhbGF2cmEtQ2hhdmUgZGUgSW50ZXJ2YWxvPC9zdHJvbmc+IGUgZGVmaW5hIGEgcGFsYXZyYS1jaGF2ZSBwYXJhIDxzdHJvbmc+TWVuc2FsPC9zdHJvbmc+LjwvbGk+PGxpPkFncmVndWUgZGFkb3MgZGUgdGVtcGVyYXR1cmEgbWVuc2FpcyBlbSBpbnRlcnZhbG9zIGRlIDQgbWVzZXMuIEVzY29saGEgPHN0cm9uZz5WYWxvciBkZSBJbnRlcnZhbG88L3N0cm9uZz4gZGVmaW5hIDxzdHJvbmc+SW50ZXJ2YWxvIGRlIFZhbG9yPC9zdHJvbmc+IHBhcmEgNCBlIGRlZmluYSA8c3Ryb25nPlVuaWRhZGU8L3N0cm9uZz4gcGFyYSA8c3Ryb25nPk1lc2VzPC9zdHJvbmc+LjwvbGk+PGxpPkFncmVndWUgZGFkb3MgZGUgdGVtcGVyYXR1cmEgZGUgMCBhIDI1IG1ldHJvcywgZW50w6NvIGRlIDI1IGEgNTAgbWV0cm9zLCBlbnTDo28gZGUgNTAgYSAxMDAgbWV0cm9zLiBFc2NvbGhhwqA8c3Ryb25nPkZhaXhhcyBkZSBJbnRlcnZhbG9zPC9zdHJvbmc+IGUgZXNwZWNpZmlxdWUgYXMgcHJvZnVuZGlkYWRlcyBtw61uaW1hIGUgbcOheGltYSBjb21vwqA8c3Ryb25nPjAgMjU7IDI1IDUwOyA1MCAxMDA8L3N0cm9uZz4uPC9saT48L3VsPlwiLFxuXHRcdG1lcmdlUmFzdGVyc05hbWU6IFwiSnVudGFyIFJhc3RlcnNcIixcblx0XHRtZXJnZVJhc3RlcnNTbmlwOiBcIkNvbWJpbmEgbcO6bHRpcGxvcyBjb25qdW50byBkZSBkYWRvcyByYXN0ZXIgZXNwYWNpYWxtZW50ZSBvdSBlbSB0b2RhcyBhcyB2YXJpw6F2ZWlzIGUgZGltZW5zw7Vlcy5cIixcblx0XHRtZXJnZVJhc3RlcnNEZXNjOiBcIkVzdGEgZnVuw6fDo28gY3JpYSB1bSByYXN0ZXIgbWVzY2xhZG8gZGUgdW1hIGxpc3RhIGRlIHJhc3Rlci4gUG9yIGV4ZW1wbG8sIHNlIHZvY8OqIHRpdmVyIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGRlIG1vc2FpY28gcXVlIGNvbnRlbmhhIDMwIGFub3MgZGUgZGFkb3MgbWVuc2FpcyBkZSBwcmVjaXBpdGHDp8OjbyBlIG91dHJvIGNvbmp1bnRvIGRlIGRhZG9zIGNvbSAxMCBhbm9zIGRlIGRhZG9zIG1lbnNhaXMgZGUgdGVtcGVyYXR1cmEsIHBvZGVyw6EgY29tYmluw6EtbG9zIGVtIHVtIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGNvbSBhbWJhcyBhcyB2YXJpw6F2ZWlzLiA8ZGl2Pjxicj5TZSBvcyByYXN0ZXJzIG11bHRpZGltZW5zaW9uYWlzIGRlIGVudHJhZGEgdGl2ZXJlbSB2YXJpw6F2ZWlzIGRpZmVyZW50ZXMsIG8gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgZGUgc2HDrWRhIGNvbnRlcsOhIHRvZGFzIGFzIHZhcmnDoXZlaXMuIDxkaXY+PGJyPlNlIG9zIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFpcyBkZSBlbnRyYWRhIHRpdmVyZW0gZGltZW5zw7VlcyBvdSB2YWxvcmVzIGRlIGRpbWVuc8OjbyBkaWZlcmVudGVzLCBvIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGRlIHNhw61kYSBpbmNsdWlyw6EgdG9kYXMgYXMgZGltZW5zw7VlcyBlIHZhbG9yZXMgZGUgZGltZW5zw6NvLiA8ZGl2Pjxicj5TZSBvcyByYXN0ZXJzIG11bHRpZGltZW5zaW9uYWlzIGRlIGVudHJhZGEgdGl2ZXJlbSBhcyBtZXNtYXMgZGltZW5zw7VlcyBlIHZhcmnDoXZlaXMsIG1hcyBkaWZlcmVudGVzIGV4dGVuc8O1ZXMgZXNwYWNpYWlzLCBvIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGRlIHNhw61kYSBpbmNsdWlyw6EgYXMgdmFyacOhdmVpcyBlIGRpbWVuc8O1ZXMgbmFzIGV4dGVuc8O1ZXMgZXNwYWNpYWlzIG1lc2NsYWRhcy48ZGl2Pjxicj5Fc3RhIGZ1bsOnw6NvIHRhbWLDqW0gcG9kZSBzZXIgdXNhZGEgcXVhbmRvIHZvY8OqIHRpdmVyIHbDoXJpb3MgcmFzdGVycyBxdWUgZGVzZWphIHF1ZSBzZWphbSB0cmF0YWRvcyBjb21vIHVtIMO6bmljbyBpdGVtLCBjb21vIGNhbGN1bGFyIGFzIG1lc21hcyBlc3RhdMOtc3RpY2FzIHBhcmEgdG9kb3MsIG91IGFvIGJhbGFuY2VhciBjb3JlcywgZGUgZm9ybWEgcXVlIG7Do28gc2VqYSBuZWNlc3PDoXJpbyBiYWxhbmNlYXIgY2FkYSBpbWFnZW0gc2VwYXJhZGFtZW50ZS4gSXN0byDDqSDDunRpbCBhbyB0cmFiYWxoYXIgY29tIGltYWdlbnMgYXJtYXplbmFkYXMgY29tbyBtb3NhaWNvcyBzZXBhcmFkb3MgZGV2aWRvIGEgcmVzdHJpw6fDtWVzIGRlIHRhbWFuaG8gZG8gYXJxdWl2bzsgZGVzdGEgZm9ybWEsIG9zIG1vc2FpY29zIHNlcsOjbyB0cmF0YWRvcyBjb21vIHBhcnRlIGRhIG1lc21hIGltYWdlbS5cIixcblx0XHRib3VuZGFyeUNsZWFuTmFtZTogXCJMaW1wYXIgTGltaXRlc1wiLFxuXHRcdGJvdW5kYXJ5Q2xlYW5TbmlwOiBcIlN1YXZpemEgbyBsaW1pdGUgZW50cmUgYXMgem9uYXMuXCIsXG5cdFx0Ym91bmRhcnlDbGVhbkRlc2M6IFwiPHA+QSBmdW7Dp8OjbyBnZW5lcmFsaXphIG91IHNpbXBsaWZpY2Egb3MgcmFzdGVycyBzdWF2aXphbmRvIG9zIGxpbWl0ZXMgZW50cmUgYXMgem9uYXMuIEEgZnVuw6fDo28gZm9ybmVjZSBvcMOnw7VlcyBwYXJhIGNvbnRyb2xhciBjb21vIGFzIGPDqWx1bGFzIGRhcyB6b25hcyBuYSBlbnRyYWRhIGluZmx1ZW5jaWFtIGEgc3Vhdml6YcOnw6NvIGUgYSBxdWFudGlkYWRlIGRlIHN1YXZpemHDp8OjbyBxdWUgc2Vyw6EgYXBsaWNhZGEuIENhZGEgY8OpbHVsYSBkZSBlbnRyYWRhIMOpIGF2YWxpYWRhIHVzYW5kbyBzZXVzIG9pdG8gdml6aW5ob3MgaW1lZGlhdG9zLjwvcD48cD5PIHByb2Nlc3NvIGRlIHN1YXZpemHDp8OjbyBwcmltZWlybyBjbGFzc2lmaWNhIGFzIGPDqWx1bGFzIHZpemluaGFzIHBvciB1bWEgcHJpb3JpZGFkZSBlbSBwYXJ0aWN1bGFyLiBBIHByaW9yaWRhZGUgZGV0ZXJtaW5hIHF1YWwgem9uYSBkYXMgY8OpbHVsYXMgdml6aW5oYXMgcG9kZSBzdWJzdGl0dWlyIG8gdmFsb3IgZGEgY8OpbHVsYSBkZSBwcm9jZXNzYW1lbnRvIG5hIHNhw61kYS48L3A+PHA+QSBwcmlvcmlkYWRlIHBvZGUgc2VyIGJhc2VhZGEgbm8gdmFsb3IgZGFzIHpvbmFzIG91IG5vIHRhbWFuaG8gZGFzIHpvbmFzLiBPIHBhcsOibWV0cm8gPHN0cm9uZz5UaXBvIGRlIGNsYXNzaWZpY2HDp8Ojbzwvc3Ryb25nPiBkZXRlcm1pbmEgbyB0aXBvIGRlIGNsYXNzaWZpY2HDp8OjbyBhIHNlciB1c2Fkby4gPC9wPjxwPkEgY29uZmlndXJhw6fDo28gcGFkcsOjbyA8c3Ryb25nPk7Do28gY2xhc3NpZmljYXI8L3N0cm9uZz4gYXZhbGlhIGEgcHJpb3JpZGFkZSBjb20gYmFzZSBubyB2YWxvciBkYXMgem9uYXMuIEPDqWx1bGFzIGRlIHpvbmFzIGNvbSB2YWxvcmVzIG1haW9yZXMgdGVyw6NvIHVtYSBwcmlvcmlkYWRlIG1haXMgYWx0YSBwYXJhIGV4cGFuZGlyIGVtIHpvbmFzIGNvbSB2YWxvcmVzIG1lbm9yZXMuPC9wPjxwPk8gdGFtYW5obyBvdSDDoXJlYSB0b3RhbCwgZGFzIHpvbmFzIHBvZGUgc2VyIHVzYWRvIHBhcmEgY2xhc3NpZmljYXIgYSBwcmlvcmlkYWRlLiBDb20gYSBjb25maWd1cmHDp8OjbyA8c3Ryb25nPkRlY3Jlc2NlbnRlPC9zdHJvbmc+ICwgYXMgem9uYXMgc8OjbyBjbGFzc2lmaWNhZGFzIHBvciB0YW1hbmhvIGVtIG9yZGVtIGRlY3Jlc2NlbnRlLiBBcyB6b25hcyBjb20gdG90YWwgZGUgw6FyZWFzIG1haW9yZXMgdGVyw6NvIGEgcHJpb3JpZGFkZSBkZSBleHBhbnPDo28gcGFyYSB6b25hcyBjb20gw6FyZWFzIG1lbm9yZXMuIENvbSBhIGNvbmZpZ3VyYcOnw6NvIDxzdHJvbmc+QXNjZW5kZW50ZTwvc3Ryb25nPiAsIG8gb3Bvc3RvIMOpIHZlcmRhZGVpcm86IHpvbmFzIGNvbSBvIHRvdGFsIGRlIMOhcmVhcyBtZW5vcmVzIHRlcsOjbyBhIHByaW9yaWRhZGUgZGUgZXhwYW5zw6NvIGVtIHpvbmFzIGNvbSBvIHRvdGFsIGRlIMOhcmVhcyBtYWlvcmVzLjwvcD48cD5BIHF1YW50aWRhZGUgZGUgc3Vhdml6YcOnw6NvIMOpIGNvbnRyb2xhZGEgcGVsbyBwYXLDom1ldHJvIDxzdHJvbmc+RXhlY3V0YXIgZXhwYW5zw6NvIGUgcmVkdcOnw6NvIGR1YXMgdmV6ZXM8L3N0cm9uZz4gLCBxdWUgZGV0ZXJtaW5hIG8gbsO6bWVybyBkZSB2ZXplcyBxdWUgbyBwcm9jZXNzbyBkZSBleHBhbnPDo28gZSByZWR1w6fDo28gc2Vyw6EgcmVhbGl6YWRvLjwvcD48cD5Db20gYSBjb25maWd1cmHDp8OjbyBkZXNtYXJjYWRhLCBvIHByb2Nlc3NvIGRlIGV4cGFuZGlyIGUgcmVkdXppciDDqSBleGVjdXRhZG8gdW1hIHZlei4gQ29tIGEgY29uZmlndXJhw6fDo28gbWFyY2FkYSwgbyBwcm9jZXNzbyBkZSBleHBhbmRpciBlIHJlZHV6aXIgw6kgZXhlY3V0YWRvIGR1YXMgdmV6ZXMsIHJlc3VsdGFuZG8gZW0gdW0gZ3JhdSBhZGljaW9uYWwgZGUgc3Vhdml6YcOnw6NvIGRvcyBsaW1pdGVzIGRhIHpvbmEuPC9wPjxwPlNlIG9zIHZhbG9yZXMgZGUgdG9kYXMgYXMgb2l0byBjw6lsdWxhcyB2aXppbmhhcyBmb3JlbSBpZ3VhaXMgYW9zIGRhIGPDqWx1bGEgZGUgcHJvY2Vzc2FtZW50bywgYSBjw6lsdWxhIGRlIHNhw61kYSBtYW50ZXLDoSBvIHZhbG9yIGRhIGPDqWx1bGEgZGUgZW50cmFkYS48L3A+XCIsXG5cdFx0cHJlZGljdFVzaW5nUmVncmVzc2lvbk5hbWU6IFwiUHJldmVyIHV0aWxpemFuZG8gUmVncmVzc8Ojb1wiLFxuXHRcdHByZWRpY3RVc2luZ1JlZ3Jlc3Npb25TbmlwOiBcIkNhbGN1bGEgdW0gcmFzdGVyIHByZXZpc3RvIGNvbSBiYXNlIGVtIGVudHJhZGFzIGRlIGRhZG9zIHJhc3RlciBlIHVtIG1vZGVsbyBkZSByZWdyZXNzw6NvLiBPIG1vZGVsbyBkZSByZWdyZXNzw6NvIMOpIGEgc2HDrWRhIGRhIGZlcnJhbWVudGEgZGUgZ2VvcHJvY2Vzc2FtZW50byBkbyByYXN0ZXIgPHN0cm9uZz5UcmVpbmFyIE1vZGVsbyBkZSBSZWdyZXNzw6NvIGRlIMOBcnZvcmVzIEFsZWF0w7NyaWFzPC9zdHJvbmc+LlwiLFxuXHRcdHByZWRpY3RVc2luZ1JlZ3Jlc3Npb25EZXNjOiBcIjxwPk8gbW9kZWxvIGRlIHJlZ3Jlc3PDo28gw6kgZGVmaW5pZG8gZW0gdW0gYXJxdWl2byBkYSBkZWZpbmnDp8OjbyBkZSByZWdyZXNzw6NvIGRhIEVzcmkgKC5lY2QpLiBFbGUgY29udMOpbSB0b2RhcyBhcyBpbmZvcm1hw6fDtWVzIHBhcmEgdW0gY29uanVudG8gZGUgZGFkb3MgZXNwZWPDrWZpY28gb3UgdW0gY29uanVudG8gZGUgY29uanVudG9zIGRlIGRhZG9zLCBlIG8gbW9kZWxvIGRlIHJlZ3Jlc3PDo28sIGUgw6kgZ2VyYWRvIHBlbGEgZmVycmFtZW50YSBkZSBnZW9wcm9jZXNzYW1lbnRvIGRvIHJhc3RlciA8c3Ryb25nPlRyZWluYXIgTW9kZWxvIGRlIFJlZ3Jlc3PDo28gZGUgw4Fydm9yZXMgQWxlYXTDs3JpYXM8L3N0cm9uZz4uPC9wPjxwPkEgZW50cmFkYSBwb2RlIHNlciB1bWEgw7puaWNhIGJhbmRhLCBtw7psdGlwbGFzIGJhbmRhcywgb3UgdW0gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwsIG91IHVtYSBsaXN0YSBkZXN0ZXMgdGlwb3MuIE9zIHRpcG9zIGRlIHJhc3RlciBkZSBlbnRyYWRhIGRldmVtIHNlciBvIG1lc21vIHRpcG8gZGUgcmFzdGVyIHRyZWluYWRvIHBlbG8gbW9kZWxvIGRlIHJlZ3Jlc3PDo28uPC9wPjx1bD48bGk+UXVhbmRvIGEgZW50cmFkYSDDqSB1bSByYXN0ZXIgZGUgbcO6bHRpcGxzIGJhbmRhcywgY2FkYSBiYW5kYSDDqSB0cmF0YWRhIGNvbW8gdW1hIHZhcmnDoXZlbCBwcmVkaXRvcmEuIEFzIGJhbmRhcyBkZXZlbSBlc3RhciBuYSBtZXNtYSBvcmRlbSBxdWUgYSBlbnRyYWRhIGRlIG3Dumx0aXBsYXMgYmFuZGFzIHBhcmEgYSBmZXJyYW1lbnRhIGRlIHRyZWluYW1lbnRvIGRvIG1vZGVsbyBkZSByZWdyZXNzw6NvLiA8L2xpPjxsaT5RdWFuZG8gYSBlbnRyYWRhIMOpIHVtIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsLCBjYWRhIHZhcmnDoXZlbCDDqSB0cmF0YWRhIGNvbW8gdW1hIHZhcmnDoXZlbCBwcmVkaXRvcmEgZSBhIHZhcmnDoXZlbCBkZXZlIHNlciB1bWEgYmFuZGEgw7puaWNhIGUgdGVyIHVtYSBkaW1lbnPDo28gZGUgdGVtcG8uIE9zIG5vbWVzIGUgYSBvcmRlbSBkYSB2YXJpw6F2ZWwgZGV2ZW0gc2VyIG9zIG1lc21vcyBkYSBlbnRyYWRhIHF1YW5kbyBvIG1vZGVsbyBkZSByZWdyZXNzw6NvIGZvaSB0cmVpbmFkby4gQSBzYcOtZGEgw6kgdW0gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwuPC9saT48bGk+QSBlbnRyYWRhIHBvZGUgc2VyIHVtYSBsaXN0YSBkZSBpdGVucy4gTyBuw7ptZXJvIGUgYSBvcmRlbSBkb3MgaXRlbnMgZGV2ZW0gY29ycmVzcG9uZGVyIMOgIGVudHJhZGEgcXVhbmRvIG8gbW9kZWxvIGRlIHJlZ3Jlc3PDo28gZm9pIHRyZWluYWRvLjwvbGk+PC91bD5cIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ1N0YXRpc3RpY3NOYW1lOiBcIkVzdGF0w61zdGljYSBkZSBNb3ZpbWVudG8gRGltZW5zaW9uYWxcIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ1N0YXRpc3RpY3NTbmlwOiBcIkNhbGN1bGEgZXN0YXTDrXN0aWNhcyBzb2JyZSB1bWEgamFuZWxhIG3Ds3ZlbCBlbSBkYWRvcyBtdWx0aWRpbWVuc2lvbmFpcyBhbyBsb25nbyBkZSB1bWEgZGltZW5zw6NvIGVzcGVjaWZpY2FkYS5cIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ1N0YXRpc3RpY3NEZXNjOiBcIjxwPkEgZnVuw6fDo28gRXN0YXTDrXN0aWNhIGRlIE1vdmltZW50byBEaW1lbnNpb25hbCBjYWxjdWxhIHbDoXJpYXMgZXN0YXTDrXN0aWNhcyBkZW50cm8gZGUgdW1hIGphbmVsYSBwcmVkZWZpbmlkYSBwYXJhIHRvZG9zIG9zIHZhbG9yZXMgZGUgZGltZW5zw6NvIGFvIGxvbmdvIGRlIHVtYSBkaW1lbnPDo28uIEVzdGEgZnVuw6fDo28gcmVjZWJlIHVtYSBjYW1hZGEgcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgY29tbyBlbnRyYWRhIGUgY3JpYSB1bWEgY2FtYWRhIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGNvbW8gc2HDrWRhIHF1ZSB0ZW0gbyBtZXNtbyB0YW1hbmhvIGRpbWVuc2lvbmFsIGRhIGNhbWFkYSBkZSBlbnRyYWRhLjwvcD48cD5Wb2PDqiBwb2RlIGVzcGVjaWZpY2FyIHVtYSBkaW1lbnPDo28gcGFyYSBhIHF1YWwgb3MgdmFsb3JlcyBkZSBkaW1lbnPDo28gc8OjbyBjb25zaWRlcmFkb3MgZHVyYW50ZSBvIGPDoWxjdWxvLiBQb3IgcGFkcsOjbywgZWxlIGNhbGN1bGEgYW8gbG9uZ28gZGEgcHJpbWVpcmEgZGltZW5zw6NvIG7Do28gZXNwYWNpYWwuIFZvY8OqIHRhbWLDqW0gcG9kZSBlc3BlY2lmaWNhciB1bSB0YW1hbmhvIGRlIGphbmVsYSBlc3BlY2lmaWNhbmRvIG9zIHBhcsOibWV0cm9zIEphbmVsYSBkZSBUcsOhcyBlIEphbmVsYSBkYSBGcmVudGUuPC9wPjxwPlF1YW5kbyBvIFRpcG8gZGUgRXN0YXTDrXN0aWNhIMOpIGRlZmluaWRvIGNvbW8gUGVyY2VudGlsLCBvcyBwYXLDom1ldHJvcyBWYWxvciBkZSBQZXJjZW50aWwgZSBUaXBvIGRlIEludGVycG9sYcOnw6NvIGRlIFBlcmNlbnR1YWwgZmljYW0gZGlzcG9uw612ZWlzLiBWb2PDqiBwb2RlIHVzYXIgZXNzZXMgcGFyw6JtZXRyb3MgcGFyYSBlc3BlY2lmaWNhciBvIHBlcmNlbnRpbCBhIHNlciBjYWxjdWxhZG8gZSBlc2NvbGhlciBvIHRpcG8gZGUgaW50ZXJwb2xhw6fDo28gYSBzZXIgdXNhZG8sIHJlc3BlY3RpdmFtZW50ZS4gUXVhbmRvIG8gVGlwbyBkZSBFc3RhdMOtc3RpY2Egw6kgZGVmaW5pZG8gY29tbyBNw6lkaWEgQ2lyY3VsYXIsIG8gcGFyw6JtZXRybyBWYWxvciBkZSBRdWVicmEgQ2lyY3VsYXIgZmljYSBkaXNwb27DrXZlbC4gTyB2YWxvciBkZSBxdWVicmEgY2lyY3VsYXIgw6kgdXNhZG8gcGFyYSBjb252ZXJ0ZXIgdW0gdmFsb3IgbGluZWFyIG5vIGludGVydmFsbyBkZSB1bWEgZGV0ZXJtaW5hZGEgbcOpZGlhIGNpcmN1bGFyLjwvcD5cIixcblx0XHR0ZXJyYWluRmxhdHRlbkZ1bmN0aW9uTmFtZTogXCJOaXZlbGFyIFRlcnJlbm9cIixcblx0XHR0ZXJyYWluRmxhdHRlbkZ1bmN0aW9uU25pcDogXCJDb3JyaWdlIG9zIGRhZG9zIGRvIHJhZGFyIGRlIGFiZXJ0dXJhIHNpbnTDqXRpY2EgKFNBUikgZGUgZW50cmFkYSBwYXJhIGRpc3RvcsOnw7VlcyByYWRpb23DqXRyaWNhcyBkZXZpZG8gw6AgdG9wb2dyYWZpYS5cIixcblx0XHR0ZXJyYWluRmxhdHRlbkZ1bmN0aW9uRGVzYzogXCI8cD5BIGZ1bsOnw6NvIE5pdmVsYXIgVGVycmVubyByYXN0ZXIgY29ycmlnZSBvcyBkYWRvcyBkZSBlbnRyYWRhIGRvIHJhZGFyIGRlIGFiZXJ0dXJhIHNpbnTDqXRpY2EgKFNBUikgcGFyYSBkaXN0b3LDp8O1ZXMgcmFkaW9tw6l0cmljYXMgZGV2aWRvIMOgIHRvcG9ncmFmaWEuPC9wPjxwPk9zIGRhZG9zIGRvIHJhZGFyIGRlIGVudHJhZGEgZGV2ZW0gcHJpbWVpcm8gc2VyIGNhbGlicmFkb3MgcGFyYSB6ZXJvIGJldGEuIFVzZSBhIGZlcnJhbWVudGEgQXBsaWNhciBjYWxpYnJhw6fDo28gcmFkaW9tw6l0cmljYSBwYXJhIGNhbGlicmFyIG9zIGRhZG9zIGRvIHJhZGFyIHBhcmEgemVybyBiZXRhLjwvcD48cD5JZiB0aGUgaW5wdXQgREVNIGRvZXMgbm90IHNwYW4gdGhlIGVudGlyZSBTQVIgZGF0YXNldCwgdGhlIHRvb2wgd2lsbCBvdXRwdXQgTm9EYXRhIHZhbHVlcyBmb3IgdGhlIHBpeGVscyBvdXRzaWRlIG9mIHRoZSBERU0gZXh0ZW50IGZvciBnYW1tYSBub3VnaHQsIHNpZ21hIG5vdWdodCwgc2NhdHRlcmluZyBhcmVhLCBhbmQgZ2VvbWV0cmljIGRpc3RvcnRpb24gb3V0cHV0cy4gUGFyYSBhIHNhw61kYSBkYSBtw6FzY2FyYSBkZSBkaXN0b3LDp8OjbyBnZW9tw6l0cmljYSwgYSBmZXJyYW1lbnRhIHByb2R1emlyw6EgdmFsb3JlcyBpbmRldGVybWluYWRvcyBwYXJhIHBpeGVscyBmb3JhIGRhIGV4dGVuc8OjbyBkbyBERU0uPC9wPjxwPkEgZW50cmFkYSBERU0gZGV2ZSBlc3RhciBubyBzaXN0ZW1hIGRlIGNvb3JkZW5hZGFzIGdlb2dyw6FmaWNhcyBXR1MgMTk4NCAoRVBTRzo0MzI2KS48L3A+XCIsXG5cdFx0Y3JlYXRlQ29sb3JDb21wb3NpdGVGdW5jdGlvbk5hbWU6IFwiQ3JpYXIgQ29tcG9zacOnw6NvIGRlIENvcmVzXCIsXG5cdFx0Y3JlYXRlQ29sb3JDb21wb3NpdGVGdW5jdGlvblNuaXA6IFwiQ3JpYSB1bSByYXN0ZXIgZGUgdHLDqnMgYmFuZGFzIGEgcGFydGlyIGRlIHVtIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3RlciBtdWx0aWJhbmRhIG5vIHF1YWwgY2FkYSBiYW5kYSBwb2RlIHVzYXIgdW0gY8OhbGN1bG8gYWxnw6licmljbyBjb20gYmFzZSBuYSDDoWxnZWJyYSBkZSBiYW5kYS5cIixcblx0XHRjcmVhdGVDb2xvckNvbXBvc2l0ZUZ1bmN0aW9uRGVzYzogXCI8cD5BIGZ1bsOnw6NvIGRlIHJhc3RlciBDcmlhciBDb21wb3Npw6fDo28gZGUgQ29yZXMgY3JpYSB1bSByYXN0ZXIgZGUgdHLDqnMgYmFuZGFzIGEgcGFydGlyIGRlIHVtIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3RlciBtdWx0aWJhbmRhIG5vIHF1YWwgY2FkYSBiYW5kYSBwb2RlIHVzYXIgdW0gY8OhbGN1bG8gYWxnw6licmljbyBiYXNlYWRvIGVtIMOhbGdlYnJhIGRlIGJhbmRhLjwvcD48cD5BbyBkZWZpbmlyIHVtIGFsZ29yaXRtbyBhcml0bcOpdGljbyBkZSBiYW5kYSwgdm9jw6ogcG9kZSBpbnNlcmlyIHVtYSBmw7NybXVsYSBhbGfDqWJyaWNhIGRlIGxpbmhhIMO6bmljYSBwYXJhIGNhZGEgZXhwcmVzc8OjbyBwYXJhIGNyaWFyIHVtYSBzYcOtZGEgbXVsdGliYW5kYS4gT3Mgb3BlcmFkb3JlcyBzdXBvcnRhZG9zIHPDo28gdW7DoXJpb3MsIG1haXMgKCspLCBtZW5vcyAoLSksIHZlemVzICgqKSBlIGRpdmlzw6NvICgvKS48L3A+PHA+QW8gdXNhciB1bSBJRCBkZSBiYW5kYSBlbSB1bWEgZXhwcmVzc8OjbywgaWRlbnRpZmlxdWUgYSBiYW5kYSBwcmVmaXhhbmRvIEIgb3UgYiBhbyBuw7ptZXJvIGRhIGJhbmRhLjwvcD48cD5VbWEgY29tYmluYcOnw6NvIGRlIGJhbmRhIGNvbXVtIHVzYWRhIHBhcmEgcmFkYXIgZGUgYWJlcnR1cmEgc2ludMOpdGljYSAoU0FSKSBlbSB1bmlkYWRlcyBsaW5lYXJlcyDDqSBWViBwYXJhIHZlcm1lbGhvLCBWSCBwYXJhIHZlcmRlIGUgVlYvVkggcGFyYSBhenVsLiBTZSBvcyBkYWRvcyBkZSBlbnRyYWRhIGVzdGl2ZXJlbSBlbSBkZWNpYsOpaXMsIGEgY29tYmluYcOnw6NvIGRlIGJhbmRhcyBkZXZlIHNlciBWViBwYXJhIHZlcm1lbGhvLCBWSCBwYXJhIHZlcmRlIGUgVlYtVkggcGFyYSBhenVsLjwvcD5cIixcblx0XHRzdXJmYWNlUGFyYW1ldGVyc05hbWU6IFwiUGFyw6JtZXRyb3MgZGEgU3VwZXJmw61jaWVcIixcblx0XHRzdXJmYWNlUGFyYW1ldGVyc1NuaXA6IFwiRGV0ZXJtaW5hIHBhcsOibWV0cm9zIGRlIHVtIHJhc3RlciBkZSBzdXBlcmbDrWNpZSBjb21vIGFzcGVjdG8sIGluY2xpbmHDp8OjbyBlIGRpdmVyc29zIHRpcG9zIGRlIGN1cnZhdHVyYXMgdXNhbmRvIG3DqXRvZG9zIGdlb2TDqXNpY29zLlwiLFxuXHRcdHN1cmZhY2VQYXJhbWV0ZXJzRGVzYzogXCI8cD5BIGZ1bsOnw6NvIFBhcsOibWV0cm9zIGRlIFN1cGVyZsOtY2llIGRldGVybWluYSBwYXLDom1ldHJvcyBkZSB1bSByYXN0ZXIgZGUgc3VwZXJmw61jaWUsIGNvbW8gYXNwZWN0bywgZGVjbGl2aWRhZGUgZSB2w6FyaW9zIHRpcG9zIGRlIGN1cnZhdHVyYXMgdXNhbmRvIG3DqXRvZG9zIGdlb2TDqXNpY29zLjwvcD48cD5Fc3RhIGZ1bsOnw6NvIHBvZGUgc2VyIHVzYWRhIHBhcmEgYXMgc2VndWludGVzIGFwbGljYcOnw7Vlczo8L3A+PHVsPjxsaT5DYWxjdWxhciBhc3BlY3RvIGUgZGVjbGl2aWRhZGUgdXNhbmRvIG3DqXRvZG9zIGdlb2TDqXNpY29zLjwvbGk+PGxpPkNhbGN1bGFyIGRpZmVyZW50ZXMgdGlwb3MgZGUgY3VydmF0dXJhcyBkZSB1bSByYXN0ZXIgZGUgc3VwZXJmw61jaWUgZGUgZW50cmFkYSwgcG9yIGV4ZW1wbG8sIDxzdHJvbmc+Q3VydmF0dXJhIHRhbmdlbmNpYWwgKGN1cnZhIGRlIG7DrXZlbCBub3JtYWwpPC9zdHJvbmc+IHF1ZSBjYXJhY3Rlcml6YSBhIGNvbnZlcmfDqm5jaWEgdG9wb2dyw6FmaWNhIGUgYSBkaXZlcmfDqm5jaWEgZGUgZmx1eG8gYW8gbG9uZ28gZGEgc3VwZXJmw61jaWUuPC9saT48L3VsPlwiLFxuXHRcdGxlYXN0Q29zdENvcnJpZG9yTmFtZTogXCJDb3JyZWRvciBkZSBNZW5vciBDdXN0b1wiLFxuXHRcdGxlYXN0Q29zdENvcnJpZG9yU25pcDogXCJDYWxjdWxhIGEgc29tYSBkZSBkb2lzIHJhc3RlcnMgZGUgZGlzdMOibmNpYSBkZSBjdXN0byBhY3VtdWxhdGl2byBjb20gYSBvcMOnw6NvIGRlIGFwbGljYXIgdW0gbGltaXRlIGJhc2VhZG8gZW0gcG9yY2VudGFnZW0gb3UgY3VzdG8gYWN1bXVsYXRpdm8uXCIsXG5cdFx0bGVhc3RDb3N0Q29ycmlkb3JEZXNjOiBcIjxwPk9zIHJhc3RlcnMgZGUgZW50cmFkYSBkZXZlbSBzZXIgZGEgYWN1bXVsYcOnw6NvIGRlIGRpc3TDom5jaWEgZSByYXN0ZXJzIGRlIGRpcmXDp8OjbyBpbnZlcnNhIHJlc3VsdGFudGVzIGRhIGZ1bsOnw6NvIDxzdHJvbmc+QWN1bXVsYcOnw6NvIGRlIERpc3TDom5jaWE8L3N0cm9uZz4gb3UgPHN0cm9uZz5EaXN0w6JuY2lhLUFsb2Nhw6fDo288L3N0cm9uZz4uIEVzdGVzIGRldmVtIHNlciBiYXNlYWRvcyBuYSBkaXN0w6JuY2lhIGRlIGN1c3RvIGUgYXMgbWVzbWFzIGNvbmZpZ3VyYcOnw7VlcyBkZSBwYXLDom1ldHJvcyBkZXZlbSBzZXIgdXNhZGFzIGFvIGNyaWFyIGFzIGNhbWFkYXMgcGFyYSBjYWRhIGZvbnRlLiBOZW5odW0gcGFyw6JtZXRybyBxdWUgZGVwZW5kYSBkYSBkaXJlY2lvbmFsaWRhZGUgKGZhdG9yIGhvcml6b250YWwsIGZhdG9yIHZlcnRpY2FsIGUgZGlyZcOnw6NvIGRhIHZpYWdlbSkgZGV2ZSBzZXIgdXNhZG8gbmEgY3JpYcOnw6NvIGRlc3NlcyByYXN0ZXJzLjwvcD48cD5PcyB2YWxvcmVzIG5vIHJhc3RlciBkbyBjb3JyZWRvciBkZSBzYcOtZGEgc8OjbyBhIHNvbWEgZG8gY3VzdG8gYWN1bXVsYXRpdm8gcGFyYSBjaGVnYXIgYSB1bSBkZXRlcm1pbmFkbyBsb2NhbCBjb20gYXMgbWVzbWFzIHVuaWRhZGVzIHF1ZSBvcyByYXN0ZXJzIGRhIGRpc3TDom5jaWEgZGUgY3VzdG8gYWN1bXVsYXRpdm8gZGUgZW50cmFkYS48L3A+PHA+U2UgdW0gdmFsb3IgZGUgPHN0cm9uZz5MaW1pdGU8L3N0cm9uZz4gZXNwZWNpZmljYWRvIGZvciBtYWlvciBxdWUgbyBjdXN0byBhY3VtdWxhdGl2byBtw6F4aW1vIHF1YW5kbyBvcyBkb2lzIHJhc3RlcnMgZGEgYWN1bXVsYcOnw6NvIGRlIGRpc3TDom5jaWEgZm9yZW0gc29tYWRvcywgbyByYXN0ZXIgZG8gY29ycmVkb3IgZGUgc2HDrWRhIGNvYnJpcsOhIGEgbWVzbWEgw6FyZWEgcXVlIG9zIHJhc3RlcnMgYWN1bXVsYXRpdm9zIGRlIGVudHJhZGEuPC9wPjxwPlNlIHVtIHZhbG9yIGRlIGxpbWl0ZSBlc3BlY2lmaWNhZG8gZm9yIG1lbm9yIHF1ZSBvIHZhbG9yIG3DrW5pbW8gbm8gcmFzdGVyIGRvIGNvcnJlZG9yLCB1bWEgbWVuc2FnZW0gZGUgYXZpc28gc2Vyw6EgcmV0b3JuYWRhIGUgbyByYXN0ZXIgZGUgc2HDrWRhIGZpY2Fyw6EgdmF6aW8uPC9wPjxwPk8gcmFzdGVyIGRvIGNvcnJlZG9yIGRlIHNhw61kYSBwb2RlIGNvbnRlciBjw6lsdWxhcyBjb20gY3VzdG9zIGFjdW11bGF0aXZvcyBsaWdlaXJhbWVudGUgbWFpb3JlcyBxdWUgbyB2YWxvciBsaW1pdGUuIElzc28gdmVtIGRvcyByYXN0ZXJzIGRlIGRpcmXDp8OjbyBkZSB2b2x0YSB1c2FuZG8gY8OpbHVsYXMgY29tIGN1c3RvcyBsaWdlaXJhbWVudGUgbWFpcyBhbHRvcyBkbyBxdWUgbyBsaW1pdGUgcGFyYSBjb25lY3RhciBjw6lsdWxhcyBkZXNjb25lY3RhZGFzIGFvIGNvcnJlZG9yLjwvcD5cIixcblx0XHRnZW9tZXRyaWNNZWRpYW5OYW1lOiBcIk1lZGlhbmEgR2VvbcOpdHJpY2FcIixcblx0XHRnZW9tZXRyaWNNZWRpYW5TbmlwOiBcIkEgZnVuw6fDo28gTWVkaWFuYSBHZW9tw6l0cmljYSBjYWxjdWxhIGEgbWVkaWFuYSBnZW9tw6l0cmljYSBlbnRyZSBwaXhlbHMgZW0gdW1hIHPDqXJpZSB0ZW1wb3JhbCBkZSBpbWFnZW5zIGRlIG3Dumx0aXBsYXMgYmFuZGFzLlwiLFxuXHRcdGdlb21ldHJpY01lZGlhbkRlc2M6IFwiPHA+RXNzYSBmdW7Dp8OjbyByZWR1eiBydcOtZG9zIGUgZGlzY3JlcMOibmNpYXMgZW0gaW1hZ2VucyBkZSBzw6lyaWVzIHRlbXBvcmFpcyBjYWxjdWxhbmRvIHVtIHBpeGVsIGdlb23DqXRyaWNvIG1lZGlhbm8gcGFyYSBjYWRhIG1hdHJpeiBkZSBwaXhlbHMgbmEgcGlsaGEgZGUgaW1hZ2Vucy4gTyBhbGdvcml0bW8gbWFudMOpbSBvcyByZWxhY2lvbmFtZW50b3MgZXNwZWN0cmFpcyBlbnRyZSBhcyBiYW5kYXMgbm9zIGVzcGVjdHJvcyBkZSBwaXhlbHMsIHBhcmEgcXVlIGEgc2HDrWRhIHBvc3NhIHNlciB1c2FkYSBlbSBhbsOhbGlzZXMsIGNvbW8gw61uZGljZXMgZGUgdmVnZXRhw6fDo28uPC9wPjxwPk51dmVucyBlIHNvbWJyYXMgZGV2ZW0gc2VyIG1hc2NhcmFkYXMgdXNhbmRvIGEgYmFuZGEgZGUgY29udHJvbGUgZGUgcXVhbGlkYWRlIGRvIGNvbmp1bnRvIGRlIGRhZG9zIGFudGVzIGRlIGFwbGljYXIgZXN0YSBmdW7Dp8Ojby48L3A+PHA+U2UgYSBpbWFnZW0gZGUgZW50cmFkYSBmb3IgZGUgcG9udG8gZmx1dHVhbnRlLCBjb21vIHJlZmxldMOibmNpYSBkZSBzdXBlcmbDrWNpZSBjb20gdmFsb3JlcyBlbnRyZSAwIGUgMSwgdW0gdmFsb3Igw6lwc2lsb24gZGUgMC4wMDEgZGV2ZXLDoSBwcm9kdXppciByZXN1bHRhZG9zIGRlIHF1YWxpZGFkZS48L3A+XCJcblx0fSxcblx0cmZ4QXJnczoge1xuXHRcdHJhc3Rlck5hbWU6IFwiUmFzdGVyXCIsXG5cdFx0Y29sb3JTY2hlbWVUeXBlTmFtZTogXCJUaXBvIGRvIEVzcXVlbWEgZGUgQ29yZXNcIixcblx0XHRjb2xvcm1hcE5hbWU6IFwiTWFwYSBkZSBDb3Jlc1wiLFxuXHRcdGNvbG9ybWFwTmFtZU5hbWU6IFwiTm9tZSBkbyBNYXBhIGRlIENvcmVzXCIsXG5cdFx0Y29sb3JSYW1wTmFtZTogXCJSYW1wYSBkZSBDb3Jlc1wiLFxuXHRcdGNvbnRyYXN0T2Zmc2V0TmFtZTogXCJEZXNsb2NhbWVudG8gZGUgQ29udHJhc3RlXCIsXG5cdFx0YnJpZ2h0bmVzc09mZnNldE5hbWU6IFwiRGVzbG9jYW1lbnRvIGRlIEJyaWxob1wiLFxuXHRcdG1ldGhvZE5hbWU6IFwiTcOpdG9kb1wiLFxuXHRcdGJhbmROYW1lc05hbWU6IFwiTm9tZXMgZGUgQmFuZGFzXCIsXG5cdFx0YmFuZFdhdmVsZW5ndGhzTmFtZTogXCJDb21wcmltZW50b3MgZGUgT25kYSBkYSBCYW5kYVwiLFxuXHRcdGJhbmRJZHNOYW1lOiBcIklEcyBkZSBCYW5kYVwiLFxuXHRcdG1pc3NpbmdCYW5kQWN0aW9uTmFtZTogXCJBw6fDo28gZGEgQmFuZGEgQXVzZW50ZVwiLFxuXHRcdGNvbnZlcnNpb25QYXJhbWV0ZXJzTmFtZTogXCJQYXLDom1ldHJvcyBkZSBDb252ZXJzw6NvXCIsXG5cdFx0aGlsbHNoYWRlVHlwZU5hbWU6IFwiVGlwbyBkZSBSZWxldm8gU29tYnJlYWRvXCIsXG5cdFx0YXppbXV0aE5hbWU6IFwiQXppbXV0ZVwiLFxuXHRcdGFsdGl0dWRlTmFtZTogXCJBbHRpdHVkZVwiLFxuXHRcdHNsb3BlVHlwZU5hbWU6IFwiRXNjYWxhXCIsXG5cdFx0ekZhY3Rvck5hbWU6IFwiRmF0b3IgWlwiLFxuXHRcdFBTUG93ZXJOYW1lOiBcIlBvdMOqbmNpYSBkZSBUYW1hbmhvIGRvIFBpeGVsXCIsXG5cdFx0UFNaRmFjdG9yTmFtZTogXCJGYXRvciBkZSBUYW1hbmhvIGRvIFBpeGVsXCIsXG5cdFx0cmVtb3ZlRWRnZUVmZmVjdE5hbWU6IFwiRGVzYXRpdmFyIGludGVycG9sYcOnw6NvIGRlIHBpeGVsIGRvIHNlZ21lbnRvIHBhZHLDo29cIixcblx0XHRmcm9tVW5pdE5hbWU6IFwiRGEgVW5pZGFkZVwiLFxuXHRcdHRvVW5pdE5hbWU6IFwiUGFyYSBVbmlkYWRlXCIsXG5cdFx0cmFzdGVyVHlwZU5hbWU6IFwiVGlwb1wiLFxuXHRcdG1pbk5hbWU6IFwiTcOtbmltbyBkZSBTYcOtZGFcIixcblx0XHRtYXhOYW1lOiBcIk3DoXhpbW8gZGUgU2HDrWRhXCIsXG5cdFx0bWluUGVyY2VudE5hbWU6IFwiUG9yY2VudGFnZW0gTcOtbmltYSBkZSBSZWNvcnRlXCIsXG5cdFx0bWF4UGVyY2VudE5hbWU6IFwiUG9yY2VudGFnZW0gTcOheGltYSBkZSBSZWNvcnRlXCIsXG5cdFx0bnVtYmVyT2ZTdGFuZGFyZERldmlhdGlvbk5hbWU6IFwiTsO6bWVybyBkZSBkZXN2aW9zIHBhZHLDo29cIixcblx0XHRzaWdtb2lkU3RyZW5ndGhMZXZlbE5hbWU6IFwiTsOtdmVsIGRlIENvbnRyYXN0ZSBkbyBTaWdtw7NpZGVcIixcblx0XHRlc3RpbWF0ZVN0YXRzSGlzdG9ncmFtTmFtZTogXCJBdmFsaWFyIEVzdGF0w61zdGljYVwiLFxuXHRcdERSQU5hbWU6IFwiQWp1c3RlIGRlIEludGVydmFsbyBEaW7Dom1pY29cIixcblx0XHRzdGF0aXN0aWNzTmFtZTogXCJFc3RhdMOtc3RpY2FcIixcblx0XHRoaXN0b2dyYW1zTmFtZTogXCJIaXN0b2dyYW1hc1wiLFxuXHRcdHN0YXRpc3RpY3NIaXN0b2dyYW1OYW1lOiBcIkRlZmluaXIgRXN0YXTDrXN0aWNhcyBlIEhpc3RvZ3JhbWFcIixcblx0XHRjb21wdXRlR2FtbWFOYW1lOiBcIkdhbWEgQXV0b23DoXRpY29cIixcblx0XHR1c2VHYW1tYU5hbWU6IFwiVXRpbGl6YXIgR2FtYVwiLFxuXHRcdGdhbW1hTmFtZTogXCJHYW1hXCIsXG5cdFx0aW5wdXROYW1lc05hbWU6IFwiTm9tZXNcIixcblx0XHRleHByZXNzaW9uTmFtZTogXCJFeHByZXNzw6NvXCIsXG5cdFx0Y2VsbHNpemVUeXBlTmFtZTogXCJUaXBvIGRlIFRhbWFuaG8gZGEgQ8OpbHVsYVwiLFxuXHRcdGV4dGVudFR5cGVOYW1lOiBcIlRpcG8gZGUgRXh0ZW5zw6NvXCIsXG5cdFx0Y2xhc3NpZmllckRlZmluaXRpb25GaWxlTmFtZTogXCJBcnF1aXZvIGRlIERlZmluacOnw6NvIGRlIEVudHJhZGFcIixcblx0XHRyYXN0ZXIxTmFtZTogXCJSYXN0ZXIxXCIsXG5cdFx0cmFzdGVyMk5hbWU6IFwiUmFzdGVyMlwiLFxuXHRcdHJhc3RlcjNOYW1lOiBcIlJhc3RlcjNcIixcblx0XHR0cnVlUmFzdGVyTmFtZTogXCJSYXN0ZXIgVmVyZGFkZWlyb1wiLFxuXHRcdGZhbHNlUmFzdGVyTmFtZTogXCJSYXN0ZXIgRmFsc29cIixcblx0XHRub0RhdGFJbnRlcnByZXRhdGlvbk5hbWU6IFwiSW50ZXJwcmV0YcOnw6NvIGRlIE5vRGF0YVwiLFxuXHRcdG5vRGF0YVZhbHVlc05hbWU6IFwiVmFsb3JlcyBkZSBOb0RhdGFcIixcblx0XHRpbmNsdWRlZFJhbmdlc05hbWU6IFwiSW50ZXJ2YWxvcyBJbmNsdcOtZG9zXCIsXG5cdFx0Y3VydmF0dXJlVHlwZU5hbWU6IFwiVGlwbyBkZSBDdXJ2YXR1cmFcIixcblx0XHRyYXN0ZXJzTmFtZTogXCJSYXN0ZXJzXCIsXG5cdFx0YXR0cmlidXRlVGFibGVOYW1lOiBcIlRhYmVsYVwiLFxuXHRcdGF0dHJpYnV0ZVRhYmxlVHlwZU5hbWU6IFwiVGlwbyBkZSBUYWJlbGFcIixcblx0XHRyb3dzTmFtZTogXCJOw7ptZXJvIGRlIExpbmhhc1wiLFxuXHRcdGNvbHVtbnNOYW1lOiBcIk7Dum1lcm8gZGUgQ29sdW5hc1wiLFxuXHRcdGtlcm5lbE5hbWU6IFwiS2VybmVsXCIsXG5cdFx0bWlycm9yRWRnZXNOYW1lOiBcIlJlZmxldGlyIEJvcmRhc1wiLFxuXHRcdGluZmx1ZW5jZXNOYW1lOiBcIkluZmx1w6puY2lhc1wiLFxuXHRcdGZpZWxkc05hbWU6IFwiQ2FtcG9zXCIsXG5cdFx0cmVtYXBzTmFtZTogXCJUYWJlbGEgZGUgUmVtYXBlYW1lbnRvXCIsXG5cdFx0ZXZhbEZyb21OYW1lOiBcIkRhIEVzY2FsYSBkZSBBdmFsaWHDp8Ojb1wiLFxuXHRcdGV2YWxUb05hbWU6IFwiUGFyYSBFc2NhbGEgZGUgQXZhbGlhw6fDo29cIixcblx0XHR3ZWlnaHRzTmFtZTogXCJQZXNvc1wiLFxuXHRcdERFTU5hbWU6IFwiREVNXCIsXG5cdFx0c2hvcnRSYW5nZUlEV1JhZGl1c05hbWU6IFwiUmFpbyBJRFcgZGUgSW50ZXJ2YWxvIEN1cnRvXCIsXG5cdFx0bWF4Vm9pZFdpZHRoTmFtZTogXCJMYXJndXJhIE3DoXhpbWEgZG8gVmF6aW9cIixcblx0XHRzaWdtYUdhdXNzaWFuTmFtZTogXCJTdWF2aXphw6fDo28gQWRhcHRhdGl2YVwiLFxuXHRcdGNvbnRvdXJUeXBlTmFtZTogXCJUaXBvIGRlIENvbnRvcm5vXCIsXG5cdFx0ekJhc2VOYW1lOiBcIkJhc2UgWlwiLFxuXHRcdG51bWJlck9mQ29udG91cnNOYW1lOiBcIk7Dum1lcm8gZGUgQ3VydmFzIGRlIE7DrXZlbFwiLFxuXHRcdGNvbnRvdXJJbnRlcnZhbE5hbWU6IFwiSW50ZXJ2YWxvIGRhIEN1cnZhIGRlIE7DrXZlbFwiLFxuXHRcdG50aENvbnRvdXJMaW5lSW5Cb2xkTmFtZTogXCJMaW5oYSBkZSBDdXJ2YSBkZSBOw612ZWwgTnRoIGVtIE5lZ3JpdG9cIixcblx0XHRmZWF0dXJlQ2xhc3NOYW1lOiBcIkZlacOnw7VlcyBkZSBFbnRyYWRhXCIsXG5cdFx0Y2xhc3NJbmRleEZpZWxkTmFtZTogXCJDYW1wb1wiLFxuXHRcdHJlc29sdmVPdmVybGFwTWV0aG9kTmFtZTogXCJTb2x1Y2lvbmFyIE3DqXRvZG8gZGUgU29icmVwb3Npw6fDo29cIixcblx0XHRyZXNhbXBsaW5nVHlwZU5hbWU6IFwiVGlwbyBkZSBSZWFtb3N0cmFnZW1cIixcblx0XHRpbnB1dENlbGxzaXplTmFtZTogXCJUYW1hbmhvIGRhIEPDqWx1bGEgZGUgRW50cmFkYVwiLFxuXHRcdG91dHB1dENlbGxzaXplTmFtZTogXCJUYW1hbmhvIGRhIEPDqWx1bGEgZGUgU2HDrWRhXCIsXG5cdFx0cG9pbnRGZWF0dXJlQ2xhc3NOYW1lOiBcIlBvbnRvcyBkZSBPcmlnZW1cIixcblx0XHRtYXhHcm93dGhSYWRpdXNGaWVsZE5hbWU6IFwiQ2FtcG8gZG8gUmFpbyBkZSBDcmVzY2ltZW50byBNw6F4aW1vXCIsXG5cdFx0c2ltaWxhcml0eVRocmVzaG9sZEZpZWxkTmFtZTogXCJDYW1wbyBkbyBMaW1pdGUgZGUgU2ltaWxhcmlkYWRlXCIsXG5cdFx0ZmlsbFZhbHVlRmllbGROYW1lOiBcIkNhbXBvIGRvIFZhbG9yIGRlIFByZWVuY2hpbWVudG9cIixcblx0XHRzcGVjdHJhbERldGFpbE5hbWU6IFwiRGV0YWxoZSBFc3BlY3RyYWwgWzEuLjIwXVwiLFxuXHRcdHNwYXRpYWxEZXRhaWxOYW1lOiBcIkRldGFsaGUgRXNwYWNpYWwgWzEuLjIwXVwiLFxuXHRcdG1pbk51bVBpeGVsc1BlclNlZ21lbnROYW1lOiBcIlRhbWFuaG8gTcOtbmltbyBkbyBTZWdtZW50byBlbSBQaXhlbHNcIixcblx0XHRib3VuZGFyaWVzT25seU5hbWU6IFwiU29tZW50ZSBsaW1pdGVzIGRlIHNlZ21lbnRvXCIsXG5cdFx0c3RhdGlzdGljc1R5cGVOYW1lOiBcIlRpcG8gZGUgRXN0YXTDrXN0aWNhXCIsXG5cdFx0ZmlsbE5vRGF0YU9ubHlOYW1lOiBcIlNvbWVudGUgcHJlZW5jaGVyIHBpeGVscyBkZSBOb0RhdGFcIixcblx0XHRpbnB1dERhdGFUeXBlTmFtZTogXCJUaXBvIGRlIERhZG9zIGRlIEVudHJhZGFcIixcblx0XHRhbmdsZVJlZmVyZW5jZVN5c3RlbU5hbWU6IFwiU2lzdGVtYSBkZSBSZWZlcsOqbmNpYSBkbyDDgm5ndWxvXCIsXG5cdFx0b3V0cHV0RGF0YVR5cGVOYW1lOiBcIlRpcG8gZGUgRGFkb3MgZGUgU2HDrWRhXCIsXG5cdFx0aW5wdXRTYW1wbGVQb2ludEZlYXR1cmVDbGFzc05hbWU6IFwiQW1vc3RyYXMgZGUgRW50cmFkYVwiLFxuXHRcdHZhbHVlRmllbGROYW1lOiBcIkNhbXBvIGRlIFZhbG9yXCIsXG5cdFx0cmFzdGVySW5mb05hbWU6IFwiSW5mbyBkbyBSYXN0ZXJcIixcblx0XHRpbnRlcnBvbGF0aW9uTWV0aG9kTmFtZTogXCJNw6l0b2RvIGRlIEludGVycG9sYcOnw6NvXCIsXG5cdFx0cmFkaXVzTmFtZTogXCJQcm9wb3LDp8Ojb1wiLFxuXHRcdHJhZGlhbmNlR2FpblZhbHVlc05hbWU6IFwiR2FuaG8gZGUgUmFkaWHDp8Ojb1wiLFxuXHRcdHJhZGlhbmNlQmlhc1ZhbHVlc05hbWU6IFwiQmlhcyBkZSBSYWRpw6JuY2lhXCIsXG5cdFx0cmVmbGVjdGVkR2FpblZhbHVlc05hbWU6IFwiR2FuaG8gZGUgUmVmbGVjdMOibmNpYVwiLFxuXHRcdHJlZmxlY3RlZEJpYXNWYWx1ZXNOYW1lOiBcIkJpYXMgZGUgUmVmbGVjdMOibmNpYVwiLFxuXHRcdHN1bkVsZXZhdGlvbk5hbWU6IFwiRWxldmHDp8OjbyBkbyBTb2wgKGdyYXVzKVwiLFxuXHRcdGFsYmVkb05hbWU6IFwiQWxiZWRvXCIsXG5cdFx0c2NhbGVGYWN0b3JOYW1lOiBcIkZhdG9yIGRlIEVzY2FsYVwiLFxuXHRcdG9mZnNldE5hbWU6IFwiRGVzbG9jYW1lbnRvXCIsXG5cdFx0dGhyZXNob2xkVHlwZU5hbWU6IFwiVGlwbyBkZSBMaW1pdGVcIixcblx0XHR0aHJlc2hvbGRzTmFtZTogXCJMaW1pdGVzXCIsXG5cdFx0dW5kZWZpbmVkQ2xhc3NOYW1lOiBcIkNsYXNzZSBJbmRlZmluaWRhXCIsXG5cdFx0bWluVmFsdWVOYW1lOiBcIk3DrW5cIixcblx0XHRtYXhWYWx1ZU5hbWU6IFwiTcOheFwiLFxuXHRcdG9wZXJhdGlvbk5hbWU6IFwiT3BlcmHDp8Ojb1wiLFxuXHRcdGNsaXBwaW5nVHlwZU5hbWU6IFwiVGlwbyBkZSBSZWNvcnRlXCIsXG5cdFx0Y2xpcHBpbmdHZW9tZXRyeU5hbWU6IFwiUmVjb3J0YW5kbyBHZW9tZXRyaWEgLyBSYXN0ZXJcIixcblx0XHRleHRlbnROYW1lOiBcIkV4dGVuc8OjbyBkZSBTYcOtZGFcIixcblx0XHR1c2VJbnB1dEZlYXR1cmVHZW9tZXRyeU5hbWU6IFwiVXRpbGl6YXIgZmVpw6fDtWVzIGRlIGVudHJhZGEgcGFyYSByZWNvcnRhciBnZW9tZXRyaWFcIixcblx0XHRyZW1hcERlZmluaXRpb25UeXBlTmFtZTogXCJUaXBvIGRhIERlZmluacOnw6NvIGRlIFJlbWFwZWFtZW50b1wiLFxuXHRcdGlucHV0UmFuZ2VOYW1lOiBcIkludGVydmFsb3MgZGUgRW50cmFkYVwiLFxuXHRcdG91dHB1dFZhbHVlc05hbWU6IFwiVmFsb3JlcyBkZSBTYcOtZGFcIixcblx0XHRub0RhdGFSYW5nZU5hbWU6IFwiSW50ZXJ2YWxvcyBkZSBOb0RhdGFcIixcblx0XHRpbnB1dEZpZWxkTmFtZTogXCJDYW1wbyBkZSBFbnRyYWRhXCIsXG5cdFx0b3V0cHV0RmllbGROYW1lOiBcIkNhbXBvIGRlIFNhw61kYVwiLFxuXHRcdGlucHV0TWF4RmllbGROYW1lOiBcIkNhbXBvIE3DoXhpbW8gZGUgRW50cmFkYSAob3BjaW9uYWwpXCIsXG5cdFx0cmVtYXBUYWJsZVR5cGVOYW1lOiBcIlRpcG8gZGEgVGFiZWxhIGRlIFJlbWFwZWFtZW50b1wiLFxuXHRcdGFsbG93VW5tYXRjaGVkTmFtZTogXCJQZXJtaXRpciBWYWxvcmVzIGRlIFBpeGVscyBJbmNvbXBhcsOhdmVpc1wiLFxuXHRcdGNoYW5nZU1pc3NpbmdWYWx1ZXNUb05vRGF0YU5hbWU6IFwiQWx0ZXJhciB2YWxvcmVzIGF1c2VudGVzIHBhcmEgTm9kYXRhXCIsXG5cdFx0dmlzaWJsZUJhbmRJRE5hbWU6IFwiSUQgZGEgQmFuZGEgVmlzw612ZWxcIixcblx0XHRpbmZyYXJlZEJhbmRJRE5hbWU6IFwiSUQgZGEgQmFuZGEgZGUgSW5mcmFWZXJtZWxob1wiLFxuXHRcdHNjaWVudGlmaWNPdXRwdXROYW1lOiBcIlNhw61kYSBDaWVudMOtZmljYVwiLFxuXHRcdGJhbmRJbmRleGVzTmFtZTogXCLDjW5kaWNlcyBkYSBCYW5kYVwiLFxuXHRcdGNvbnN0YW50TmFtZTogXCJDb25zdGFudGVcIixcblx0XHR3ZWlnaHROYW1lOiBcIlBlc29cIixcblx0XHRtaW5pbXVtTmFtZTogXCJNw61uaW1vXCIsXG5cdFx0bWF4aW11bU5hbWU6IFwiTcOheGltb1wiLFxuXHRcdHNvdXJjZURhdGFOYW1lOiBcIlJhc3RlciBkZSBPcmlnZW1cIixcblx0XHRzb3VyY2VGaWVsZE5hbWU6IFwiQ2FtcG8gZGUgT3JpZ2VtXCIsXG5cdFx0Y29zdFJhc3Rlck5hbWU6IFwiUmFzdGVyIGRlIEN1c3RvXCIsXG5cdFx0bWF4RGlzdGFuY2VOYW1lOiBcIkRpc3TDom5jaWEgTcOheGltYVwiLFxuXHRcdHZhbHVlUmFzdGVyTmFtZTogXCJSYXN0ZXIgZGUgVmFsb3JcIixcblx0XHRjb3N0TXVsdGlwbGllck5hbWU6IFwiTXVsdGlwbGljYWRvciBwYXJhIEFwbGljYXIgYW9zIEN1c3Rvc1wiLFxuXHRcdHN0YXJ0Q29zdE5hbWU6IFwiQ3VzdG8gSW5pY2lhbFwiLFxuXHRcdGFjY3VtQ29zdFJlc2lzdGFuY2VSYXRlTmFtZTogXCJUYXhhIGRlIFJlc2lzdMOqbmNpYSBkbyBDdXN0byBBY3VtdWxhdGl2b1wiLFxuXHRcdGNhcGFjaXR5TmFtZTogXCJDYXBhY2lkYWRlXCIsXG5cdFx0dHJhdmVsRGlyZWN0aW9uTmFtZTogXCJEaXJlw6fDo28gZG8gUGVyY3Vyc29cIixcblx0XHRjZWxsU2l6ZU5hbWU6IFwiVGFtYW5obyBkYSBDw6lsdWxhXCIsXG5cdFx0cG9wdWxhdGlvbkZpZWxkTmFtZTogXCJDYW1wbyBkZSBQcmVlbmNoaW1lbnRvXCIsXG5cdFx0YXJlYVVuaXRzTmFtZTogXCJVbmlkYWRlcyBkZSDDgXJlYVwiLFxuXHRcdG91dHB1dFZhbHVlVHlwZU5hbWU6IFwiVmFsb3JlcyBkYSBDw6lsdWxhIGRlIFNhw61kYVwiLFxuXHRcdGJhcnJpZXJzTmFtZTogXCJCYXJyZWlyYXMgZGUgRW50cmFkYVwiLFxuXHRcdGRlc3RpbmF0aW9uRGF0YU5hbWU6IFwiUmFzdGVyIGRlIERlc3Rpbm9cIixcblx0XHRkZXN0aW5hdGlvbkZpZWxkTmFtZTogXCJDYW1wbyBkZSBEZXN0aW5vXCIsXG5cdFx0cGF0aFR5cGVOYW1lOiBcIlRpcG8gZGUgQ2FtaW5ob1wiLFxuXHRcdG9ic2VydmVyRmVhdHVyZXNOYW1lOiBcIkZlacOnw7VlcyBkbyBPYnNlcnZhZG9yXCIsXG5cdFx0YW5hbHlzaXNNZXRob2ROYW1lOiBcIk3DqXRvZG8gZGUgQW7DoWxpc2VcIixcblx0XHRhbmFseXNpc1R5cGVOYW1lOiBcIlRpcG8gZGUgQW7DoWxpc2VcIixcblx0XHR2ZXJ0aWNhbEVycm9yTmFtZTogXCJFcnJvIFZlcnRpY2FsXCIsXG5cdFx0cmVmcmFjdGl2aXR5Q29lZmZpY2llbnROYW1lOiBcIkNvZWZpY2llbnRlIGRlIFJlZnJhdGl2aWRhZGVcIixcblx0XHRzdXJmYWNlT2Zmc2V0TmFtZTogXCJEZXNsb2NhbWVudG8gZGUgU3VwZXJmw61jaWVcIixcblx0XHRvYnNlcnZlckVsZXZhdGlvbk5hbWU6IFwiRWxldmHDp8OjbyBkbyBPYnNlcnZhZG9yXCIsXG5cdFx0b2JzZXJ2ZXJPZmZzZXROYW1lOiBcIkRlc2xvY2FtZW50byBkbyBPYnNlcnZhZG9yXCIsXG5cdFx0aW5uZXJSYWRpdXNOYW1lOiBcIlJhaW8gSW50ZXJub1wiLFxuXHRcdGlubmVyUmFkaXVzSXMzRERpc3RhbmNlTmFtZTogXCJPIFJhaW8gSW50ZXJubyDDqSBhIERpc3TDom5jaWEgM0RcIixcblx0XHRvdXRlclJhZGl1c05hbWU6IFwiUmFpbyBFeHRlcm5vXCIsXG5cdFx0b3V0ZXJSYWRpdXNJczNERGlzdGFuY2VOYW1lOiBcIk8gUmFpbyBFeHRlcm5vIMOpIGEgRGlzdMOibmNpYSAzRFwiLFxuXHRcdGhvcml6b250YWxTdGFydEFuZ2xlTmFtZTogXCLDgm5ndWxvIEluaWNpYWwgSG9yaXpvbnRhbFwiLFxuXHRcdGhvcml6b250YWxFbmRBbmdsZU5hbWU6IFwiw4JuZ3VsbyBGaW5hbCBIb3Jpem9udGFsXCIsXG5cdFx0dmVydGljYWxVcHBlckFuZ2xlTmFtZTogXCLDgm5ndWxvIFN1cGVyaW9yIFZlcnRpY2FsXCIsXG5cdFx0dmVydGljYWxMb3dlckFuZ2xlTmFtZTogXCLDgm5ndWxvIEluZmVyaW9yIFZlcnRpY2FsXCIsXG5cdFx0em9uZURhdGFOYW1lOiBcIlJhc3RlciBkZSBab25hXCIsXG5cdFx0em9uZUZpZWxkTmFtZTogXCJDYW1wbyBkZSBab25hXCIsXG5cdFx0aWdub3JlTm9EYXRhTmFtZTogXCJJZ25vcmFyIE5vRGF0YSBub3MgY8OhbGN1bG9zXCIsXG5cdFx0dGVtcGVyYXR1cmVSYXN0ZXJOYW1lOiBcIlJhc3RlciBkZSBUZW1wZXJhdHVyYVwiLFxuXHRcdGluVGVtcGVyYXR1cmVVbml0c05hbWU6IFwiVW5pZGFkZXMgZGUgVGVtcGVyYXR1cmFcIixcblx0XHRvdXRIZWF0SW5kZXhUZW1wZXJhdHVyZVVuaXRzTmFtZTogXCJVbmlkYWRlcyBkbyDDjW5kaWNlIGRlIEFxdWVjaW1lbnRvXCIsXG5cdFx0cmVsYXRpdmVIdW1pZGl0eVJhc3Rlck5hbWU6IFwiUmFzdGVyIGRlIEh1bWlkYWRlIFJlbGF0aXZhXCIsXG5cdFx0b3V0V2luZENoaWxsVGVtcGVyYXR1cmVVbml0c05hbWU6IFwiVW5pZGFkZXMgZGEgU2Vuc2HDp8OjbyBUw6lybWljYVwiLFxuXHRcdHdpbmRTcGVlZFJhc3Rlck5hbWU6IFwiUmFzdGVyIGRlIFZlbG9jaWRhZGUgZG8gVmVudG9cIixcblx0XHRpbldpbmRTcGVlZFVuaXRzTmFtZTogXCJVbmlkYWRlcyBkZSBWZWxvY2lkYWRlIGRvIFZlbnRvXCIsXG5cdFx0dmFsdWVOYW1lOiBcIlZhbG9yXCIsXG5cdFx0cHJvcGVydHlOYW1lOiBcIlByb3ByaWVkYWRlIGRvIE5vbWVcIixcblx0XHRqc29uTmFtZTogXCJNZXRhZGFkb3MgSlNPTlwiLFxuXHRcdHpvbmVUYWJsZU5hbWU6IFwiVGFiZWxhIGRlIEF0cmlidXRvcyBab25haXNcIixcblx0XHRhdHRyaWJ1dGVGaWVsZE5hbWVzOiBcIk5vbWVzIGRvIENhbXBvIGRlIEF0cmlidXRvXCIsXG5cdFx0YmFja2dyb3VuZE5hbWU6IFwiVmFsb3IgZG8gUGxhbm8gZGUgRnVuZG9cIixcblx0XHR3aGVyZUNsYXVzZU5hbWU6IFwiQ2zDoXVzdWxhIFdoZXJlXCIsXG5cdFx0bWluaW11bVZhbHVlRmllbGROYW1lOiBcIk5vbWUgZG8gQ2FtcG8gZGUgVmFsb3IgTcOtbmltb1wiLFxuXHRcdG1heGltdW1WYWx1ZUZpZWxkTmFtZTogXCJOb21lIGRvIENhbXBvIGRlIFZhbG9yIE3DoXhpbW9cIixcblx0XHRvdXRWYWx1ZUZpZWxkTmFtZTogXCJOb21lIGRvIENhbXBvIGRlIFZhbG9yIGRlIFNhw61kYVwiLFxuXHRcdGRlZmF1bHRWYWx1ZU5hbWU6IFwiVmFsb3IgZGUgU2HDrWRhIFBhZHLDo29cIixcblx0XHRjb252ZXJzaW9uTWF0cml4TmFtZTogXCJNYXRyaXogZGUgQ29udmVyc8Ojb1wiLFxuXHRcdElzUHNldWRvQ29sb3JPdXRwdXROYW1lOiBcIsOJIHVtYSBwc2V1ZG8gY29yIGRlIHNhw61kYVwiLFxuXHRcdHVubWFwcGVkQXNSYW5kb21Db2xvck5hbWU6IFwiQXRyaWJ1aXIgQ29yIEFsZWF0b3JpYW1lbnRlIFBhcmEgUGl4ZWxzIE7Do28gTWFwZWFkb3NcIixcblx0XHRkaXN0YW5jZU1ldGhvZE5hbWU6IFwiTcOpdG9kbyBkZSBEaXN0w6JuY2lhXCIsXG5cdFx0Zmxvd0RpclJhc3Rlck5hbWU6IFwiUmFzdGVyIGRlIERpcmXDp8OjbyBkZSBGbHV4b1wiLFxuXHRcdHBvdXJQb2ludE5hbWU6IFwiRmx1aXIgUmFzdGVyIGRlIFBvbnRvXCIsXG5cdFx0cG91clBvaW50RmllbGROYW1lOiBcIkZsdWlyIENhbXBvIGRlIFBvbnRvXCIsXG5cdFx0Y29uc3RhbnRaTmFtZTogXCJDb25zdGFudGUgWlwiLFxuXHRcdHpPZmZzZXROYW1lOiBcIkRlc2xvY2FtZW50byBaXCIsXG5cdFx0Z2VvSWROYW1lOiBcIkdlw7NpZGVcIixcblx0XHRjYWxpYnJhdGlvblR5cGVOYW1lOiBcIlRpcG8gZGUgQ2FsaWJyYcOnw6NvXCIsXG5cdFx0ZmlsdGVyVHlwZU5hbWU6IFwiVGlwbyBkZSBGaWx0cm9cIixcblx0XHRmaWx0ZXJTaXplTmFtZTogXCJUYW1hbmhvIGRlIEZpbHRyb1wiLFxuXHRcdG5vaXNlTW9kZWxOYW1lOiBcIk1vZGVsbyBkZSBSdcOtZG9cIixcblx0XHRub2lzZVZhcmlhbmNlTmFtZTogXCJWYXJpYcOnw6NvIGRlIFJ1w61kb1wiLFxuXHRcdGFkZGl0aXZlTm9pc2VNZWFuTmFtZTogXCJNw6lkaWEgZGUgUnXDrWRvIEFkaXRpdm9cIixcblx0XHRtdWx0aXBsaWNhdGl2ZU5vaXNlTWVhbk5hbWU6IFwiTcOpZGlhIGRlIFJ1w61kbyBNdWx0aXBsaWNhdGl2b1wiLFxuXHRcdG51bWJlcm9mTG9va3NOYW1lOiBcIk7Dum1lcm8gZGUgVmlzdWFsaXphw6fDtWVzXCIsXG5cdFx0ZGFtcGluZ0ZhY3Rvck5hbWU6IFwiRmF0b3IgZGUgQW1vcnRlY2ltZW50b1wiLFxuXHRcdG1hc2tSYXN0ZXJOYW1lOiBcIlJhc3RlciBkZSBNw6FzY2FyYVwiLFxuXHRcdG5pYmJsZVZhbHVlc05hbWU6IFwiVXRpbGl6YXIgdmFsb3JlcyBOb2RhdGEgc2UgZm9yZW0gdml6aW5ob3MgbWFpcyBwcsOzeGltb3NcIixcblx0XHRuaWJibGVOb0RhdGFOYW1lOiBcIkV4dHJhaXIgY8OpbHVsYXMgZGUgTm9EYXRhXCIsXG5cdFx0ekxpbWl0TmFtZTogXCJMaW1pdGUgWlwiLFxuXHRcdGZsb3dEaXJlY3Rpb25UeXBlTmFtZTogXCJUaXBvIGRlIERpcmXDp8OjbyBkbyBGbHV4b1wiLFxuXHRcdHdlaWdodFJhc3Rlck5hbWU6IFwiUmFzdGVyIGRlIFBlc29cIixcblx0XHRmb3JjZUVkZ2VOYW1lOiBcIkZvcsOnYXIgYSBzYcOtZGEgZG8gZmx1eG8gZGUgdG9kYXMgYXMgY8OpbHVsYXMgZG8gc2VnbWVudG9cIixcblx0XHRzdHJlYW1SYXN0ZXJOYW1lOiBcIlJhc3RlciBkbyBGbHV4b1wiLFxuXHRcdHN1cmZhY2VSYXN0ZXJOYW1lOiBcIlJhc3RlciBkZSBTdXBlcmbDrWNpZVwiLFxuXHRcdGNvbnZlcnNpb25UeXBlOiBcIlRpcG8gZGUgQ29udmVyc8Ojb1wiLFxuXHRcdGRpc3RhbmNlUmFzdGVyMTogXCJSYXN0ZXIgZGUgRGlzdMOibmNpYSAxXCIsXG5cdFx0ZGlzdGFuY2VSYXN0ZXIyOiBcIlJhc3RlciBkZSBEaXN0w6JuY2lhIDJcIixcblx0XHRjb3N0RGlzdGFuY2VSYXN0ZXI6IFwiUmFzdGVyIGRhIERpc3TDom5jaWEgZGUgQ3VzdG9cIixcblx0XHRjb3N0QmFja2xpbmtSYXN0ZXI6IFwiUmFzdGVyIGRlIFbDrW5jdWxvIEFudGVyaW9yIGRlIEN1c3RvXCIsXG5cdFx0b3ZlcnJpZGVzTmFtZTogXCJTdWJzdGl0dWnDp8O1ZXNcIixcblx0XHRmaWVsZE5hbWU6IFwiQ2FtcG9cIixcblx0XHRzaWduYXR1cmVGaWxlT3JVcmw6IFwiQXJxdWl2byBkZSBBc3NpbmF0dXJhIG91IFVSTFwiLFxuXHRcdHJlZE5hbWU6IFwiVmVybWVsaG9cIixcblx0XHRncmVlbk5hbWU6IFwiVmVyZGVcIixcblx0XHRibHVlTmFtZTogXCJBenVsXCIsXG5cdFx0aW5mcmFyZWROYW1lOiBcIkluZnJhLVZlcm1lbGhvXCIsXG5cdFx0cGFuY2hyb21hdGljTmFtZTogXCJQYW5jcm9tw6F0aWNhXCIsXG5cdFx0bXVsdGlzcGVjdHJhbE5hbWU6IFwiTXVsdGllc3BlY3RyYWxcIixcblx0XHRwYW5zaGFycGVuaW5nVHlwZTogXCJUaXBvIGRlIE5pdGlkZXogUGFuY3JvbcOhdGljYVwiLFxuXHRcdHNlbnNvck5hbWU6IFwiU2Vuc29yXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZU5hbWU6IFwiUmVmZXLDqm5jaWEgRXNwYWNpYWxcIixcblx0XHR4Q2VsbHNpemVOYW1lOiBcIlRhbWFuaG8gZGEgQ8OpbHVsYSBYXCIsXG5cdFx0eUNlbGxzaXplTmFtZTogXCJUYW1hbmhvIGRhIEPDqWx1bGEgWVwiLFxuXHRcdHhPcmlnaW5OYW1lOiBcIlBvbnRvIGRlIFJlZ2lzdHJvIFhcIixcblx0XHR5T3JpZ2luTmFtZTogXCJQb250byBkZSBSZWdpc3RybyBZXCIsXG5cdFx0cGVyY2VudGlsZU5hbWU6IFwiVmFsb3IgUGVyY2VudGlsXCIsXG5cdFx0bmVpZ2hib3Job29kVHlwZTogXCJUaXBvIGRlIFZpemluaGFuw6dhXCIsXG5cdFx0d2lkdGhOYW1lOiBcIkxhcmd1cmFcIixcblx0XHRoZWlnaHROYW1lOiBcIkFsdHVyYVwiLFxuXHRcdHN0YXJ0QW5nbGVOYW1lOiBcIsOCbmd1bG8gSW5pY2lhbFwiLFxuXHRcdGVuZEFuZ2xlTmFtZTogXCLDgm5ndWxvIEZpbmFsXCIsXG5cdFx0bmVpZ2hib3Job29kVmFsdWVzOiBcIlZhbG9yZXMgZGUgVml6aW5oYW7Dp2FcIixcblx0XHRob3Jpem9udGFsUmFzdGVyOiBcIlJhc3RlciBIb3Jpem9udGFsXCIsXG5cdFx0aG9yaXpvbnRhbEZhY3RvcjogXCJGYXRvciBIb3Jpem9udGFsXCIsXG5cdFx0dmVydGljYWxSYXN0ZXI6IFwiUmFzdGVyIFZlcnRpY2FsXCIsXG5cdFx0dmVydGljYWxGYWN0b3I6IFwiRmF0b3IgVmVydGljYWxcIixcblx0XHRzdHJlYW1SYXN0ZXI6IFwiUmFzdGVyIGRvIEZsdXhvXCIsXG5cdFx0Zmxvd0RpclJhc3RlcjogXCJSYXN0ZXIgZGUgRGlyZcOnw6NvIGRlIEZsdXhvXCIsXG5cdFx0bnVtYmVyTmVpZ2hib3JDZWxsczogXCJOw7ptZXJvIGRlIEPDqWx1bGFzIFZpemluaGFzXCIsXG5cdFx0em9uZUNvbm5lY3Rpdml0eTogXCJDb25lY3RpdmlkYWRlIGRlIFpvbmFcIixcblx0XHRhZGRMaW5rQmVoYXZpb3I6IFwiQWRpY2lvbmFyIExpbmtcIixcblx0XHRleGNsdWRlZFZhbHVlOiBcIlZhbG9yZXMgRXhjbHXDrWRvc1wiLFxuXHRcdGNvbnN0YW50RmlsbENoZWNrOiBcIkdlcmFyIFJhc3RlciBkZSBQcmVlbmNoaW1lbnRvIGRhIENvbnN0YW50ZVwiLFxuXHRcdGZpbGxSYXN0ZXI6IFwiUmFzdGVyIGRlIFByZWVuY2hpbWVudG9cIixcblx0XHRjb25zdGFudEZpbGxWYWx1ZTogXCJWYWxvciBDb25zdGFudGVcIixcblx0XHRpbnB1dEJpdFBvc2l0aW9uczogXCJCaXQgZGUgRW50cmFkYVwiLFxuXHRcdG91dHB1dEJpdFBvc2l0aW9uczogXCJCaXQgZGUgU2HDrWRhXCIsXG5cdFx0ZGlzdGFuY2VUeXBlTmFtZTogXCJUaXBvIGRlIERpc3TDom5jaWFcIixcblx0XHRiYXJyaWVyRGF0YU5hbWU6IFwiQmFycmVpcmFzIGRvIFJhc3RlclwiLFxuXHRcdHBvdXJQb2ludERhdGFOYW1lOiBcIlJhc3RlciBkZSBQb250byBkZSBFc2NvYW1lbnRvXCIsXG5cdFx0YWNjdW11bGF0aW9uUmFzdGVyTmFtZTogXCJSYXN0ZXIgZGUgQWN1bXVsYcOnw6NvIGRlIEZsdXhvXCIsXG5cdFx0c25hcERpc3RhbmNlTmFtZTogXCJBanVzdGFyIERpc3TDom5jaWFcIixcblx0XHRvcmRlck1ldGhvZE5hbWU6IFwiTcOpdG9kbyBkZSBPcmRlbmHDp8Ojb1wiLFxuXHRcdGRpcmVjdGlvbk1lYXN1cmVtZW50TmFtZTogXCJEaXJlw6fDo28gZGEgTWVkaWRhXCIsXG5cdFx0cHJvY2Vzc0FzTXVsdGliYW5kOiBcIlByb2Nlc3NhciBjb21vIE3Dumx0aXBsYXMgQmFuZGFzXCIsXG5cdFx0cHJvY2Vzc011bHRpZGltZW5zaW9uYWw6IFwiUHJvY2Vzc2FyIGNvbW8gbXVsdGlkaW1lbnNpb25hbFwiLFxuXHRcdGZvcmNlRmxvd0RpcmVjdGlvbkNvbnZlbnRpb246IFwiRm9yw6dhciBjb252ZW7Dp8OjbyBkZSBkaXJlw6fDo28gZGUgZmx1eG8gcGFyYSByYXN0ZXIgZG8gbGluayBkZSByZXRvcm5vXCIsXG5cdFx0aW5pdGlhbEFjY3VtdWxhdGlvbjogXCJBY3VtdWxhw6fDo28gSW5pY2lhbFwiLFxuXHRcdG1heGltdW1BY2N1bXVsYXRpb246IFwiQWN1bXVsYcOnw6NvIE3DoXhpbWFcIixcblx0XHRzb3VyY2VMb2NhdGlvbkJhbmRzOiBcIkdlcmFyIGxpbmhhIGUgY29sdW5hIGRlIG9yaWdlbSBjb21vIGJhbmRhcyBhZGljaW9uYWlzIG5hIHNhw61kYVwiLFxuXHRcdGJhY2tEaXJlY3Rpb25CYW5kOiBcIkdlcmFyIGRpcmXDp8OjbyBkZSB2b2x0YSBjb21vIGJhbmRhIGFkaWNpb25hbCBuYSBzYcOtZGFcIixcblx0XHRudW1iZXJPZkNlbGxzOiBcIk7Dum1lcm8gZGUgQ8OpbHVsYXNcIixcblx0XHR6b25lVmFsdWVzOiBcIlZhbG9yZXMgZGUgWm9uYVwiLFxuXHRcdHNocmlua01ldGhvZDogXCJNw6l0b2RvIFJlZHV6aXJcIixcblx0XHRleHBhbmRNZXRob2Q6IFwiTcOpdG9kbyBFeHBhbmRpclwiLFxuXHRcdGlucHV0U3BlY3RyYWxQcm9maWxlVHlwZTogXCJUaXBvIGRlIFBlcmZpbCBFc3BlY3RyYWxcIixcblx0XHRzcGVjdHJhbFByb2ZpbGVGaWxlTmFtZTogXCJQZXJmaWwgRXNwZWN0cmFsXCIsXG5cdFx0dHJhaW5pbmdGZWF0dXJlRmlsZU5hbWU6IFwiRmVpw6fDo28gZGUgVHJlaW5hbWVudG9cIixcblx0XHRub25OZWdhdGl2ZTogXCJOw6NvLW5lZ2F0aXZvXCIsXG5cdFx0c3VtVG9PbmU6IFwiU29tYXIgcGFyYSBVbVwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvbjogXCJEaXN0cmlidWnDp8Ojb1wiLFxuXHRcdG1lYW5OYW1lOiBcIk3DqWRpYVwiLFxuXHRcdHByb2JhYmlsaXR5TmFtZTogXCJQcm9iYWJpbGlkYWRlXCIsXG5cdFx0YWxwaGFOYW1lOiBcIkFsZmFcIixcblx0XHRiZXRhTmFtZTogXCJCZXRhXCIsXG5cdFx0ck5hbWU6IFwiclwiLFxuXHRcdG5OYW1lOiBcIk5cIixcblx0XHRzZWVkOiBcIk9yaWdlbVwiLFxuXHRcdHJhbmRvbU51bWJlckdlbmVyYXRvcjogXCJHZXJhZG9yIGRlIE7Dum1lcm8gQWxlYXTDs3Jpb1wiLFxuXHRcdGNlbGxGYWN0b3I6IFwiRmF0b3IgZGEgQ8OpbHVsYVwiLFxuXHRcdGFnZ3JlZ2F0aW9uVHlwZTogXCJUw6ljbmljYSBkZSBBZ3JlZ2HDp8Ojb1wiLFxuXHRcdGV4dGVudEhhbmRsaW5nOiBcIkV4cGFuZGlyIGV4dGVuc8OjbyBzZSBuZWNlc3PDoXJpb1wiLFxuXHRcdHRyZW5kQW5hbHlzaXNEaW1lbnNpb25OYW1lOiBcIk5vbWUgZGEgZGltZW5zw6NvXCIsXG5cdFx0dHJlbmRBbmFseXNpc1R5cGU6IFwiVGlwbyBkZSBUZW5kw6puY2lhXCIsXG5cdFx0aGFybW9uaWNGcmVxdWVuY3k6IFwiRnJlcXXDqm5jaWEgSGFybcO0bmljYVwiLFxuXHRcdHBvbHlub21pYWxPcmRlcjogXCJPcmRlbSBQb2xpbm9taWFsXCIsXG5cdFx0Y3ljbGVMZW5ndGhOYW1lOiBcIkNvbXByaW1lbnRvIGRvIENpY2xvXCIsXG5cdFx0dHJlbmRBbmFseXNpc1JNU0U6IFwiUk1TRVwiLFxuXHRcdHRyZW5kQW5hbHlzaXNSMjogXCJSLVF1YWRyYWRhXCIsXG5cdFx0dHJlbmRBbmFseXNpc1Nsb3BlUFZhbHVlOiBcIlZhbG9yIFAgZG8gQ29lZmljaWVudGUgZGUgRGVjbGl2aWRhZGVcIixcblx0XHR0cmVuZEFuYWx5c2lzU2Vhc29uYWxQZXJpb2Q6IFwiUGVyw61vZG8gU2F6b25hbFwiLFxuXHRcdGN5Y2xlVW5pdE5hbWU6IFwiVW5pZGFkZSBkZSBDaWNsb1wiLFxuXHRcdHByZWRpY3REaW1lbnNpb25WYWx1ZXM6IFwiVmFsb3Jlc1wiLFxuXHRcdGRpbWVuc2lvbkRlZmluaXRpb25UeXBlOiBcIkRlZmluacOnw6NvIGRlIERpbWVuc8Ojb1wiLFxuXHRcdHByZWRpY3REaW1lbnNpb25TdGFydDogXCJJbmljaWFyXCIsXG5cdFx0cHJlZGljdERpbWVuc2lvbkVuZDogXCJGaW5hbFwiLFxuXHRcdHByZWRpY3REaW1lbnNpb25JbnRlcnZhbDogXCJJbnRlcnZhbG8gZG8gVmFsb3JcIixcblx0XHRkaW1lbnNpb25Vbml0OiBcIlVuaWRhZGVcIixcblx0XHRpbnRlcnBvbGF0aW9uQ2VsbHNpemVOYW1lOiBcIlRhbWFuaG8gZGEgQ8OpbHVsYSBkZSBJbnRlcnBvbGHDp8Ojb1wiLFxuXHRcdHZhcmlhYmxlTmFtZTogXCJWYXJpw6F2ZWlzXCIsXG5cdFx0ZGltZW5zaW9ubGVzc05hbWU6IFwiQWRpbWVuc2lvbmFsXCIsXG5cdFx0bWRpbURlZmluaXRpb246IFwiRGVmaW5pw6fDo28gZGUgRGltZW5zw6NvXCIsXG5cdFx0ZGltZW5zaW9uTmFtZTogXCJEaW1lbnPDo29cIixcblx0XHRpdGVyYXRpb25TdGFydDogXCJJbmljaWFyIGRhIHByaW1laXJhIGl0ZXJhw6fDo29cIixcblx0XHRpdGVyYXRpb25FbmQ6IFwiRmluYWxpemFyIGRhIHByaW1laXJhIGl0ZXJhw6fDo29cIixcblx0XHRpbnRlcnZhbFN0YXJ0OiBcIkluw61jaW8gZG8gSW50ZXJ2YWxvXCIsXG5cdFx0aW50ZXJ2YWxFbmQ6IFwiRmltIGRvIEludGVydmFsb1wiLFxuXHRcdHN0ZXBOYW1lOiBcIkludGVydmFsb1wiLFxuXHRcdHJhbmdlc05hbWU6IFwiRmFpeGFzXCIsXG5cdFx0bWluVmFsdWU6IFwiVmFsb3IgTcOtbmltb1wiLFxuXHRcdG1heFZhbHVlOiBcIlZhbG9yIE3DoXhpbW9cIixcblx0XHRjaGFuZ2VBbmFseXNpc1Jhc3Rlck5hbWU6IFwiUmFzdGVyIGRhIEFuw6FsaXNlIGRlIEFsdGVyYcOnw6NvXCIsXG5cdFx0Y2hhbmdlVHlwZU5hbWU6IFwiQWx0ZXJhciBUaXBvXCIsXG5cdFx0c2VnbWVudERhdGU6IFwiRGF0YSBkbyBTZWdtZW50b1wiLFxuXHRcdGNoYW5nZURpcmVjdGlvbk5hbWU6IFwiQWx0ZXJhciBEaXJlw6fDo29cIixcblx0XHRtYXhOdW1DaGFuZ2VzTmFtZTogXCJOw7ptZXJvIE3DoXhpbW8gZGUgQWx0ZXJhw6fDtWVzXCIsXG5cdFx0ZmlsdGVyQnlZZWFyOiBcIkZpbHRyYXIgUG9yIEFub1wiLFxuXHRcdG1pbmltdW1ZZWFyOiBcIlZhbG9yIE3DrW5pbW9cIixcblx0XHRtYXhpbXVtWWVhcjogXCJWYWxvciBNw6F4aW1vXCIsXG5cdFx0ZmlsdGVyQnlEdXJhdGlvbjogXCJGaWx0cmFyIFBvciBEdXJhw6fDo29cIixcblx0XHRtaW5pbXVtRHVyYXRpb246IFwiRHVyYcOnw6NvIE3DrW5pbWFcIixcblx0XHRtYXhpbXVtRHVyYXRpb246IFwiRHVyYcOnw6NvIE3DoXhpbWFcIixcblx0XHRmaWx0ZXJCeU1hZ25pdHVkZTogXCJGaWx0cmFyIFBvciBNYWduaXR1ZGVcIixcblx0XHRtaW5pbXVtTWFnbml0dWRlOiBcIk1hZ25pdHVkZSBNw61uaW1hXCIsXG5cdFx0bWF4aW11bU1hZ25pdHVkZTogXCJNYWduaXR1ZGUgTcOheGltYVwiLFxuXHRcdGZpbHRlckJ5U3RhcnRWYWx1ZTogXCJGaWx0cmFyIHBvciBWYWxvciBJbmljaWFsXCIsXG5cdFx0bWluaW11bVN0YXJ0VmFsdWU6IFwiVmFsb3IgSW5pY2lhbCBNw61uaW1vXCIsXG5cdFx0bWF4aW11bVN0YXJ0VmFsdWU6IFwiVmFsb3IgSW5pY2lhbCBNw6F4aW1vXCIsXG5cdFx0ZmlsdGVyQnlFbmRWYWx1ZTogXCJGaWx0cmFyIHBvciBWYWxvciBGaW5hbFwiLFxuXHRcdG1pbmltdW1FbmRWYWx1ZTogXCJWYWxvciBGaW5hbCBNw61uaW1vXCIsXG5cdFx0bWF4aW11bUVuZFZhbHVlOiBcIlZhbG9yIEZpbmFsIE3DoXhpbW9cIixcblx0XHRtb2RlbFR5cGVOYW1lOiBcIlRpcG8gZGUgTW9kZWxvXCIsXG5cdFx0ZnJvbVJhc3Rlck5hbWU6IFwiRG8gUmFzdGVyXCIsXG5cdFx0dG9SYXN0ZXJOYW1lOiBcIlBhcmEgUmFzdGVyXCIsXG5cdFx0Y29tcHV0ZUNoYW5nZU1ldGhvZDogXCJDYWxjdWxhciBNw6l0b2RvIGRlIEFsdGVyYcOnw6NvXCIsXG5cdFx0ZnJvbUNsYXNzVmFsdWVzOiBcIkRlIFZhbG9yZXMgZGUgQ2xhc3NlIChFeGVtcGxvOiAyIDUpXCIsXG5cdFx0dG9DbGFzc1ZhbHVlczogXCJQYXJhIFZhbG9yZXMgZGUgQ2xhc3NlIChFeGVtcGxvOiAyIDUpXCIsXG5cdFx0a2VlcE1ldGhvZDogXCJNw6l0b2RvIGRlIEZpbHRyb1wiLFxuXHRcdHVzZUNvbG9yTWV0aG9kOiBcIkRlZmluaXIgQ29yZXMgZGUgVHJhbnNpw6fDo29cIixcblx0XHRkZXRlY3RDaGFuZ2VCYW5kczogXCJCYW5kYXMgcGFyYSBEZXRlY3RhciBBbHRlcmHDp8O1ZXMgKGNvbWXDp2FyIGVtIDApXCIsXG5cdFx0dG1hc2tCYW5kczogXCJCYW5kYXMgcGFyYSBNw6FzY2FyYSBUZW1wb3JhbCAoY29tZcOnYXIgZW0gMClcIixcblx0XHRjaGlTcXVhcmVkVGhyZXNob2xkOiBcIkxpbWl0ZSBkZSBDaGktUXVhZHJhZG8gcGFyYSBEZXRlY3RhciBBbHRlcmHDp8O1ZXNcIixcblx0XHRtaW5Bbm9tYWx5OiBcIk9ic2VydmHDp8O1ZXMgZGUgQW5vbWFsaWEgU3VjZXNzaXZhcyBNw61uaW1hc1wiLFxuXHRcdHVwZGF0aW5nRnJlcXVlbmN5OiBcIkF0dWFsaXphbmRvIEZyZXF1w6puY2lhIGRlIEFqdXN0ZSAoZW0gYW5vcylcIixcblx0XHRkaXN0YW5jZUFjY3VtdWxhdGlvblJhc3Rlck5hbWU6IFwiUmFzdGVyIGRlIEFjdW11bGHDp8OjbyBkZSBEaXN0w6JuY2lhXCIsXG5cdFx0Y29zdEJhY2tkaXJlY3Rpb25SYXN0ZXJOYW1lOiBcIkRpcmXDp8OjbyBkZSBWb2x0YSBvdSBSYXN0ZXIgZGUgRGlyZcOnw6NvIGRlIEZsdXhvXCIsXG5cdFx0cmFzdGVyQ29sbGVjdGlvbk5hbWU6IFwiQ29sZcOnw6NvIGRlIFJhc3RlclwiLFxuXHRcdGl0ZW1GdW5jdGlvbk5hbWU6IFwiRnVuw6fDo28gZG8gSXRlbVwiLFxuXHRcdGFnZ3JlZ2F0aW9uRnVuY3Rpb25OYW1lOiBcIkZ1bsOnw6NvIGRlIEFncmVnYcOnw6NvXCIsXG5cdFx0cHJvY2Vzc2luZ0Z1bmN0aW9uTmFtZTogXCJGdW7Dp8OjbyBkZSBQcm9jZXNzYW1lbnRvXCIsXG5cdFx0YWdncmVnYXRpb25EZWZpbml0aW9uTmFtZTogXCJEZWZpbmnDp8OjbyBkZSBBZ3JlZ2HDp8Ojb1wiLFxuXHRcdHF1ZXJ5R2VvbWV0cnlOYW1lOiBcIkNvbnN1bHRhciBnZW9tZXRyaWFcIixcblx0XHRmYWN0b3JGdW5jdGlvblplcm9GYWN0b3I6IFwiRmF0b3IgWmVyb1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQ3V0QW5nbGU6IFwiw4JuZ3VsbyBkZSBDb3J0ZVwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU2lkZUZhY3RvcjogXCJGYXRvciBMYXRlcmFsXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TbG9wZTogXCJEZWNsaXZpZGFkZVwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uTG93Q3V0QW5nbGU6IFwiw4JuZ3VsbyBkZSBDb3J0ZSBCYWl4b1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uSGlnaEN1dEFuZ2xlOiBcIsOCbmd1bG8gZGUgQ29ydGUgQWx0b1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQ29zUG93ZXI6IFwiUG90w6puY2lhIGRvIENvLXNlbm9cIixcblx0XHRmYWN0b3JGdW5jdGlvblNlY1Bvd2VyOiBcIlBvdMOqbmNpYSBkYSBTZWNhbnRlXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25UYWJsZVBhdGg6IFwiQ2FtaW5obyBkYSBUYWJlbGFcIixcblx0XHRwcm9jZXNzaW5nQmFuZDogXCJCYW5kYSBkZSBQcm9jZXNzYW1lbnRvXCIsXG5cdFx0cHJvY2Vzc2luZ0JhbmROYW1lOiBcIk5vbWUgZGEgQmFuZGEgZGUgUHJvY2Vzc2FtZW50b1wiLFxuXHRcdHNuYXBwaW5nRGF0ZTogXCJEYXRhIGRlIEFqdXN0ZVwiLFxuXHRcdG1heE51bVNlZ21lbnRzOiBcIk7Dum1lcm8gTcOheGltbyBkZSBTZWdtZW50b3NcIixcblx0XHR2ZXJ0ZXhDb3VudE92ZXJzaG9vdDogXCJFeGNlc3NvIGRhIENvbnRhZ2VtIGRlIFbDqXJ0aWNlXCIsXG5cdFx0c3Bpa2VUaHJlc2hvbGQ6IFwiTGltaXRlIGRlIFNwaWtlXCIsXG5cdFx0cmVjb3ZlcnlUaHJlc2hvbGQ6IFwiTGltaXRlIGRlIFJlY3VwZXJhw6fDo29cIixcblx0XHRtaW5OdW1PYnM6IFwiTsO6bWVybyBtw61uaW1vIGRlIE9ic2VydmHDp8O1ZXNcIixcblx0XHRwVmFsdWVUaHJlc2hvbGQ6IFwiTGltaXRlIGRlIFZhbG9yIFBcIixcblx0XHRiZXN0TW9kZWxQcm9wb3J0aW9uOiBcIk1lbGhvciBQcm9wb3LDp8OjbyBkbyBNb2RlbG9cIixcblx0XHRwcmV2ZW50T25lWWVhclJlY292ZXJ5OiBcIkltcGVkaXIgUmVjdXBlcmHDp8OjbyBkZSBVbSBBbm9cIixcblx0XHRyZWNvdmVyeUluY3JlYXNlVHJlbmQ6IFwiQSBSZWN1cGVyYcOnw6NvIFRlbSBUZW5kw6puY2lhIGRlIEF1bWVudG9cIixcblx0XHRvdXRwdXRPdGhlckJhbmRzOiBcIlNhw61kYSBkZSBPdXRyYXMgQmFuZGFzXCIsXG5cdFx0c29ydFR5cGU6IFwiVGlwbyBkZSBDbGFzc2lmaWNhw6fDo29cIixcblx0XHRudW1iZXJPZlJ1bnM6IFwiRXhlY3V0YXIgZXhwYW5zw6NvIGUgcmVkdcOnw6NvIGR1YXMgdmV6ZXNcIixcblx0XHRwZXJjZW50aWxlVmFsdWU6IFwiVmFsb3IgUGVyY2VudGlsXCIsXG5cdFx0cGVyY2VudGlsZUludGVycG9sYXRpb25UeXBlOiBcIlRpcG8gZGUgaW50ZXJwb2xhw6fDo28gZGUgcGVyY2VudGlsXCIsXG5cdFx0cmFzdGVySW5mb1Byb3BlcnR5OiBcIlByb3ByaWVkYWRlXCIsXG5cdFx0cmFzdGVySW5mb1ZhbHVlOiBcIlZhbG9yXCIsXG5cdFx0cmFzdGVySW5mb0NvbHVtbnM6IFwiQ29sdW5hczpcIixcblx0XHRyYXN0ZXJJbmZvUm93czogXCJMaW5oYXNcIixcblx0XHRyYXN0ZXJJbmZvQmFuZENvdW50OiBcIk7Dum1lcm8gZGUgQmFuZGFzXCIsXG5cdFx0cmFzdGVySW5mb1BpeGVsU2l6ZVg6IFwiVGFtYW5obyBkYSBDw6lsdWxhIFhcIixcblx0XHRyYXN0ZXJJbmZvUGl4ZWxTaXplWTogXCJUYW1hbmhvIGRhIEPDqWx1bGEgWVwiLFxuXHRcdHJhc3RlckluZm9QaXhlbFR5cGU6IFwiVGlwbyBkZSBQaXhlbFwiLFxuXHRcdHJhc3RlckV4dGVudFRvcDogXCJTdXBlcmlvclwiLFxuXHRcdHJhc3RlckV4dGVudEJvdHRvbTogXCJJbmZlcmlvclwiLFxuXHRcdHJhc3RlckV4dGVudExlZnQ6IFwiRXNxdWVyZGFcIixcblx0XHRyYXN0ZXJFeHRlbnRSaWdodDogXCJEaXJlaXRhXCIsXG5cdFx0cmFzdGVyU3RhdGlzdGljc05vdENhbGN1bGF0ZWQ6IFwiQSBlc3RhdMOtc3RpY2EgbsOjbyBmb2kgY2FsY3VsYWRhLlwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VQcm9qZWN0aW9uOiBcIlByb2plw6fDo29cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlV2tpZDogXCJXS0lEXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUxhdGVzdFdraWQ6IFwiV0tJRCBBbnRlcmlvclwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VXa3Q6IFwiV0tUXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVZjc1draWQ6IFwiVkNTV0tJRFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VMYXRlc3RWY3NXa2lkOiBcIlZDU1dLSUQgQW50ZXJpb3JcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlQXV0aG9yaXR5OiBcIkF1dG9yaWRhZGVcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTGluZWFyVW5pdDogXCJVbmlkYWRlIExpbmVhclwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VBbmd1bGFyVW5pdDogXCJVbmlkYWRlIEFuZ3VsYXJcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlRmFsc2VFYXN0aW5nOiBcIkZhbHNvIExlc3RlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUZhbHNlTm9ydGhpbmc6IFwiRmFsc28gTm9ydGVcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlQ2VudHJhbE1lcmlkaWFuOiBcIk1lcmlkaWFubyBDZW50cmFsXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVByaW1lTWVyaWRpYW46IFwiTWVyaWRpYW5vIFByaW5jaXBhbFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTdGFuZGFyZFBhcmFsbGVsMTogXCJQYXJhbGVsbyBQYWRyw6NvIDFcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU3RhbmRhcmRQYXJhbGxlbDI6IFwiUGFyYWxlbG8gUGFkcsOjbyAyXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUxhdGl0dWRlT2ZPcmlnaW46IFwiTGF0aXR1ZGUgZGUgT3JpZ2VtXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUF1eGlsaWFyeVNwaGVyZVR5cGU6IFwiVGlwbyBkZSBFc2ZlcmEgQXV4aWxpYXJcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlRGF0dW06IFwiRGF0dW1cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU3BoZXJvaWQ6IFwiRXNmZXLDs2lkZVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTZW1pbWFqb3JBeGlzOiBcIlNlbWktRWl4byBNYWlvclwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTZW1pbWlub3JBeGlzOiBcIlNlbWktRWl4byBNZW5vclwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VJbnZlcnNlRmxhdHRlbmluZzogXCJBY2hhdGFtZW50byBJbnZlcnNvXCIsXG5cdFx0aW5wdXREZWZpbml0aW9uRmlsZU5hbWU6IFwiQXJxdWl2byBkZSBEZWZpbmnDp8OjbyBkZSBFbnRyYWRhXCIsXG5cdFx0ZGVsZXRlTmFtZTogXCJFeGNsdWlyXCIsXG5cdFx0YWRkVmFyaWFibGVOYW1lOiBcIkFkaWNpb25hciB2YXJpw6F2ZWxcIixcblx0XHRtYXhOdW1QaXhlbHNQZXJTZWdtZW50OiBcIlRhbWFuaG8gTcOheGltbyBkbyBTZWdtZW50byBlbSBQaXhlbHNcIixcblx0XHRmb3J3YXJkV2luZG93TmFtZTogXCJKYW5lbGEgZGEgRnJlbnRlXCIsXG5cdFx0YmFja3dhcmRXaW5kb3dOYW1lOiBcIkphbmVsYSBkZSBUcsOhc1wiLFxuXHRcdG5vRGF0YUhhbmRsaW5nTmFtZTogXCJNYW5pcHVsYcOnw6NvIGRvIE5vRGF0YVwiLFxuXHRcdGNpcmN1bGFyV3JhcFZhbHVlTmFtZTogXCJWYWxvciBkZSBRdWVicmEgQ2lyY3VsYXJcIixcblx0XHRmcm9tQ2xhc3NOYW1lRmllbGROYW1lOiBcIk5vbWUgZGUgQ2FtcG8gcGFyYSBOb21lcyBkYSBDbGFzc2UgZW0gRG8gUmFzdGVyXCIsXG5cdFx0dG9DbGFzc05hbWVGaWVsZE5hbWU6IFwiTm9tZSBkZSBDYW1wbyBwYXJhIE5vbWVzIGRhIENsYXNzZSBlbSBQYXJhIFJhc3RlclwiLFxuXHRcdHRhcmdldFJhc3Rlck5hbWU6IFwiUmFzdGVyIGRlIERlc3Rpbm9cIixcblx0XHRjaXJjdWxhcldyYXBWYWx1ZTogXCJWYWxvciBkZSBRdWVicmEgQ2lyY3VsYXJcIixcblx0XHRiYW5kSW5kZXhlc1I6IFwiRXhwcmVzc8OjbyBWZXJtZWxoYVwiLFxuXHRcdGJhbmRJbmRleGVzRzogXCJFeHByZXNzw6NvIFZlcmRlXCIsXG5cdFx0YmFuZEluZGV4ZXNCOiBcIkV4cHJlc3PDo28gQXp1bFwiLFxuXHRcdGV4YW1wbGVOYW1lOiBcIkV4ZW1wbG9cIixcblx0XHRpbnB1dE5hbWU6IFwiRW50cmFkYVwiLFxuXHRcdG91dHB1dE5hbWU6IFwiU2HDrWRhXCIsXG5cdFx0b3B0aW9uYWxOYW1lOiBcIk9wY2lvbmFsXCIsXG5cdFx0YnJvd3NlRGVmaW5pdGlvbkZpbGU6IFwiUHJvY3VyYXIgYXJxdWl2byBkZSBkZWZpbmnDp8Ojb1wiLFxuXHRcdHNlbGVjdERlZmluaXRpb25GaWxlOiBcIlNlbGVjaW9uZSBvIGFycXVpdm8gZGUgZGVmaW5pw6fDo28gZGUgZW50cmFkYVwiLFxuXHRcdGlucHV0RGVmaW5pdGlvblVSTDogXCJVUkwgZG8gYXJxdWl2byBkZSBkZWZpbmnDp8OjbyBkZSBlbnRyYWRhXCIsXG5cdFx0ZW50ZXJEZWZpbml0aW9uRmlsZVVSTDogXCJJbnNpcmEgYSBVUkwgZG8gYXJxdWl2byBkZSBkZWZpbmnDp8Ojb1wiLFxuXHRcdGJyb3dzZVhNTEZpbGU6IFwiUHJvY3VyYXIgYXJxdWl2byBYTUxcIixcblx0XHRzZWxlY3RTdGF0c0ZpbGU6IFwiU2VsZWNpb25lIG8gYXJxdWl2byBkZSBlc3RhdMOtc3RpY2FzIGUgaGlzdG9ncmFtYXNcIixcblx0XHRlbnRlclhNTEZpbGVVUkw6IFwiRGlnaXRlIGEgVVJMIGRvIGFycXVpdm8gWE1MXCIsXG5cdFx0eG1sRmlsZVVSTDogXCJVUkwgZG8gYXJxdWl2byBYTUxcIixcblx0XHRjaXJjdWxhckNhbGN1bGF0aW9uOiBcIkNhbGN1bGFyIEVzdGF0w61zdGljYSBDaXJjdWxhclwiLFxuXHRcdGxvY2FsU3VyZmFjZVR5cGU6IFwiVGlwbyBkZSBTdXBlcmbDrWNpZSBMb2NhbFwiLFxuXHRcdHN1cmZhY2VQYXJhbWV0ZXJUeXBlOiBcIlRpcG8gZGUgUGFyw6JtZXRyb1wiLFxuXHRcdG5laWdoYm9yaG9vZERpc3RhbmNlOiBcIkRpc3TDom5jaWEgZGUgVml6aW5oYW7Dp2FcIixcblx0XHR1c2VBZGFwdGl2ZU5laWdoYm9yaG9vZDogXCJVc2FyIFZpemluaGFuw6dhIEFkYXB0w6F2ZWxcIixcblx0XHRvdXRwdXRTbG9wZVR5cGU6IFwiTWVkacOnw6NvIGRlIEluY2xpbmHDp8OjbyBkZSBTYcOtZGFcIixcblx0XHRwcm9qZWN0QXppbXV0aHM6IFwiQXppbXV0ZXMgR2VvZMOpc2ljb3MgZG8gUHJvamV0b1wiLFxuXHRcdHVzZUVxdWF0b3JpYWxBc3BlY3Q6IFwiVXNhciBBc3BlY3RvIEVxdWF0b3JpYWxcIixcblx0XHR6VW5pdDogXCJVbmlkYWRlIFpcIixcblx0XHRhbmFseXNpc01hc2s6IFwiTcOhc2NhcmEgZGUgQW7DoWxpc2VcIixcblx0XHRzdGREZXZpYXRpb246IFwiRGVzdmlvIFBhZHLDo29cIixcblx0XHRcInRydWVcIjogXCJWZXJkYWRlaXJvXCIsXG5cdFx0XCJmYWxzZVwiOiBcIkZhbHNvXCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyMTogXCJSYXN0ZXIgZGUgRGlzdMOibmNpYSBkZSBDdXN0byBBY3VtdWxhZG8gZGUgRW50cmFkYSAxXCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyMjogXCJSYXN0ZXIgZGUgRGlzdMOibmNpYSBkZSBDdXN0byBBY3VtdWxhZG8gZGUgRW50cmFkYSAyXCIsXG5cdFx0dGhyZXNob2xkOiBcIkxpbWl0ZVwiLFxuXHRcdHRocmVzaG9sZE1ldGhvZDogXCJNw6l0b2RvIGRlIExpbWl0ZVwiLFxuXHRcdGRpcmVjdGlvblJhc3RlcjE6IFwiUmFzdGVyIGRlIERpcmXDp8OjbyBkZSBWb2x0YSBkZSBFbnRyYWRhIDFcIixcblx0XHRkaXJlY3Rpb25SYXN0ZXIyOiBcIlJhc3RlciBkZSBEaXJlw6fDo28gZGUgVm9sdGEgZGUgRW50cmFkYSAyXCIsXG5cdFx0bWF4SXRlcmF0aW9uczogXCJOw7ptZXJvIE3DoXhpbW8gZGUgSXRlcmHDp8O1ZXNcIixcblx0XHRlcHNpbG9uOiBcIsOJcHNpbG9uXCJcblx0fSxcblx0ZW51bUxhYmVsczoge1xuXHRcdGF0dHJpYnV0ZVRhYmxlVHlwZU1hbnVhbDogXCJNYW51YWxcIixcblx0XHRhdHRyaWJ1dGVUYWJsZVR5cGVFeHRlcm5hbDogXCJFeHRlcm5vXCIsXG5cdFx0Y2xyU2NoZW1lVHlwZUNvbG9ybWFwOiBcIk1hcGEgZGUgQ29yZXNcIixcblx0XHRjbHJTY2hlbWVUeXBlQ29sb3JSYW1wOiBcIlJhbXBhIGRlIENvcmVzXCIsXG5cdFx0Y29sb3JtYXBUeXBlRWxldmF0aW9uOiBcIkVsZXZhw6fDo29cIixcblx0XHRjb2xvcm1hcFR5cGVHcmF5OiBcIkNpbnphXCIsXG5cdFx0Y29sb3JtYXBUeXBlTkRWSTogXCJORFZJXCIsXG5cdFx0Y29sb3JtYXBUeXBlTkRWSTI6IFwiTkRWSTJcIixcblx0XHRjb2xvcm1hcFR5cGVORFZJMzogXCJORFZJM1wiLFxuXHRcdGNvbG9ybWFwVHlwZVJhbmRvbTogXCJBbGVhdMOzcmlvXCIsXG5cdFx0bm9uZTogXCJOZW5odW1cIixcblx0XHRzbG9wZVR5cGVBZGp1c3RlZDogXCJBanVzdGFkb1wiLFxuXHRcdHNsb3BlVHlwZURlZ3JlZTogXCJHcmF1c1wiLFxuXHRcdHNsb3BlVHlwZVBlcmNlbnRSaXNlOiBcIkF1bWVudG8gZGEgUG9yY2VudGFnZW1cIixcblx0XHRzbG9wZVR5cGVTY2FsZWQ6IFwiRGltZW5zaW9uYWRvXCIsXG5cdFx0c3RyZXRjaFR5cGVNaW5NYXg6IFwiTcOtbi1Nw6F4XCIsXG5cdFx0c3RyZXRjaFR5cGVQZXJjZW50TWluTWF4OiBcIlBlcmNlbnRhZ2VtIE3DrW4tTcOheFwiLFxuXHRcdHN0cmV0Y2hUeXBlU2lnbW9pZDogXCJTaWdtw7NpZGVcIixcblx0XHRzdHJldGNoVHlwZVN0ZERldjogXCJEZXN2aW8gUGFkcsOjb1wiLFxuXHRcdGhpbGxzaGFkZVR5cGVTaW1wbGU6IFwiVHJhZGljaW9uYWxcIixcblx0XHRoaWxsc2hhZGVUeXBlTXVsdGlkaXJlY3Rpb25hbDogXCJNdWx0aWRpcmVjaW9uYWxcIixcblx0XHRiYW5kQ29tYm9CeU5hbWVzOiBcIk5vbWVzIGRlIEJhbmRhc1wiLFxuXHRcdGJhbmRDb21ib0J5V2F2ZWxlbmd0aDogXCJDb21wcmltZW50b3MgZGUgT25kYSBkYSBCYW5kYVwiLFxuXHRcdGJhbmRDb21ib0J5SURzOiBcIklEcyBkZSBCYW5kYVwiLFxuXHRcdG1pc3NpbmdCYW5kQWN0aW9uQmVzdE1hdGNoOiBcIk1lbGhvciBDb21iaW5hw6fDo29cIixcblx0XHRtaXNzaW5nQmFuZEFjdGlvbkZhaWw6IFwiRmFsaGFcIixcblx0XHR1bml0VHlwZUNlbHNpdXM6IFwiQ2Vsc2l1c1wiLFxuXHRcdHVuaXRUeXBlQ2VudGltZXRlcnM6IFwiQ2VudMOtbWV0cm9zXCIsXG5cdFx0dW5pdFR5cGVEZWNpbWV0ZXJzOiBcIkRlY8OtbWV0cm9zXCIsXG5cdFx0dW5pdFR5cGVGYWhyZW5oZWl0OiBcIkZhaHJlbmhlaXRcIixcblx0XHR1bml0VHlwZUZlZXQ6IFwiUMOpc1wiLFxuXHRcdHVuaXRUeXBlRmVldFBlclNlYzogXCJQw6lzIHBvciBTZWd1bmRvIChmdC9zKVwiLFxuXHRcdHVuaXRUeXBlSW5jaGVzOiBcIlBvbGVnYWRhc1wiLFxuXHRcdHVuaXRUeXBlS2VsdmluOiBcIktlbHZpblwiLFxuXHRcdHVuaXRUeXBlS2lsb21ldGVyczogXCJRdWlsw7RtZXRyb3NcIixcblx0XHR1bml0VHlwZUttc1BlckhvdXI6IFwiUXVpbMO0bWV0cm9zIFBvciBIb3JhIChrbS9oKVwiLFxuXHRcdHVuaXRUeXBlS25vdHM6IFwiTsOzIChrbilcIixcblx0XHR1bml0VHlwZU1ldGVyczogXCJNZXRyb3NcIixcblx0XHR1bml0VHlwZU1ldGVyc1BlclNlYzogXCJNZXRyb3MgcG9yIFNlZ3VuZG9zIChtL3MpXCIsXG5cdFx0dW5pdFR5cGVNaWxlczogXCJNaWxoYXNcIixcblx0XHR1bml0VHlwZU1pbGVzUGVySG91cjogXCJNaWxoYXMgcG9yIEhvcmEgKG1waClcIixcblx0XHR1bml0VHlwZU1pbGxpbWV0ZXJzOiBcIk1pbMOtbWV0cm9zXCIsXG5cdFx0dW5pdFR5cGVOYXV0aWNhbE1pbGVzOiBcIk1pbGhhcyBOw6F1dGljYXNcIixcblx0XHR1bml0VHlwZVlhcmRzOiBcIkphcmRhc1wiLFxuXHRcdHVuaXRUeXBlRGVjaW1hbERlZ3JlZXM6IFwiR3JhdXMgRGVjaW1haXNcIixcblx0XHR1bml0VHlwZVBvaW50czogXCJQb250b3NcIixcblx0XHR1bml0VHlwZVVua25vd246IFwiRGVzY29uaGVjaWRvXCIsXG5cdFx0dW5pdFR5cGVTcU1hcFVuaXRzOiBcIlVuaWRhZGVzIFF1YWRyw6F0aWNhcyBkbyBNYXBhXCIsXG5cdFx0dW5pdFR5cGVTcU1pbGVzOiBcIk1pbGhhcyBRdWFkcmFkYXNcIixcblx0XHR1bml0VHlwZVNxS21zOiBcIlF1aWzDtG1ldHJvcyBRdWFkcmFkb3NcIixcblx0XHR1bml0VHlwZUFjcmVzOiBcIkFjcmVzXCIsXG5cdFx0dW5pdFR5cGVIZWN0YXJlczogXCJIZWN0YXJlc1wiLFxuXHRcdHVuaXRUeXBlU3FZYXJkczogXCJKYXJkYXMgUXVhZHJhZGFzXCIsXG5cdFx0dW5pdFR5cGVTcUZ0OiBcIlDDqXMgUXVhZHJhZG9zXCIsXG5cdFx0dW5pdFR5cGVTcUluY2hlczogXCJQb2xlZ2FkYXMgUXVhZHJhZGFzXCIsXG5cdFx0dW5pdFR5cGVTcU10czogXCJNZXRyb3MgUXVhZHJhZG9zXCIsXG5cdFx0dW5pdFR5cGVTcUNtczogXCJDZW50w61tZXRyb3MgUXVhZHJhZG9zXCIsXG5cdFx0dW5pdFR5cGVTcU1tczogXCJNaWzDrW1ldHJvcyBRdWFkcmFkb3NcIixcblx0XHRjZWxsc2l6ZVR5cGVGaXJzdDogXCJQcmltZWlybyBEZVwiLFxuXHRcdGNlbGxzaXplVHlwZU1pbjogXCJNw61uaW1vIERlXCIsXG5cdFx0Y2VsbHNpemVUeXBlTWF4OiBcIk3DoXhpbW8gRGVcIixcblx0XHRjZWxsc2l6ZVR5cGVNZWFuOiBcIk3DqWRpYSBEZVwiLFxuXHRcdGNlbGxzaXplVHlwZUxhc3Q6IFwiw5psdGltbyBEZVwiLFxuXHRcdGV4dGVudFR5cGVGaXJzdDogXCJQcmltZWlybyBEZVwiLFxuXHRcdGV4dGVudFR5cGVJbnRlcnNlY3Rpb246IFwiSW50ZXJzZWPDp8OjbyBEZVwiLFxuXHRcdGV4dGVudFR5cGVVbmlvbjogXCJVbmnDo28gRGVcIixcblx0XHRleHRlbnRUeXBlTGFzdDogXCLDmmx0aW1vIERlXCIsXG5cdFx0bm9EYXRhSW50ZXJwcmV0QW55OiBcIkNvbWJpbmFyIFF1YWxxdWVyIFVtXCIsXG5cdFx0bm9EYXRhSW50ZXJwcmV0QWxsOiBcIkNvbWJpbmFyIFRvZG9zXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVN0YW5kYXJkOiBcIlN0YW5kYXJkXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVByb2ZpbGU6IFwiUGVyZmlsXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVBsYW5mb3JtOiBcIkZvcm1hIFBsYW5hXCIsXG5cdFx0ZmlsdGVyVHlwZUxpbmVEZXRlY3Rpb25Ib3Jpem9udGFsOiBcIkRldGVjw6fDo28gZGUgTGluaGEgSG9yaXpvbnRhbFwiLFxuXHRcdGZpbHRlclR5cGVMaW5lRGV0ZWN0aW9uVmVydGljYWw6IFwiRGV0ZWPDp8OjbyBkZSBMaW5oYSBWZXJ0aWNhbFwiLFxuXHRcdGZpbHRlclR5cGVMaW5lRGV0ZWN0aW9uTGVmdERpYWdvbmFsOiBcIkRldGVjw6fDo28gZGUgTGluaGEgRGlhZ29uYWwgRXNxdWVyZGFcIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvblJpZ2h0RGlhZ29uYWw6IFwiRGV0ZWPDp8OjbyBkZSBMaW5oYSBEaWFnb25hbCBEaXJlaXRhXCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50Tm9ydGg6IFwiTm9ydGUgR3JhZGllbnRlXCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50V2VzdDogXCJPZXN0ZSBHcmFkaWVudGVcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnRFYXN0OiBcIkxlc3RlIEdyYWRpZW50ZVwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudFNvdXRoOiBcIlN1bCBHcmFkaWVudGVcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnROb3J0aEVhc3Q6IFwiTm9yZGVzdGUgR3JhZGllbnRlXCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50Tm9ydGhXZXN0OiBcIk5vcm9lc3RlIEdyYWRpZW50ZVwiLFxuXHRcdGZpbHRlclR5cGVTbW9vdGhBcml0aG1ldGljTWVhbjogXCJTdWF2aXphciBNw6lkaWEgQXJpdG3DqXRpY2FcIixcblx0XHRmaWx0ZXJUeXBlU21vb3RoaW5nM3gzOiBcIlN1YXZpemHDp8OjbyAzeDNcIixcblx0XHRmaWx0ZXJUeXBlU21vb3RoaW5nNXg1OiBcIlN1YXZpemHDp8OjbyA1eDVcIixcblx0XHRmaWx0ZXJUeXBlU2hhcnBlbmluZzN4MzogXCJOaXRpZGV6IDN4M1wiLFxuXHRcdGZpbHRlclR5cGVTaGFycGVuaW5nNXg1OiBcIk5pdGlkZXogNXg1XCIsXG5cdFx0ZmlsdGVyVHlwZUxhcGxhY2lhbjN4MzogXCJMYXBsYWNpYW5vIDN4M1wiLFxuXHRcdGZpbHRlclR5cGVMYXBsYWNpYW41eDU6IFwiTGFwbGFjaWFubyA1eDVcIixcblx0XHRmaWx0ZXJUeXBlU29iZWxIb3Jpem9udGFsOiBcIkhvcml6b250YWwgZGUgU29iZWxcIixcblx0XHRmaWx0ZXJUeXBlU29iZWxWZXJ0aWNhbDogXCJWZXJ0aWNhbCBkZSBTb2JlbFwiLFxuXHRcdGZpbHRlclR5cGVTaGFycGVuOiBcIk7DrXRpZG9cIixcblx0XHRmaWx0ZXJUeXBlU2hhcnBlbjI6IFwiTWFpcyBOw610aWRvXCIsXG5cdFx0ZmlsdGVyVHlwZVBvaW50U3ByZWFkOiBcIlByb3BhZ2HDp8OjbyBkZSBQb250b1wiLFxuXHRcdHVzZXJEZWZpbmVkOiBcIlVzdcOhcmlvIERlZmluaWRvXCIsXG5cdFx0Q29udG91clR5cGVMaW5lczogXCJMaW5oYXMgZGUgQ29udG9ybm9cIixcblx0XHRDb250b3VyVHlwZUZpbGw6IFwiUHJlZW5jaGltZW50byBkZSBDb250b3Jub1wiLFxuXHRcdENvbnRvdXJUeXBlU21vb3RoT25seTogXCJTb21lbnRlIHN1cGVyZsOtY2llIHN1YXZlXCIsXG5cdFx0cmFzdGVyaXplRmlyc3Q6IFwiUHJpbWVpcm9cIixcblx0XHRyYXN0ZXJpemVMYXN0OiBcIsOabHRpbW9cIixcblx0XHRyYXN0ZXJpemVTbWFsbGVzdDogXCJNZW5vclwiLFxuXHRcdHJhc3Rlcml6ZUxhcmdlc3Q6IFwiTWFpb3JcIixcblx0XHRyZXNhbXBsaW5nVHlwZU5lYXJlc3Q6IFwiVml6aW5obyBNYWlzIFByw7N4aW1vXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVCaWxpbmVhcjogXCJJbnRlcnBvbGHDp8OjbyBCaWxpbmVhclwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlQ3ViaWM6IFwiQ29udm9sdcOnw6NvIEPDumJpY2FcIixcblx0XHRyZXNhbXBsaW5nVHlwZU1ham9yaXR5OiBcIk1haW9yaWFcIixcblx0XHRyZXNhbXBsaW5nVHlwZUJpbGluZWFyUGx1czogXCJJbnRlcnBvbGHDp8OjbyBCaWxpbmVhciBBZGljaW9uYWxcIixcblx0XHRyZXNhbXBsaW5nVHlwZUdhdXNzOiBcIkdhdXNzIEJsdXJcIixcblx0XHRyZXNhbXBsaW5nVHlwZUdhdXNzUGx1czogXCJHYXVzcyBCbHVyIEFkaWNpb25hbFwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlQXZlcmFnZTogXCJNw6lkaWFcIixcblx0XHRyZXNhbXBsaW5nVHlwZU1pbmltdW06IFwiTcOtbmltb1wiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTWF4aW11bTogXCJNw6F4aW1vXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVWZWN0b3JBdmc6IFwiTcOpZGlhIFZldG9yaWFsXCIsXG5cdFx0bWluaW11bTogXCJNw61uaW1vXCIsXG5cdFx0bWF4aW11bTogXCJNw6F4aW1vXCIsXG5cdFx0bWVhbjogXCJNw6lkaWFcIixcblx0XHRzdGREZXZpYXRpb246IFwiRGVzdmlvIFBhZHLDo29cIixcblx0XHR1dk1hZ0RpclR5cGVVVjogXCJVLVZcIixcblx0XHR1dk1hZ0RpclR5cGVNYWdEaXI6IFwiTWFnbml0dWRlLURpcmXDp8Ojb1wiLFxuXHRcdHVua25vd246IFwiRGVzY29uaGVjaWRvXCIsXG5cdFx0YW5nbGVSZWZTeXNHZW9ncmFwaGljOiBcIkdlb2dyw6FmaWNvXCIsXG5cdFx0YW5nbGVSZWZTeXNBcml0aG1ldGljOiBcIkFyaXRtw6l0aWNvXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhTmVhcmVzdDogXCJWaXppbmhvIE1haXMgUHLDs3hpbW9cIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFCaWxpbmVhcjogXCJCaWxpbmVhclwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVRpbm5pbmdMaW5lYXI6IFwiRXN0YW5oYWdlbSBMaW5lYXJcIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFUaW5uaW5nTmF0dXJhbE5laWdoYm9yOiBcIlZpemluaG8gTmF0dXJhbFwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVRpbm5pbmdJRFc6IFwiRGlzdMOibmNpYSBJbnZlcnNhIFBvbmRlcmFkYVwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlQ29uc3RhbnQ6IFwiQ29uc3RhbnRlXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVPdHN1OiBcIk90c3VcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZVRzYWk6IFwiVHNhaVwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlS2FwdXI6IFwiS2FwdXJcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZUtpdHRsZXI6IFwiS2l0dGxlclwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlUm9zaW46IFwiUm9zaW5cIixcblx0XHRhcmdTdGF0c1R5cGVNYXg6IFwiUGFyw6JtZXRybyBNw6F4aW1vXCIsXG5cdFx0YXJnU3RhdHNUeXBlTWluOiBcIlBhcsOibWV0cm8gTcOtbmltb1wiLFxuXHRcdGFyZ1N0YXRzVHlwZU1lZGlhbjogXCJQYXLDom1ldHJvIGRhIE1lZGlhbmFcIixcblx0XHRhcmdTdGF0c1R5cGVEdXJhdGlvbjogXCJEdXJhw6fDo29cIixcblx0XHRhcml0aG1ldGljT3BQbHVzOiBcIkFkacOnw6NvXCIsXG5cdFx0YXJpdGhtZXRpY09wTWludXM6IFwiU3VidHJhaXJcIixcblx0XHRhcml0aG1ldGljT3BNdWx0aXBseTogXCJNdWx0aXBsaWNhclwiLFxuXHRcdGFyaXRobWV0aWNPcERpdmlkZTogXCJEaXZpZGlyXCIsXG5cdFx0YXJpdGhtZXRpY09wUG93ZXI6IFwiUG90w6puY2lhXCIsXG5cdFx0YXJpdGhtZXRpY09wTW9kZTogXCJNb2RvXCIsXG5cdFx0Y2xpcFR5cGVPdXRzaWRlOiBcIlJlY29ydGFyIEZvcmFcIixcblx0XHRjbGlwVHlwZUluc2lkZTogXCJSZWNvcnRhciBEZW50cm9cIixcblx0XHR5ZXM6IFwiU2ltXCIsXG5cdFx0bm86IFwiTsOjb1wiLFxuXHRcdGRlbnNpdGllczogXCJEZW5zaWRhZGVzXCIsXG5cdFx0ZXhwZWN0ZWRDb3VudHM6IFwiQ29udGFnZW5zIEVzcGVyYWRhc1wiLFxuXHRcdHBsYW5hcjogXCJQbGFuYXJcIixcblx0XHRnZW9kZXNpYzogXCJHZW9kw6lzaWNhXCIsXG5cdFx0ZWFjaENlbGw6IFwiQ2FkYSBDw6lsdWxhXCIsXG5cdFx0ZWFjaFpvbmU6IFwiQ2FkYSBab25hXCIsXG5cdFx0YmVzdFNpbmdsZTogXCJNYWlzIFNpbXBsZXNcIixcblx0XHRhbGxTaWdodGxpbmVzOiBcIlRvZGFzIGFzIExpbmhhcyBkZSBWaXPDo29cIixcblx0XHRwZXJpbWV0ZXJTaWdodGxpbmVzOiBcIkxpbmhhcyBkZSBWaXPDo28gZG8gUGVyw61tZXRyb1wiLFxuXHRcdGZyZXF1ZW5jeTogXCJGcmVxdcOqbmNpYVwiLFxuXHRcdG9ic2VydmVyczogXCJPYnNlcnZhZG9yZXNcIixcblx0XHRtYWpvcml0eTogXCJNYWlvcmlhXCIsXG5cdFx0bWVkaWFuOiBcIk1lZGlhbmFcIixcblx0XHRtaW5vcml0eTogXCJNaW5vcmlhXCIsXG5cdFx0cGVyY2VudGlsZTogXCJQZXJjZW50aWxcIixcblx0XHRyYW5nZTogXCJJbnRlcnZhbG9cIixcblx0XHRzdW06IFwiU29tYVwiLFxuXHRcdHZhcmlldHk6IFwiVmFyaWVkYWRlXCIsXG5cdFx0bmR2aTogXCJORFZJXCIsXG5cdFx0c2F2aTogXCJTQVZJXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNNZXRob2RUU0FWSTogXCJTQVZJIFRyYW5zZm9ybWFkb1wiLFxuXHRcdGJhbmRBcml0aG1ldGljTWV0aG9kTVNBVkk6IFwiU0FWSSBNb2RpZmljYWRvXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNNZXRob2RTdWx0YW46IFwiRsOzcm11bGEgZGUgU3VsdGFuXCIsXG5cdFx0Z2VtaTogXCJHRU1JXCIsXG5cdFx0cHZpOiBcIlBWSVwiLFxuXHRcdGd2aTogXCJHVkkgKExhbmRzYXQgVE0pXCIsXG5cdFx0dmFyaTogXCJWQVJJXCIsXG5cdFx0c3I6IFwiU1JcIixcblx0XHRnbmR2aTogXCJHTkRWSVwiLFxuXHRcdG5kdmlyZTogXCJORFZJcmVcIixcblx0XHRzcnJlOiBcIlNScmVcIixcblx0XHRtdHZpMjogXCJNVFZJMlwiLFxuXHRcdHJ0dmlDb3JlOiBcIlJUVklDb3JlXCIsXG5cdFx0Y2lyZTogXCJDSXJlXCIsXG5cdFx0Y2lnOiBcIkNJZ1wiLFxuXHRcdG5kd2k6IFwiTkRXSVwiLFxuXHRcdGV2aTogXCJFVklcIixcblx0XHRpcm9uT3hpZGU6IFwiw5N4aWRvIGRlIEZlcnJvXCIsXG5cdFx0ZmVycm91c01pbmVyYWxzOiBcIk1pbmVyYWlzIEbDqXJyZW9zXCIsXG5cdFx0Y2xheU1pbmVyYWxzOiBcIk1pbmVyYWlzIGRvIEJhcnJvXCIsXG5cdFx0d25kd2k6IFwiV05EV0lcIixcblx0XHRiYWk6IFwiQkFJXCIsXG5cdFx0bW5kd2k6IFwiTU5EV0lcIixcblx0XHRuYnI6IFwiTkJSXCIsXG5cdFx0bmRiaTogXCJOREJJXCIsXG5cdFx0bmRtaTogXCJORE1JXCIsXG5cdFx0bmRzaTogXCJORFNJXCIsXG5cdFx0bG9jYWxTcXVhcmVSb290OiBcIlJhaXogUXVhZHJhZGFcIixcblx0XHRsb2NhbEFDb3M6IFwiQUNvc1wiLFxuXHRcdGxvY2FsQVNpbjogXCJBU2VuXCIsXG5cdFx0bG9jYWxBVGFuOiBcIkFUYW5cIixcblx0XHRsb2NhbEFUYW5IOiBcIkFUYW5IXCIsXG5cdFx0bG9jYWxBYnM6IFwiQWJzXCIsXG5cdFx0bG9jYWxCaXR3aXNlTm90OiBcIk7Do28gQml0d2lzZVwiLFxuXHRcdGxvY2FsQm9vbGVhbk5vdDogXCJOw6NvIEJvb2xlYW5vXCIsXG5cdFx0bG9jYWxDb3M6IFwiQ29zXCIsXG5cdFx0bG9jYWxDb3NIOiBcIkNvc0hcIixcblx0XHRsb2NhbEV4cDogXCJFeHBcIixcblx0XHRsb2NhbEV4cDEwOiBcIkV4cDEwXCIsXG5cdFx0bG9jYWxFeHAyOiBcIkV4cDJcIixcblx0XHRsb2NhbEludDogXCJJbnRcIixcblx0XHRsb2NhbElzTnVsbDogXCJOdWxvXCIsXG5cdFx0bG9jYWxGbG9hdDogXCJSZWFsXCIsXG5cdFx0bG9jYWxMbjogXCJMblwiLFxuXHRcdGxvY2FsTG9nMTA6IFwiTG9nMTBcIixcblx0XHRsb2NhbExvZzI6IFwiTG9nMlwiLFxuXHRcdGxvY2FsTmVnYXRlOiBcIk5lZ2F0aXZvXCIsXG5cdFx0bG9jYWxSb3VuZERvd246IFwiQXJyZWRvbmRhciBwYXJhIE1lbm9zXCIsXG5cdFx0bG9jYWxSb3VuZFVwOiBcIkFycmVkb25kYXIgcGFyYSBtYWlzXCIsXG5cdFx0bG9jYWxTaW46IFwiU2VuXCIsXG5cdFx0bG9jYWxTaW5IOiBcIlNlbkhcIixcblx0XHRsb2NhbFRhbjogXCJUYW5nZW50ZVwiLFxuXHRcdGxvY2FsVGFuSDogXCJUYW5IXCIsXG5cdFx0bG9jYWxBQ29zSDogXCJBQ29zSFwiLFxuXHRcdGxvY2FsQVNpbkg6IFwiQVNlbkhcIixcblx0XHRsb2NhbFBsdXM6IFwiQWRpw6fDo29cIixcblx0XHRsb2NhbE1pbnVzOiBcIlN1YnRyYWlyXCIsXG5cdFx0bG9jYWxUaW1lczogXCJNdWx0aXBsaWNhclwiLFxuXHRcdGxvY2FsUG93ZXI6IFwiUG90w6puY2lhXCIsXG5cdFx0bG9jYWxCaXR3aXNlQW5kOiBcIkUgQml0d2lzZVwiLFxuXHRcdGxvY2FsQml0d2lzZUxlZnRTaGlmdDogXCJNdWRhbsOnYSDDoCBFc3F1ZXJkYSBkZSBCaXR3aXNlXCIsXG5cdFx0bG9jYWxCaXR3aXNlT3I6IFwiT3UgQml0d2lzZVwiLFxuXHRcdGxvY2FsQml0d2lzZVJpZ2h0U2hpZnQ6IFwiRGVzbG9jYXIgw6AgRGlyZWl0YSBkbyBCaXR3aXNlXCIsXG5cdFx0bG9jYWxCaXR3aXNlWG9yOiBcIlhPdSBCaXR3aXNlXCIsXG5cdFx0bG9jYWxCb29sZWFuQW5kOiBcIkUgQm9vbGVhbm9cIixcblx0XHRsb2NhbEJvb2xlYW5PcjogXCJPdSBCb29sZWFub1wiLFxuXHRcdGxvY2FsQm9vbGVhblhvcjogXCJYT3UgQm9vbGVhblwiLFxuXHRcdGxvY2FsRGl2aWRlOiBcIkRpdmlkaXJcIixcblx0XHRsb2NhbEVxdWFsVG86IFwiSWd1YWwgQVwiLFxuXHRcdGxvY2FsR3JlYXRlclRoYW46IFwiTWFpb3IgUXVlXCIsXG5cdFx0bG9jYWxHcmVhdGVyVGhhbkVxdWFsOiBcIk1haW9yIHF1ZSBJZ3VhbFwiLFxuXHRcdGxvY2FsTGVzc1RoYW46IFwiTWVub3IgUXVlXCIsXG5cdFx0bG9jYWxMZXNzVGhhbkVxdWFsOiBcIk1lbm9yIHF1ZSBJZ3VhbFwiLFxuXHRcdGxvY2FsTW9kOiBcIk1vZFwiLFxuXHRcdGxvY2FsTm90RXF1YWw6IFwiTsOjbyBJZ3VhbFwiLFxuXHRcdGxvY2FsQVRhbjI6IFwiQVRhbjJcIixcblx0XHRsb2NhbFNxdWFyZTogXCJRdWFkcmFkb1wiLFxuXHRcdGxvY2FsU2V0TnVsbDogXCJEZWZpbmlyIE51bG9cIixcblx0XHRyZW1hcERlZlR5cGVMaXN0OiBcIkxpc3RhXCIsXG5cdFx0cmVtYXBEZWZUeXBlVGFibGU6IFwiVGFiZWxhXCIsXG5cdFx0cmVtYXBUYWJsZVR5cGVTaW1wbGU6IFwiU2ltcGxlc1wiLFxuXHRcdHJlbWFwVGFibGVUeXBlRHluYW1pYzogXCJEaW7Dom1pY29cIixcblx0XHRyZW1hcFRhYmxlVHlwZVJlYXNzaWdubWVudDogXCJSZWF0cmlidWnDp8Ojb1wiLFxuXHRcdGdlb21Db3JyZWN0aW9uQnlDb25zdFo6IFwiVXRpbGl6YXIgQ29uc3RhbnRlIFpcIixcblx0XHRnZW9tQ29ycmVjdGlvbkJ5REVNOiBcIlV0aWxpemFyIERFTVwiLFxuXHRcdHJhZGFyQ2FsaWJCZXRhTm91Z2h0OiBcIkJldGEgemVyb1wiLFxuXHRcdHJhZGFyQ2FsaWJTaWdtYU5vdWdodDogXCJTaWdtYSB6ZXJvXCIsXG5cdFx0cmFkYXJDYWxpYkdhbW1hTm91Z2h0OiBcIkdhbWEgemVyb1wiLFxuXHRcdHNwZWNrbGVGaWx0ZXJUeXBlTGVlOiBcIkZpbHRybyBkZSBMZWVcIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUVuaGFuY2VkTGVlOiBcIkZpbHRybyBkZSBMZWUgTWVsaG9yYWRvXCIsXG5cdFx0c3BlY2tsZUZpbHRlclR5cGVGcm9zdDogXCJGaWx0cm8gZGUgRnJvc3RcIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUt1YW46IFwiRmlsdHJvIGRlIEt1YW5cIixcblx0XHRzcGVja2xlTm9pc2VNb2RlbE11bDogXCJSdcOtZG8gTXVsdGlwbGljYXRpdm9cIixcblx0XHRzcGVja2xlTm9pc2VNb2RlbEFkZDogXCJSdcOtZG8gQWRpdGl2b1wiLFxuXHRcdHNwZWNrbGVOb2lzZU1vZGVsQWRkbk11bDogXCJSdcOtZG8gTXVsdGlwbGljYXRpdm8gZSBBZGl0aXZvXCIsXG5cdFx0bW9zYWljT3BUeXBlRmlyc3Q6IFwiUHJpbWVpcm9cIixcblx0XHRtb3NhaWNPcFR5cGVMYXN0OiBcIsOabHRpbW9cIixcblx0XHRtb3NhaWNPcFR5cGVNaW46IFwiTcOtblwiLFxuXHRcdG1vc2FpY09wVHlwZU1heDogXCJNw6F4XCIsXG5cdFx0bW9zYWljT3BUeXBlTWVhbjogXCJNw6lkaWFcIixcblx0XHRtb3NhaWNPcFR5cGVCbGVuZDogXCJNZXNjbGFyXCIsXG5cdFx0bW9zYWljT3BUeXBlU3VtOiBcIlNvbWFcIixcblx0XHRpbnRlZ2VyOiBcIkludGVpcm9cIixcblx0XHRyZnhEODogXCJEOFwiLFxuXHRcdHJmeE1GRDogXCJNRkRcIixcblx0XHRkaW5mOiBcIkRpbmZcIixcblx0XHR2ZXJ0aWNhbDogXCJWZXJ0aWNhbFwiLFxuXHRcdGhvcml6b250YWw6IFwiSG9yaXpvbnRhbFwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYWpvcml0eTogXCJNYWlvcmlhXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01heDogXCJNw6F4aW1vXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lYW46IFwiTcOpZGlhXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lZGlhbjogXCJNZWRpYW5hXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01pbjogXCJNw61uaW1vXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01pbm9yaXR5OiBcIk1pbm9yaWFcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzUmFuZ2U6IFwiSW50ZXJ2YWxvXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1N0ZERldjogXCJEZXN2aW8gUGFkcsOjb1wiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NTdW06IFwiU29tYVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NWYXJpZXR5OiBcIlZhcmllZGFkZVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYWpvcml0eUlnbm9yZU5EOiBcIk1haW9yaWEgKElnbm9yYXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYXhJZ25vcmVORDogXCJNw6F4aW1vIChJZ25vcmFyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWVhbklnbm9yZU5EOiBcIk3DqWRpYSAoSWdub3JhciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lZGlhbklnbm9yZU5EOiBcIk1lZGlhbmEgKElnbm9yYXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNaW5JZ25vcmVORDogXCJNw61uaW1vIChJZ25vcmFyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWlub3JpdHlJZ25vcmVORDogXCJNaW5vcmlhIChJZ25vcmFyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzUmFuZ2VJZ25vcmVORDogXCJJbnRlcnZhbG8gKElnbm9yYXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NTdGREZXZJZ25vcmVORDogXCJEZXN2aW8gUGFkcsOjbyAoSWdub3JhciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1N1bUlnbm9yZU5EOiBcIlNvbWEgKElnbm9yYXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NWYXJpZXR5SWdub3JlTkQ6IFwiVmFyaWVkYWRlIChJZ25vcmFyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzVHlwZVBlcmNlbnRpbGVJZ25vcmVORDogXCJQZXJjZW50aWwgKGlnbm9yYXIgTm9EYXRhKVwiLFxuXHRcdGZyb21Tb3VyY2U6IFwiRGEgT3JpZ2VtXCIsXG5cdFx0dG9Tb3VyY2U6IFwiUGFyYSBPcmlnZW1cIixcblx0XHRjb2xvcnNwYWNlQ29udmVyc2lvblJnYlRvSHN2OiBcIlJHQiBwYXJhIEhTVlwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uSHN2VG9SZ2I6IFwiSFNWIHBhcmEgUkdCXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVJSFM6IFwiSUhTXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVCcm92ZXk6IFwiQnJvdmV5XCIsXG5cdFx0cGFuc2hhcnBlblR5cGVFc3JpOiBcIkVzcmlcIixcblx0XHRwYW5zaGFycGVuVHlwZU1lYW46IFwiTcOpZGlhXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVHcmFtU2NobWlkdDogXCJHcmFtU2NobWlkdFwiLFxuXHRcdHJlY3RhbmdsZU5laWdoYm9yaG9vZDogXCJSZXTDom5ndWxvXCIsXG5cdFx0Y2lyY2xlTmVpZ2hib3Job29kOiBcIkPDrXJjdWxvXCIsXG5cdFx0YW5udWx1c05laWdoYm9yaG9vZDogXCJBbmVsYXJcIixcblx0XHR3ZWRnZU5laWdoYm9yaG9vZDogXCJDdW5oYVwiLFxuXHRcdGlycmVndWxhck5laWdoYm9yaG9vZDogXCJJcnJlZ3VsYXJcIixcblx0XHR3ZWlnaHROZWlnaGJvcmhvb2Q6IFwiUGVzb1wiLFxuXHRcdGZvdXI6IFwiUXVhdHJvXCIsXG5cdFx0ZWlnaHQ6IFwiT2l0b1wiLFxuXHRcdHdpdGhpbjogXCJEZW50cm9cIixcblx0XHRjcm9zczogXCJUcmFuc3ZlcnNhbFwiLFxuXHRcdGFkZExpbms6IFwiQWRpY2lvbmFyIExpbmtcIixcblx0XHRub0xpbms6IFwiTmVuaHVtIExpbmtcIixcblx0XHR3ZWlnaHRlZE1lYW46IFwiTcOpZGlhIFBvbmRlcmFkYVwiLFxuXHRcdGxzOFFDQml0UGF0dGVybkNpcnJ1czogXCJMYW5kc2F0IDggQ2lycm9zXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuQ2xvdWQ6IFwiTGFuZHNhdCA4IE51dmVtXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuQ2xvdWRTaGFkb3c6IFwiTGFuZHNhdCA4IFNvbWJyYSBkZSBOdXZlbVwiLFxuXHRcdGxzOFFDQml0UGF0dGVybkRlc2lnbmF0ZWRGaWxsOiBcIkxhbmRzYXQgOCBQcmVlbmNoaW1lbnRvIERlc2lnbmFkb1wiLFxuXHRcdGxzOFFDQml0UGF0dGVybkRyb3BwZWRGcmFtZTogXCJMYW5kc2F0IDggRXN0cnV0dXJhIERhbmlmaWNhZGFcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5Tbm93SWNlOiBcIkxhbmRzYXQgOCBOZXZlL0dlbG9cIixcblx0XHRsczhRQ0JpdFBhdHRlcm5UZXJyYWluT2NjbHVzaW9uOiBcIkxhbmRzYXQgOCBPY2x1c8OjbyBkZSBUZXJyZW5vXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuVmVnZXRhdGlvbjogXCJMYW5kc2F0IDggVmVnZXRhw6fDo29cIixcblx0XHRsczhRQ0JpdFBhdHRlcm5XYXRlcjogXCJMYW5kc2F0IDggw4FndWFcIixcblx0XHRkb3duU3RyZWFtOiBcIkNvcnJlbnRlIEluYXRpdmFcIixcblx0XHR1cFN0cmVhbTogXCJDb3JyZW50ZSBBdGl2YVwiLFxuXHRcdHN0cmFobGVyOiBcIlNUUkFITEVSXCIsXG5cdFx0c2hyZXZlOiBcIlNIUkVWRVwiLFxuXHRcdGN1cnJlbnRTbGljZTogXCJEaXZpc8OjbyBBdHVhbFwiLFxuXHRcdGFsbFNsaWNlczogXCJUb2RhcyBhcyBEaXZpc8O1ZXNcIixcblx0XHRleHBhbmREaXN0YW5jZTogXCJESVNUw4JOQ0lBXCIsXG5cdFx0ZXhwYW5kTW9ycGhvbG9naWNhbDogXCJNT1JGT0zDk0dJQ09cIixcblx0XHRzcGVjdHJhbFByb2ZpbGVGaWxlOiBcIlBlcmZpbCBFc3BlY3RyYWxcIixcblx0XHR0cmFpbmluZ0ZlYXR1cmVGaWxlOiBcIkZlacOnw6NvIGRlIFRyZWluYW1lbnRvXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZVVuaWZvcm06IFwiVW5pZm9ybWVcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlVW5pZm9ybUludGVnZXI6IFwiSW50ZWlyb1wiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVOb3JtYWw6IFwiTm9ybWFsXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZUV4cG9uZW50aWFsOiBcIkV4cG9uZW5jaWFsXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZVBvaXNzb246IFwiUG9pc3NvblwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVHYW1tYTogXCJHYW1hXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZUJpbm9taWFsOiBcIkJpbsO0bWlvXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZUdlb21ldHJpYzogXCJHZW9tw6l0cmljb1wiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVOZWdhdGl2ZUJpbm9taWFsOiBcIkJpbsO0bWlvIE5lZ2F0aXZvXCIsXG5cdFx0cmFuZG9tR2VuZXJhdG9yVHlwZVN0YW5kYXJkQ1JhbmQ6IFwiU3RhbmRhcmQgQyBSYW5kXCIsXG5cdFx0cmFuZG9tR2VuZXJhdG9yVHlwZUFsZ29yaXRobUFDTTU5OTogXCJBbGdvcml0bW8gQUNNIGNvbGV0YWRvIDU5OVwiLFxuXHRcdHJhbmRvbUdlbmVyYXRvclR5cGVNZXJzZW5uZVR3aXN0ZXI6IFwiTWVyc2VubmUgVHdpc3RlclwiLFxuXHRcdHN1bU5hbWU6IFwiU29tYVwiLFxuXHRcdG1lZGFpbk5hbWU6IFwiTWVkaWFuYVwiLFxuXHRcdHRyZW5kTGluZWFyOiBcIkxpbmVhclwiLFxuXHRcdHRyZW5kSGFybW9uaWM6IFwiSGFybcO0bmljb1wiLFxuXHRcdHRyZW5kUG9seW5vbWlhbDogXCJQb2xpbm9taWFsXCIsXG5cdFx0dHJlbmRNYW5uS2VuZGFsbDogXCJNYW5uLUtlbmRhbGxcIixcblx0XHR0cmVuZFNlYXNvbmFsS2VuZGFsbDogXCJLZW5kYWxsIFNhem9uYWxcIixcblx0XHRkaW1lbnNpb25CeVZhbHVlOiBcIlBvciBWYWxvclwiLFxuXHRcdGRpbWVuc2lvbkJ5SW50ZXJ2YWw6IFwiUG9yIEludGVydmFsb1wiLFxuXHRcdG1kaW1EZWZUeXBlQWxsOiBcIlRvZG9zXCIsXG5cdFx0bWRpbURlZlR5cGVCeVZhbHVlczogXCJQb3IgVmFsb3Jlc1wiLFxuXHRcdG1kaW1EZWZUeXBlQnlSYW5nZXM6IFwiUG9yIEludGVydmFsb3NcIixcblx0XHRtZGltRGVmVHlwZUJ5SXRlcmF0aW9uOiBcIlBvciBJdGVyYcOnw6NvXCIsXG5cdFx0bWRpbURlZlR5cGVCeUludGVydmFsOiBcIlBvciBJbnRlcnZhbG9cIixcblx0XHRtZGltRGVmVHlwZUJ5VGFyZ2V0UmFzdGVyOiBcIlBvciBSYXN0ZXIgZGUgRGVzdGlub1wiLFxuXHRcdGVzcmlUaW1lVW5pdHNIb3VyczogXCJIb3Jhc1wiLFxuXHRcdGVzcmlUaW1lVW5pdHNEYXlzOiBcIkRpYXNcIixcblx0XHRlc3JpVGltZVVuaXRzV2Vla3M6IFwiU2VtYW5hc1wiLFxuXHRcdGVzcmlUaW1lVW5pdHNNb250aHM6IFwiTWVzZXNcIixcblx0XHRlc3JpVGltZVVuaXRzWWVhcnM6IFwiQW5vc1wiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkSG91cmx5OiBcIkEgQ2FkYSBIb3JhXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmREYWlseTogXCJEaWFyaWFtZW50ZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkV2Vla2x5OiBcIlNlbWFuYWxtZW50ZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkRGVrYWRseTogXCJEw6ljYWRhc1wiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUGVudGFkbHk6IFwiUXVpbnF1w6puaW9cIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZE1vbnRobHk6IFwiTWVuc2FsbWVudGVcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFF1YXJ0ZXJseTogXCJUcmltZXN0cmFsXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRZZWFybHk6IFwiQW51YWxtZW50ZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUmVjdXJyaW5nRGFpbHk6IFwiRGlhcmlhbWVudGUgcmVjb3JyZW50ZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUmVjdXJyaW5nV2Vla2x5OiBcIlNlbWFuYWxtZW50ZSByZWNvcnJlbnRlXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRSZWN1cnJpbmdNb250aGx5OiBcIk1lbnNhbG1lbnRlIHJlY29ycmVudGVcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ1F1YXJ0ZXJseTogXCJUcmltZXN0cmFsbWVudGUgcmVjb3JyZW50ZVwiLFxuXHRcdGFnZ0RlZlR5cGVBbGw6IFwiVG9kb3NcIixcblx0XHRhZ2dEZWZUeXBlSW50ZXJ2YWxLZXl3b3JkOiBcIlBhbGF2cmEtY2hhdmUgZGUgSW50ZXJ2YWxvXCIsXG5cdFx0YWdnRGVmVHlwZUludGVydmFsVmFsdWU6IFwiVmFsb3IgZG8gSW50ZXJ2YWxvXCIsXG5cdFx0YWdnRGVmVHlwZUludGVydmFsUmFuZ2VzOiBcIkZhaXhhcyBkZSBJbnRlcnZhbG9cIixcblx0XHRsYXRlc3RDaGFuZ2U6IFwiSG9yYSBkYSDDmmx0aW1hIEFsdGVyYcOnw6NvXCIsXG5cdFx0ZWFybGllc3RDaGFuZ2U6IFwiSG9yYSBkYSBQcmltZWlyYSBBbHRlcmHDp8Ojb1wiLFxuXHRcdGxhcmdlc3RDaGFuZ2U6IFwiSG9yYSBkYSBNYWlvciBBbHRlcmHDp8Ojb1wiLFxuXHRcdG51bWJlck9mQ2hhbmdlczogXCJOw7ptZXJvIGRlIEFsdGVyYcOnw7Vlc1wiLFxuXHRcdGxvbmdlc3RDaGFuZ2U6IFwiVGVtcG8gZGUgQWx0ZXJhw6fDo28gbWFpcyBMb25nb1wiLFxuXHRcdHNob3J0ZXN0Q2hhbmdlOiBcIlRlbXBvIGRlIEFsdGVyYcOnw6NvIE1lbm9yXCIsXG5cdFx0ZmFzdGVzdENoYW5nZTogXCJUZW1wbyBkZSBBbHRlcmHDp8OjbyBNYWlzIFLDoXBpZG9cIixcblx0XHRzbG93ZXN0Q2hhbmdlOiBcIlRlbXBvIGRlIEFsdGVyYcOnw6NvIE1haXMgTGVudG9cIixcblx0XHRhbGxDaGFuZ2VzOiBcIlRvZG9zXCIsXG5cdFx0aW5jcmVhc2VDaGFuZ2VzOiBcIkF1bWVudGFyXCIsXG5cdFx0ZGVjcmVhc2VDaGFuZ2VzOiBcIkRpbWludWlyXCIsXG5cdFx0c2VnbWVudEJlZ2lubmluZzogXCJJbsOtY2lvIGRvIHNlZ21lbnRvXCIsXG5cdFx0c2VnbWVudEVuZDogXCJGaW5hbCBkbyBzZWdtZW50b1wiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kRGlmZmVyZW5jZTogXCJEaWZlcmVuw6dhXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2RSZWxhdGl2ZURpZmZlcmVuY2U6IFwiRGlmZXJlbsOnYSBSZWxhdGl2YVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kQ2F0ZWdvcmljYWw6IFwiRGlmZXJlbsOnYSBDYXRlZ8OzcmljYVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kTXVsdGlzcGVjdHJhbEV1Y2xpZGVhbkRpc3RhbmNlOiBcIkRpc3TDom5jaWEgRXVjbGlkaWFuYSBFc3BlY3RyYWxcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZE11bHRpc3BlY3RyYWxBbmd1bGFyRGlmZmVyZW5jZTogXCJEaWZlcmVuw6dhIGRlIMOCbmd1bG8gRXNwZWN0cmFsXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2RNdWx0aXNwZWN0cmFsQXhpc1dpdGhCaWdnZXN0Q2hhbmdlOiBcIkJhbmRhIENvbSBNYWlzIEFsdGVyYcOnw7Vlc1wiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlS2VlcEFsbDogXCJNYW50ZXIgVG9kb3NcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZUtlZXBDaGFuZ2VkT25seTogXCJNYW50ZXIgU29tZW50ZSBQaXhlbHMgQWx0ZXJhZG9zXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VLZWVwVW5jaGFuZ2VkT25seTogXCJNYW50ZXIgU29tZW50ZSBQaXhlbHMgTsOjbyBBbHRlcmFkb3NcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZVVzZUNvbG9yQXZlcmFnZTogXCJNw6lkaWEgRGUgZSBQYXJhIENvcmVzXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VVc2VDb2xvckZyb206IFwiVXRpbGl6YXIgRGUgQ29yZXNcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZVVzZUNvbG9yVG86IFwiVXRpbGl6YXIgUGFyYSBDb3Jlc1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQmluYXJ5OiBcIkJpbsOhcmlvXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Gb3J3YXJkOiBcIlBhcmEgRnJlbnRlXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25MaW5lYXI6IFwiTGluZWFyXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25JbnZMaW5lYXI6IFwiTGluZWFyIEludmVyc29cIixcblx0XHRmYWN0b3JGdW5jdGlvblRhYmxlOiBcIlRhYmVsYVwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU3ltTGluZWFyOiBcIkxpbmVhciBTaW3DqXRyaWNvXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TeW1JbnZMaW5lYXI6IFwiTGluZWFyIFNpbcOpdHJpY28gSW52ZXJzb1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQ29zOiBcIkNvLXNlbm9cIixcblx0XHRmYWN0b3JGdW5jdGlvblNlYzogXCJTZWNhbnRlXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Db3NTZWM6IFwiQ28tc2VubyBTZWNhbnRlXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TZWNDb3M6IFwiU2VjYW50ZSBDby1zZW5vXCIsXG5cdFx0bm9Tb3J0OiBcIk7Do28gQ2xhc3NpZmljYXJcIixcblx0XHRhc2NlbmQ6IFwiQXNjZW5kZW50ZVwiLFxuXHRcdGRlc2NlbmQ6IFwiRGVzY2VuZGVudGVcIixcblx0XHRhdXRvRGV0ZWN0OiBcIkRldGVjw6fDo28gYXV0b23DoXRpY2FcIixcblx0XHRuZWFyZXN0OiBcIk1haXMgUHLDs3hpbW9cIixcblx0XHRsaW5lYXI6IFwiTGluZWFyXCIsXG5cdFx0ZXNyaU1vbnRoSmFudWFyeTogXCJKYW5laXJvXCIsXG5cdFx0ZXNyaU1vbnRoRmVicnVhcnk6IFwiRmV2ZXJlaXJvXCIsXG5cdFx0ZXNyaU1vbnRoTWFyY2g6IFwiTWFyw6dvXCIsXG5cdFx0ZXNyaU1vbnRoQXByaWw6IFwiQWJyaWxcIixcblx0XHRlc3JpTW9udGhNYXk6IFwiTWFpb1wiLFxuXHRcdGVzcmlNb250aEp1bmU6IFwiSnVuaG9cIixcblx0XHRlc3JpTW9udGhKdWx5OiBcIkp1bGhvXCIsXG5cdFx0ZXNyaU1vbnRoQXVndXN0OiBcIkFnb3N0b1wiLFxuXHRcdGVzcmlNb250aFNlcHRlbWJlcjogXCJTZXRlbWJyb1wiLFxuXHRcdGVzcmlNb250aE9jdG9iZXI6IFwiT3V0dWJyb1wiLFxuXHRcdGVzcmlNb250aE5vdmVtYmVyOiBcIk5vdmVtYnJvXCIsXG5cdFx0ZXNyaU1vbnRoRGVjZW1iZXI6IFwiRGV6ZW1icm9cIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ0lnbm9yZU5vRGF0YTogXCJEYWRvc1wiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nUHJvcGFnYXRlTm9EYXRhOiBcIk5vRGF0YVwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nRmlsbE9ubHlOb0RhdGE6IFwiUHJlZW5jaGltZW50byBkZSBOb0RhdGFcIixcblx0XHRjaXJjdWxhck1lYW46IFwiTcOpZGlhIENpcmN1bGFyXCIsXG5cdFx0Y2lyY3VsYXJOYW1lOiBcIkNpcmN1bGFyXCIsXG5cdFx0YXJpdGhtZXRpY05hbWU6IFwiQXJpdG3DqXRpY29cIixcblx0XHRzbG9wZU5hbWU6IFwiRGVjbGl2aWRhZGVcIixcblx0XHRhc3BlY3ROYW1lOiBcIkFzcGVjdG9cIixcblx0XHRtZWFuQ3VydmF0dXJlOiBcIkN1cnZhdHVyYSBtw6lkaWFcIixcblx0XHRwcm9maWxlQ3VydmF0dXJlOiBcIkN1cnZhdHVyYSBkbyBwZXJmaWwgKGxpbmhhIGRlIGRlY2xpdmlkYWRlIG5vcm1hbClcIixcblx0XHR0YW5nZW50aWFsQ3VydmF0dXJlOiBcIkN1cnZhdHVyYSB0YW5nZW5jaWFsIChjdXJ2YSBkZSBuw612ZWwgbm9ybWFsKVwiLFxuXHRcdHBsYW5DdXJ2YXR1cmU6IFwiQ3VydmF0dXJhIGRvIHBsYW5vIChjdXJ2YSBkZSBuw612ZWwgcHJvamV0YWRhKVwiLFxuXHRcdGNvbnRvdXJHZW9kZXNpY1RvcnNpb246IFwiVG9yw6fDo28gZ2VvZMOpc2ljYSBkZSBjdXJ2YSBkZSBuw612ZWxcIixcblx0XHRnYXVzc2lhbkN1cnZhdHVyZTogXCJDdXJ2YXR1cmEgR2F1c3NpYW5hXCIsXG5cdFx0Y2Fzb3JhdGlDdXJ2YXR1cmU6IFwiQ3VydmF0dXJhIGRlIENhc29yYXRpXCIsXG5cdFx0bG9jYWxTdXJmYWNlVHlwZVF1YWRyYXRpYzogXCJRdWFkcsOhdGljb1wiLFxuXHRcdGxvY2FsU3VyZmFjZVR5cGVCaXF1YWRyYXRpYzogXCJCaXF1YWRyw6F0aWNvXCIsXG5cdFx0dGhyZXNob2xkTm9UaHJlc2hvbGQ6IFwiU2VtIExpbWl0ZVwiLFxuXHRcdHRocmVzaG9sZFBlcmNlbnRMZWFzdENvc3Q6IFwiUG9yY2VudGFnZW0gZGUgTWVub3IgQ3VzdG9cIixcblx0XHR0aHJlc2hvbGRBY2N1bXVsYXRpdmVDb3N0OiBcIkN1c3RvIEFjdW11bGF0aXZvXCIsXG5cdFx0Y2xybWFwVHlwZUhpbGxzaGFkZTogXCJSZWxldm8gU29tYnJlYWRvXCJcblx0fSxcblx0Y2F0ZWdvcnlMYWJlbHM6IHtcblx0XHRzb3VyY2VDaGFyYWN0ZXJpc3RpY3M6IFwiQ2FyYWN0ZXLDrXN0aWNhcyBkZSBPcmlnZW1cIixcblx0XHRuZWlnaGJvcmhvb2RTZXR0aW5nczogXCJDb25maWd1cmHDp8O1ZXMgZGUgVml6aW5oYW7Dp2FcIixcblx0XHRzdGF0aXN0aWNzOiBcIkVzdGF0w61zdGljYVwiLFxuXHRcdGdhbW1hOiBcIkdhbWFcIixcblx0XHR2aWV3c2hlZFBhcmFtZXRlcnM6IFwiUGFyw6JtZXRyb3MgZG8gUGFub3JhbWFcIixcblx0XHRvYnNlcnZlclBhcmFtZXRlcnM6IFwiUGFyw6JtZXRyb3MgZG8gT2JzZXJ2YWRvclwiLFxuXHRcdGlycmVndWxhckRhdGFJbnRlcnBvbGF0aW9uOiBcIkludGVycG9sYcOnw6NvIGRlIERhZG9zIElycmVndWxhcmVzXCIsXG5cdFx0bW9kZWxTdGF0aXN0aWNzOiBcIkVzdGF0w61zdGljYSBkbyBNb2RlbG9cIixcblx0XHRhZ2dyZWdhdGlvbkRlZjogXCJEZWZpbmnDp8OjbyBkZSBBZ3JlZ2HDp8Ojb1wiLFxuXHRcdGZpbHRlckJ5QXR0cmlidXRlczogXCJGaWx0cmFyIFBvciBBdHJpYnV0b3NcIixcblx0XHRwZXJjZW50aWxlTmFtZTogXCJQZXJjZW50aWxcIixcblx0XHRyYXN0ZXJJbmZvOiBcIkluZm9ybWHDp8O1ZXMgZG8gUmFzdGVyXCIsXG5cdFx0ZXh0ZW50OiBcIkV4dGVuc8Ojb1wiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2U6IFwiUmVmZXLDqm5jaWEgRXNwYWNpYWxcIlxuXHR9LFxuXHRvdXRwdXRSYXN0ZXJIZWxwVGV4dHM6IHtcblx0XHRvdXRwdXROYW1lOiBcIjxwPk8gbm9tZSBkYSBjYW1hZGEgcXVlIHNlcsOhIGNyaWFkYSBlIGFkaWNpb25hZGEgYW8gbWFwYS48L3A+XCIsXG5cdFx0cmVzdWx0VHlwZTogXCI8cD5PIHRpcG8gZGUgc2HDrWRhIHF1ZSBzZXLDoSBjcmlhZG8uIEFzIHNhw61kYXMgcG9kZW0gc2VyIGNhbWFkYXMgZGUgaW1hZ2VucyBtb3NhaWNhZGFzIG91IGNhbWFkYXMgZGUgaW1hZ2VucyBkaW7Dom1pY2FzLjwvcD5cIixcblx0XHRzYXZlUmVzdWx0SW46IFwiPHA+TyBub21lIGRhIHBhc3RhIGVtIDxiPk1ldSBjb250ZcO6ZG88L2I+IG9uZGUgbyByZXN1bHRhZG8gc2Vyw6Egc2Fsdm8uPC9wPlwiXG5cdH0sXG5cdGFuYWx5c2lzRW52aXJvbm1lbnRzSGVscFRleHRzOiB7XG5cdFx0ZGVzY3JpcHRpb246IFwiPHA+Q29uZmlndXJhw6fDtWVzIGRvIGFtYmllbnRlIHBhcmEgYW7DoWxpc2Ugbm8gTWFwIFZpZXdlci4gPC9wPlwiLFxuXHRcdG91dFNSOiBcIjxwPkVzcGVjaWZpY2EgbyBzaXN0ZW1hIGRlIGNvb3JkZW5hZGFzIHBhcmEgYW7DoWxpc2UgZSBhIGNhbWFkYSByZXN1bHRhbnRlLjwvcD5cIixcblx0XHRleHRlbnQ6IFwiPHA+RXNwZWNpZmljYSBhIMOhcmVhIGEgc2VyIHVzYWRhIHBhcmEgYW7DoWxpc2UuPC9wPlwiLFxuXHRcdHNuYXBSYXN0ZXI6IFwiPHA+QWp1c3RhIGEgZXh0ZW5zw6NvIGRhIHNhw61kYSBwYXJhIHF1ZSBjb3JyZXNwb25kYSBhbyBhbGluaGFtZW50byBkYSBjw6lsdWxhIGRhIGNhbWFkYSByYXN0ZXIgZGUgYWp1c3RlIGVzcGVjaWZpY2FkYS48L3A+XCIsXG5cdFx0Y2VsbFNpemU6IFwiPHA+RXNwZWNpZmljYSBvIHRhbWFuaG8gb3UgcmVzb2x1w6fDo28gZGEgY8OpbHVsYSBxdWUgc2Vyw6EgdXNhZGEgcGFyYSBhbsOhbGlzZSBlIHBhcmEgY3JpYXIgYSBjYW1hZGEgcmFzdGVyIGRlIHNhw61kYS48L3A+XCIsXG5cdFx0bWFzazogXCI8cD5Fc3BlY2lmaWNhIHVtYSBjYW1hZGEgZGUgbcOhc2NhcmEsIG5hIHF1YWwgYXBlbmFzIGFzIGPDqWx1bGFzIHF1ZSBzZSBlbnF1YWRyYW0gbmEgw6FyZWEgZGUgbcOhc2NhcmEgc2Vyw6NvIHVzYWRhcyBwYXJhIGFuw6FsaXNlLjwvcD5cIixcblx0XHRyZXNhbXBsaW5nTWV0aG9kOiBcIjxwPkVzcGVjaWZpY2EgY29tbyBpbnRlcnBvbGFyIHZhbG9yZXMgZGUgcGl4ZWwgcXVhbmRvIG9zIHJhc3RlcnMgZGUgZW50cmFkYSBlIHNhw61kYSBuw6NvIHNlIGFsaW5oYW0uPC9wPlwiXG5cdH0sXG5cdG1haW5HZW5TdHJpbmdzOiB7XG5cdFx0dW5zdXBwb3J0ZWREYXRhVHlwZTogXCJUaXBvIG7Do28gc3Vwb3J0YWRvXCIsXG5cdFx0Y3VycmVudGx5VW5zdXBwb3J0ZWQ6IFwiIFVtIGVkaXRvciBwYWRyw6NvIHBhcmEgbyAke21pc3NpbmdUeXBlfSBlc3TDoSBwZW5kZW50ZSwgbWFzIHNlcsOhIGxhbsOnYWRvIGVtIGJyZXZlLiBDYWl4YSBkZSB0ZXh0byB0ZW1wb3LDoXJpYSBkbyBlc3Bhw6dvIHJlc2VydmFkbyBwYXJhIGVzcGVjaWZpY2FyIGVudHJhZGFzIGJhc2VhZGFzIGVtIHN0cmluZy5cIixcblx0XHR1bnN1cHBvcnRlZE92ZXJyaWRlV2FybmluZzogXCJVbSBjb21wb25lbnRlIGRvIGVkaXRvciBkZSBzdWJzdGl0dWnDp8OjbyBxdWUgZm9ybmVjZSB1bSBVWCBtZWxob3IgcGFyYSB0cmFiYWxoYXIgY29tIG9zIHNlZ3VpbnRlcyBwYXLDom1ldHJvcywgZXN0w6EgcGVuZGVudGUsIG1hcyBzZXLDoSBsYW7Dp2FkbyBlbSBicmV2ZTpcIixcblx0XHRvdmVycmlkZVdpZGdldE1pc3Npbmc6IFwiQ29tcG9uZW50ZSBkbyBlZGl0b3IgZGUgc3Vic3RpdHVpw6fDo28gYXVzZW50ZSFcIixcblx0XHR1aUluY29tcGxldGU6IFwiRmFsaGEgYW8gZW52aWFyIHRyYWJhbGhvLiBBIGZ1bsOnw6NvIG7Do28gcG9kZSBzZXIgZXhlY3V0YWRhLCBwb2lzIGFsZ3VucyBkb3MgY2FtcG9zIG9icmlnYXTDs3Jpb3MgZXN0w6NvIGluY29tcGxldG9zIG91IGF1c2VudGVzIG5hIGludGVyZmFjZSBkbyB1c3XDoXJpby5cIixcblx0XHRjb3VudDogXCJDb250YWdlbVwiLFxuXHRcdHNlbGVjdFZhcmlhYmxlczogXCJTZWxlY2lvbmFyIHZhcmnDoXZlaXNcIixcblx0XHRzZWxlY3RGZWF0dXJlOiBcIlNlbGVjaW9uZSB1bWEgY2FtYWRhIGRlIGZlacOnw6NvXCIsXG5cdFx0Z3JlYXRlclRoYW5FcnJvck1lc3NhZ2U6IFwiTyBuw7ptZXJvIGRlIGVudHJhZGEgZGV2ZSBzZXIgbWFpb3IgcXVlICR7bWlufVwiLFxuXHRcdGxlc3NlclRoYW5FcnJvck1lc3NhZ2U6IFwiTyBuw7ptZXJvIGRlIGVudHJhZGEgZGV2ZSBzZXIgbWVub3IgcXVlICR7bWF4fVwiLFxuXHRcdGdyZWF0ZXJUaGFuT3JFcXVhbEVycm9yTWVzc2FnZTogXCJPIG7Dum1lcm8gZGUgZW50cmFkYSBkZXZlIHNlciBtYWlvciBvdSBpZ3VhbCBhICR7bWlufVwiLFxuXHRcdGxlc3NlclRoYW5PckVxdWFsRXJyb3JNZXNzYWdlOiBcIk8gbsO6bWVybyBkZSBlbnRyYWRhIGRldmUgc2VyIG1lbm9yIG91IGlndWFsIGEgJHttYXh9XCIsXG5cdFx0YWxsb3dTY2FsYXI6IFwiU2VsZWNpb25lIHVtYSBjYW1hZGEgb3UgaW5zaXJhIHVtYSBjb25zdGFudGVcIixcblx0XHRzZWxlY3RGaWVsZDogXCJTZWxlY2lvbmFyIGNhbXBvXCIsXG5cdFx0cGFyYW1ldGVyUmVxdWlyZWQ6IFwiRXN0ZSBwYXLDom1ldHJvIMOpIGV4aWdpZG8uc1wiLFxuXHRcdGVudGVyQVZhbHVlOiBcIkluc2VyaXIgdW0gdmFsb3IuLi5cIixcblx0XHRpbnZhbGlkSW5wdXQ6IFwiTyB2YWxvciBpbnNlcmlkbyBuw6NvIMOpIHbDoWxpZG8uXCIsXG5cdFx0aXRlbU5vdEZvdW5kOiBcIk8gaXRlbSBuw6NvIGV4aXN0ZSBvdSBlc3TDoSBpbmFjZXNzw612ZWwuXCIsXG5cdFx0aXRlbVBlcm1pc3Npb25EZW5pZWQ6IFwiVm9jw6ogbsOjbyB0ZW0gcGVybWlzc8O1ZXMgcGFyYSBhY2Vzc2FyIGVzdGUgaXRlbS5cIixcblx0XHRsYXllck5vdEF2YWlsYWJsZTogXCJGYWxoYSBhbyBjYXJyZWdhciBhIGNhbWFkYSAke2xheWVyTmFtZX0uXCIsXG5cdFx0bXVsdGlwbGVMYXllcnNOb3RBdmFpbGFibGU6IFwiRmFsaGEgYW8gY2FycmVnYXIgY2FtYWRhICR7bGF5ZXJOYW1lfSBlIG91dHJvcy5cIixcblx0XHRsZWFybk1vcmVMYWJlbDogXCJPYnRlbmhhIE1haXMgSW5mb3JtYcOnw7Vlc1wiLFxuXHRcdGZpZWxkTm90QXZhaWxhYmxlOiBcIkZhbGhhIGFvIGNhcnJlZ2FyIG8gY2FtcG8uXCIsXG5cdFx0YWxsb3dBbmFseXNpczogXCJBIGFuw6FsaXNlIG7Do28gw6kgcGVybWl0aWRhIG5vIHNlcnZpw6dvIGRlIGltYWdlbS5cIixcblx0XHRhbGxvd0FuYWx5c2lzUmVhc29uOiBcIlVtYSBvdSBtYWlzIGNhbWFkYXMgZG8gbWFwYSBuw6NvIGVzdMOjbyBsaXN0YWRhcyBhcXVpIHBvcnF1ZSBuw6NvIHBlcm1pdGVtIGFuw6FsaXNlLlwiLFxuXHRcdGxlYXJuTW9yZVRleHQ6IFwiU2FpYmEgbWFpc1wiLFxuXHRcdGF0TGVhc3RPbmVSYXN0ZXJJbnB1dDogXCJQZWxvIG1lbm9zIHVtYSBjYW1hZGEgZGUgZW50cmFkYSBkZXZlIHNlciB1bWEgY2FtYWRhIHJhc3Rlci5cIixcblx0XHRicm93c2VBbmFseXNpc0xheWVyczogXCJQcm9jdXJhciBjYW1hZGFzXCIsXG5cdFx0YWN0aXZlTWFwVmlld0V4dGVudDogXCJVc2FyIEV4dGVuc8OjbyBkbyBNYXBhIEF0dWFsXCIsXG5cdFx0Y2hvb3NlUmFzdGVyOiBcIkVzY29saGEgUmVjb3J0YW5kbyBSYXN0ZXJcIixcblx0XHRjaG9vc2VHZW9tZXRyeTogXCJFc2NvbGhhIFJlY29ydGFuZG8gR2VvbWV0cmlhXCIsXG5cdFx0cmVzdWx0VHlwZTogXCJUaXBvIGRlIHJlc3VsdGFkb1wiLFxuXHRcdHNhdmVJbkZvbGRlcjogXCJTYWx2YXIgbmEgcGFzdGFcIixcblx0XHRvdXRwdXROYW1lOiBcIk5vbWUgZGUgc2HDrWRhXCIsXG5cdFx0b3V0cHV0TGF5ZXJUeXBlOiBcIlRpcG8gZGEgY2FtYWRhIGRlIHNhw61kYVwiLFxuXHRcdGR5bmFtaWNJbWFnZXJ5TGF5ZXI6IFwiQ2FtYWRhIGRlIGltYWdlbnMgZGluw6JtaWNhXCIsXG5cdFx0dGlsZWRJbWFnZXJ5TGF5ZXI6IFwiQ2FtYWRhIGRlIGltYWdlbnMgZG8gbW9zYWljb1wiLFxuXHRcdGN1c3RvbTogXCJQZXJzb25hbGl6YWRhXCIsXG5cdFx0bG9hZGluZzogXCJDYXJyZWdhbmRvLi4uXCIsXG5cdFx0bGF5ZXJNaXNzaW5nOiBcIlVtYSBvdSBtYWlzIGNhbWFkYXMgZG8gbWFwYSBuw6NvIGVzdMOjbyBsaXN0YWRhcyBhcXVpIHBvcnF1ZSBuw6NvIHBlcm1pdGVtIGFuw6FsaXNlLiBTYWliYSBtYWlzLlwiLFxuXHRcdGJyb3dzZUNvb3JkaW5hdGVTeXN0ZW1zOiBcIlByb2N1cmFyIHNpc3RlbWFzIGRlIGNvb3JkZW5hZGFzXCIsXG5cdFx0dW5hYmxlVG9SZXBvcHVsYXRlT3V0U1I6IFwiTsOjbyDDqSBwb3Nzw612ZWwgcHJlZW5jaGVyIG8gc2lzdGVtYSBkZSBjb29yZGVuYWRhcyBkZSBzYcOtZGEuXCIsXG5cdFx0ZGVmYXVsdFRpdGxlOiBcIlZlamEgbWFpc1wiLFxuXHRcdFwiQVJDIChlcXVhbCBhcmMtc2Vjb25kKVwiOiBcIkFSQyAoc2VndW5kbyBhcmNvIGlndWFsKVwiLFxuXHRcdEFmcmljYTogXCLDgWZyaWNhXCIsXG5cdFx0QW50YXJjdGljYTogXCJBbnTDoXJ0aWNhXCIsXG5cdFx0QXJnZW50aW5hOiBcIkFyZ2VudGluYVwiLFxuXHRcdEFzaWE6IFwiw4FzaWFcIixcblx0XHRcIkFzdGVyb2lkIEJlbHRcIjogXCJDaW50dXLDo28gZGUgQXN0ZXLDs2lkZXNcIixcblx0XHRcIkF0bGFudGljIE9jZWFuXCI6IFwiT2NlYW5vIEF0bMOibnRpY29cIixcblx0XHRBdXN0cmFsaWE6IFwiQXVzdHLDoWxpYVwiLFxuXHRcdFwiQXVzdHJhbGlhIGFuZCBOZXcgWmVhbGFuZFwiOiBcIkF1c3Ryw6FsaWEgZSBOb3ZhIFplbMOibmRpYVwiLFxuXHRcdEF1c3RyaWE6IFwiw4F1c3RyaWFcIixcblx0XHRcIkJMTSAoVVMgRmVldClcIjogXCJCTE0gKFVTIEZlZXQpXCIsXG5cdFx0QmFuZ2xhZGVzaDogXCJCYW5nbGFkZWNoZVwiLFxuXHRcdFwiQmVpamluZyAxOTU0XCI6IFwiQmVpamluZyAxOTU0XCIsXG5cdFx0Qmh1dGFuOiBcIkJ1dMOjb1wiLFxuXHRcdENHQ1MyMDAwOiBcIkNHQ1MyMDAwXCIsXG5cdFx0Q2FuYWRhOiBcIkNhbmFkw6FcIixcblx0XHRDYXJpYmJlYW46IFwiQ2FyaWJlXCIsXG5cdFx0XCJDYXJpYmJlYW4gU2VhXCI6IFwiTWFyIGRvIENhcmliZVwiLFxuXHRcdFwiQ2VudHJhbCBBbWVyaWNhXCI6IFwiQW3DqXJpY2EgQ2VudHJhbFwiLFxuXHRcdFwiQ2VudHJhbCBhbmQgTm9ydGggQW1lcmljYVwiOiBcIkFtw6lyaWNhIGRvIE5vcnRlIGUgQ2VudHJhbFwiLFxuXHRcdENvbG9tYmlhOiBcIkNvbMO0bWJpYVwiLFxuXHRcdENvbnRpbmVudGFsOiBcIkNvbnRpbmVudGFsXCIsXG5cdFx0XCJDb3VudHkgU3lzdGVtc1wiOiBcIlNpc3RlbWFzIGRvIE11bmljw61waW9cIixcblx0XHRcIkRlbW9jcmF0aWMgUmVwdWJsaWMgb2YgdGhlIENvbmdvXCI6IFwiQ29uZ29cIixcblx0XHRcIkVQU0cgQXJjdGljXCI6IFwiRVBTRyDDgXJ0aWNvXCIsXG5cdFx0RWFydGg6IFwiVGVycmFcIixcblx0XHRcIkVsbGlwc29pZGFsLWJhc2VkXCI6IFwiQmFzZWFkbyBubyBlbGlwc29pZGFsXCIsXG5cdFx0RXVyb3BlOiBcIkV1cm9wYVwiLFxuXHRcdEZpbmxhbmQ6IFwiRmlubMOibmRpYVwiLFxuXHRcdEZyYW5jZTogXCJGcmFuw6dhXCIsXG5cdFx0XCJHU0sgMjAxMVwiOiBcIkdTSyAyMDExXCIsXG5cdFx0XCJHYXVzcyBLcnVnZXJcIjogXCJHYXVzcyBLcnVnZXJcIixcblx0XHRcIkdlb2dyYXBoaWMgQ29vcmRpbmF0ZSBTeXN0ZW1zXCI6IFwiU2lzdGVtYSBkZSBDb29yZGVuYWRhcyBHZW9ncsOhZmljYXNcIixcblx0XHRHZXJtYW55OiBcIkFsZW1hbmhhXCIsXG5cdFx0XCJHcmF2aXR5LXJlbGF0ZWRcIjogXCJSZWxhY2lvbmFkbyDDoCBncmF2aWRhZGVcIixcblx0XHRcIkdyZWVud2ljaC1iYXNlZFwiOiBcIkJhc2VhZG8gbm8gR3JlZW53aWNoXCIsXG5cdFx0XCJIaWdod2F5cyBFbmdsYW5kXCI6IFwiUm9kb3ZpYXMgSW5nbGF0ZXJyYVwiLFxuXHRcdElsbGlub2lzOiBcIklsbGlub2lzXCIsXG5cdFx0XCJJbmRpYW4gT2NlYW5cIjogXCJPY2Vhbm8gw41uZGljb1wiLFxuXHRcdFwiSW5kaWFuIFN1YmNvbnRpbmVudFwiOiBcIlN1YmNvbnRpbmVudGUgSW5kaWFub1wiLFxuXHRcdEluZGlhbmE6IFwiSW5kaWFuYVwiLFxuXHRcdEluZG9uZXNpYTogXCJJbmRvbsOpc2lhXCIsXG5cdFx0SW93YTogXCJJb3dhXCIsXG5cdFx0XCJJcmVsYW5kIGFuZCBVbml0ZWQgS2luZ2RvbVwiOiBcIklybGFuZGEgZSBSZWlubyBVbmlkb1wiLFxuXHRcdEl0YWx5OiBcIkl0w6FsaWFcIixcblx0XHRKYXBhbjogXCJKYXDDo29cIixcblx0XHRKdXBpdGVyOiBcIkrDunBpdGVyXCIsXG5cdFx0S2Fuc2FzOiBcIkthbnNhc1wiLFxuXHRcdFwiTGFzIFZlZ2FzXCI6IFwiTGFzIFZlZ2FzXCIsXG5cdFx0TGlieWE6IFwiTMOtYmlhXCIsXG5cdFx0TWFsYXlzaWE6IFwiTWFsw6FzaWFcIixcblx0XHRcIk1hbGF5c2lhIGFuZCBTaW5nYXBvcmVcIjogXCJNYWzDoXNpYSBlIENpbmdhcHVyYVwiLFxuXHRcdE1hcnM6IFwiTWFydGVcIixcblx0XHRNZXJjdXJ5OiBcIk1lcmPDunJpb1wiLFxuXHRcdE1pbm5lc290YTogXCJNaW5uZXNvdGFcIixcblx0XHRNb250YW5hOiBcIk1vbnRhbmFcIixcblx0XHRcIk5BRCAxOTI3XCI6IFwiTkFEIDE5MjdcIixcblx0XHRcIk5BRCAxOTI3IChVUyBGZWV0KVwiOiBcIk5BRCAxOTI3IChVUyBGZWV0KVwiLFxuXHRcdFwiTkFEIDE5ODNcIjogXCJOQUQgMTk4M1wiLFxuXHRcdFwiTkFEIDE5ODMgKDIwMTEpXCI6IFwiTkFEIDE5ODMgKDIwMTEpXCIsXG5cdFx0XCJOQUQgMTk4MyAoMjAxMSkgKEludGwgRmVldClcIjogXCJOQUQgMTk4MyAoMjAxMSkgKEludGwgRmVldClcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKSAoTWV0ZXJzKVwiOiBcIk5BRCAxOTgzICgyMDExKSAoTWV0cm9zKVwiLFxuXHRcdFwiTkFEIDE5ODMgKDIwMTEpIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzICgyMDExKSAoVVMgRmVldClcIixcblx0XHRcIk5BRCAxOTgzIChDT1JTOTYpIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgKENPUlM5NikgKEludGwgRmVldClcIixcblx0XHRcIk5BRCAxOTgzIChDT1JTOTYpIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKENPUlM5NikgKE1ldHJvcylcIixcblx0XHRcIk5BRCAxOTgzIChDT1JTOTYpIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIChDT1JTOTYpIChVUyBGZWV0KVwiLFxuXHRcdFwiTkFEIDE5ODMgKEludGwgRmVldClcIjogXCJOQUQgMTk4MyAoSW50bCBGZWV0KVwiLFxuXHRcdFwiTkFEIDE5ODMgKE1ldGVycylcIjogXCJOQUQgMTk4MyAoTWV0cm9zKVwiLFxuXHRcdFwiTkFEIDE5ODMgKFBBMTEpIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKFBBMTEpIChNZXRyb3MpXCIsXG5cdFx0XCJOQUQgMTk4MyAoUEExMSkgKFVTIEZlZXQpXCI6IFwiTkFEIDE5ODMgKFBBMTEpIChVUyBGZWV0KVwiLFxuXHRcdFwiTkFEIDE5ODMgKFVTIEZlZXQpXCI6IFwiTkFEIDE5ODMgKFVTIEZlZXQpXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgSEFSTiAoSW50bCBGZWV0KVwiLFxuXHRcdFwiTkFEIDE5ODMgSEFSTiAoTWV0ZXJzKVwiOiBcIk5BRCAxOTgzIEhBUk4gKE1ldHJvcylcIixcblx0XHRcIk5BRCAxOTgzIEhBUk4gKFVTIEZlZXQpXCI6IFwiTkFEIDE5ODMgSEFSTiAoVVMgRmVldClcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgTlNSUzIwMDcgKEludGwgRmVldClcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgTlNSUzIwMDcgKE1ldHJvcylcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIE5TUlMyMDA3IChVUyBGZWV0KVwiLFxuXHRcdFwiTmF0aW9uYWwgR3JpZHNcIjogXCJHcmFkZXMgTmFjaW9uYWlzXCIsXG5cdFx0TmF2YWpvOiBcIk5hdmFqb1wiLFxuXHRcdE5lcHR1bmU6IFwiTmV0dW5vXCIsXG5cdFx0XCJOZXcgQmVpamluZ1wiOiBcIk5ldyBCZWlqaW5nXCIsXG5cdFx0XCJOZXcgWmVhbGFuZFwiOiBcIk5vdmEgWmVsw6JuZGlhXCIsXG5cdFx0XCJOb3J0aCBBbWVyaWNhXCI6IFwiQW3DqXJpY2EgZG8gTm9ydGVcIixcblx0XHRcIk5vcnRoZXJuIEhlbWlzcGhlcmVcIjogXCJIZW1pc2bDqXJpbyBOb3J0ZVwiLFxuXHRcdE5vcndheTogXCJOb3J1ZWdhXCIsXG5cdFx0T2NlYW5zOiBcIk9jZWFub3NcIixcblx0XHRPcmVnb246IFwiT3JlZ29uXCIsXG5cdFx0XCJPdGhlciBHQ1NcIjogXCJPdGhlciBHQ1NcIixcblx0XHRcIlBhY2lmaWMgT2NlYW5cIjogXCJPY2Vhbm8gUGFjw61maWNvXCIsXG5cdFx0UGx1dG86IFwiUGx1dMOjb1wiLFxuXHRcdFBvbGFyOiBcIlBvbGFyXCIsXG5cdFx0UG9ydHVnYWw6IFwiUG9ydHVnYWxcIixcblx0XHRcIlByb2plY3RlZCBDb29yZGluYXRlIFN5c3RlbXNcIjogXCJTaXN0ZW1hIGRlIENvb3JkZW5hZGFzIFBsYW5hc1wiLFxuXHRcdFwiUHVsa292byAxOTQyXCI6IFwiUHVsa292byAxOTQyXCIsXG5cdFx0XCJQdWxrb3ZvIDE5OTVcIjogXCJQdWxrb3ZvIDE5OTVcIixcblx0XHRSZXBsYWNlZDogXCJTdWJzdGl0dcOtZG9cIixcblx0XHRcIlNBRCAxOTY5XCI6IFwiU0FEIDE5NjlcIixcblx0XHRTSVJHQVM6IFwiU0lSR0FTXCIsXG5cdFx0XCJTSVJHQVMgMjAwMFwiOiBcIlNJUkdBUyAyMDAwXCIsXG5cdFx0U2F0dXJuOiBcIlNhdHVybm9cIixcblx0XHRcIlNvbGFyIFN5c3RlbVwiOiBcIlNpc3RlbWEgU29sYXJcIixcblx0XHRcIlNvdXRoIEFmcmljYVwiOiBcIsOBZnJpY2EgZG8gU3VsXCIsXG5cdFx0XCJTb3V0aCBBbWVyaWNhXCI6IFwiQW3DqXJpY2EgZG8gU3VsXCIsXG5cdFx0XCJTb3V0aCBLb3JlYVwiOiBcIkNvcsOpaWEgZG8gU3VsXCIsXG5cdFx0XCJTb3V0aGVybiBIZW1pc3BoZXJlXCI6IFwiSGVtaXNmw6lyaW8gU3VsXCIsXG5cdFx0XCJTcGhlcm9pZC1iYXNlZFwiOiBcIkJhc2VhZG8gbm8gZXNmZXLDs2lkZVwiLFxuXHRcdFwiU3RhdGUgUGxhbmVcIjogXCJTdGF0ZSBQbGFuZVwiLFxuXHRcdFwiU3RhdGUgU3lzdGVtc1wiOiBcIlNpc3RlbWFzIEVzdGFkdWFpc1wiLFxuXHRcdFN3ZWRlbjogXCJTdcOpY2lhXCIsXG5cdFx0XCJTd2l0emVybGFuZCBhbmQgTGllY2h0ZW5zdGVpblwiOiBcIlN1w63Dp2EgZSBMaWVjaHRlbnN0ZWluXCIsXG5cdFx0VGV4YXM6IFwiVGV4YXNcIixcblx0XHRUcmliYWw6IFwiVHJpYmFsXCIsXG5cdFx0VHVya2V5OiBcIlR1cnF1aWFcIixcblx0XHRcIlVTIEZlZXRcIjogXCJVUyBGZWV0XCIsXG5cdFx0XCJVU0EgYW5kIHRlcnJpdG9yaWVzXCI6IFwiRXN0YWRvcyBVbmlkb3MgZSB0ZXJyaXTDs3Jpb3NcIixcblx0XHRVVE06IFwiVVRNXCIsXG5cdFx0VWtyYWluZTogXCJVY3LDom5pYVwiLFxuXHRcdFwiVW5rbm93biBIZWlnaHQgU3lzdGVtc1wiOiBcIlNpc3RlbWFzIGRlIEFsdHVyYSBEZXNjb25oZWNpZG9zXCIsXG5cdFx0VXJhbnVzOiBcIlVyYW5vXCIsXG5cdFx0VmVudXM6IFwiVsOqbnVzXCIsXG5cdFx0XCJWZXJ0aWNhbCBDb29yZGluYXRlIFN5c3RlbXNcIjogXCJTaXN0ZW1hcyBkZSBDb29yZGVuYWRhcyBWZXJ0aWNhaXNcIixcblx0XHRWaWV0bmFtOiBcIlZpZXRuw6NcIixcblx0XHRcIldHUyAxOTcyXCI6IFwiV0dTIDE5NzJcIixcblx0XHRcIldHUyAxOTg0XCI6IFwiV0dTIDE5ODRcIixcblx0XHRXaXNjb25zaW46IFwiV2lzY29uc2luXCIsXG5cdFx0XCJXaXNjb25zaW4gQ1JTXCI6IFwiV2lzY29uc2luIENSU1wiLFxuXHRcdFdvcmxkOiBcIk11bmRpYWxcIixcblx0XHRcIldvcmxkIChTcGhlcmUtYmFzZWQpXCI6IFwiTXVuZGlhbCAoYmFzZWFkbyBubyBlc2ZlcsOzaWRlKVwiLFxuXHRcdFd5b21pbmc6IFwiV3lvbWluZ1wiLFxuXHRcdFwiWGlhbiAxOTgwXCI6IFwiWGlhbiAxOTgwXCIsXG5cdFx0ZG9uZTogXCJDb25jbHVpclwiLFxuXHRcdG5vUmVzdWx0czogXCJOZW5odW0gcmVzdWx0YWRvIGVuY29udHJhZG9cIixcblx0XHRzZWFyY2hQbGFjZWhvbGRlcjogXCJOb21lIG91IFdLSURcIixcblx0XHRicm93c2VUZW1wbGF0ZTogXCJQcm9jdXJhciBtb2RlbG9zIGRlIGZ1bsOnw6NvIHJhc3RlclwiLFxuXHRcdHNhdmVUZW1wbGF0ZTogXCJTYWx2YXIgbW9kZWxvIGRlIGZ1bsOnw6NvIHJhc3RlclwiLFxuXHRcdHByZXZpZXc6IFwiVmlzdWFsaXphclwiLFxuXHRcdHByZXZpZXdEZXNjcmlwdGlvbjogXCJWaXN1YWxpemUgbyByZXN1bHRhZG8gYW50ZXMgZGUgZXhlY3V0YXIgYSBhbsOhbGlzZS5cIixcblx0XHRzaG93UHJldmlldzogXCJNb3N0cmFyIHZpc3VhbGl6YcOnw6NvXCIsXG5cdFx0cHJldmlld0xheWVyOiBcIkNhbWFkYSBkZSB2aXN1YWxpemHDp8OjbyAke251bWJlcn1cIixcblx0XHRuZXdQcmV2aWV3OiBcIk5vdmEgdmlzdWFsaXphw6fDo29cIixcblx0XHRwcmV2aWV3UG9wdXA6IFwiSGFiaWxpdGUgYSB2aXN1YWxpemHDp8OjbyBkb3MgcmVzdWx0YWRvcyBkYSBhbsOhbGlzZSBjb20gYmFzZSBub3MgcGFyw6JtZXRyb3MgZGUgZW50cmFkYS5cIixcblx0XHR1cGRhdGVQcmV2aWV3TGF5ZXI6IFwiQXR1YWxpemFyIGNhbWFkYSBkZSB2aXN1YWxpemHDp8OjbyBzZWxlY2lvbmFkYVwiLFxuXHRcdGNyZWF0ZVByZXZpZXdMYXllcjogXCJDcmllIHVtYSBub3ZhIGNhbWFkYSBkZSB2aXN1YWxpemHDp8Ojb1wiLFxuXHRcdG1heGltdW1QcmV2aWV3QWxsb3dlZDogXCJOw7ptZXJvIG3DoXhpbW8gcGVybWl0aWRvIGRlIGNhbWFkYXMgZGUgdmlzdWFsaXphw6fDo286ICR7bWF4Q291bnR9XCIsXG5cdFx0cHJldmlld0ZhaWx1cmU6IFwiRXN0YSBjYW1hZGEgZGUgdmlzdWFsaXphw6fDo28gbsOjbyBlc3TDoSBkaXNwb27DrXZlbC4gVmVyaWZpcXVlIG9zIHBhcsOibWV0cm9zIGRlIGVudHJhZGEgZSBhdHVhbGl6ZSBlc3RhIGNhbWFkYSBkZSB2aXN1YWxpemHDp8OjbyBub3ZhbWVudGUuXCIsXG5cdFx0aGVhZGVyOiBcIlNlbGVjaW9uYXIgaXRlbVwiLFxuXHRcdGNvbnRlbnQ6IFwiVm9jw6ogdGVtIGFsdGVyYcOnw7VlcyBuw6NvIHNhbHZhcyBlbSAke3JmdFRpdGxlfS4gU2Ugdm9jw6ogcmVjb21lw6dhciBjb20gdW0gbm92byBtb2RlbG8sIGVzc2FzIGFsdGVyYcOnw7VlcyBzZXLDo28gcGVyZGlkYXMuXCIsXG5cdFx0ZG9udFNhdmU6IFwiTsOjbyBzYWx2YXJcIixcblx0XHRcImNvbnRpbnVlXCI6IFwiQ29udGludWFyXCIsXG5cdFx0c3RyZXRjaDogXCJBanVzdGFyIG5hIGphbmVsYVwiLFxuXHRcdHBhbjogXCJNb3ZlclwiLFxuXHRcdG5ld1RlbXBsYXRlOiBcIkNyaWFyIG5vdm8gbW9kZWxvXCIsXG5cdFx0b3BlblRlbXBsYXRlOiBcIkFicmlyIG1vZGVsb1wiLFxuXHRcdGFkZEZ1bmN0aW9uOiBcIkFkaWNpb25hciBmdW7Dp8O1ZXMgcmFzdGVyXCIsXG5cdFx0YWRkQ29uc3RhbnQ6IFwiQWRpY2lvbmFyIGNvbnN0YW50ZVwiLFxuXHRcdGFkZFJhc3RlcjogXCJBZGljaW9uYXIgdmFyacOhdmVsIHJhc3RlclwiLFxuXHRcdG1vdmU6IFwiTW92ZXJcIixcblx0XHR6b29tOiBcIlpvb21cIixcblx0XHRzYXZlQXM6IFwiU2FsdmFyIENvbW9cIixcblx0XHRjbGVhcjogXCJMaW1wYXJcIixcblx0XHRhZGRSYXN0ZXJGdW5jdGlvblRpdGxlOiBcIkFkaWNpb25hciBmdW7Dp8O1ZXMgcmFzdGVyXCIsXG5cdFx0dGVtcGxhdGVQcm9wZXJ0aWVzVGl0bGU6IFwiUHJvcHJpZWRhZGVzIGRvIG1vZGVsb1wiLFxuXHRcdGJyb3dzZVJGVDogXCJQcm9jdXJhciBtb2RlbG9zIGRlIGZ1bsOnw6NvIHJhc3RlclwiLFxuXHRcdGRlZmF1bHRUb29sRGVzY3JpcHRpb246IFwiRmVycmFtZW50YSBkZSBhbsOhbGlzZSAke3Rvb2xUaXRsZX0uXCIsXG5cdFx0b3BlblRvb2xUZXh0OiBcIkFicmlyIEZlcnJhbWVudGFcIixcblx0XHR0b29sRHJvcGRvd25UZXh0OiBcIk1lbnUgU3VzcGVuc28gZGEgRmVycmFtZW50YVwiLFxuXHRcdGFkZFRvTWFwOiBcIkNvbmZpcm1lIGUgYWRpY2lvbmUgYW8gbWFwYVwiLFxuXHRcdGNvbmZpcm06IFwiQ29uZmlybWFyXCIsXG5cdFx0c2VsZWN0OiBcIlNlbGVjaW9uYXJcIixcblx0XHRzZWxlY3RUYXNrOiBcIlNlbGVjaW9uYXIgdGFyZWZhXCIsXG5cdFx0dW5zdXBwb3J0ZWRMYXllcjogXCJFc3RlIHBhcsOibWV0cm8gbsOjbyBzdXBvcnRhIGFzIHNlZ3VpbnRlcyBjYW1hZGFzOiAke2xheWVyTmFtZX0uXCIsXG5cdFx0dmlld0RldGFpbHM6IFwiVmlzdWFsaXphciBkZXRhbGhlcyBkZSBpdGVtIGNvbXBsZXRvXCIsXG5cdFx0cmVuYW1lOiBcIlJlbm9tZWFyXCIsXG5cdFx0ZHVwbGljYXRlOiBcIkR1cGxpY2FyXCIsXG5cdFx0bGF1bmNoOiBcIkFicmlyIHBhcmEgZXhlY3V0YXJcIixcblx0XHR0ZW1wbGF0ZUVkaXRvcjogXCJFZGl0b3IgZGUgbW9kZWxvc1wiLFxuXHRcdGNyZWF0ZUl0ZW06IFwiU2FsdmFyIG1vZGVsbyBkZSBmdW7Dp8OjbyByYXN0ZXJcIixcblx0XHRhY3Rpb25MYWJlbDogXCJGaWx0cmFyXCIsXG5cdFx0ZmlsdGVyUG9wb3ZlckhlYWRpbmc6IFwiRmlsdHJhciBhcyBmdW7Dp8O1ZXNcIixcblx0XHRkZWZhdWx0U2VhcmNoUGxhY2Vob2xkZXI6IFwiUGVzcXVpc2FyIHBvciBub21lXCIsXG5cdFx0c2V0dGluZ3M6IFwiQ29uZmlndXJhw6fDtWVzXCIsXG5cdFx0c3VtbWFyeTogXCJSZXN1bW9cIixcblx0XHRkZWZpbml0aW9uUXVlcnk6IFwiQ29uc3VsdGEgZGUgZGVmaW5pw6fDo29cIixcblx0XHRtYXRjaFZhcmlhYmxlczogXCJWYXJpw6F2ZWlzIOKAi+KAi2RlIGNvcnJlc3BvbmTDqm5jaWFcIixcblx0XHR1bmlvbkRpbWVuc2lvbjogXCJEaW1lbnPDo28gZGEgdW5pw6NvXCIsXG5cdFx0bmFtZUVkaXRvclBsYWNlaG9sZGVyOiBcIkluc2VyaXIgdMOtdHVsb1wiLFxuXHRcdHN1bW1hcnlFZGl0b3JQbGFjZWhvbGRlcjogXCJJbnNpcmEgdW1hIGJyZXZlIGRlc2NyacOnw6NvLlwiLFxuXHRcdGRlZmluaXRpb25RdWVyeVBsYWNlaG9sZGVyOiBcIkluc2VyaXIuLi5cIixcblx0XHR1cGxvYWQ6IFwiQ2FycmVnYXJcIixcblx0XHRjaG9vc2VJbWFnZTogXCJDbGlxdWUgcGFyYSBlc2NvbGhlciB1bSBhcnF1aXZvXCIsXG5cdFx0dXBkYXRlOiBcIkF0dWFsaXphclwiLFxuXHRcdHRodW1ibmFpbEVycm9yczoge1xuXHRcdFx0d3JvbmdJbWFnZVR5cGU6IFwiVGlwbyBkZSBpbWFnZW0gc2VsZWNpb25hZG8gZXJyYWRvXCIsXG5cdFx0XHRub3RBdmFpbGFibGU6IFwiTWluaWF0dXJhIG7Do28gZGlzcG9uw612ZWxcIixcblx0XHRcdGxvYWRFcnJvcjogXCJOw6NvIGZvaSBwb3Nzw612ZWwgY2FycmVnYXIgYSBpbWFnZW1cIixcblx0XHRcdGNob29zZUZpbGU6IFwiQ2xpcXVlIHBhcmEgZXNjb2xoZXIgYXJxdWl2b1wiXG5cdFx0fVxuXHR9XG59O1xuY29uc3QgY29weSA9IFwiQ29waWFyXCI7XG5jb25zdCBzYXZlID0gXCJTYWx2YXJcIjtcbmNvbnN0IHRpdGxlID0gXCJUw610dWxvXCI7XG5jb25zdCBmb2xkZXIgPSBcIlBhc3RhXCI7XG5jb25zdCB0YWdzID0gXCJUYWdzXCI7XG5jb25zdCBzYXZpbmdNZXNzYWdlID0gXCJTYWx2YW5kbyBpdGVtIGVtXCI7XG5jb25zdCBzaGFyZVdpdGggPSBcIkNvbXBhcnRpbGhhciBDb21cIjtcbmNvbnN0IHNoYXJlID0gXCJDb21wYXJ0aWxoYXJcIjtcbmNvbnN0IHNldFNoYXJpbmdMZXZlbCA9IFwiQ29uZmlndXJhciBOw612ZWwgZGUgQ29tcGFydGlsaGFtZW50b1wiO1xuY29uc3Qgc2V0R3JvdXBTaGFyaW5nID0gXCJDb25maWd1cmFyIENvbXBhcnRpbGhhbWVudG8gZG8gR3J1cG9cIjtcbmNvbnN0IG93bmVyID0gXCJQcm9wcmlldMOhcmlvXCI7XG5jb25zdCBvcmdhbml6YXRpb24gPSBcIk9yZ2FuaXphw6fDo29cIjtcbmNvbnN0IGV2ZXJ5b25lID0gXCJUb2RvcyAocMO6YmxpY28pXCI7XG5jb25zdCBncm91cHMgPSBcIkdydXBvczpcIjtcbmNvbnN0IHR5cGUgPSBcIlRpcG9cIjtcbmNvbnN0IG1vc2FpYyA9IFwiTW9zYWljb1wiO1xuY29uc3QgaXRlbUdyb3VwID0gXCJHcnVwbyBkZSBJdGVtXCI7XG5jb25zdCBpdGVtID0gXCJJdGVtXCI7XG5jb25zdCBkZWZpbml0aW9uUXVlcnkgPSBcIkNvbnN1bHRhIGRlIERlZmluacOnw6NvXCI7XG5jb25zdCBncm91cEl0ZW1zQnkgPSBcIkFncnVwYXIgSXRlbnMgUG9yXCI7XG5jb25zdCBncm91cEZpZWxkTmFtZSA9IFwiTm9tZSBkZSBDYW1wbyBkbyBHcnVwb1wiO1xuY29uc3QgdGFnRmllbGROYW1lID0gXCJOb21lIGRlIENhbXBvIGRhIFRhZ1wiO1xuY29uc3Qgbm9UaXRsZVRhZ0Vycm9yTXNnID0gXCJWb2PDqiBkZXZlIGZvcm5lY2VyIHVtIHTDrXR1bG8gcGFyYSBzZXUgaXRlbSBlIHRhZ3MgcGFyYSBwZXJtaXRpciBhbyBzZXUgbWFwYSBzZXIgZW5jb250cmFkbyBwb3IgcGVzcXVpc2FzLlwiO1xuY29uc3Qgbm9UaXRsZUVycm9yTXNnID0gXCJWb2PDqiBkZXZlIGZvcm5lY2VyIHVtIHTDrXR1bG8gcGFyYSBvIGl0ZW0uXCI7XG5jb25zdCBub1RhZ0Vycm9yTXNnID0gXCJWb2PDqiBkZXZlIGZvcm5lY2VyIHBlbG8gbWVub3MgdW1hIHRhZyBwYXJhIGFqdWRhciBvcyB1c3XDoXJpb3MgYSBlbmNvbnRyYXIgc2V1IGl0ZW0gcG9yIHBlc3F1aXNhcy5cIjtcbmNvbnN0IGVycm9yID0gXCJFcnJvXCI7XG5jb25zdCB3YXJuaW5nID0gXCJBdmlzb1wiO1xuY29uc3Qgc3VjY2VzcyA9IFwiQmVtIFN1Y2VkaWRvXCI7XG5jb25zdCBkZXRhaWxzID0gXCJEZXRhbGhlczpcIjtcbmNvbnN0IHRyeUFnYWluID0gXCJUZW50YXIgTm92YW1lbnRlXCI7XG5jb25zdCB0b29sTW9kZWxlciA9IHtcblx0c2F2ZTogXCJTYWx2YXJcIixcblx0ZWRpdFByb3BlcnRpZXM6IFwiRWRpdGFyIFByb3ByaWVkYWRlc1wiLFxuXHRzYXZlQXM6IFwiU2FsdmFyIENvbW9cIixcblx0c2F2aW5nTm90aWZpY2F0aW9uOiBcIlNhbHZhbmRvIGFzIGFsdGVyYcOnw7VlcyBubyBpdGVtLi4uXCIsXG5cdHNhdmluZ1RpdGxlOiBcIlNhbHZhbmRvXCIsXG5cdHNhdmVGYWlsZWRNZXNzYWdlOiBcIkZhbGhhIGFvIHNhbHZhciBhbHRlcmHDp8O1ZXMuXCIsXG5cdHNhdmVXaXRoRXJyb3JzTWVzc2FnZTogXCJBcyBhbHRlcmHDp8O1ZXMgZm9yYW0gc2FsdmFzIGNvbSBvcyBlcnJvcyBzZWd1aW50ZXMuXCIsXG5cdHZpZXdJdGVtTWVzc2FnZTogXCJWaXN1YWxpemFyIG8gaXRlbSBzYWx2b1wiLFxuXHRoZXJlOiBcImFxdWkuXCIsXG5cdGl0ZW1DcmVhdGVkTWVzc2FnZTogXCJOb3ZvIGl0ZW0gZm9pIGNyaWFkby5cIixcblx0Y2xpY2tUb1ZpZXdJdGVtTWVzc2FnZTogXCJDbGlxdWUgZW0gT0sgcGFyYSB2aXN1YWxpemFyIGEgcMOhZ2luYSBkZSBkZXRhbGhlcyBkbyBpdGVtOyBjbGlxdWUgZW0gQ2FuY2VsYXIgcGFyYSBjb250aW51YXIuXCIsXG5cdHJlYWRpbmdGYWlsZWQ6IFwiRmFsaGEgYW8gY2FycmVnYXIgbW9kZWxvIGRlIGZ1bsOnw6NvIHJhc3RlciBzZWxlY2lvbmFkby5cIixcblx0ZmFpbGVkVG9Mb2FkWE1MOiBcIkZhbGhhIGFvIGNhcnJlZ2FyIG1vZGVsbyBkZSBmdW7Dp8OjbyByYXN0ZXIgc2VsZWNpb25hZG8gbm8gZm9ybWF0byBYTUwuXCIsXG5cdGxlYXJuTW9yZTogXCJTYWliYSBtYWlzXCIsXG5cdG92ZXJ3cml0ZVRpdGxlOiBcIkNvbmZpcm1hciBzdWJzdGl0dWnDp8Ojb1wiLFxuXHRvdmVyd3JpdGVNZXNzYWdlOiBcIlZvY8OqIGRlc2VqYSBzdWJzdGl0dWlyIG8gaXRlbSBleGlzdGVudGU/XCIsXG5cdG92ZXJ3cml0ZVN1Y2Nlc3NNZXNzYWdlOiBcIk8gaXRlbSBmb2kgYXR1YWxpemFkby5cIlxufTtcbmNvbnN0IHRvb2xFZGl0b3IgPSB7XG5cdHJ1bjogXCJFeGVjdXRhclwiLFxuXHRzYXZlOiBcIlNhbHZhclwiLFxuXHRkZWxldGVTZWxlY3RlZDogXCJFeGNsdWlyIEl0ZW5zIFNlbGVjaW9uYWRvc1wiLFxuXHRhZGRSYXN0ZXI6IFwiQWRpY2lvbmFyIFJhc3RlclwiLFxuXHRhZGRTY2FsYXI6IFwiQWRpY2lvbmFyIEVzY2FsYXJcIixcblx0bGF5b3V0OiBcIkxheW91dCBBdXRvbcOhdGljb1wiLFxuXHRlcnJvclRpdGxlOiBcIkVycm9cIixcblx0aW52YWxpZFRvb2xNZXNzYWdlOiBcIk8gbW9kZWxvIGRlIGZ1bsOnw6NvIGRvIHJhc3RlciBuw6NvIMOpIHbDoWxpZG8uXCIsXG5cdG91dDogXCJGb3JhXCIsXG5cdHpvb21JbjogXCJNYWlzIFpvb21cIixcblx0em9vbU91dDogXCJNZW5vcyBab29tXCIsXG5cdHpvb21Ub0ZpdDogXCJBanVzdGFyIG5hIEphbmVsYVwiLFxuXHRwYW5PbjogXCJUcm9jYXIgcGFyYSBtb2RvIG1vdmVyXCIsXG5cdHBhbk9mZjogXCJEZXNhdGl2YXIgbW9kbyBtb3ZlclwiLFxuXHRkZWZhdWx0TW9kZWxOYW1lOiBcIk1vZGVsbyBkZSBGZXJyYW1lbnRhXCIsXG5cdGRlZmF1bHRSYXN0ZXJOYW1lOiBcIlJhc3RlclwiXG59O1xuY29uc3QgdG9vbERldGFpbHNFZGl0b3IgPSB7XG5cdGRlZmF1bHRUb29sTmFtZTogXCJNb2RlbG8gZGUgRnVuw6fDo28gZG8gUmFzdGVyXCIsXG5cdGRlZmF1bHRUb29sRGVzY3JpcHRpb246IFwiQWRpY2lvbmFyIHVtIGJyZXZlIHJlc3VtbyBzb2JyZSBhIGZ1bsOnw6NvIGRvIHJhc3Rlci5cIixcblx0ZGVmYXVsdEhlbHBUZXh0OiBcIkNsaXF1ZSBubyDDrWNvbmUgZGUgYWp1ZGEgcGFyYSBlZGl0YXIgbyB0ZXh0byBkZSBhanVkYVwiLFxuXHRlZGl0SGVscFRpdGxlOiBcIkVkaXRhciBBanVkYVwiLFxuXHRzYXZlTGFiZWw6IFwiU2FsdmFyXCIsXG5cdGNhbmNlbExhYmVsOiBcIkNhbmNlbGFyXCIsXG5cdHRodW1ibmFpbDoge1xuXHRcdHdyb25nSW1hZ2VUeXBlOiBcIlRpcG8gZGUgaW1hZ2VtIHNlbGVjaW9uYWRvIGVycmFkb1wiLFxuXHRcdG5vdEF2YWlsYWJsZTogXCJNaW5pYXR1cmEgbsOjbyBkaXNwb27DrXZlbFwiLFxuXHRcdGxvYWRFcnJvcjogXCJOw6NvIGZvaSBwb3Nzw612ZWwgY2FycmVnYXIgYSBpbWFnZW1cIixcblx0XHRjaG9vc2VGaWxlOiBcIkNsaXF1ZSBwYXJhIGVzY29saGVyIGFycXVpdm9cIlxuXHR9XG59O1xuY29uc3Qgc2F2ZVV0aWxzID0ge1xuXHR0aHVtYm5haWw6IFwiTWluaWF0dXJhXCIsXG5cdHNoYXJpbmc6IFwiQ29tcGFydGlsaGFtZW50b1wiXG59O1xuY29uc3QgY2xvc2UgPSBcIkZlY2hhclwiO1xuY29uc3QgdW5zYXZlZFdhcm5pbmdFeGlzdGluZyA9IFwiR29zdGFyaWEgZGUgc2FsdmFyIGFzIGFsdGVyYcOnw7VlcyBubyBpdGVtIDxiPiR7aXRlbVRpdGxlfTwvYj4gP1wiO1xuY29uc3QgdW5zYXZlZFdhcm5pbmdOZXcgPSBcIkdvc3RhcmlhIGRlIHNhbHZhciBhcyBzdWFzIGFsdGVyYcOnw7Vlcz9cIjtcbmNvbnN0IHNhdmVBcyA9IFwiU2FsdmFyIENvbW9cIjtcbmNvbnN0IGRvbnRTYXZlID0gXCJOw6NvIFNhbHZhclwiO1xuY29uc3QgdW5zYXZlZFRpdGxlID0gXCJBbHRlcmHDp8O1ZXMgTsOjbyBTYWx2YXNcIjtcbmNvbnN0IGludmFsaWRSRlRNZXNzYWdlID0gXCJPIG1vZGVsbyBkZSBmdW7Dp8OjbyBkbyByYXN0ZXIgY3JpYWRvIG7Do28gw6kgdsOhbGlkby5cIjtcbmNvbnN0IGVycm9yVGl0bGUgPSBcIkVycm9cIjtcbmNvbnN0IGJyZWFkY3J1bWIgPSBcIkVkaXRvciBkZSBGdW7Dp8OjbyBkbyBSYXN0ZXJcIjtcbmNvbnN0IGJyZWFkY3J1bWJFZGl0b3IgPSBcIkNvbnRlw7pkbyA+IEVkaXRvciBkZSBGdW7Dp8OjbyBkbyBSYXN0ZXJcIjtcbmNvbnN0IHZpZXdlck1vZGVUaXRsZSA9IFwiU29tZW50ZSBMZWl0dXJhXCI7XG5jb25zdCB2aWV3ZXJNb2RlTWVzc2FnZSA9IFwiTyBpdGVtIGRvIG1vZGVsbyBkZSBmdW7Dp8OjbyByYXN0ZXIgw6kgc29tZW50ZSBsZWl0dXJhLiBBcyBhbHRlcmHDp8O1ZXMgbsOjbyBwb2RlbSBzZXIgc2FsdmFzLlwiO1xuY29uc3QgdXNlclN0YXJ0RGlyZWN0aW9uID0gXCJTZWxlY2lvbmUgdW1hIGZ1bsOnw6NvIHBhcmEgaW5pY2lhciBhIGNvbnN0cnXDp8OjbyBkZSB1bSBtb2RlbG8gZGUgZnVuw6fDo28gZG8gcmFzdGVyLlwiO1xuY29uc3Qgc2VsZWN0RnVuY3Rpb24gPSBcIkFkaWNpb25hciBGdW7Dp8Ojb1wiO1xuY29uc3QgZGVzZWxlY3RGdW5jdGlvbiA9IFwiRnVuw6fDo28gUmVtb3ZlclwiO1xuY29uc3QgZGlhbG9nVGl0bGUgPSBcIlNpc3RlbWFcIjtcbmNvbnN0IGNhdGVnb3J5ID0gXCJDYXRlZ29yaWFzXCI7XG5jb25zdCBzZWFyY2ggPSBcIlByb2N1cmFyIEZ1bsOnw7VlcyBkZSBSYXN0ZXJcIjtcbmNvbnN0IGNhdGVnb3J5TmFtZXMgPSB7XG5cdGFuYWx5c2lzOiBcIkFuw6FsaXNlXCIsXG5cdGFwcGVhcmFuY2U6IFwiQXBhcsOqbmNpYVwiLFxuXHRjbGFzc2lmaWNhdGlvbjogXCJDbGFzc2lmaWNhw6fDo29cIixcblx0Y29udmVyc2lvbjogXCJDb252ZXJzw6NvXCIsXG5cdGNvcnJlY3Rpb246IFwiQ29ycmXDp8Ojb1wiLFxuXHRkYXRhTWFuYWdlbWVudDogXCJHZXJlbmNpYW1lbnRvIGRlIERhZG9zXCIsXG5cdGRpc3RhbmNlOiBcIkRpc3TDom5jaWFcIixcblx0ZGlzdGFuY2VMZWdhY3k6IFwiRGlzdMOibmNpYSAoVmFsaWRhZGEpXCIsXG5cdGh5ZHJvbG9neTogXCJIaWRyb2xvZ2lhXCIsXG5cdG1hdGg6IFwiTWF0ZW3DoXRpY2FcIixcblx0bWF0aENvbmRpdGlvbmFsOiBcIk1hdGVtw6F0aWNhOiBDb25kaWNpb25hbFwiLFxuXHRtYXRoTG9naWNhbDogXCJNYXRlbcOhdGljYTogTMOzZ2ljYVwiLFxuXHRtYXRoVHJpZ29ub21ldHJpYzogXCJNYXRlbcOhdGljYTogVHJpZ29ub23DqXRyaWNvXCIsXG5cdHJlY2xhc3M6IFwiUmVjbGFzc2lmaWNhclwiLFxuXHRzdGF0aXN0aWNhbDogXCJFc3RhdMOtc3RpY2FcIixcblx0c3VyZmFjZTogXCJTdXBlcmbDrWNpZVwiXG59O1xuY29uc3QgY29tbW9uU3RyaW5nc19wdEJSID0ge1xuXHRvazogb2ssXG5cdGNhbmNlbDogY2FuY2VsLFxuXHRlbnRlclVSTDogZW50ZXJVUkwsXG5cdHNlcnZpY2VVUkw6IHNlcnZpY2VVUkwsXG5cdHNlbGVjdFJhc3Rlcjogc2VsZWN0UmFzdGVyLFxuXHRmYWlsZWRUb0xvYWRMYXllcjogZmFpbGVkVG9Mb2FkTGF5ZXIsXG5cdGxvYWRpbmdMYXllcjogbG9hZGluZ0xheWVyLFxuXHRzZWxlY3RGZWF0dXJlOiBzZWxlY3RGZWF0dXJlLFxuXHRlbnRlckZVUkw6IGVudGVyRlVSTCxcblx0YWRkUmFzdGVyOiBhZGRSYXN0ZXIsXG5cdGFkZFNjYWxhcjogYWRkU2NhbGFyLFxuXHRyYXN0ZXI6IHJhc3Rlcixcblx0c2NhbGFyOiBzY2FsYXIsXG5cdGRlZmF1bHRNb2RlbE5hbWU6IGRlZmF1bHRNb2RlbE5hbWUsXG5cdGdlbmVyYWw6IGdlbmVyYWwsXG5cdHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMsXG5cdHZhcmlhYmxlczogdmFyaWFibGVzLFxuXHRuYW1lOiBuYW1lLFxuXHRkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG5cdHBhcmFtZXRlcjogcGFyYW1ldGVyLFxuXHRpc1B1YmxpYzogaXNQdWJsaWMsXG5cdGlzRGF0YXNldDogaXNEYXRhc2V0LFxuXHR1bmtub3duUGl4ZWxUeXBlOiB1bmtub3duUGl4ZWxUeXBlLFxuXHRvdXRwdXRQaXhlbFR5cGU6IG91dHB1dFBpeGVsVHlwZSxcblx0dThQaXhlbFR5cGU6IHU4UGl4ZWxUeXBlLFxuXHRzOFBpeGVsVHlwZTogczhQaXhlbFR5cGUsXG5cdHUxNlBpeGVsVHlwZTogdTE2UGl4ZWxUeXBlLFxuXHRzMTZQaXhlbFR5cGU6IHMxNlBpeGVsVHlwZSxcblx0dTMyUGl4ZWxUeXBlOiB1MzJQaXhlbFR5cGUsXG5cdHMzMlBpeGVsVHlwZTogczMyUGl4ZWxUeXBlLFxuXHRmMzJQaXhlbFR5cGU6IGYzMlBpeGVsVHlwZSxcblx0ZjY0UGl4ZWxUeXBlOiBmNjRQaXhlbFR5cGUsXG5cdHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdG11bHRpZGltZW5zaW9uYWxSdWxlczogbXVsdGlkaW1lbnNpb25hbFJ1bGVzLFxuXHRtYXRjaFZhcmlhYmxlczogbWF0Y2hWYXJpYWJsZXMsXG5cdHVuaW9uRGltZW5zaW9uczogdW5pb25EaW1lbnNpb25zLFxuXHRyYXN0ZXJGdW5jdGlvbkVkaXRvcjogcmFzdGVyRnVuY3Rpb25FZGl0b3IsXG5cdHJmeExpY2Vuc2VJbmZvOiByZnhMaWNlbnNlSW5mbyxcblx0cmFzdGVyRnVuY3Rpb25zOiByYXN0ZXJGdW5jdGlvbnMsXG5cdGNvcHk6IGNvcHksXG5cdHNhdmU6IHNhdmUsXG5cdHRpdGxlOiB0aXRsZSxcblx0Zm9sZGVyOiBmb2xkZXIsXG5cdHRhZ3M6IHRhZ3MsXG5cdHNhdmluZ01lc3NhZ2U6IHNhdmluZ01lc3NhZ2UsXG5cdHNoYXJlV2l0aDogc2hhcmVXaXRoLFxuXHRzaGFyZTogc2hhcmUsXG5cdHNldFNoYXJpbmdMZXZlbDogc2V0U2hhcmluZ0xldmVsLFxuXHRzZXRHcm91cFNoYXJpbmc6IHNldEdyb3VwU2hhcmluZyxcblx0b3duZXI6IG93bmVyLFxuXHRvcmdhbml6YXRpb246IG9yZ2FuaXphdGlvbixcblx0ZXZlcnlvbmU6IGV2ZXJ5b25lLFxuXHRncm91cHM6IGdyb3Vwcyxcblx0dHlwZTogdHlwZSxcblx0bW9zYWljOiBtb3NhaWMsXG5cdGl0ZW1Hcm91cDogaXRlbUdyb3VwLFxuXHRpdGVtOiBpdGVtLFxuXHRkZWZpbml0aW9uUXVlcnk6IGRlZmluaXRpb25RdWVyeSxcblx0Z3JvdXBJdGVtc0J5OiBncm91cEl0ZW1zQnksXG5cdGdyb3VwRmllbGROYW1lOiBncm91cEZpZWxkTmFtZSxcblx0dGFnRmllbGROYW1lOiB0YWdGaWVsZE5hbWUsXG5cdG5vVGl0bGVUYWdFcnJvck1zZzogbm9UaXRsZVRhZ0Vycm9yTXNnLFxuXHRub1RpdGxlRXJyb3JNc2c6IG5vVGl0bGVFcnJvck1zZyxcblx0bm9UYWdFcnJvck1zZzogbm9UYWdFcnJvck1zZyxcblx0ZXJyb3I6IGVycm9yLFxuXHR3YXJuaW5nOiB3YXJuaW5nLFxuXHRzdWNjZXNzOiBzdWNjZXNzLFxuXHRkZXRhaWxzOiBkZXRhaWxzLFxuXHR0cnlBZ2FpbjogdHJ5QWdhaW4sXG5cdHRvb2xNb2RlbGVyOiB0b29sTW9kZWxlcixcblx0dG9vbEVkaXRvcjogdG9vbEVkaXRvcixcblx0dG9vbERldGFpbHNFZGl0b3I6IHRvb2xEZXRhaWxzRWRpdG9yLFxuXHRzYXZlVXRpbHM6IHNhdmVVdGlscyxcblx0Y2xvc2U6IGNsb3NlLFxuXHR1bnNhdmVkV2FybmluZ0V4aXN0aW5nOiB1bnNhdmVkV2FybmluZ0V4aXN0aW5nLFxuXHR1bnNhdmVkV2FybmluZ05ldzogdW5zYXZlZFdhcm5pbmdOZXcsXG5cdHNhdmVBczogc2F2ZUFzLFxuXHRkb250U2F2ZTogZG9udFNhdmUsXG5cdHVuc2F2ZWRUaXRsZTogdW5zYXZlZFRpdGxlLFxuXHRpbnZhbGlkUkZUTWVzc2FnZTogaW52YWxpZFJGVE1lc3NhZ2UsXG5cdGVycm9yVGl0bGU6IGVycm9yVGl0bGUsXG5cdGJyZWFkY3J1bWI6IGJyZWFkY3J1bWIsXG5cdGJyZWFkY3J1bWJFZGl0b3I6IGJyZWFkY3J1bWJFZGl0b3IsXG5cdHZpZXdlck1vZGVUaXRsZTogdmlld2VyTW9kZVRpdGxlLFxuXHR2aWV3ZXJNb2RlTWVzc2FnZTogdmlld2VyTW9kZU1lc3NhZ2UsXG5cdHVzZXJTdGFydERpcmVjdGlvbjogdXNlclN0YXJ0RGlyZWN0aW9uLFxuXHRzZWxlY3RGdW5jdGlvbjogc2VsZWN0RnVuY3Rpb24sXG5cdGRlc2VsZWN0RnVuY3Rpb246IGRlc2VsZWN0RnVuY3Rpb24sXG5cdGRpYWxvZ1RpdGxlOiBkaWFsb2dUaXRsZSxcblx0Y2F0ZWdvcnk6IGNhdGVnb3J5LFxuXHRzZWFyY2g6IHNlYXJjaCxcblx0Y2F0ZWdvcnlOYW1lczogY2F0ZWdvcnlOYW1lc1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY29tbW9uU3RyaW5nc19wdEJSO1xuZXhwb3J0IHsgYWRkUmFzdGVyLCBhZGRTY2FsYXIsIGJyZWFkY3J1bWIsIGJyZWFkY3J1bWJFZGl0b3IsIGNhbmNlbCwgY2F0ZWdvcnksIGNhdGVnb3J5TmFtZXMsIGNsb3NlLCBjb3B5LCBkZWZhdWx0TW9kZWxOYW1lLCBkZWZpbml0aW9uUXVlcnksIGRlc2NyaXB0aW9uLCBkZXNlbGVjdEZ1bmN0aW9uLCBkZXRhaWxzLCBkaWFsb2dUaXRsZSwgZG9udFNhdmUsIGVudGVyRlVSTCwgZW50ZXJVUkwsIGVycm9yLCBlcnJvclRpdGxlLCBldmVyeW9uZSwgZjMyUGl4ZWxUeXBlLCBmNjRQaXhlbFR5cGUsIGZhaWxlZFRvTG9hZExheWVyLCBmb2xkZXIsIGdlbmVyYWwsIGdyb3VwRmllbGROYW1lLCBncm91cEl0ZW1zQnksIGdyb3VwcywgaW52YWxpZFJGVE1lc3NhZ2UsIGlzRGF0YXNldCwgaXNQdWJsaWMsIGl0ZW0sIGl0ZW1Hcm91cCwgbG9hZGluZ0xheWVyLCBtYXRjaFZhcmlhYmxlcywgbW9zYWljLCBtdWx0aWRpbWVuc2lvbmFsUnVsZXMsIG5hbWUsIG5vVGFnRXJyb3JNc2csIG5vVGl0bGVFcnJvck1zZywgbm9UaXRsZVRhZ0Vycm9yTXNnLCBvaywgb3JnYW5pemF0aW9uLCBvdXRwdXRQaXhlbFR5cGUsIG93bmVyLCBwYXJhbWV0ZXIsIHBhcmFtZXRlcnMsIHByb3BlcnRpZXMsIHJhc3RlciwgcmFzdGVyRnVuY3Rpb25FZGl0b3IsIHJhc3RlckZ1bmN0aW9ucywgcmZ4TGljZW5zZUluZm8sIHMxNlBpeGVsVHlwZSwgczMyUGl4ZWxUeXBlLCBzOFBpeGVsVHlwZSwgc2F2ZSwgc2F2ZUFzLCBzYXZlVXRpbHMsIHNhdmluZ01lc3NhZ2UsIHNjYWxhciwgc2VhcmNoLCBzZWxlY3RGZWF0dXJlLCBzZWxlY3RGdW5jdGlvbiwgc2VsZWN0UmFzdGVyLCBzZXJ2aWNlVVJMLCBzZXRHcm91cFNoYXJpbmcsIHNldFNoYXJpbmdMZXZlbCwgc2hhcmUsIHNoYXJlV2l0aCwgc3VjY2VzcywgdGFnRmllbGROYW1lLCB0YWdzLCB0aXRsZSwgdG9vbERldGFpbHNFZGl0b3IsIHRvb2xFZGl0b3IsIHRvb2xNb2RlbGVyLCB0cnlBZ2FpbiwgdHlwZSwgdTE2UGl4ZWxUeXBlLCB1MzJQaXhlbFR5cGUsIHU4UGl4ZWxUeXBlLCB1bmlvbkRpbWVuc2lvbnMsIHVua25vd25QaXhlbFR5cGUsIHVuc2F2ZWRUaXRsZSwgdW5zYXZlZFdhcm5pbmdFeGlzdGluZywgdW5zYXZlZFdhcm5pbmdOZXcsIHVzZXJTdGFydERpcmVjdGlvbiwgdmFyaWFibGVzLCB2aWV3ZXJNb2RlTWVzc2FnZSwgdmlld2VyTW9kZVRpdGxlLCB3YXJuaW5nIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi1zdHJpbmdzLnB0LUJSLTEzYTY1OGJkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==