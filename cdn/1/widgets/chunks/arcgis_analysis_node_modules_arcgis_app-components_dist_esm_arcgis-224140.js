"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-224140"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-drag-and-drop.entry.js":
/*!***********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-drag-and-drop.entry.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_drag_and_drop: () => (/* binding */ ArcgisDragAndDrop)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale-050b6db9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js");
/* harmony import */ var _file_bf8ab90f_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./file-bf8ab90f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/file-bf8ab90f.js");
/* harmony import */ var _privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./privileges-5c382f61.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/privileges-5c382f61.js");
/* harmony import */ var _item_types_586f0301_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./item-types-586f0301.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-types-586f0301.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./item-types-2029b06b.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-types-2029b06b.js");
/* harmony import */ var _guid_aeaed84d_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./guid-aeaed84d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/guid-aeaed84d.js");
/* harmony import */ var _item_3535552d_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./item-3535552d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-3535552d.js");
/* harmony import */ var _url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./url-4c3ae54c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/url-4c3ae54c.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */














const helpMapNumbers = {
    append: 120001300,
    default: 120000456
};
function validateAddedFile(files, isFolder, user, fileConstraints, uiInfo) {
    var _a, _b;
    // Check if unzipped shapefile, then
    // Check if multiple files uploaded, then
    // Check if file extension is supported
    // If it passes all those tests, update the page
    const { helpBase, helpMap, i18n, helpIdType } = uiInfo;
    const { extension } = (0,_file_bf8ab90f_js__WEBPACK_IMPORTED_MODULE_2__.s)(files[0]);
    const { maxFileSize, allowedExtensions } = fileConstraints;
    let valid = false;
    let errorMessage;
    const validExtension = (_a = allowedExtensions === null || allowedExtensions === void 0 ? void 0 : allowedExtensions.includes(extension)) !== null && _a !== void 0 ? _a : true;
    const foundShapefile = Object.keys(files).some((key) => {
        const { extension } = (0,_file_bf8ab90f_js__WEBPACK_IMPORTED_MODULE_2__.s)(files[key]);
        const shapefileExtensions = ["shp", "shx", "dbf", "prj"];
        return shapefileExtensions.includes(extension);
    });
    const validationTypes = (_b = fileConstraints.validationTypes) !== null && _b !== void 0 ? _b : null;
    const possibleType = (0,_item_types_586f0301_js__WEBPACK_IMPORTED_MODULE_4__.f)((0,_file_bf8ab90f_js__WEBPACK_IMPORTED_MODULE_2__.s)(files[0]).extension, validationTypes)[0];
    const validFileType = possibleType &&
        (possibleType.appendUploadFormat || possibleType.allowAddDirect || !possibleType.orgOnly || !(0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_3__.a)(user));
    if (foundShapefile) {
        errorMessage = {
            title: i18n.error.shapefileErrorTitle,
            message: i18n.error.shapefileErrorMessage,
            link: {
                text: i18n.error.shapefileErrorLink,
                path: `${helpBase}${helpMap["120002804"]}`
            }
        };
    }
    else if (files.length > 1) {
        errorMessage = {
            title: i18n.error.multipleFilesErrorTitle,
            message: i18n.error.multipleFilesErrorMessage
        };
    }
    else if (maxFileSize != null && files[0].size > maxFileSize) {
        const sizeInMB = maxFileSize / 1000000;
        errorMessage = { message: i18n.error.maxSize.replace("${size}", sizeInMB.toString()) };
    }
    else if (!validFileType || !validExtension) {
        const helpMapNumber = helpMapNumbers[helpIdType];
        isFolder
            ? (errorMessage = {
                message: i18n.error.folderError
            })
            : (errorMessage = {
                title: i18n.error.unsupportedFileTypeTitle,
                link: {
                    text: i18n.error.unsupportedFileTypeMessage,
                    path: `${helpBase}${helpMap[helpMapNumber]}`
                }
            });
    }
    else {
        valid = true;
    }
    return { success: valid, errorMessage };
}

const arcgisDragAndDropCss = ".drag-and-drop-well{position:relative}.drag-and-drop-well ::slotted(*){transition:all 200ms ease-in-out;position:relative;border:2px dashed transparent}.drag-and-drop-well ::slotted(*):before{content:\"\";position:absolute;top:0;right:0;bottom:0;left:0;background-color:rgba(0, 121, 193, 0) !important;pointer-events:none;transition:background-color 200ms ease-in-out !important;z-index:2}.dragging ::slotted(*){border-color:#007ac2 !important}.dragging ::slotted(*):before{border-color:#007ac2 !important;background-color:rgba(0, 121, 193, 0.05) !important}.notice-container{display:flex;align-items:center;justify-content:center;position:absolute;top:0px;left:0px;right:0px;pointer-events:none;z-index:10}.alert__message{display:block;line-height:1.375}.alert__link{display:inline}.full-height{height:100%}";

const ArcgisDragAndDrop = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisDropSuccess = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisDropSuccess", 7);
        this.arcgisAlertActive = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisAlertActive", 7);
        this.arcgisDragOver = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisDragOver", 7);
        this.config = undefined;
        this.user = undefined;
        this.active = true;
        this.alertMessage = { title: "" };
        this.alertActive = false;
        this.error = false;
        this.files = undefined;
        this.allowedExtensions = null;
        this.validTypes = null;
        this.dragOverNoticeMessage = undefined;
        this.insideModal = undefined;
        this.fullHeight = undefined;
        this.showHelpLinkOnError = true;
        this.maxFileSize = undefined;
        this.helpIdType = "default";
        this.isFolder = false;
        this.dragOver = undefined;
    }
    handleAlertChange() {
        var _a, _b;
        const { alertActive } = this;
        if (alertActive) {
            window.dispatchEvent(new CustomEvent("calciteInternalAlertSync", { detail: { queue: [] } }));
            (_a = this.el.shadowRoot.querySelector("#new-item-alert")) === null || _a === void 0 ? void 0 : _a.setAttribute("active", "");
        }
        else {
            (_b = this.el.shadowRoot.querySelector("#new-item-alert")) === null || _b === void 0 ? void 0 : _b.removeAttribute("active");
        }
        this.arcgisAlertActive.emit(alertActive);
    }
    handleFileUpdate() {
        const { files, i18n, isFolder, user, config, validTypes, helpIdType } = this;
        const { success, errorMessage } = validateAddedFile(files, isFolder, user, {
            allowedExtensions: this.allowedExtensions,
            maxFileSize: this.maxFileSize,
            validationTypes: validTypes
        }, { helpIdType, i18n, helpBase: config.helpBase, helpMap: config.helpMap });
        if (success) {
            this.arcgisDropSuccess.emit(files[0]);
        }
        else {
            this.alertMessage = errorMessage;
            this.alertActive = true;
        }
    }
    handleDragOver(e) {
        if (e.dataTransfer.types.includes("Files")) {
            if (this.wellRef) {
                // * Make sure the notice is visible on screen
                const windowHeight = window.innerHeight;
                const { y: wellOffsetTop, bottom } = this.wellRef.getBoundingClientRect();
                const topBoundary = Math.max(wellOffsetTop, 0);
                const bottomBoundary = Math.min(windowHeight, bottom);
                this.noticeRef.style.height = `${bottomBoundary - topBoundary}px`;
                // -Math.min(0, wellOffsetTop) because:
                //  --- when the well's top is NOT visible, we'll have wellOffsetTop < 0
                //  => we'll offset `top` of the notice's container by that amount
                //  --- when the well's top is visible, we'll have wellOffsetTop > 0
                //  => we'll use 0 for the top of the notice's container
                const relativeTop = -Math.min(0, wellOffsetTop);
                this.noticeRef.style.top = `${relativeTop}px`;
            }
            e.preventDefault();
            this.dragOver = true;
            this.arcgisDragOver.emit(this.dragOver);
        }
        return false;
    }
    async componentWillLoad() {
        const locale = await (0,_locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_1__.g)(this.el);
        this.i18n = locale[0];
    }
    render() {
        const { title, message, link } = this.alertMessage;
        const { text, path } = Object.assign({}, link);
        const { active, dragOverNoticeMessage, dragOver, insideModal, fullHeight, showHelpLinkOnError } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { ref: (ele) => (this.wellRef = ele), class: {
                hide: !active,
                "drag-and-drop-well": true,
                dragging: this.dragOver,
                "full-height": fullHeight
            }, onDragOver: active && this.handleDragOver.bind(this), onDragLeave: () => {
                this.dragOver = false;
            }, onDrop: (e) => {
                var _a, _b, _c, _d;
                if (!active) {
                    return;
                }
                e.preventDefault();
                this.alertActive = false;
                this.dragOver = false;
                const { files, items } = e.dataTransfer;
                const item = items === null || items === void 0 ? void 0 : items[0];
                this.isFolder =
                    ((_d = ((_b = (_a = item.webkitGetAsEntry) === null || _a === void 0 ? void 0 : _a.call(item)) !== null && _b !== void 0 ? _b : (_c = item === null || item === void 0 ? void 0 : item.getAsEntry) === null || _c === void 0 ? void 0 : _c.call(item))) === null || _d === void 0 ? void 0 : _d.isDirectory) || false;
                this.files = files;
            } }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", null), insideModal ? (
        // TODO: consider having this component return an error code rather than a full alert
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-new-item-alert", { id: "new-item-alert", kind: "danger", onAlertDismiss: () => {
                this.alertActive = false;
            }, active: !!this.alertActive, heading: title, description: message, link: { href: link === null || link === void 0 ? void 0 : link.path, title: link === null || link === void 0 ? void 0 : link.text } })) : ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-alert", { label: "", id: "new-item-alert", icon: true, kind: "danger", onCalciteAlertClose: () => {
                this.alertActive = false;
            }, open: !!this.alertActive, tabIndex: !this.alertActive ? -1 : null, ref: (el) => {
                // here, we hide the queue as it takes up too much room on mobile and we're not using it
                const queue = el.shadowRoot.querySelector(".alert-queue-count");
                if (queue) {
                    queue.style.display = "none";
                }
            } }, title && (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "title" }, title), message && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "message", class: "alert__message" }, message)), showHelpLinkOnError && link && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-link", { slot: "link", target: "_blank", href: path, class: "alert__link" }, text)))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "notice-container", ref: (ele) => (this.noticeRef = ele) }, dragOverNoticeMessage && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-notice", { icon: "upload-to", open: dragOver, scale: "m", width: "auto" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "message" }, dragOverNoticeMessage))))));
    }
    get el() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
    static get watchers() { return {
        "alertActive": ["handleAlertChange"],
        "files": ["handleFileUpdate"]
    }; }
};
ArcgisDragAndDrop.style = arcgisDragAndDropCss;



//# sourceMappingURL=arcgis-drag-and-drop.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/file-bf8ab90f.js":
/*!**********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/file-bf8ab90f.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ sanitizeFileName),
/* harmony export */   f: () => (/* binding */ formatFileSize),
/* harmony export */   g: () => (/* binding */ getItemInfoByType),
/* harmony export */   s: () => (/* binding */ sanitizeFileInput),
/* harmony export */   v: () => (/* binding */ validateOverwriteFileName)
/* harmony export */ });
/* harmony import */ var _item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./item-types-2029b06b.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-types-2029b06b.js");
/* harmony import */ var _guid_aeaed84d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./guid-aeaed84d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/guid-aeaed84d.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



function sanitizeFileName(name, addGUID) {
    //TODO: add new param to spec file.
    const expression = /(?:\.([^.]+))?$/;
    const invalidTitleCharacters = /\.|-/g;
    let fileName = name.replace(/^.*(\\|\/|:)/, "");
    let extension = (fileName && expression.exec(fileName)[1] ? expression.exec(fileName)[1].toLowerCase() : "");
    let title = "";
    if (fileName.indexOf(".rft.") > -1) {
        const [name, suffix] = fileName.split(".rft.");
        extension = `rft.${suffix}`;
        title = name;
    }
    if (fileName && !title) {
        title = fileName.lastIndexOf(".") === -1 ? fileName : fileName.substring(0, fileName.lastIndexOf("."));
    }
    // Replace any invalid characters with an underscore
    title = title.replace(invalidTitleCharacters, "_");
    // Allow file upload of existing item's file name // currently used in append
    if (addGUID) {
        title = makeUniqueFileName(title);
        fileName = `${title}.${extension}`;
    }
    return { title, fileName, extension };
}
// Helper method that takes in a file & returns the cleaned up file name as is and in title form, and the detected file extension
function sanitizeFileInput(file, addGUID) {
    return sanitizeFileName(file.name, !!addGUID);
}
function makeUniqueFileName(name) {
    return `${name}_${(0,_guid_aeaed84d_js__WEBPACK_IMPORTED_MODULE_1__.g)()}`;
}
function validateOverwriteFileName(uploadedFileName, sourceFileName) {
    let fileName = uploadedFileName;
    const position = uploadedFileName.lastIndexOf("\\");
    if (position > -1) {
        fileName = fileName.substring(position + 1, fileName.length);
    }
    return fileName.replace(/\ /g, "_") === sourceFileName.replace(/\ /g, "_");
}
function getItemInfoByType(type) {
    if (_item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_0__.a[type]) {
        return _item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_0__.a[type];
    }
    else {
        return _item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_0__.a[Object.keys(_item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_0__.a).find((fileType) => _item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_0__.a[fileType].type === type)];
    }
}
function formatFileSize(size) {
    if (!size) {
        return "0 B";
    }
    const i = Math.floor(Math.log(size) / Math.log(1024));
    const adjustedSize = Math.round(size / Math.pow(1024, i));
    const unit = ["B", "KB", "MB", "GB", "TB"][i];
    return `${adjustedSize} ${unit}`;
}



//# sourceMappingURL=file-bf8ab90f.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
    let timeout;
    let status = "idle";
    function flush(...args) {
        status = "flushed";
        return debounced(...args);
    }
    function invoke(...args) {
        status = "invoked";
        return debounced(...args);
    }
    function cancel(...args) {
        status = "cancelled";
        return debounced(...args);
    }
    function getStatus() {
        return status;
    }
    const debounced = (...args) => new Promise((resolve) => {
        switch (status) {
            case "flushed":
                status = "idle";
                if (timeout) {
                    clearTimeout(timeout);
                    resolve(fn(...args));
                }
                else {
                    resolve(null);
                }
                break;
            case "invoked":
                clearTimeout(timeout);
                status = "idle";
                resolve(fn(...args));
                break;
            case "cancelled":
                clearTimeout(timeout);
                status = "idle";
                resolve(null);
                break;
            default:
                if (timeout) {
                    clearTimeout(timeout);
                }
                status = "pending";
                timeout = setTimeout(() => {
                    status = "idle";
                    return resolve(fn(...args));
                }, delay);
                break;
        }
    });
    debounced.flush = flush;
    debounced.invoke = invoke;
    debounced.cancel = cancel;
    debounced.getStatus = getStatus;
    return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
    let timeout;
    return (...args) => new Promise((resolve) => {
        if (timeout) {
            return;
        }
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            timeout = undefined;
            resolve(fn(...args));
        }, delay);
    });
};
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
    await Promise.all([promise, timeout(minDelay)]);
    return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
    const { key, data } = getKeyAndItem(item);
    return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
    const resultArr = [];
    const lookupMap = {};
    myArr.forEach((item) => {
        const id = getItemId(item);
        if (lookupMap[id] == null) {
            lookupMap[id] = item;
            resultArr.push(item);
        }
    });
    return resultArr;
}
function unique(myArr) {
    const primitives = { boolean: {}, number: {}, string: {} };
    const objs = [];
    return myArr.filter((item) => {
        let type = typeof item;
        if (type in primitives) {
            return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
        }
        else {
            return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
    });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));



//# sourceMappingURL=functional-44de8fcf.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/guid-aeaed84d.js":
/*!**********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/guid-aeaed84d.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ guid)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
function generateId(counts) {
    return counts
        .map((count) => {
        let out = "";
        for (let i = 0; i < count; i++) {
            out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }
        return out;
    })
        .join("-");
}
const guid = () => generateId([2, 1, 1, 1, 3]);



//# sourceMappingURL=guid-aeaed84d.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-3535552d.js":
/*!**********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-3535552d.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ isSubscriber),
/* harmony export */   b: () => (/* binding */ isPremium),
/* harmony export */   c: () => (/* binding */ canUpdateItem),
/* harmony export */   d: () => (/* binding */ itemsBelongToUserOrg),
/* harmony export */   g: () => (/* binding */ getItemHomeAppUrl),
/* harmony export */   i: () => (/* binding */ isOwner),
/* harmony export */   u: () => (/* binding */ userIsItemAdmin)
/* harmony export */ });
/* harmony import */ var _url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url-4c3ae54c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/url-4c3ae54c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


function isEsri(item) {
    var _a;
    return !!((_a = item.owner) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes("esri"));
}
function isPremium(item) {
    var _a;
    return isEsri(item) && !!((_a = item.typeKeywords) === null || _a === void 0 ? void 0 : _a.includes("Requires Credits"));
}
function isSubscriber(item) {
    var _a;
    return isEsri(item) && !!((_a = item.typeKeywords) === null || _a === void 0 ? void 0 : _a.includes("Requires Subscription"));
}
function isOwner(item, user) {
    return item.owner === user.username;
}
/**
 * Can the user update the item
 */
function canUpdateItem(item, user) {
    return userIsItemAdmin(item, user) || item.itemControl === "update";
}
/**
 * Is the user either an owner or admin of the item
 */
function userIsItemAdmin(item, user) {
    return isOwner(item, user) || isItemAdmin(item, user);
}
/**
 * Does the user have admin capabilities on this item
 */
function isItemAdmin(item, user) {
    var _a;
    // if this flag is already set (probably home app), use it
    if (item.isAdmin != null) {
        return !!item.isAdmin;
    }
    const itemOwner = item.owner;
    const itemControlAdmin = item.itemControl === "admin";
    const esriUsers = ["esri_livingatlas", "esri_demographics", "esri_boundaries"];
    if (((_a = item.portal) === null || _a === void 0 ? void 0 : _a.isPortal) &&
        !isOwner(item, user) &&
        itemControlAdmin &&
        itemOwner.includes("esri_") &&
        // portal incorrectly returns "itemControl="admin" for esri owned items
        !esriUsers.includes(itemOwner)) {
        return false;
    }
    return itemControlAdmin;
}
const itemsBelongToUserOrg = (items, user) => {
    return !!user.orgId && items.every((item) => item.isOrgItem);
};
const getItemHomeAppUrl = (itemId, baseUrl) => `${(0,_url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_0__.a)(baseUrl)}item.html?id=${itemId}`;



//# sourceMappingURL=item-3535552d.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-types-586f0301.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-types-586f0301.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ isLargeCSV),
/* harmony export */   f: () => (/* binding */ findPossibleItemTypesByExtension),
/* harmony export */   i: () => (/* binding */ isLargeGeoJSON),
/* harmony export */   m: () => (/* binding */ mapItemTypesToFileExtensions)
/* harmony export */ });
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/* harmony import */ var _item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./item-types-2029b06b.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-types-2029b06b.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



function findPossibleItemTypesByExtension(extension, validationTypes) {
    // Search item types extensions for the one imported
    let itemTypes;
    if (validationTypes) {
        itemTypes = validationTypes.map((value) => {
            return value.type;
        });
    }
    else {
        itemTypes = Object.keys(_item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_1__.a);
    }
    let possibleItemTypes = [];
    itemTypes.forEach((type) => {
        var _a;
        if (((_a = _item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_1__.a[type].fileExt) === null || _a === void 0 ? void 0 : _a.indexOf(extension)) >= 0) {
            possibleItemTypes.push(_item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_1__.a[type]);
        }
    });
    return possibleItemTypes;
}
function mapItemTypesToFileExtensions(types) {
    if (!types) {
        return null;
    }
    return (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_0__.b)(types.flatMap((type) => { var _a; return (_a = _item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_1__.a[type]) === null || _a === void 0 ? void 0 : _a.fileExt; }).filter((valid) => !!valid));
}
const isLargeGeoJSON = (sizeInBytes) => {
    const sizeInMB = sizeInBytes / 1024 / 1024;
    // https://devtopia.esri.com/WebGIS/arcgis-app-components/issues/2553#issuecomment-3645404
    return sizeInMB > 50; // 50MB
};
const isLargeCSV = (sizeInBytes) => {
    const sizeInMB = sizeInBytes / 1024 / 1024;
    // https://devtopia.esri.com/WebGIS/arcgis-app-components/issues/2875#issuecomment-3748913
    return sizeInMB > 20; // 20MB
};



//# sourceMappingURL=item-types-586f0301.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS_UTILITY),
/* harmony export */   a: () => (/* binding */ formatDate),
/* harmony export */   b: () => (/* binding */ formatPlural),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   l: () => (/* binding */ languageMap)
/* harmony export */ });
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



const languageMap = new Map([
    ["ar", "ar"],
    ["bg", "bg"],
    ["bs", "bs"],
    ["ca", "ca"],
    ["cs", "cs"],
    ["da", "da"],
    ["de", "de"],
    ["el", "el"],
    ["en", "en"],
    ["es", "es"],
    ["et", "et"],
    ["fi", "fi"],
    ["fr", "fr"],
    ["he", "he"],
    ["hr", "hr"],
    ["hu", "hu"],
    ["id", "id"],
    ["it", "it"],
    ["ja", "ja"],
    ["ko", "ko"],
    ["lt", "lt"],
    ["lv", "lv"],
    ["nb", "nb"],
    ["nl", "nl"],
    ["pl", "pl"],
    ["pt-br", "pt-BR"],
    ["pt-pt", "pt-PT"],
    ["ro", "ro"],
    ["ru", "ru"],
    ["sk", "sk"],
    ["sl", "sl"],
    ["sr", "sr"],
    ["sv", "sv"],
    ["th", "th"],
    ["tr", "tr"],
    ["uk", "uk"],
    ["vi", "vi"],
    ["zh-cn", "zh-CN"],
    ["zh-hk", "zh-HK"],
    ["zh-tw", "zh-TW"]
]);
// rtl
function getElementDir(el) {
    return getElementProp(el, "dir", "ltr");
}
function getElementProp(el, prop, value) {
    const closestWithProp = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, `[${prop}]`);
    return closestWithProp ? closestWithProp.getAttribute(prop) : value;
}
// css
const CSS_UTILITY = {
    rtl: "arcgis--rtl"
};
async function formatNumber(number, options) {
    const { api, type, places } = options || {};
    if (api === 4) {
        const [intl] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/intl"]);
        const numberFormatIntlOptions = intl.convertNumberFormatToIntlOptions({
            places,
            style: type,
            digitSeparator: true
        });
        return intl.formatNumber(number, Object.assign(Object.assign({}, numberFormatIntlOptions), { style: type }));
    }
    const [dojoNumber] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["dojo/number"]);
    return dojoNumber.format(number, {
        type,
        places,
        pattern: options === null || options === void 0 ? void 0 : options.pattern
    });
}
const cache = {};
function formatDate(date) {
    const lang = document.documentElement.lang;
    const dayShortMonthYear = {
        year: "numeric",
        month: "short",
        day: "numeric"
    };
    if (!cache[lang]) {
        cache[lang] = new Intl.DateTimeFormat(document.documentElement.lang, dayShortMonthYear);
    }
    return cache[lang].format(date);
}
function formatPlural(lang, stringObj, number) {
    const singles = ["id", "ja", "ko", "th", "vi", "zh-cn", "zh-hk", "zh-tw"];
    const likeEnglish = [
        "en",
        "ca",
        "da",
        "de",
        "el",
        "es",
        "et",
        "fi",
        "hi",
        "hu",
        "it",
        "nb",
        "nl",
        "pt-pt",
        "sv",
        "tr"
    ];
    const locale = lang !== null && lang !== void 0 ? lang : "en";
    // if the number is one, or it is a "simple" language, return the 1 string
    if (number === 1 || singles.includes(locale)) {
        return stringObj.single.replace("${number}", "1");
    }
    // if the number is not 1 and the language uses the same pluralization strategy as english,
    // return the multiple string
    if (number !== 1 && likeEnglish.includes(locale)) {
        return stringObj.multiple.replace("${number}", `${number}`);
    }
    // if none of the above worked, return the "unknown" string
    return stringObj.unknown.replace("${number}", `${number}`);
}



//# sourceMappingURL=languageUtil-ef0e54b2.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
    var _a, _b, _c;
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        // "ru-RU" maps to "ru" use case
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
        }
        else {
            return "en";
        }
    }
}
function getComponentClosestLanguageIntl(element) {
    var _a, _b, _c;
    // it's OK if we don't have the 4 letter language file for it
    // 4 letter language code needed for formatting numbers
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            // we support the 2 letter coded language
            // e.g. it-CH vs it
            return lang;
        }
        else {
            return "en";
        }
    }
}
function fetchLocaleStringsForComponent(componentName, locale) {
    return new Promise((resolve, reject) => {
        fetch((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
            if (result.ok)
                resolve(result.json());
            else
                reject();
        }, () => reject());
    });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
    const id = `${componentName}${locale}`;
    if (!stringCache[id]) {
        stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
    }
    return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
    const componentName = tagName || element.tagName.toLowerCase();
    const componentLanguage = getComponentClosestLanguage(element);
    const componentLanguageIntl = getComponentClosestLanguageIntl(element);
    let strings;
    try {
        strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
    }
    catch (e) {
        console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
        strings = await fetchLocaleStringsFromCache(componentName, "en");
    }
    return [strings, componentLanguage, componentLanguageIntl];
}



//# sourceMappingURL=locale-050b6db9.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/privileges-5c382f61.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/privileges-5c382f61.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ isPublicUser),
/* harmony export */   b: () => (/* binding */ isOrgAdmin),
/* harmony export */   c: () => (/* binding */ isHostedPortal),
/* harmony export */   d: () => (/* binding */ isCustomRole),
/* harmony export */   e: () => (/* binding */ canUpdateOrgGroups),
/* harmony export */   f: () => (/* binding */ canUpdateItemCategories),
/* harmony export */   g: () => (/* binding */ canManageCollaborations),
/* harmony export */   h: () => (/* binding */ isOrgUser),
/* harmony export */   i: () => (/* binding */ isDeveloper),
/* harmony export */   j: () => (/* binding */ canShareItemToGroup),
/* harmony export */   k: () => (/* binding */ canShareItemToOrg),
/* harmony export */   l: () => (/* binding */ adminCanShareOthersItemToGroup),
/* harmony export */   m: () => (/* binding */ canShareOthersItemsToOrg),
/* harmony export */   n: () => (/* binding */ canShareItemToPublic),
/* harmony export */   o: () => (/* binding */ canShareOthersItemsToPublic),
/* harmony export */   p: () => (/* binding */ hasAdminSharePrivilege),
/* harmony export */   q: () => (/* binding */ canViewOthersOrgItems)
/* harmony export */ });
/* harmony import */ var _item_3535552d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./item-3535552d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-3535552d.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const getUserRole = (user) => {
    var _a, _b, _c;
    return typeof (user === null || user === void 0 ? void 0 : user.role) === "string" && !!(user === null || user === void 0 ? void 0 : user.role)
        ? user === null || user === void 0 ? void 0 : user.role
        : (_b = (_a = user === null || user === void 0 ? void 0 : user.roleId) !== null && _a !== void 0 ? _a : user === null || user === void 0 ? void 0 : user.id) !== null && _b !== void 0 ? _b : (_c = user === null || user === void 0 ? void 0 : user.sourceJSON) === null || _c === void 0 ? void 0 : _c.id;
};
function isPublicUser(user) {
    return user && !user.orgId;
}
function isHostedPortal(portal) {
    return !portal.isPortal || !!portal.isBackedBySDS;
}
function isDeveloper(subscriptionInfo) {
    const devSubscriptionTypes = ["Trial Developer", "Developer", "Developer Subscription"];
    return devSubscriptionTypes.includes(subscriptionInfo === null || subscriptionInfo === void 0 ? void 0 : subscriptionInfo.type);
}
function isOrgAdmin(user) {
    return getUserRole(user) === "org_admin" || getUserRole(user) === "account_admin";
}
function isOrgUser(user) {
    return getUserRole(user) === "org_user" || getUserRole(user) === "account_user";
}
function isCustomRole(user) {
    // The Home App collapse the `roleId` and `role` into a single `id` property, that's why
    //  https://devtopia.esri.com/WebGIS/arcgis-portal-app/blob/master/src/js/arcgisonline/sharing/dijit/Role.ts#L469 works
    // In practice, we only need to check if `roleId` exist
    //  https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/44682#issuecomment-4146866
    return !!(user === null || user === void 0 ? void 0 : user.roleId) && user.roleId.length > 0;
}
/**
 * Checks whether the privilege "portal:admin:updateItemCategorySchema" is granted.
 */
function canUpdateItemCategories(user) {
    var _a;
    return !!((_a = user === null || user === void 0 ? void 0 : user.privileges) === null || _a === void 0 ? void 0 : _a.includes("portal:admin:updateItemCategorySchema"));
}
/**
 * Checks whether the privilege "portal:admin:updateGroups" is granted.
 */
function canUpdateOrgGroups(user) {
    var _a;
    return !!((_a = user === null || user === void 0 ? void 0 : user.privileges) === null || _a === void 0 ? void 0 : _a.includes("portal:admin:updateGroups"));
}
/**
 * Checks whether the user is allowed to update other user's items in their organization.
 */
function canUpdateOrgItems(user) {
    return ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:admin:updateItems");
}
/**
 * Checks to ensure the portal is an organization portal
 */
function isOrgPortal(portal) {
    return !!(portal.urlKey && portal.customBaseUrl) || !!portal.isPortal;
}
/**
 * Checks whether the user is allowed to share their item to groups
 */
function canShareItemToGroup(user) {
    return ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:user:shareToGroup");
}
/**
 * Checks whether the user can share an item on a given portal
 */
function canShare(user, portal) {
    return (!isOrgPortal(portal) ||
        canShareItemToGroup(user) ||
        canShareItemToOrg(user) ||
        (!!portal.canSharePublic && canShareItemToPublic(user)));
}
/**
 * Checks whether the user is allowed to share their item ot the organization.
 */
function canShareItemToOrg(user) {
    return ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:user:shareToOrg");
}
/**
 * Checks whether the user is allowed to share their item to public
 */
function canShareItemToPublic(user) {
    return ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:user:shareToPublic");
}
/**
 * Checks whether the user can share other user's items
 */
function canShareOthersItemsToOrg(user) {
    return ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:admin:shareToOrg");
}
/**
 * Checks whether the user can share other user's items
 */
function canShareOthersItemsToPublic(user) {
    return ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:admin:shareToPublic");
}
/**
 * Checks whether the user can share other user's items
 */
function adminCanShareOthersItemToGroup(user) {
    return ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:admin:shareToGroup");
}
/**
 * Checks whether the user is in an allowed organization and has the power to manage collaborations
 */
function canManageCollaborations(config, user, portal, subscriptionInfo) {
    const excludedOrgTypes = ["Trial", "Trial Press", "Trial Developer", "Developer Subscription", "Evaluation"];
    const isValidOrgType = subscriptionInfo && !excludedOrgTypes.includes(subscriptionInfo.type);
    const hasPrivilege = ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:admin:manageCollaborations");
    return !!((config === null || config === void 0 ? void 0 : config.collaborationsEnabled) &&
        user &&
        (isOrgAdmin(user) || hasPrivilege) &&
        ((portal === null || portal === void 0 ? void 0 : portal.isPortal) || isValidOrgType));
}
/**
 * Checks whether the user can view other organization users' items
 */
function canViewOrgItems(user) {
    return ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:admin:viewItems");
}
/**
 * Checks whether the user can view other organization users' items
 */
function canViewOthersOrgItems(user) {
    return !!user && (!isCustomRole(user) || (isCustomRole(user) && canViewOrgItems(user)));
}
// TODO: add unit tests
const hasAdminSharePrivilege = ({ items, user, portal }) => {
    const item = items[0];
    // enterprise incorrectly returns items owned by "esri_" as item control admin (WebGIS/arcgis-portal-app#38695)
    const owner = item.owner;
    const whitelistOwner = ["esri_livingatlas"];
    if (portal.isPortal && owner !== user.username && owner.includes("esri_") && !whitelistOwner.includes(owner)) {
        return false;
    }
    const isOwnerOrAdmin = (0,_item_3535552d_js__WEBPACK_IMPORTED_MODULE_0__.u)(item, user);
    const isCustom = isCustomRole(user);
    const canShareOrgItems = canShareOthersItems(user);
    const canUpdateAndShare = (0,_item_3535552d_js__WEBPACK_IMPORTED_MODULE_0__.c)(item, user) &&
        canUpdateOrgItems(user) &&
        !isCustom &&
        (canShare(user, portal) || canShareOthersItems(user));
    // if it's the item owner or admin, or custom admin who can share
    return isOwnerOrAdmin || canUpdateAndShare || ((0,_item_3535552d_js__WEBPACK_IMPORTED_MODULE_0__.d)(items, user) && canShareOrgItems);
};
/**
 * Checks whether the user can share other user's items
 */
function canShareOthersItems(user) {
    return adminCanShareOthersItemToGroup(user) || canShareOthersItemsToOrg(user) || canShareOthersItemsToPublic(user);
}



//# sourceMappingURL=privileges-5c382f61.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/url-4c3ae54c.js":
/*!*********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/url-4c3ae54c.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ addTrailingSlashIfMissing),
/* harmony export */   b: () => (/* binding */ geoJsonRegExp),
/* harmony export */   c: () => (/* binding */ agsRegExp),
/* harmony export */   g: () => (/* binding */ getRestUrlFromUrl),
/* harmony export */   p: () => (/* binding */ parseAGSServerInfo),
/* harmony export */   r: () => (/* binding */ regexServerType),
/* harmony export */   s: () => (/* binding */ specialCharactersRegExp),
/* harmony export */   v: () => (/* binding */ validArcgisRestServicePath)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
const specialCharactersRegExp = /\+|\?|\/|\(|\)|\\|\!|\#|\"|\||\*|\:|<|>|\%|\$|\@|\'|\^|\[|\]|\,|\=|\;/gi;
const geoJsonRegExp = /(\.|outputFormat=)json|geojson$/i;
const agsRegExp = /\/ags\//gi;

const serverTypes = "MapServer|GeocodeServer|GPServer|GeometryServer|ImageServer|NAServer|FeatureServer|GeoDataServer|GlobeServer|MobileServer|WMServer|SceneServer|VectorTileServer|StreamServer|WorkspaceServer|GeoenrichmentServer|VideoServer";
const regexServerType = new RegExp(`http.+\/(${serverTypes})`);
const validArcgisRestServicePath = `\/arcgis\/rest\/services|\/rest\/services|\/arcgis\/services|\/arcgis\/rest`;
const serverInfoExp = `(?<server>http.+(?:${validArcgisRestServicePath})(?:\/?.*\/(?<name>.*)\/(?<type>${serverTypes})))(?!.*\/${serverTypes})\/?(?<soe>\\d+)?.*`;
/** Returns an array containing the input url, base server url, server name, server type, and layer index (if entered).
 * Example: [
 * "https://sampleserver6.arcgisonline.com/arcgis/rest/services/FeatureServer/500",
 * "https://sampleserver6.arcgisonline.com/arcgis/rest/services/TestService/FeatureServer",
 * "TestService",
 * "FeatureServer",
 * "500"
 * ]  */
const regexServerInfo = new RegExp(serverInfoExp, "i");

const parseAGSServerInfo = (url) => {
    const extractedInfo = url.match(regexServerInfo);
    if (!extractedInfo) {
        const containsAGS = url.match(agsRegExp);
        // Type is always MapServer for /ags/ services
        return containsAGS ? { baseServerUrl: url, serverName: null, serverType: "MapServer", index: null } : null;
    }
    const [, baseServerUrl, serverName, serverType, indexStr] = extractedInfo;
    const index = parseInt(indexStr);
    return { baseServerUrl, serverName, serverType, index: isNaN(index) ? null : index };
};
const getRestUrlFromUrl = (url) => {
    if (!url) {
        return null;
    }
    const extractedInfo = url.match(validArcgisRestServicePath);
    if (!extractedInfo) {
        return null;
    }
    const urlParts = url.split("/rest");
    return urlParts.length < 2 ? null : `${urlParts[0]}/rest/`;
};
const addTrailingSlashIfMissing = (url) => url && url.charAt(url.length - 1) !== "/" ? `${url}/` : url;



//# sourceMappingURL=url-4c3ae54c.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTIyNDE0MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tHO0FBQzVCO0FBQ1Y7QUFDQztBQUNvQjtBQUN0RDtBQUNTO0FBQ0Q7QUFDRDtBQUNOO0FBQ0E7QUFDRDtBQUNPOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0NBQXNDO0FBQ2xELFlBQVksWUFBWSxFQUFFLG9EQUFpQjtBQUMzQyxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZLEVBQUUsb0RBQWlCO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5QkFBeUIsMERBQWdDLENBQUMsb0RBQWlCO0FBQzNFO0FBQ0EscUdBQXFHLDBEQUFZO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTLEVBQUUscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUNBQXVDLEtBQUs7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVMsRUFBRSx1QkFBdUI7QUFDL0Q7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsa0RBQWtELGtCQUFrQixpQ0FBaUMsaUNBQWlDLGtCQUFrQiw4QkFBOEIsd0NBQXdDLGFBQWEsa0JBQWtCLE1BQU0sUUFBUSxTQUFTLE9BQU8saURBQWlELG9CQUFvQix5REFBeUQsVUFBVSx1QkFBdUIsZ0NBQWdDLDhCQUE4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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0RBQWU7QUFDMUM7QUFDQTtBQUNBLDhCQUE4QixvREFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvREFBb0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXliOztBQUV6Yjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBLDRDQUE0QywyQkFBMkIsa0NBQWtDLFlBQVksWUFBWSxZQUFZO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZFQUE2RTtBQUM1RztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBLDBGQUEwRixJQUFJOztBQUVzSDs7QUFFcE4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9hcmNnaXMtZHJhZy1hbmQtZHJvcC5lbnRyeS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9maWxlLWJmOGFiOTBmLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vZ3VpZC1hZWFlZDg0ZC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9pdGVtLTM1MzU1NTJkLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2l0ZW0tdHlwZXMtNTg2ZjAzMDEuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2xvY2FsZS0wNTBiNmRiOS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9wcml2aWxlZ2VzLTVjMzgyZjYxLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL3VybC00YzNhZTU0Yy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgYyBhcyBjcmVhdGVFdmVudCwgaCwgZCBhcyBnZXRFbGVtZW50IH0gZnJvbSAnLi9pbmRleC1lM2JmN2RhNy5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MgfSBmcm9tICcuL2xvY2FsZS0wNTBiNmRiOS5qcyc7XG5pbXBvcnQgeyBzIGFzIHNhbml0aXplRmlsZUlucHV0IH0gZnJvbSAnLi9maWxlLWJmOGFiOTBmLmpzJztcbmltcG9ydCB7IGEgYXMgaXNQdWJsaWNVc2VyIH0gZnJvbSAnLi9wcml2aWxlZ2VzLTVjMzgyZjYxLmpzJztcbmltcG9ydCB7IGYgYXMgZmluZFBvc3NpYmxlSXRlbVR5cGVzQnlFeHRlbnNpb24gfSBmcm9tICcuL2l0ZW0tdHlwZXMtNTg2ZjAzMDEuanMnO1xuaW1wb3J0ICcuL2RvbS00ZDM2NzY3Ny5qcyc7XG5pbXBvcnQgJy4vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzJztcbmltcG9ydCAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgJy4vaXRlbS10eXBlcy0yMDI5YjA2Yi5qcyc7XG5pbXBvcnQgJy4vZ3VpZC1hZWFlZDg0ZC5qcyc7XG5pbXBvcnQgJy4vaXRlbS0zNTM1NTUyZC5qcyc7XG5pbXBvcnQgJy4vdXJsLTRjM2FlNTRjLmpzJztcbmltcG9ydCAnLi9mdW5jdGlvbmFsLTQ0ZGU4ZmNmLmpzJztcblxuY29uc3QgaGVscE1hcE51bWJlcnMgPSB7XG4gICAgYXBwZW5kOiAxMjAwMDEzMDAsXG4gICAgZGVmYXVsdDogMTIwMDAwNDU2XG59O1xuZnVuY3Rpb24gdmFsaWRhdGVBZGRlZEZpbGUoZmlsZXMsIGlzRm9sZGVyLCB1c2VyLCBmaWxlQ29uc3RyYWludHMsIHVpSW5mbykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgLy8gQ2hlY2sgaWYgdW56aXBwZWQgc2hhcGVmaWxlLCB0aGVuXG4gICAgLy8gQ2hlY2sgaWYgbXVsdGlwbGUgZmlsZXMgdXBsb2FkZWQsIHRoZW5cbiAgICAvLyBDaGVjayBpZiBmaWxlIGV4dGVuc2lvbiBpcyBzdXBwb3J0ZWRcbiAgICAvLyBJZiBpdCBwYXNzZXMgYWxsIHRob3NlIHRlc3RzLCB1cGRhdGUgdGhlIHBhZ2VcbiAgICBjb25zdCB7IGhlbHBCYXNlLCBoZWxwTWFwLCBpMThuLCBoZWxwSWRUeXBlIH0gPSB1aUluZm87XG4gICAgY29uc3QgeyBleHRlbnNpb24gfSA9IHNhbml0aXplRmlsZUlucHV0KGZpbGVzWzBdKTtcbiAgICBjb25zdCB7IG1heEZpbGVTaXplLCBhbGxvd2VkRXh0ZW5zaW9ucyB9ID0gZmlsZUNvbnN0cmFpbnRzO1xuICAgIGxldCB2YWxpZCA9IGZhbHNlO1xuICAgIGxldCBlcnJvck1lc3NhZ2U7XG4gICAgY29uc3QgdmFsaWRFeHRlbnNpb24gPSAoX2EgPSBhbGxvd2VkRXh0ZW5zaW9ucyA9PT0gbnVsbCB8fCBhbGxvd2VkRXh0ZW5zaW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWxsb3dlZEV4dGVuc2lvbnMuaW5jbHVkZXMoZXh0ZW5zaW9uKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcbiAgICBjb25zdCBmb3VuZFNoYXBlZmlsZSA9IE9iamVjdC5rZXlzKGZpbGVzKS5zb21lKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgeyBleHRlbnNpb24gfSA9IHNhbml0aXplRmlsZUlucHV0KGZpbGVzW2tleV0pO1xuICAgICAgICBjb25zdCBzaGFwZWZpbGVFeHRlbnNpb25zID0gW1wic2hwXCIsIFwic2h4XCIsIFwiZGJmXCIsIFwicHJqXCJdO1xuICAgICAgICByZXR1cm4gc2hhcGVmaWxlRXh0ZW5zaW9ucy5pbmNsdWRlcyhleHRlbnNpb24pO1xuICAgIH0pO1xuICAgIGNvbnN0IHZhbGlkYXRpb25UeXBlcyA9IChfYiA9IGZpbGVDb25zdHJhaW50cy52YWxpZGF0aW9uVHlwZXMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XG4gICAgY29uc3QgcG9zc2libGVUeXBlID0gZmluZFBvc3NpYmxlSXRlbVR5cGVzQnlFeHRlbnNpb24oc2FuaXRpemVGaWxlSW5wdXQoZmlsZXNbMF0pLmV4dGVuc2lvbiwgdmFsaWRhdGlvblR5cGVzKVswXTtcbiAgICBjb25zdCB2YWxpZEZpbGVUeXBlID0gcG9zc2libGVUeXBlICYmXG4gICAgICAgIChwb3NzaWJsZVR5cGUuYXBwZW5kVXBsb2FkRm9ybWF0IHx8IHBvc3NpYmxlVHlwZS5hbGxvd0FkZERpcmVjdCB8fCAhcG9zc2libGVUeXBlLm9yZ09ubHkgfHwgIWlzUHVibGljVXNlcih1c2VyKSk7XG4gICAgaWYgKGZvdW5kU2hhcGVmaWxlKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBpMThuLmVycm9yLnNoYXBlZmlsZUVycm9yVGl0bGUsXG4gICAgICAgICAgICBtZXNzYWdlOiBpMThuLmVycm9yLnNoYXBlZmlsZUVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgIGxpbms6IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBpMThuLmVycm9yLnNoYXBlZmlsZUVycm9yTGluayxcbiAgICAgICAgICAgICAgICBwYXRoOiBgJHtoZWxwQmFzZX0ke2hlbHBNYXBbXCIxMjAwMDI4MDRcIl19YFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChmaWxlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBpMThuLmVycm9yLm11bHRpcGxlRmlsZXNFcnJvclRpdGxlLFxuICAgICAgICAgICAgbWVzc2FnZTogaTE4bi5lcnJvci5tdWx0aXBsZUZpbGVzRXJyb3JNZXNzYWdlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG1heEZpbGVTaXplICE9IG51bGwgJiYgZmlsZXNbMF0uc2l6ZSA+IG1heEZpbGVTaXplKSB7XG4gICAgICAgIGNvbnN0IHNpemVJbk1CID0gbWF4RmlsZVNpemUgLyAxMDAwMDAwO1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSB7IG1lc3NhZ2U6IGkxOG4uZXJyb3IubWF4U2l6ZS5yZXBsYWNlKFwiJHtzaXplfVwiLCBzaXplSW5NQi50b1N0cmluZygpKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICghdmFsaWRGaWxlVHlwZSB8fCAhdmFsaWRFeHRlbnNpb24pIHtcbiAgICAgICAgY29uc3QgaGVscE1hcE51bWJlciA9IGhlbHBNYXBOdW1iZXJzW2hlbHBJZFR5cGVdO1xuICAgICAgICBpc0ZvbGRlclxuICAgICAgICAgICAgPyAoZXJyb3JNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGkxOG4uZXJyb3IuZm9sZGVyRXJyb3JcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IChlcnJvck1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGkxOG4uZXJyb3IudW5zdXBwb3J0ZWRGaWxlVHlwZVRpdGxlLFxuICAgICAgICAgICAgICAgIGxpbms6IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogaTE4bi5lcnJvci51bnN1cHBvcnRlZEZpbGVUeXBlTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYCR7aGVscEJhc2V9JHtoZWxwTWFwW2hlbHBNYXBOdW1iZXJdfWBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdmFsaWQsIGVycm9yTWVzc2FnZSB9O1xufVxuXG5jb25zdCBhcmNnaXNEcmFnQW5kRHJvcENzcyA9IFwiLmRyYWctYW5kLWRyb3Atd2VsbHtwb3NpdGlvbjpyZWxhdGl2ZX0uZHJhZy1hbmQtZHJvcC13ZWxsIDo6c2xvdHRlZCgqKXt0cmFuc2l0aW9uOmFsbCAyMDBtcyBlYXNlLWluLW91dDtwb3NpdGlvbjpyZWxhdGl2ZTtib3JkZXI6MnB4IGRhc2hlZCB0cmFuc3BhcmVudH0uZHJhZy1hbmQtZHJvcC13ZWxsIDo6c2xvdHRlZCgqKTpiZWZvcmV7Y29udGVudDpcXFwiXFxcIjtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwgMTIxLCAxOTMsIDApICFpbXBvcnRhbnQ7cG9pbnRlci1ldmVudHM6bm9uZTt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgMjAwbXMgZWFzZS1pbi1vdXQgIWltcG9ydGFudDt6LWluZGV4OjJ9LmRyYWdnaW5nIDo6c2xvdHRlZCgqKXtib3JkZXItY29sb3I6IzAwN2FjMiAhaW1wb3J0YW50fS5kcmFnZ2luZyA6OnNsb3R0ZWQoKik6YmVmb3Jle2JvcmRlci1jb2xvcjojMDA3YWMyICFpbXBvcnRhbnQ7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsIDEyMSwgMTkzLCAwLjA1KSAhaW1wb3J0YW50fS5ub3RpY2UtY29udGFpbmVye2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MHB4O2xlZnQ6MHB4O3JpZ2h0OjBweDtwb2ludGVyLWV2ZW50czpub25lO3otaW5kZXg6MTB9LmFsZXJ0X19tZXNzYWdle2Rpc3BsYXk6YmxvY2s7bGluZS1oZWlnaHQ6MS4zNzV9LmFsZXJ0X19saW5re2Rpc3BsYXk6aW5saW5lfS5mdWxsLWhlaWdodHtoZWlnaHQ6MTAwJX1cIjtcblxuY29uc3QgQXJjZ2lzRHJhZ0FuZERyb3AgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFyY2dpc0Ryb3BTdWNjZXNzID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNEcm9wU3VjY2Vzc1wiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNBbGVydEFjdGl2ZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzQWxlcnRBY3RpdmVcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzRHJhZ092ZXIgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0RyYWdPdmVyXCIsIDcpO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy51c2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWxlcnRNZXNzYWdlID0geyB0aXRsZTogXCJcIiB9O1xuICAgICAgICB0aGlzLmFsZXJ0QWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5maWxlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5hbGxvd2VkRXh0ZW5zaW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsaWRUeXBlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZHJhZ092ZXJOb3RpY2VNZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmluc2lkZU1vZGFsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmZ1bGxIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2hvd0hlbHBMaW5rT25FcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMubWF4RmlsZVNpemUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaGVscElkVHlwZSA9IFwiZGVmYXVsdFwiO1xuICAgICAgICB0aGlzLmlzRm9sZGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhZ092ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGhhbmRsZUFsZXJ0Q2hhbmdlKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IGFsZXJ0QWN0aXZlIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYWxlcnRBY3RpdmUpIHtcbiAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImNhbGNpdGVJbnRlcm5hbEFsZXJ0U3luY1wiLCB7IGRldGFpbDogeyBxdWV1ZTogW10gfSB9KSk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmVsLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcIiNuZXctaXRlbS1hbGVydFwiKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEF0dHJpYnV0ZShcImFjdGl2ZVwiLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIChfYiA9IHRoaXMuZWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiI25ldy1pdGVtLWFsZXJ0XCIpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVtb3ZlQXR0cmlidXRlKFwiYWN0aXZlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXJjZ2lzQWxlcnRBY3RpdmUuZW1pdChhbGVydEFjdGl2ZSk7XG4gICAgfVxuICAgIGhhbmRsZUZpbGVVcGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgZmlsZXMsIGkxOG4sIGlzRm9sZGVyLCB1c2VyLCBjb25maWcsIHZhbGlkVHlwZXMsIGhlbHBJZFR5cGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3VjY2VzcywgZXJyb3JNZXNzYWdlIH0gPSB2YWxpZGF0ZUFkZGVkRmlsZShmaWxlcywgaXNGb2xkZXIsIHVzZXIsIHtcbiAgICAgICAgICAgIGFsbG93ZWRFeHRlbnNpb25zOiB0aGlzLmFsbG93ZWRFeHRlbnNpb25zLFxuICAgICAgICAgICAgbWF4RmlsZVNpemU6IHRoaXMubWF4RmlsZVNpemUsXG4gICAgICAgICAgICB2YWxpZGF0aW9uVHlwZXM6IHZhbGlkVHlwZXNcbiAgICAgICAgfSwgeyBoZWxwSWRUeXBlLCBpMThuLCBoZWxwQmFzZTogY29uZmlnLmhlbHBCYXNlLCBoZWxwTWFwOiBjb25maWcuaGVscE1hcCB9KTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzRHJvcFN1Y2Nlc3MuZW1pdChmaWxlc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFsZXJ0TWVzc2FnZSA9IGVycm9yTWVzc2FnZTtcbiAgICAgICAgICAgIHRoaXMuYWxlcnRBY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZURyYWdPdmVyKGUpIHtcbiAgICAgICAgaWYgKGUuZGF0YVRyYW5zZmVyLnR5cGVzLmluY2x1ZGVzKFwiRmlsZXNcIikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndlbGxSZWYpIHtcbiAgICAgICAgICAgICAgICAvLyAqIE1ha2Ugc3VyZSB0aGUgbm90aWNlIGlzIHZpc2libGUgb24gc2NyZWVuXG4gICAgICAgICAgICAgICAgY29uc3Qgd2luZG93SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgeTogd2VsbE9mZnNldFRvcCwgYm90dG9tIH0gPSB0aGlzLndlbGxSZWYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9wQm91bmRhcnkgPSBNYXRoLm1heCh3ZWxsT2Zmc2V0VG9wLCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBib3R0b21Cb3VuZGFyeSA9IE1hdGgubWluKHdpbmRvd0hlaWdodCwgYm90dG9tKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGljZVJlZi5zdHlsZS5oZWlnaHQgPSBgJHtib3R0b21Cb3VuZGFyeSAtIHRvcEJvdW5kYXJ5fXB4YDtcbiAgICAgICAgICAgICAgICAvLyAtTWF0aC5taW4oMCwgd2VsbE9mZnNldFRvcCkgYmVjYXVzZTpcbiAgICAgICAgICAgICAgICAvLyAgLS0tIHdoZW4gdGhlIHdlbGwncyB0b3AgaXMgTk9UIHZpc2libGUsIHdlJ2xsIGhhdmUgd2VsbE9mZnNldFRvcCA8IDBcbiAgICAgICAgICAgICAgICAvLyAgPT4gd2UnbGwgb2Zmc2V0IGB0b3BgIG9mIHRoZSBub3RpY2UncyBjb250YWluZXIgYnkgdGhhdCBhbW91bnRcbiAgICAgICAgICAgICAgICAvLyAgLS0tIHdoZW4gdGhlIHdlbGwncyB0b3AgaXMgdmlzaWJsZSwgd2UnbGwgaGF2ZSB3ZWxsT2Zmc2V0VG9wID4gMFxuICAgICAgICAgICAgICAgIC8vICA9PiB3ZSdsbCB1c2UgMCBmb3IgdGhlIHRvcCBvZiB0aGUgbm90aWNlJ3MgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVUb3AgPSAtTWF0aC5taW4oMCwgd2VsbE9mZnNldFRvcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpY2VSZWYuc3R5bGUudG9wID0gYCR7cmVsYXRpdmVUb3B9cHhgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5kcmFnT3ZlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0RyYWdPdmVyLmVtaXQodGhpcy5kcmFnT3Zlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gYXdhaXQgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyh0aGlzLmVsKTtcbiAgICAgICAgdGhpcy5pMThuID0gbG9jYWxlWzBdO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgdGl0bGUsIG1lc3NhZ2UsIGxpbmsgfSA9IHRoaXMuYWxlcnRNZXNzYWdlO1xuICAgICAgICBjb25zdCB7IHRleHQsIHBhdGggfSA9IE9iamVjdC5hc3NpZ24oe30sIGxpbmspO1xuICAgICAgICBjb25zdCB7IGFjdGl2ZSwgZHJhZ092ZXJOb3RpY2VNZXNzYWdlLCBkcmFnT3ZlciwgaW5zaWRlTW9kYWwsIGZ1bGxIZWlnaHQsIHNob3dIZWxwTGlua09uRXJyb3IgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IHJlZjogKGVsZSkgPT4gKHRoaXMud2VsbFJlZiA9IGVsZSksIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgaGlkZTogIWFjdGl2ZSxcbiAgICAgICAgICAgICAgICBcImRyYWctYW5kLWRyb3Atd2VsbFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nOiB0aGlzLmRyYWdPdmVyLFxuICAgICAgICAgICAgICAgIFwiZnVsbC1oZWlnaHRcIjogZnVsbEhlaWdodFxuICAgICAgICAgICAgfSwgb25EcmFnT3ZlcjogYWN0aXZlICYmIHRoaXMuaGFuZGxlRHJhZ092ZXIuYmluZCh0aGlzKSwgb25EcmFnTGVhdmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdPdmVyID0gZmFsc2U7XG4gICAgICAgICAgICB9LCBvbkRyb3A6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWxlcnRBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdPdmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmaWxlcywgaXRlbXMgfSA9IGUuZGF0YVRyYW5zZmVyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtcyA9PT0gbnVsbCB8fCBpdGVtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXRlbXNbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5pc0ZvbGRlciA9XG4gICAgICAgICAgICAgICAgICAgICgoX2QgPSAoKF9iID0gKF9hID0gaXRlbS53ZWJraXRHZXRBc0VudHJ5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpdGVtKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKF9jID0gaXRlbSA9PT0gbnVsbCB8fCBpdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpdGVtLmdldEFzRW50cnkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKGl0ZW0pKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmlzRGlyZWN0b3J5KSB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVzID0gZmlsZXM7XG4gICAgICAgICAgICB9IH0sIGgoXCJzbG90XCIsIG51bGwpLCBpbnNpZGVNb2RhbCA/IChcbiAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgaGF2aW5nIHRoaXMgY29tcG9uZW50IHJldHVybiBhbiBlcnJvciBjb2RlIHJhdGhlciB0aGFuIGEgZnVsbCBhbGVydFxuICAgICAgICBoKFwiYXJjZ2lzLW5ldy1pdGVtLWFsZXJ0XCIsIHsgaWQ6IFwibmV3LWl0ZW0tYWxlcnRcIiwga2luZDogXCJkYW5nZXJcIiwgb25BbGVydERpc21pc3M6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFsZXJ0QWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9LCBhY3RpdmU6ICEhdGhpcy5hbGVydEFjdGl2ZSwgaGVhZGluZzogdGl0bGUsIGRlc2NyaXB0aW9uOiBtZXNzYWdlLCBsaW5rOiB7IGhyZWY6IGxpbmsgPT09IG51bGwgfHwgbGluayA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGluay5wYXRoLCB0aXRsZTogbGluayA9PT0gbnVsbCB8fCBsaW5rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaW5rLnRleHQgfSB9KSkgOiAoaChcImNhbGNpdGUtYWxlcnRcIiwgeyBsYWJlbDogXCJcIiwgaWQ6IFwibmV3LWl0ZW0tYWxlcnRcIiwgaWNvbjogdHJ1ZSwga2luZDogXCJkYW5nZXJcIiwgb25DYWxjaXRlQWxlcnRDbG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxlcnRBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIG9wZW46ICEhdGhpcy5hbGVydEFjdGl2ZSwgdGFiSW5kZXg6ICF0aGlzLmFsZXJ0QWN0aXZlID8gLTEgOiBudWxsLCByZWY6IChlbCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGhlcmUsIHdlIGhpZGUgdGhlIHF1ZXVlIGFzIGl0IHRha2VzIHVwIHRvbyBtdWNoIHJvb20gb24gbW9iaWxlIGFuZCB3ZSdyZSBub3QgdXNpbmcgaXRcbiAgICAgICAgICAgICAgICBjb25zdCBxdWV1ZSA9IGVsLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcIi5hbGVydC1xdWV1ZS1jb3VudFwiKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gfSwgdGl0bGUgJiYgaChcImRpdlwiLCB7IHNsb3Q6IFwidGl0bGVcIiB9LCB0aXRsZSksIG1lc3NhZ2UgJiYgKGgoXCJkaXZcIiwgeyBzbG90OiBcIm1lc3NhZ2VcIiwgY2xhc3M6IFwiYWxlcnRfX21lc3NhZ2VcIiB9LCBtZXNzYWdlKSksIHNob3dIZWxwTGlua09uRXJyb3IgJiYgbGluayAmJiAoaChcImNhbGNpdGUtbGlua1wiLCB7IHNsb3Q6IFwibGlua1wiLCB0YXJnZXQ6IFwiX2JsYW5rXCIsIGhyZWY6IHBhdGgsIGNsYXNzOiBcImFsZXJ0X19saW5rXCIgfSwgdGV4dCkpKSksIGgoXCJkaXZcIiwgeyBjbGFzczogXCJub3RpY2UtY29udGFpbmVyXCIsIHJlZjogKGVsZSkgPT4gKHRoaXMubm90aWNlUmVmID0gZWxlKSB9LCBkcmFnT3Zlck5vdGljZU1lc3NhZ2UgJiYgKGgoXCJjYWxjaXRlLW5vdGljZVwiLCB7IGljb246IFwidXBsb2FkLXRvXCIsIG9wZW46IGRyYWdPdmVyLCBzY2FsZTogXCJtXCIsIHdpZHRoOiBcImF1dG9cIiB9LCBoKFwiZGl2XCIsIHsgc2xvdDogXCJtZXNzYWdlXCIgfSwgZHJhZ092ZXJOb3RpY2VNZXNzYWdlKSkpKSkpO1xuICAgIH1cbiAgICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gICAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICAgICAgXCJhbGVydEFjdGl2ZVwiOiBbXCJoYW5kbGVBbGVydENoYW5nZVwiXSxcbiAgICAgICAgXCJmaWxlc1wiOiBbXCJoYW5kbGVGaWxlVXBkYXRlXCJdXG4gICAgfTsgfVxufTtcbkFyY2dpc0RyYWdBbmREcm9wLnN0eWxlID0gYXJjZ2lzRHJhZ0FuZERyb3BDc3M7XG5cbmV4cG9ydCB7IEFyY2dpc0RyYWdBbmREcm9wIGFzIGFyY2dpc19kcmFnX2FuZF9kcm9wIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyY2dpcy1kcmFnLWFuZC1kcm9wLmVudHJ5LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgYSBhcyBhZGRDcmVhdGVJdGVtVHlwZXMgfSBmcm9tICcuL2l0ZW0tdHlwZXMtMjAyOWIwNmIuanMnO1xuaW1wb3J0IHsgZyBhcyBndWlkIH0gZnJvbSAnLi9ndWlkLWFlYWVkODRkLmpzJztcblxuZnVuY3Rpb24gc2FuaXRpemVGaWxlTmFtZShuYW1lLCBhZGRHVUlEKSB7XG4gICAgLy9UT0RPOiBhZGQgbmV3IHBhcmFtIHRvIHNwZWMgZmlsZS5cbiAgICBjb25zdCBleHByZXNzaW9uID0gLyg/OlxcLihbXi5dKykpPyQvO1xuICAgIGNvbnN0IGludmFsaWRUaXRsZUNoYXJhY3RlcnMgPSAvXFwufC0vZztcbiAgICBsZXQgZmlsZU5hbWUgPSBuYW1lLnJlcGxhY2UoL14uKihcXFxcfFxcL3w6KS8sIFwiXCIpO1xuICAgIGxldCBleHRlbnNpb24gPSAoZmlsZU5hbWUgJiYgZXhwcmVzc2lvbi5leGVjKGZpbGVOYW1lKVsxXSA/IGV4cHJlc3Npb24uZXhlYyhmaWxlTmFtZSlbMV0udG9Mb3dlckNhc2UoKSA6IFwiXCIpO1xuICAgIGxldCB0aXRsZSA9IFwiXCI7XG4gICAgaWYgKGZpbGVOYW1lLmluZGV4T2YoXCIucmZ0LlwiKSA+IC0xKSB7XG4gICAgICAgIGNvbnN0IFtuYW1lLCBzdWZmaXhdID0gZmlsZU5hbWUuc3BsaXQoXCIucmZ0LlwiKTtcbiAgICAgICAgZXh0ZW5zaW9uID0gYHJmdC4ke3N1ZmZpeH1gO1xuICAgICAgICB0aXRsZSA9IG5hbWU7XG4gICAgfVxuICAgIGlmIChmaWxlTmFtZSAmJiAhdGl0bGUpIHtcbiAgICAgICAgdGl0bGUgPSBmaWxlTmFtZS5sYXN0SW5kZXhPZihcIi5cIikgPT09IC0xID8gZmlsZU5hbWUgOiBmaWxlTmFtZS5zdWJzdHJpbmcoMCwgZmlsZU5hbWUubGFzdEluZGV4T2YoXCIuXCIpKTtcbiAgICB9XG4gICAgLy8gUmVwbGFjZSBhbnkgaW52YWxpZCBjaGFyYWN0ZXJzIHdpdGggYW4gdW5kZXJzY29yZVxuICAgIHRpdGxlID0gdGl0bGUucmVwbGFjZShpbnZhbGlkVGl0bGVDaGFyYWN0ZXJzLCBcIl9cIik7XG4gICAgLy8gQWxsb3cgZmlsZSB1cGxvYWQgb2YgZXhpc3RpbmcgaXRlbSdzIGZpbGUgbmFtZSAvLyBjdXJyZW50bHkgdXNlZCBpbiBhcHBlbmRcbiAgICBpZiAoYWRkR1VJRCkge1xuICAgICAgICB0aXRsZSA9IG1ha2VVbmlxdWVGaWxlTmFtZSh0aXRsZSk7XG4gICAgICAgIGZpbGVOYW1lID0gYCR7dGl0bGV9LiR7ZXh0ZW5zaW9ufWA7XG4gICAgfVxuICAgIHJldHVybiB7IHRpdGxlLCBmaWxlTmFtZSwgZXh0ZW5zaW9uIH07XG59XG4vLyBIZWxwZXIgbWV0aG9kIHRoYXQgdGFrZXMgaW4gYSBmaWxlICYgcmV0dXJucyB0aGUgY2xlYW5lZCB1cCBmaWxlIG5hbWUgYXMgaXMgYW5kIGluIHRpdGxlIGZvcm0sIGFuZCB0aGUgZGV0ZWN0ZWQgZmlsZSBleHRlbnNpb25cbmZ1bmN0aW9uIHNhbml0aXplRmlsZUlucHV0KGZpbGUsIGFkZEdVSUQpIHtcbiAgICByZXR1cm4gc2FuaXRpemVGaWxlTmFtZShmaWxlLm5hbWUsICEhYWRkR1VJRCk7XG59XG5mdW5jdGlvbiBtYWtlVW5pcXVlRmlsZU5hbWUobmFtZSkge1xuICAgIHJldHVybiBgJHtuYW1lfV8ke2d1aWQoKX1gO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPdmVyd3JpdGVGaWxlTmFtZSh1cGxvYWRlZEZpbGVOYW1lLCBzb3VyY2VGaWxlTmFtZSkge1xuICAgIGxldCBmaWxlTmFtZSA9IHVwbG9hZGVkRmlsZU5hbWU7XG4gICAgY29uc3QgcG9zaXRpb24gPSB1cGxvYWRlZEZpbGVOYW1lLmxhc3RJbmRleE9mKFwiXFxcXFwiKTtcbiAgICBpZiAocG9zaXRpb24gPiAtMSkge1xuICAgICAgICBmaWxlTmFtZSA9IGZpbGVOYW1lLnN1YnN0cmluZyhwb3NpdGlvbiArIDEsIGZpbGVOYW1lLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBmaWxlTmFtZS5yZXBsYWNlKC9cXCAvZywgXCJfXCIpID09PSBzb3VyY2VGaWxlTmFtZS5yZXBsYWNlKC9cXCAvZywgXCJfXCIpO1xufVxuZnVuY3Rpb24gZ2V0SXRlbUluZm9CeVR5cGUodHlwZSkge1xuICAgIGlmIChhZGRDcmVhdGVJdGVtVHlwZXNbdHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIGFkZENyZWF0ZUl0ZW1UeXBlc1t0eXBlXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhZGRDcmVhdGVJdGVtVHlwZXNbT2JqZWN0LmtleXMoYWRkQ3JlYXRlSXRlbVR5cGVzKS5maW5kKChmaWxlVHlwZSkgPT4gYWRkQ3JlYXRlSXRlbVR5cGVzW2ZpbGVUeXBlXS50eXBlID09PSB0eXBlKV07XG4gICAgfVxufVxuZnVuY3Rpb24gZm9ybWF0RmlsZVNpemUoc2l6ZSkge1xuICAgIGlmICghc2l6ZSkge1xuICAgICAgICByZXR1cm4gXCIwIEJcIjtcbiAgICB9XG4gICAgY29uc3QgaSA9IE1hdGguZmxvb3IoTWF0aC5sb2coc2l6ZSkgLyBNYXRoLmxvZygxMDI0KSk7XG4gICAgY29uc3QgYWRqdXN0ZWRTaXplID0gTWF0aC5yb3VuZChzaXplIC8gTWF0aC5wb3coMTAyNCwgaSkpO1xuICAgIGNvbnN0IHVuaXQgPSBbXCJCXCIsIFwiS0JcIiwgXCJNQlwiLCBcIkdCXCIsIFwiVEJcIl1baV07XG4gICAgcmV0dXJuIGAke2FkanVzdGVkU2l6ZX0gJHt1bml0fWA7XG59XG5cbmV4cG9ydCB7IHNhbml0aXplRmlsZU5hbWUgYXMgYSwgZm9ybWF0RmlsZVNpemUgYXMgZiwgZ2V0SXRlbUluZm9CeVR5cGUgYXMgZywgc2FuaXRpemVGaWxlSW5wdXQgYXMgcywgdmFsaWRhdGVPdmVyd3JpdGVGaWxlTmFtZSBhcyB2IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGUtYmY4YWI5MGYuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIGl0IGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIG4gbWlsbGlzZWNvbmRzXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgZGVib3VuY2UgPSAoZm4sIGRlbGF5KSA9PiB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgbGV0IHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgIGZ1bmN0aW9uIGZsdXNoKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhdHVzID0gXCJmbHVzaGVkXCI7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludm9rZSguLi5hcmdzKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiaW52b2tlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWwoLi4uYXJncykge1xuICAgICAgICBzdGF0dXMgPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxuICAgIGNvbnN0IGRlYm91bmNlZCA9ICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcImZsdXNoZWRcIjpcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaW52b2tlZFwiOlxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjYW5jZWxsZWRcIjpcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgZGVib3VuY2VkLmludm9rZSA9IGludm9rZTtcbiAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgIGRlYm91bmNlZC5nZXRTdGF0dXMgPSBnZXRTdGF0dXM7XG4gICAgcmV0dXJuIGRlYm91bmNlZDtcbn07XG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIG4gbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZFxuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IHRocm90dGxlID0gKGZuLCBkZWxheSkgPT4ge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIHJldHVybiAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7IC8vICQmIG1lYW5zIHRoZSB3aG9sZSBtYXRjaGVkIHN0cmluZ1xufVxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG4vKipcbiAqIFNldCBhIG1pbmltdW0gdGltZSBmb3IgYSBwcm9taXNlIHRvIHJlc29sdmUgKHVzZWZ1bCBmb3IgcHJldmVudGluZyBmbGFzaCBvZiBsb2FkZXJzKVxuICovXG5hc3luYyBmdW5jdGlvbiBtaW5EZWxheShwcm9taXNlLCBtaW5EZWxheSkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFtwcm9taXNlLCB0aW1lb3V0KG1pbkRlbGF5KV0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGlubGluZSBzZXRUaW1lb3V0IGFzIGFuIGF3YWl0IGluIGFzeW5jIGZ1bmN0aW9uc1xuICovXG5mdW5jdGlvbiB0aW1lb3V0KG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5jb25zdCBhcnJheVRvTG9va3VwTWFwID0gKGRhdGFBcnIsIGdldEtleUFuZEl0ZW0pID0+IE9iamVjdC5mcm9tRW50cmllcygoZGF0YUFyciB8fCBbXSkubWFwKChpdGVtKSA9PiB7XG4gICAgY29uc3QgeyBrZXksIGRhdGEgfSA9IGdldEtleUFuZEl0ZW0oaXRlbSk7XG4gICAgcmV0dXJuIFtrZXksIGRhdGFdO1xufSkpO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHR3byBhcnJheXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHNcbiAqIGFuZCB3aGV0aGVyIHRoZXkgY29udGFpbiB0aGUgc2FtZSBlbGVtZW50c1xuICogcmVnYXJkbGVzcyBvZiBvcmRlclxuICovXG5jb25zdCBhcnJheXNBcmVFcXVpdmFsZW50ID0gKGFycjEsIGFycjIpID0+IGFycjEubGVuZ3RoID09PSBhcnIyLmxlbmd0aCAmJiBhcnIxLnJlZHVjZSgobWVtbywgc3RyKSA9PiBtZW1vICYmIGFycjIuaW5kZXhPZihzdHIpID4gLTEsIHRydWUpO1xuZnVuY3Rpb24gdW5pcXVlQnkobXlBcnIsIGdldEl0ZW1JZCkge1xuICAgIGNvbnN0IHJlc3VsdEFyciA9IFtdO1xuICAgIGNvbnN0IGxvb2t1cE1hcCA9IHt9O1xuICAgIG15QXJyLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSBnZXRJdGVtSWQoaXRlbSk7XG4gICAgICAgIGlmIChsb29rdXBNYXBbaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvb2t1cE1hcFtpZF0gPSBpdGVtO1xuICAgICAgICAgICAgcmVzdWx0QXJyLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0QXJyO1xufVxuZnVuY3Rpb24gdW5pcXVlKG15QXJyKSB7XG4gICAgY29uc3QgcHJpbWl0aXZlcyA9IHsgYm9vbGVhbjoge30sIG51bWJlcjoge30sIHN0cmluZzoge30gfTtcbiAgICBjb25zdCBvYmpzID0gW107XG4gICAgcmV0dXJuIG15QXJyLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVvZiBpdGVtO1xuICAgICAgICBpZiAodHlwZSBpbiBwcmltaXRpdmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlc1t0eXBlXS5oYXNPd25Qcm9wZXJ0eShpdGVtKSA/IGZhbHNlIDogKHByaW1pdGl2ZXNbdHlwZV1baXRlbV0gPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpzLmluZGV4T2YoaXRlbSkgPj0gMCA/IGZhbHNlIDogb2Jqcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBjaHVuayA9IChhcnIsIHNpemUpID0+IFsuLi5BcnJheShNYXRoLmNlaWwoYXJyLmxlbmd0aCAvIHNpemUpKV0ubWFwKChfLCBpKSA9PiBhcnIuc2xpY2Uoc2l6ZSAqIGksIHNpemUgKyBzaXplICogaSkpO1xuXG5leHBvcnQgeyBhcnJheVRvTG9va3VwTWFwIGFzIGEsIHVuaXF1ZSBhcyBiLCB0aHJvdHRsZSBhcyBjLCBkZWJvdW5jZSBhcyBkLCBlc2NhcGVSZWdFeHAgYXMgZSwgYXJyYXlzQXJlRXF1aXZhbGVudCBhcyBmLCBjaHVuayBhcyBnLCBpc0RlZmluZWQgYXMgaSwgbWluRGVsYXkgYXMgbSwgdGltZW91dCBhcyB0LCB1bmlxdWVCeSBhcyB1IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZ1bmN0aW9uYWwtNDRkZThmY2YuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUlkKGNvdW50cykge1xuICAgIHJldHVybiBjb3VudHNcbiAgICAgICAgLm1hcCgoY291bnQpID0+IHtcbiAgICAgICAgbGV0IG91dCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgb3V0ICs9ICgoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApIHwgMCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0pXG4gICAgICAgIC5qb2luKFwiLVwiKTtcbn1cbmNvbnN0IGd1aWQgPSAoKSA9PiBnZW5lcmF0ZUlkKFsyLCAxLCAxLCAxLCAzXSk7XG5cbmV4cG9ydCB7IGd1aWQgYXMgZyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ndWlkLWFlYWVkODRkLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgYSBhcyBhZGRUcmFpbGluZ1NsYXNoSWZNaXNzaW5nIH0gZnJvbSAnLi91cmwtNGMzYWU1NGMuanMnO1xuXG5mdW5jdGlvbiBpc0VzcmkoaXRlbSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gISEoKF9hID0gaXRlbS5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJlc3JpXCIpKTtcbn1cbmZ1bmN0aW9uIGlzUHJlbWl1bShpdGVtKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBpc0VzcmkoaXRlbSkgJiYgISEoKF9hID0gaXRlbS50eXBlS2V5d29yZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhcIlJlcXVpcmVzIENyZWRpdHNcIikpO1xufVxuZnVuY3Rpb24gaXNTdWJzY3JpYmVyKGl0ZW0pIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIGlzRXNyaShpdGVtKSAmJiAhISgoX2EgPSBpdGVtLnR5cGVLZXl3b3JkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKFwiUmVxdWlyZXMgU3Vic2NyaXB0aW9uXCIpKTtcbn1cbmZ1bmN0aW9uIGlzT3duZXIoaXRlbSwgdXNlcikge1xuICAgIHJldHVybiBpdGVtLm93bmVyID09PSB1c2VyLnVzZXJuYW1lO1xufVxuLyoqXG4gKiBDYW4gdGhlIHVzZXIgdXBkYXRlIHRoZSBpdGVtXG4gKi9cbmZ1bmN0aW9uIGNhblVwZGF0ZUl0ZW0oaXRlbSwgdXNlcikge1xuICAgIHJldHVybiB1c2VySXNJdGVtQWRtaW4oaXRlbSwgdXNlcikgfHwgaXRlbS5pdGVtQ29udHJvbCA9PT0gXCJ1cGRhdGVcIjtcbn1cbi8qKlxuICogSXMgdGhlIHVzZXIgZWl0aGVyIGFuIG93bmVyIG9yIGFkbWluIG9mIHRoZSBpdGVtXG4gKi9cbmZ1bmN0aW9uIHVzZXJJc0l0ZW1BZG1pbihpdGVtLCB1c2VyKSB7XG4gICAgcmV0dXJuIGlzT3duZXIoaXRlbSwgdXNlcikgfHwgaXNJdGVtQWRtaW4oaXRlbSwgdXNlcik7XG59XG4vKipcbiAqIERvZXMgdGhlIHVzZXIgaGF2ZSBhZG1pbiBjYXBhYmlsaXRpZXMgb24gdGhpcyBpdGVtXG4gKi9cbmZ1bmN0aW9uIGlzSXRlbUFkbWluKGl0ZW0sIHVzZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gaWYgdGhpcyBmbGFnIGlzIGFscmVhZHkgc2V0IChwcm9iYWJseSBob21lIGFwcCksIHVzZSBpdFxuICAgIGlmIChpdGVtLmlzQWRtaW4gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gISFpdGVtLmlzQWRtaW47XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1Pd25lciA9IGl0ZW0ub3duZXI7XG4gICAgY29uc3QgaXRlbUNvbnRyb2xBZG1pbiA9IGl0ZW0uaXRlbUNvbnRyb2wgPT09IFwiYWRtaW5cIjtcbiAgICBjb25zdCBlc3JpVXNlcnMgPSBbXCJlc3JpX2xpdmluZ2F0bGFzXCIsIFwiZXNyaV9kZW1vZ3JhcGhpY3NcIiwgXCJlc3JpX2JvdW5kYXJpZXNcIl07XG4gICAgaWYgKCgoX2EgPSBpdGVtLnBvcnRhbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzUG9ydGFsKSAmJlxuICAgICAgICAhaXNPd25lcihpdGVtLCB1c2VyKSAmJlxuICAgICAgICBpdGVtQ29udHJvbEFkbWluICYmXG4gICAgICAgIGl0ZW1Pd25lci5pbmNsdWRlcyhcImVzcmlfXCIpICYmXG4gICAgICAgIC8vIHBvcnRhbCBpbmNvcnJlY3RseSByZXR1cm5zIFwiaXRlbUNvbnRyb2w9XCJhZG1pblwiIGZvciBlc3JpIG93bmVkIGl0ZW1zXG4gICAgICAgICFlc3JpVXNlcnMuaW5jbHVkZXMoaXRlbU93bmVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpdGVtQ29udHJvbEFkbWluO1xufVxuY29uc3QgaXRlbXNCZWxvbmdUb1VzZXJPcmcgPSAoaXRlbXMsIHVzZXIpID0+IHtcbiAgICByZXR1cm4gISF1c2VyLm9yZ0lkICYmIGl0ZW1zLmV2ZXJ5KChpdGVtKSA9PiBpdGVtLmlzT3JnSXRlbSk7XG59O1xuY29uc3QgZ2V0SXRlbUhvbWVBcHBVcmwgPSAoaXRlbUlkLCBiYXNlVXJsKSA9PiBgJHthZGRUcmFpbGluZ1NsYXNoSWZNaXNzaW5nKGJhc2VVcmwpfWl0ZW0uaHRtbD9pZD0ke2l0ZW1JZH1gO1xuXG5leHBvcnQgeyBpc1N1YnNjcmliZXIgYXMgYSwgaXNQcmVtaXVtIGFzIGIsIGNhblVwZGF0ZUl0ZW0gYXMgYywgaXRlbXNCZWxvbmdUb1VzZXJPcmcgYXMgZCwgZ2V0SXRlbUhvbWVBcHBVcmwgYXMgZywgaXNPd25lciBhcyBpLCB1c2VySXNJdGVtQWRtaW4gYXMgdSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVtLTM1MzU1NTJkLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgYiBhcyB1bmlxdWUgfSBmcm9tICcuL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMnO1xuaW1wb3J0IHsgYSBhcyBhZGRDcmVhdGVJdGVtVHlwZXMgfSBmcm9tICcuL2l0ZW0tdHlwZXMtMjAyOWIwNmIuanMnO1xuXG5mdW5jdGlvbiBmaW5kUG9zc2libGVJdGVtVHlwZXNCeUV4dGVuc2lvbihleHRlbnNpb24sIHZhbGlkYXRpb25UeXBlcykge1xuICAgIC8vIFNlYXJjaCBpdGVtIHR5cGVzIGV4dGVuc2lvbnMgZm9yIHRoZSBvbmUgaW1wb3J0ZWRcbiAgICBsZXQgaXRlbVR5cGVzO1xuICAgIGlmICh2YWxpZGF0aW9uVHlwZXMpIHtcbiAgICAgICAgaXRlbVR5cGVzID0gdmFsaWRhdGlvblR5cGVzLm1hcCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50eXBlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGl0ZW1UeXBlcyA9IE9iamVjdC5rZXlzKGFkZENyZWF0ZUl0ZW1UeXBlcyk7XG4gICAgfVxuICAgIGxldCBwb3NzaWJsZUl0ZW1UeXBlcyA9IFtdO1xuICAgIGl0ZW1UeXBlcy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCgoX2EgPSBhZGRDcmVhdGVJdGVtVHlwZXNbdHlwZV0uZmlsZUV4dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluZGV4T2YoZXh0ZW5zaW9uKSkgPj0gMCkge1xuICAgICAgICAgICAgcG9zc2libGVJdGVtVHlwZXMucHVzaChhZGRDcmVhdGVJdGVtVHlwZXNbdHlwZV0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBvc3NpYmxlSXRlbVR5cGVzO1xufVxuZnVuY3Rpb24gbWFwSXRlbVR5cGVzVG9GaWxlRXh0ZW5zaW9ucyh0eXBlcykge1xuICAgIGlmICghdHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB1bmlxdWUodHlwZXMuZmxhdE1hcCgodHlwZSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBhZGRDcmVhdGVJdGVtVHlwZXNbdHlwZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWxlRXh0OyB9KS5maWx0ZXIoKHZhbGlkKSA9PiAhIXZhbGlkKSk7XG59XG5jb25zdCBpc0xhcmdlR2VvSlNPTiA9IChzaXplSW5CeXRlcykgPT4ge1xuICAgIGNvbnN0IHNpemVJbk1CID0gc2l6ZUluQnl0ZXMgLyAxMDI0IC8gMTAyNDtcbiAgICAvLyBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtYXBwLWNvbXBvbmVudHMvaXNzdWVzLzI1NTMjaXNzdWVjb21tZW50LTM2NDU0MDRcbiAgICByZXR1cm4gc2l6ZUluTUIgPiA1MDsgLy8gNTBNQlxufTtcbmNvbnN0IGlzTGFyZ2VDU1YgPSAoc2l6ZUluQnl0ZXMpID0+IHtcbiAgICBjb25zdCBzaXplSW5NQiA9IHNpemVJbkJ5dGVzIC8gMTAyNCAvIDEwMjQ7XG4gICAgLy8gaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLWFwcC1jb21wb25lbnRzL2lzc3Vlcy8yODc1I2lzc3VlY29tbWVudC0zNzQ4OTEzXG4gICAgcmV0dXJuIHNpemVJbk1CID4gMjA7IC8vIDIwTUJcbn07XG5cbmV4cG9ydCB7IGlzTGFyZ2VDU1YgYXMgYSwgZmluZFBvc3NpYmxlSXRlbVR5cGVzQnlFeHRlbnNpb24gYXMgZiwgaXNMYXJnZUdlb0pTT04gYXMgaSwgbWFwSXRlbVR5cGVzVG9GaWxlRXh0ZW5zaW9ucyBhcyBtIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZW0tdHlwZXMtNTg2ZjAzMDEuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBsIGFzIGxvYWRNb2R1bGVzIH0gZnJvbSAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgeyBjIGFzIGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeSB9IGZyb20gJy4vZG9tLTRkMzY3Njc3LmpzJztcblxuY29uc3QgbGFuZ3VhZ2VNYXAgPSBuZXcgTWFwKFtcbiAgICBbXCJhclwiLCBcImFyXCJdLFxuICAgIFtcImJnXCIsIFwiYmdcIl0sXG4gICAgW1wiYnNcIiwgXCJic1wiXSxcbiAgICBbXCJjYVwiLCBcImNhXCJdLFxuICAgIFtcImNzXCIsIFwiY3NcIl0sXG4gICAgW1wiZGFcIiwgXCJkYVwiXSxcbiAgICBbXCJkZVwiLCBcImRlXCJdLFxuICAgIFtcImVsXCIsIFwiZWxcIl0sXG4gICAgW1wiZW5cIiwgXCJlblwiXSxcbiAgICBbXCJlc1wiLCBcImVzXCJdLFxuICAgIFtcImV0XCIsIFwiZXRcIl0sXG4gICAgW1wiZmlcIiwgXCJmaVwiXSxcbiAgICBbXCJmclwiLCBcImZyXCJdLFxuICAgIFtcImhlXCIsIFwiaGVcIl0sXG4gICAgW1wiaHJcIiwgXCJoclwiXSxcbiAgICBbXCJodVwiLCBcImh1XCJdLFxuICAgIFtcImlkXCIsIFwiaWRcIl0sXG4gICAgW1wiaXRcIiwgXCJpdFwiXSxcbiAgICBbXCJqYVwiLCBcImphXCJdLFxuICAgIFtcImtvXCIsIFwia29cIl0sXG4gICAgW1wibHRcIiwgXCJsdFwiXSxcbiAgICBbXCJsdlwiLCBcImx2XCJdLFxuICAgIFtcIm5iXCIsIFwibmJcIl0sXG4gICAgW1wibmxcIiwgXCJubFwiXSxcbiAgICBbXCJwbFwiLCBcInBsXCJdLFxuICAgIFtcInB0LWJyXCIsIFwicHQtQlJcIl0sXG4gICAgW1wicHQtcHRcIiwgXCJwdC1QVFwiXSxcbiAgICBbXCJyb1wiLCBcInJvXCJdLFxuICAgIFtcInJ1XCIsIFwicnVcIl0sXG4gICAgW1wic2tcIiwgXCJza1wiXSxcbiAgICBbXCJzbFwiLCBcInNsXCJdLFxuICAgIFtcInNyXCIsIFwic3JcIl0sXG4gICAgW1wic3ZcIiwgXCJzdlwiXSxcbiAgICBbXCJ0aFwiLCBcInRoXCJdLFxuICAgIFtcInRyXCIsIFwidHJcIl0sXG4gICAgW1widWtcIiwgXCJ1a1wiXSxcbiAgICBbXCJ2aVwiLCBcInZpXCJdLFxuICAgIFtcInpoLWNuXCIsIFwiemgtQ05cIl0sXG4gICAgW1wiemgtaGtcIiwgXCJ6aC1IS1wiXSxcbiAgICBbXCJ6aC10d1wiLCBcInpoLVRXXCJdXG5dKTtcbi8vIHJ0bFxuZnVuY3Rpb24gZ2V0RWxlbWVudERpcihlbCkge1xuICAgIHJldHVybiBnZXRFbGVtZW50UHJvcChlbCwgXCJkaXJcIiwgXCJsdHJcIik7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50UHJvcChlbCwgcHJvcCwgdmFsdWUpIHtcbiAgICBjb25zdCBjbG9zZXN0V2l0aFByb3AgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWwsIGBbJHtwcm9wfV1gKTtcbiAgICByZXR1cm4gY2xvc2VzdFdpdGhQcm9wID8gY2xvc2VzdFdpdGhQcm9wLmdldEF0dHJpYnV0ZShwcm9wKSA6IHZhbHVlO1xufVxuLy8gY3NzXG5jb25zdCBDU1NfVVRJTElUWSA9IHtcbiAgICBydGw6IFwiYXJjZ2lzLS1ydGxcIlxufTtcbmFzeW5jIGZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW1iZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFwaSwgdHlwZSwgcGxhY2VzIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChhcGkgPT09IDQpIHtcbiAgICAgICAgY29uc3QgW2ludGxdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9pbnRsXCJdKTtcbiAgICAgICAgY29uc3QgbnVtYmVyRm9ybWF0SW50bE9wdGlvbnMgPSBpbnRsLmNvbnZlcnROdW1iZXJGb3JtYXRUb0ludGxPcHRpb25zKHtcbiAgICAgICAgICAgIHBsYWNlcyxcbiAgICAgICAgICAgIHN0eWxlOiB0eXBlLFxuICAgICAgICAgICAgZGlnaXRTZXBhcmF0b3I6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbnRsLmZvcm1hdE51bWJlcihudW1iZXIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbnVtYmVyRm9ybWF0SW50bE9wdGlvbnMpLCB7IHN0eWxlOiB0eXBlIH0pKTtcbiAgICB9XG4gICAgY29uc3QgW2Rvam9OdW1iZXJdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZG9qby9udW1iZXJcIl0pO1xuICAgIHJldHVybiBkb2pvTnVtYmVyLmZvcm1hdChudW1iZXIsIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcGxhY2VzLFxuICAgICAgICBwYXR0ZXJuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGF0dGVyblxuICAgIH0pO1xufVxuY29uc3QgY2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICAgIGNvbnN0IGxhbmcgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZztcbiAgICBjb25zdCBkYXlTaG9ydE1vbnRoWWVhciA9IHtcbiAgICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICAgIG1vbnRoOiBcInNob3J0XCIsXG4gICAgICAgIGRheTogXCJudW1lcmljXCJcbiAgICB9O1xuICAgIGlmICghY2FjaGVbbGFuZ10pIHtcbiAgICAgICAgY2FjaGVbbGFuZ10gPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZywgZGF5U2hvcnRNb250aFllYXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbbGFuZ10uZm9ybWF0KGRhdGUpO1xufVxuZnVuY3Rpb24gZm9ybWF0UGx1cmFsKGxhbmcsIHN0cmluZ09iaiwgbnVtYmVyKSB7XG4gICAgY29uc3Qgc2luZ2xlcyA9IFtcImlkXCIsIFwiamFcIiwgXCJrb1wiLCBcInRoXCIsIFwidmlcIiwgXCJ6aC1jblwiLCBcInpoLWhrXCIsIFwiemgtdHdcIl07XG4gICAgY29uc3QgbGlrZUVuZ2xpc2ggPSBbXG4gICAgICAgIFwiZW5cIixcbiAgICAgICAgXCJjYVwiLFxuICAgICAgICBcImRhXCIsXG4gICAgICAgIFwiZGVcIixcbiAgICAgICAgXCJlbFwiLFxuICAgICAgICBcImVzXCIsXG4gICAgICAgIFwiZXRcIixcbiAgICAgICAgXCJmaVwiLFxuICAgICAgICBcImhpXCIsXG4gICAgICAgIFwiaHVcIixcbiAgICAgICAgXCJpdFwiLFxuICAgICAgICBcIm5iXCIsXG4gICAgICAgIFwibmxcIixcbiAgICAgICAgXCJwdC1wdFwiLFxuICAgICAgICBcInN2XCIsXG4gICAgICAgIFwidHJcIlxuICAgIF07XG4gICAgY29uc3QgbG9jYWxlID0gbGFuZyAhPT0gbnVsbCAmJiBsYW5nICE9PSB2b2lkIDAgPyBsYW5nIDogXCJlblwiO1xuICAgIC8vIGlmIHRoZSBudW1iZXIgaXMgb25lLCBvciBpdCBpcyBhIFwic2ltcGxlXCIgbGFuZ3VhZ2UsIHJldHVybiB0aGUgMSBzdHJpbmdcbiAgICBpZiAobnVtYmVyID09PSAxIHx8IHNpbmdsZXMuaW5jbHVkZXMobG9jYWxlKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nT2JqLnNpbmdsZS5yZXBsYWNlKFwiJHtudW1iZXJ9XCIsIFwiMVwiKTtcbiAgICB9XG4gICAgLy8gaWYgdGhlIG51bWJlciBpcyBub3QgMSBhbmQgdGhlIGxhbmd1YWdlIHVzZXMgdGhlIHNhbWUgcGx1cmFsaXphdGlvbiBzdHJhdGVneSBhcyBlbmdsaXNoLFxuICAgIC8vIHJldHVybiB0aGUgbXVsdGlwbGUgc3RyaW5nXG4gICAgaWYgKG51bWJlciAhPT0gMSAmJiBsaWtlRW5nbGlzaC5pbmNsdWRlcyhsb2NhbGUpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdPYmoubXVsdGlwbGUucmVwbGFjZShcIiR7bnVtYmVyfVwiLCBgJHtudW1iZXJ9YCk7XG4gICAgfVxuICAgIC8vIGlmIG5vbmUgb2YgdGhlIGFib3ZlIHdvcmtlZCwgcmV0dXJuIHRoZSBcInVua25vd25cIiBzdHJpbmdcbiAgICByZXR1cm4gc3RyaW5nT2JqLnVua25vd24ucmVwbGFjZShcIiR7bnVtYmVyfVwiLCBgJHtudW1iZXJ9YCk7XG59XG5cbmV4cG9ydCB7IENTU19VVElMSVRZIGFzIEMsIGZvcm1hdERhdGUgYXMgYSwgZm9ybWF0UGx1cmFsIGFzIGIsIGZvcm1hdE51bWJlciBhcyBmLCBnZXRFbGVtZW50RGlyIGFzIGcsIGxhbmd1YWdlTWFwIGFzIGwgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgfSBmcm9tICcuL2RvbS00ZDM2NzY3Ny5qcyc7XG5pbXBvcnQgeyBsIGFzIGxhbmd1YWdlTWFwIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMnO1xuaW1wb3J0IHsgYSBhcyBnZXRBc3NldFBhdGggfSBmcm9tICcuL2luZGV4LWUzYmY3ZGE3LmpzJztcblxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL3N0ZW5jaWwtdHJpY2tzL2ltcGxlbWVudGluZy1pbnRlcm5hdGlvbmFsaXNhdGlvbi1pMThuLXdpdGgtc3RlbmNpbC01ZTY1NTk1NTQxMTdcbmZ1bmN0aW9uIGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZShlbGVtZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgLy8gbGFuZ3VhZ2Ugc2V0IGJ5IHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uIG9yIGJyb3dzZXIuIGRlZmF1bHRzIHRvIGVuZ2xpc2guXG4gICAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBcInJ1LVJVXCIgbWFwcyB0byBcInJ1XCIgdXNlIGNhc2VcbiAgICAgICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nLnNsaWNlKDAsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcImVuXCI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAvLyBpdCdzIE9LIGlmIHdlIGRvbid0IGhhdmUgdGhlIDQgbGV0dGVyIGxhbmd1YWdlIGZpbGUgZm9yIGl0XG4gICAgLy8gNCBsZXR0ZXIgbGFuZ3VhZ2UgY29kZSBuZWVkZWQgZm9yIGZvcm1hdHRpbmcgbnVtYmVyc1xuICAgIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICAgIGNvbnN0IGxhbmcgPSAoKGNsb3Nlc3RFbGVtZW50ID09PSBudWxsIHx8IGNsb3Nlc3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXN0RWxlbWVudC5sYW5nKSB8fCAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgICAgICAgLy8gd2Ugc3VwcG9ydCB0aGUgMiBsZXR0ZXIgY29kZWQgbGFuZ3VhZ2VcbiAgICAgICAgICAgIC8vIGUuZy4gaXQtQ0ggdnMgaXRcbiAgICAgICAgICAgIHJldHVybiBsYW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmZXRjaChnZXRBc3NldFBhdGgoYC4uL2FyY2dpcy1hcHAtYXNzZXRzL2kxOG4vJHtjb21wb25lbnROYW1lfS5pMThuLiR7bG9jYWxlfS5qc29uYCkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5vaylcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdC5qc29uKCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9LCAoKSA9PiByZWplY3QoKSk7XG4gICAgfSk7XG59XG5jb25zdCBzdHJpbmdDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGxvY2FsZSkge1xuICAgIGNvbnN0IGlkID0gYCR7Y29tcG9uZW50TmFtZX0ke2xvY2FsZX1gO1xuICAgIGlmICghc3RyaW5nQ2FjaGVbaWRdKSB7XG4gICAgICAgIHN0cmluZ0NhY2hlW2lkXSA9IGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nQ2FjaGVbaWRdO1xufVxuLyoqXG4gKiBHZXQgc3RyaW5ncyBhbmQgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIDIgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGUgZmlyc3Qgb25lIHJldHVybnMgYSBjb2RlIHRoYXQncyBhbHNvIHN1cHBvcnRlZCBhcyBhIGxhbmd1YWdlIGZpbGUuXG4gKiBUaGUgc2Vjb25kIG9uZSByZXR1cm5zIGEgY29kZSB3aGVyZSB0aGVyZSBpcyBzdXBwb3J0IGZvciB0aGUgZmlyc3QgMiBsZXR0ZXJzIG9mIHRoZSBjb2RlIGFzIHBhcnQgb2YgYSBsYW5ndWFnZSBmaWxlLFxuICogYnV0IHdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCA0IGxldHRlciBjb2RlIGZyb20gdGhlIHBhZ2UuXG4gKiBFLmcuIEZvciBcIml0LWNoXCIgaXQgd2lsbCByZXR1cm4gXCJpdFwiIGFzIHRoZSBmaXJzdCBsYW5ndWFnZSBjb2RlIGFuZCBcIml0LWNoXCIgYXMgdGhlIHNlY29uZC5cbiAqIFRoZSBzZWNvbmQgb25lIGlzIHJlcXVpcmVkIGZvciBlc3JpLmludGwuc2V0TG9jYWxlKCkgdG8gZ2V0IHRoZSBjb3JyZWN0IGZvcm1hdHRpbmcuXG4gKlxuICogSWYgYSB0YWdOYW1lIGlzIHByb3ZpZGVkIGl0IHdpbGwgb3ZlcndpdGUgdGhlIGVsZW1lbnQncyB0YWdOYW1lXG4gKlxuICogIEByZXR1cm4gWyBzdHJpbmdzLCBmaXJzdCBsYW5ndWFnZSBjb2RlLCBzZWNvbmQgbGFuZ3VhZ2UgY29kZV1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyhlbGVtZW50LCB0YWdOYW1lKSB7XG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IHRhZ05hbWUgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2UgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCk7XG4gICAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2VJbnRsID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KTtcbiAgICBsZXQgc3RyaW5ncztcbiAgICB0cnkge1xuICAgICAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudExhbmd1YWdlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBubyBsb2NhbGUgZm9yICR7Y29tcG9uZW50TmFtZX0gKCR7Y29tcG9uZW50TGFuZ3VhZ2V9KSBsb2FkaW5nIGRlZmF1bHQgbG9jYWxlIGVuLmApO1xuICAgICAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIFwiZW5cIik7XG4gICAgfVxuICAgIHJldHVybiBbc3RyaW5ncywgY29tcG9uZW50TGFuZ3VhZ2UsIGNvbXBvbmVudExhbmd1YWdlSW50bF07XG59XG5cbmV4cG9ydCB7IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZSBhcyBhLCBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIGFzIGcgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxlLTA1MGI2ZGI5LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgdSBhcyB1c2VySXNJdGVtQWRtaW4sIGMgYXMgY2FuVXBkYXRlSXRlbSwgZCBhcyBpdGVtc0JlbG9uZ1RvVXNlck9yZyB9IGZyb20gJy4vaXRlbS0zNTM1NTUyZC5qcyc7XG5cbmNvbnN0IGdldFVzZXJSb2xlID0gKHVzZXIpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gdHlwZW9mICh1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIucm9sZSkgPT09IFwic3RyaW5nXCIgJiYgISEodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnJvbGUpXG4gICAgICAgID8gdXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnJvbGVcbiAgICAgICAgOiAoX2IgPSAoX2EgPSB1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIucm9sZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIuaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChfYyA9IHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5zb3VyY2VKU09OKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaWQ7XG59O1xuZnVuY3Rpb24gaXNQdWJsaWNVc2VyKHVzZXIpIHtcbiAgICByZXR1cm4gdXNlciAmJiAhdXNlci5vcmdJZDtcbn1cbmZ1bmN0aW9uIGlzSG9zdGVkUG9ydGFsKHBvcnRhbCkge1xuICAgIHJldHVybiAhcG9ydGFsLmlzUG9ydGFsIHx8ICEhcG9ydGFsLmlzQmFja2VkQnlTRFM7XG59XG5mdW5jdGlvbiBpc0RldmVsb3BlcihzdWJzY3JpcHRpb25JbmZvKSB7XG4gICAgY29uc3QgZGV2U3Vic2NyaXB0aW9uVHlwZXMgPSBbXCJUcmlhbCBEZXZlbG9wZXJcIiwgXCJEZXZlbG9wZXJcIiwgXCJEZXZlbG9wZXIgU3Vic2NyaXB0aW9uXCJdO1xuICAgIHJldHVybiBkZXZTdWJzY3JpcHRpb25UeXBlcy5pbmNsdWRlcyhzdWJzY3JpcHRpb25JbmZvID09PSBudWxsIHx8IHN1YnNjcmlwdGlvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1YnNjcmlwdGlvbkluZm8udHlwZSk7XG59XG5mdW5jdGlvbiBpc09yZ0FkbWluKHVzZXIpIHtcbiAgICByZXR1cm4gZ2V0VXNlclJvbGUodXNlcikgPT09IFwib3JnX2FkbWluXCIgfHwgZ2V0VXNlclJvbGUodXNlcikgPT09IFwiYWNjb3VudF9hZG1pblwiO1xufVxuZnVuY3Rpb24gaXNPcmdVc2VyKHVzZXIpIHtcbiAgICByZXR1cm4gZ2V0VXNlclJvbGUodXNlcikgPT09IFwib3JnX3VzZXJcIiB8fCBnZXRVc2VyUm9sZSh1c2VyKSA9PT0gXCJhY2NvdW50X3VzZXJcIjtcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tUm9sZSh1c2VyKSB7XG4gICAgLy8gVGhlIEhvbWUgQXBwIGNvbGxhcHNlIHRoZSBgcm9sZUlkYCBhbmQgYHJvbGVgIGludG8gYSBzaW5nbGUgYGlkYCBwcm9wZXJ0eSwgdGhhdCdzIHdoeVxuICAgIC8vICBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcC9ibG9iL21hc3Rlci9zcmMvanMvYXJjZ2lzb25saW5lL3NoYXJpbmcvZGlqaXQvUm9sZS50cyNMNDY5IHdvcmtzXG4gICAgLy8gSW4gcHJhY3RpY2UsIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiBgcm9sZUlkYCBleGlzdFxuICAgIC8vICBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcC9pc3N1ZXMvNDQ2ODIjaXNzdWVjb21tZW50LTQxNDY4NjZcbiAgICByZXR1cm4gISEodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnJvbGVJZCkgJiYgdXNlci5yb2xlSWQubGVuZ3RoID4gMDtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHByaXZpbGVnZSBcInBvcnRhbDphZG1pbjp1cGRhdGVJdGVtQ2F0ZWdvcnlTY2hlbWFcIiBpcyBncmFudGVkLlxuICovXG5mdW5jdGlvbiBjYW5VcGRhdGVJdGVtQ2F0ZWdvcmllcyh1c2VyKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAhISgoX2EgPSB1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIucHJpdmlsZWdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKFwicG9ydGFsOmFkbWluOnVwZGF0ZUl0ZW1DYXRlZ29yeVNjaGVtYVwiKSk7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBwcml2aWxlZ2UgXCJwb3J0YWw6YWRtaW46dXBkYXRlR3JvdXBzXCIgaXMgZ3JhbnRlZC5cbiAqL1xuZnVuY3Rpb24gY2FuVXBkYXRlT3JnR3JvdXBzKHVzZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICEhKChfYSA9IHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5wcml2aWxlZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoXCJwb3J0YWw6YWRtaW46dXBkYXRlR3JvdXBzXCIpKTtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHVzZXIgaXMgYWxsb3dlZCB0byB1cGRhdGUgb3RoZXIgdXNlcidzIGl0ZW1zIGluIHRoZWlyIG9yZ2FuaXphdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FuVXBkYXRlT3JnSXRlbXModXNlcikge1xuICAgIHJldHVybiAoKHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5wcml2aWxlZ2VzKSB8fCBbXSkuaW5jbHVkZXMoXCJwb3J0YWw6YWRtaW46dXBkYXRlSXRlbXNcIik7XG59XG4vKipcbiAqIENoZWNrcyB0byBlbnN1cmUgdGhlIHBvcnRhbCBpcyBhbiBvcmdhbml6YXRpb24gcG9ydGFsXG4gKi9cbmZ1bmN0aW9uIGlzT3JnUG9ydGFsKHBvcnRhbCkge1xuICAgIHJldHVybiAhIShwb3J0YWwudXJsS2V5ICYmIHBvcnRhbC5jdXN0b21CYXNlVXJsKSB8fCAhIXBvcnRhbC5pc1BvcnRhbDtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHVzZXIgaXMgYWxsb3dlZCB0byBzaGFyZSB0aGVpciBpdGVtIHRvIGdyb3Vwc1xuICovXG5mdW5jdGlvbiBjYW5TaGFyZUl0ZW1Ub0dyb3VwKHVzZXIpIHtcbiAgICByZXR1cm4gKCh1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIucHJpdmlsZWdlcykgfHwgW10pLmluY2x1ZGVzKFwicG9ydGFsOnVzZXI6c2hhcmVUb0dyb3VwXCIpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBjYW4gc2hhcmUgYW4gaXRlbSBvbiBhIGdpdmVuIHBvcnRhbFxuICovXG5mdW5jdGlvbiBjYW5TaGFyZSh1c2VyLCBwb3J0YWwpIHtcbiAgICByZXR1cm4gKCFpc09yZ1BvcnRhbChwb3J0YWwpIHx8XG4gICAgICAgIGNhblNoYXJlSXRlbVRvR3JvdXAodXNlcikgfHxcbiAgICAgICAgY2FuU2hhcmVJdGVtVG9PcmcodXNlcikgfHxcbiAgICAgICAgKCEhcG9ydGFsLmNhblNoYXJlUHVibGljICYmIGNhblNoYXJlSXRlbVRvUHVibGljKHVzZXIpKSk7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGFsbG93ZWQgdG8gc2hhcmUgdGhlaXIgaXRlbSBvdCB0aGUgb3JnYW5pemF0aW9uLlxuICovXG5mdW5jdGlvbiBjYW5TaGFyZUl0ZW1Ub09yZyh1c2VyKSB7XG4gICAgcmV0dXJuICgodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnByaXZpbGVnZXMpIHx8IFtdKS5pbmNsdWRlcyhcInBvcnRhbDp1c2VyOnNoYXJlVG9PcmdcIik7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGFsbG93ZWQgdG8gc2hhcmUgdGhlaXIgaXRlbSB0byBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY2FuU2hhcmVJdGVtVG9QdWJsaWModXNlcikge1xuICAgIHJldHVybiAoKHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5wcml2aWxlZ2VzKSB8fCBbXSkuaW5jbHVkZXMoXCJwb3J0YWw6dXNlcjpzaGFyZVRvUHVibGljXCIpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBjYW4gc2hhcmUgb3RoZXIgdXNlcidzIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGNhblNoYXJlT3RoZXJzSXRlbXNUb09yZyh1c2VyKSB7XG4gICAgcmV0dXJuICgodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnByaXZpbGVnZXMpIHx8IFtdKS5pbmNsdWRlcyhcInBvcnRhbDphZG1pbjpzaGFyZVRvT3JnXCIpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBjYW4gc2hhcmUgb3RoZXIgdXNlcidzIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGNhblNoYXJlT3RoZXJzSXRlbXNUb1B1YmxpYyh1c2VyKSB7XG4gICAgcmV0dXJuICgodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnByaXZpbGVnZXMpIHx8IFtdKS5pbmNsdWRlcyhcInBvcnRhbDphZG1pbjpzaGFyZVRvUHVibGljXCIpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBjYW4gc2hhcmUgb3RoZXIgdXNlcidzIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGFkbWluQ2FuU2hhcmVPdGhlcnNJdGVtVG9Hcm91cCh1c2VyKSB7XG4gICAgcmV0dXJuICgodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnByaXZpbGVnZXMpIHx8IFtdKS5pbmNsdWRlcyhcInBvcnRhbDphZG1pbjpzaGFyZVRvR3JvdXBcIik7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGluIGFuIGFsbG93ZWQgb3JnYW5pemF0aW9uIGFuZCBoYXMgdGhlIHBvd2VyIHRvIG1hbmFnZSBjb2xsYWJvcmF0aW9uc1xuICovXG5mdW5jdGlvbiBjYW5NYW5hZ2VDb2xsYWJvcmF0aW9ucyhjb25maWcsIHVzZXIsIHBvcnRhbCwgc3Vic2NyaXB0aW9uSW5mbykge1xuICAgIGNvbnN0IGV4Y2x1ZGVkT3JnVHlwZXMgPSBbXCJUcmlhbFwiLCBcIlRyaWFsIFByZXNzXCIsIFwiVHJpYWwgRGV2ZWxvcGVyXCIsIFwiRGV2ZWxvcGVyIFN1YnNjcmlwdGlvblwiLCBcIkV2YWx1YXRpb25cIl07XG4gICAgY29uc3QgaXNWYWxpZE9yZ1R5cGUgPSBzdWJzY3JpcHRpb25JbmZvICYmICFleGNsdWRlZE9yZ1R5cGVzLmluY2x1ZGVzKHN1YnNjcmlwdGlvbkluZm8udHlwZSk7XG4gICAgY29uc3QgaGFzUHJpdmlsZWdlID0gKCh1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIucHJpdmlsZWdlcykgfHwgW10pLmluY2x1ZGVzKFwicG9ydGFsOmFkbWluOm1hbmFnZUNvbGxhYm9yYXRpb25zXCIpO1xuICAgIHJldHVybiAhISgoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmNvbGxhYm9yYXRpb25zRW5hYmxlZCkgJiZcbiAgICAgICAgdXNlciAmJlxuICAgICAgICAoaXNPcmdBZG1pbih1c2VyKSB8fCBoYXNQcml2aWxlZ2UpICYmXG4gICAgICAgICgocG9ydGFsID09PSBudWxsIHx8IHBvcnRhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9ydGFsLmlzUG9ydGFsKSB8fCBpc1ZhbGlkT3JnVHlwZSkpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBjYW4gdmlldyBvdGhlciBvcmdhbml6YXRpb24gdXNlcnMnIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGNhblZpZXdPcmdJdGVtcyh1c2VyKSB7XG4gICAgcmV0dXJuICgodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnByaXZpbGVnZXMpIHx8IFtdKS5pbmNsdWRlcyhcInBvcnRhbDphZG1pbjp2aWV3SXRlbXNcIik7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB1c2VyIGNhbiB2aWV3IG90aGVyIG9yZ2FuaXphdGlvbiB1c2VycycgaXRlbXNcbiAqL1xuZnVuY3Rpb24gY2FuVmlld090aGVyc09yZ0l0ZW1zKHVzZXIpIHtcbiAgICByZXR1cm4gISF1c2VyICYmICghaXNDdXN0b21Sb2xlKHVzZXIpIHx8IChpc0N1c3RvbVJvbGUodXNlcikgJiYgY2FuVmlld09yZ0l0ZW1zKHVzZXIpKSk7XG59XG4vLyBUT0RPOiBhZGQgdW5pdCB0ZXN0c1xuY29uc3QgaGFzQWRtaW5TaGFyZVByaXZpbGVnZSA9ICh7IGl0ZW1zLCB1c2VyLCBwb3J0YWwgfSkgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1swXTtcbiAgICAvLyBlbnRlcnByaXNlIGluY29ycmVjdGx5IHJldHVybnMgaXRlbXMgb3duZWQgYnkgXCJlc3JpX1wiIGFzIGl0ZW0gY29udHJvbCBhZG1pbiAoV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwIzM4Njk1KVxuICAgIGNvbnN0IG93bmVyID0gaXRlbS5vd25lcjtcbiAgICBjb25zdCB3aGl0ZWxpc3RPd25lciA9IFtcImVzcmlfbGl2aW5nYXRsYXNcIl07XG4gICAgaWYgKHBvcnRhbC5pc1BvcnRhbCAmJiBvd25lciAhPT0gdXNlci51c2VybmFtZSAmJiBvd25lci5pbmNsdWRlcyhcImVzcmlfXCIpICYmICF3aGl0ZWxpc3RPd25lci5pbmNsdWRlcyhvd25lcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpc093bmVyT3JBZG1pbiA9IHVzZXJJc0l0ZW1BZG1pbihpdGVtLCB1c2VyKTtcbiAgICBjb25zdCBpc0N1c3RvbSA9IGlzQ3VzdG9tUm9sZSh1c2VyKTtcbiAgICBjb25zdCBjYW5TaGFyZU9yZ0l0ZW1zID0gY2FuU2hhcmVPdGhlcnNJdGVtcyh1c2VyKTtcbiAgICBjb25zdCBjYW5VcGRhdGVBbmRTaGFyZSA9IGNhblVwZGF0ZUl0ZW0oaXRlbSwgdXNlcikgJiZcbiAgICAgICAgY2FuVXBkYXRlT3JnSXRlbXModXNlcikgJiZcbiAgICAgICAgIWlzQ3VzdG9tICYmXG4gICAgICAgIChjYW5TaGFyZSh1c2VyLCBwb3J0YWwpIHx8IGNhblNoYXJlT3RoZXJzSXRlbXModXNlcikpO1xuICAgIC8vIGlmIGl0J3MgdGhlIGl0ZW0gb3duZXIgb3IgYWRtaW4sIG9yIGN1c3RvbSBhZG1pbiB3aG8gY2FuIHNoYXJlXG4gICAgcmV0dXJuIGlzT3duZXJPckFkbWluIHx8IGNhblVwZGF0ZUFuZFNoYXJlIHx8IChpdGVtc0JlbG9uZ1RvVXNlck9yZyhpdGVtcywgdXNlcikgJiYgY2FuU2hhcmVPcmdJdGVtcyk7XG59O1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBjYW4gc2hhcmUgb3RoZXIgdXNlcidzIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGNhblNoYXJlT3RoZXJzSXRlbXModXNlcikge1xuICAgIHJldHVybiBhZG1pbkNhblNoYXJlT3RoZXJzSXRlbVRvR3JvdXAodXNlcikgfHwgY2FuU2hhcmVPdGhlcnNJdGVtc1RvT3JnKHVzZXIpIHx8IGNhblNoYXJlT3RoZXJzSXRlbXNUb1B1YmxpYyh1c2VyKTtcbn1cblxuZXhwb3J0IHsgaXNQdWJsaWNVc2VyIGFzIGEsIGlzT3JnQWRtaW4gYXMgYiwgaXNIb3N0ZWRQb3J0YWwgYXMgYywgaXNDdXN0b21Sb2xlIGFzIGQsIGNhblVwZGF0ZU9yZ0dyb3VwcyBhcyBlLCBjYW5VcGRhdGVJdGVtQ2F0ZWdvcmllcyBhcyBmLCBjYW5NYW5hZ2VDb2xsYWJvcmF0aW9ucyBhcyBnLCBpc09yZ1VzZXIgYXMgaCwgaXNEZXZlbG9wZXIgYXMgaSwgY2FuU2hhcmVJdGVtVG9Hcm91cCBhcyBqLCBjYW5TaGFyZUl0ZW1Ub09yZyBhcyBrLCBhZG1pbkNhblNoYXJlT3RoZXJzSXRlbVRvR3JvdXAgYXMgbCwgY2FuU2hhcmVPdGhlcnNJdGVtc1RvT3JnIGFzIG0sIGNhblNoYXJlSXRlbVRvUHVibGljIGFzIG4sIGNhblNoYXJlT3RoZXJzSXRlbXNUb1B1YmxpYyBhcyBvLCBoYXNBZG1pblNoYXJlUHJpdmlsZWdlIGFzIHAsIGNhblZpZXdPdGhlcnNPcmdJdGVtcyBhcyBxIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByaXZpbGVnZXMtNWMzODJmNjEuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5jb25zdCBzcGVjaWFsQ2hhcmFjdGVyc1JlZ0V4cCA9IC9cXCt8XFw/fFxcL3xcXCh8XFwpfFxcXFx8XFwhfFxcI3xcXFwifFxcfHxcXCp8XFw6fDx8PnxcXCV8XFwkfFxcQHxcXCd8XFxefFxcW3xcXF18XFwsfFxcPXxcXDsvZ2k7XG5jb25zdCBnZW9Kc29uUmVnRXhwID0gLyhcXC58b3V0cHV0Rm9ybWF0PSlqc29ufGdlb2pzb24kL2k7XG5jb25zdCBhZ3NSZWdFeHAgPSAvXFwvYWdzXFwvL2dpO1xuXG5jb25zdCBzZXJ2ZXJUeXBlcyA9IFwiTWFwU2VydmVyfEdlb2NvZGVTZXJ2ZXJ8R1BTZXJ2ZXJ8R2VvbWV0cnlTZXJ2ZXJ8SW1hZ2VTZXJ2ZXJ8TkFTZXJ2ZXJ8RmVhdHVyZVNlcnZlcnxHZW9EYXRhU2VydmVyfEdsb2JlU2VydmVyfE1vYmlsZVNlcnZlcnxXTVNlcnZlcnxTY2VuZVNlcnZlcnxWZWN0b3JUaWxlU2VydmVyfFN0cmVhbVNlcnZlcnxXb3Jrc3BhY2VTZXJ2ZXJ8R2VvZW5yaWNobWVudFNlcnZlcnxWaWRlb1NlcnZlclwiO1xuY29uc3QgcmVnZXhTZXJ2ZXJUeXBlID0gbmV3IFJlZ0V4cChgaHR0cC4rXFwvKCR7c2VydmVyVHlwZXN9KWApO1xuY29uc3QgdmFsaWRBcmNnaXNSZXN0U2VydmljZVBhdGggPSBgXFwvYXJjZ2lzXFwvcmVzdFxcL3NlcnZpY2VzfFxcL3Jlc3RcXC9zZXJ2aWNlc3xcXC9hcmNnaXNcXC9zZXJ2aWNlc3xcXC9hcmNnaXNcXC9yZXN0YDtcbmNvbnN0IHNlcnZlckluZm9FeHAgPSBgKD88c2VydmVyPmh0dHAuKyg/OiR7dmFsaWRBcmNnaXNSZXN0U2VydmljZVBhdGh9KSg/OlxcLz8uKlxcLyg/PG5hbWU+LiopXFwvKD88dHlwZT4ke3NlcnZlclR5cGVzfSkpKSg/IS4qXFwvJHtzZXJ2ZXJUeXBlc30pXFwvPyg/PHNvZT5cXFxcZCspPy4qYDtcbi8qKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGlucHV0IHVybCwgYmFzZSBzZXJ2ZXIgdXJsLCBzZXJ2ZXIgbmFtZSwgc2VydmVyIHR5cGUsIGFuZCBsYXllciBpbmRleCAoaWYgZW50ZXJlZCkuXG4gKiBFeGFtcGxlOiBbXG4gKiBcImh0dHBzOi8vc2FtcGxlc2VydmVyNi5hcmNnaXNvbmxpbmUuY29tL2FyY2dpcy9yZXN0L3NlcnZpY2VzL0ZlYXR1cmVTZXJ2ZXIvNTAwXCIsXG4gKiBcImh0dHBzOi8vc2FtcGxlc2VydmVyNi5hcmNnaXNvbmxpbmUuY29tL2FyY2dpcy9yZXN0L3NlcnZpY2VzL1Rlc3RTZXJ2aWNlL0ZlYXR1cmVTZXJ2ZXJcIixcbiAqIFwiVGVzdFNlcnZpY2VcIixcbiAqIFwiRmVhdHVyZVNlcnZlclwiLFxuICogXCI1MDBcIlxuICogXSAgKi9cbmNvbnN0IHJlZ2V4U2VydmVySW5mbyA9IG5ldyBSZWdFeHAoc2VydmVySW5mb0V4cCwgXCJpXCIpO1xuXG5jb25zdCBwYXJzZUFHU1NlcnZlckluZm8gPSAodXJsKSA9PiB7XG4gICAgY29uc3QgZXh0cmFjdGVkSW5mbyA9IHVybC5tYXRjaChyZWdleFNlcnZlckluZm8pO1xuICAgIGlmICghZXh0cmFjdGVkSW5mbykge1xuICAgICAgICBjb25zdCBjb250YWluc0FHUyA9IHVybC5tYXRjaChhZ3NSZWdFeHApO1xuICAgICAgICAvLyBUeXBlIGlzIGFsd2F5cyBNYXBTZXJ2ZXIgZm9yIC9hZ3MvIHNlcnZpY2VzXG4gICAgICAgIHJldHVybiBjb250YWluc0FHUyA/IHsgYmFzZVNlcnZlclVybDogdXJsLCBzZXJ2ZXJOYW1lOiBudWxsLCBzZXJ2ZXJUeXBlOiBcIk1hcFNlcnZlclwiLCBpbmRleDogbnVsbCB9IDogbnVsbDtcbiAgICB9XG4gICAgY29uc3QgWywgYmFzZVNlcnZlclVybCwgc2VydmVyTmFtZSwgc2VydmVyVHlwZSwgaW5kZXhTdHJdID0gZXh0cmFjdGVkSW5mbztcbiAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KGluZGV4U3RyKTtcbiAgICByZXR1cm4geyBiYXNlU2VydmVyVXJsLCBzZXJ2ZXJOYW1lLCBzZXJ2ZXJUeXBlLCBpbmRleDogaXNOYU4oaW5kZXgpID8gbnVsbCA6IGluZGV4IH07XG59O1xuY29uc3QgZ2V0UmVzdFVybEZyb21VcmwgPSAodXJsKSA9PiB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhY3RlZEluZm8gPSB1cmwubWF0Y2godmFsaWRBcmNnaXNSZXN0U2VydmljZVBhdGgpO1xuICAgIGlmICghZXh0cmFjdGVkSW5mbykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdXJsUGFydHMgPSB1cmwuc3BsaXQoXCIvcmVzdFwiKTtcbiAgICByZXR1cm4gdXJsUGFydHMubGVuZ3RoIDwgMiA/IG51bGwgOiBgJHt1cmxQYXJ0c1swXX0vcmVzdC9gO1xufTtcbmNvbnN0IGFkZFRyYWlsaW5nU2xhc2hJZk1pc3NpbmcgPSAodXJsKSA9PiB1cmwgJiYgdXJsLmNoYXJBdCh1cmwubGVuZ3RoIC0gMSkgIT09IFwiL1wiID8gYCR7dXJsfS9gIDogdXJsO1xuXG5leHBvcnQgeyBhZGRUcmFpbGluZ1NsYXNoSWZNaXNzaW5nIGFzIGEsIGdlb0pzb25SZWdFeHAgYXMgYiwgYWdzUmVnRXhwIGFzIGMsIGdldFJlc3RVcmxGcm9tVXJsIGFzIGcsIHBhcnNlQUdTU2VydmVySW5mbyBhcyBwLCByZWdleFNlcnZlclR5cGUgYXMgciwgc3BlY2lhbENoYXJhY3RlcnNSZWdFeHAgYXMgcywgdmFsaWRBcmNnaXNSZXN0U2VydmljZVBhdGggYXMgdiB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmwtNGMzYWU1NGMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9