"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_raster-106253"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createStore)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const appendToMap = (map, propName, value) => {
    const items = map.get(propName);
    if (!items) {
        map.set(propName, [value]);
    }
    else if (!items.includes(value)) {
        items.push(value);
    }
};
const debounce = (fn, ms) => {
    let timeoutId;
    return (...args) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
            timeoutId = 0;
            fn(...args);
        }, ms);
    };
};

/**
 * Check if a possible element isConnected.
 * The property might not be there, so we check for it.
 *
 * We want it to return true if isConnected is not a property,
 * otherwise we would remove these elements and would not update.
 *
 * Better leak in Edge than to be useless.
 */
const isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;
const cleanupElements = debounce((map) => {
    for (let key of map.keys()) {
        map.set(key, map.get(key).filter(isConnected));
    }
}, 2000);
const stencilSubscription = () => {
    if (typeof _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.g !== 'function') {
        // If we are not in a stencil project, we do nothing.
        // This function is not really exported by @stencil/core.
        return {};
    }
    const elmsToUpdate = new Map();
    return {
        dispose: () => elmsToUpdate.clear(),
        get: (propName) => {
            const elm = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.g)();
            if (elm) {
                appendToMap(elmsToUpdate, propName, elm);
            }
        },
        set: (propName) => {
            const elements = elmsToUpdate.get(propName);
            if (elements) {
                elmsToUpdate.set(propName, elements.filter(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f));
            }
            cleanupElements(elmsToUpdate);
        },
        reset: () => {
            elmsToUpdate.forEach((elms) => elms.forEach(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f));
            cleanupElements(elmsToUpdate);
        },
    };
};

const unwrap = (val) => (typeof val === 'function' ? val() : val);
const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
    const unwrappedState = unwrap(defaultState);
    let states = new Map(Object.entries(unwrappedState !== null && unwrappedState !== void 0 ? unwrappedState : {}));
    const handlers = {
        dispose: [],
        get: [],
        set: [],
        reset: [],
    };
    const reset = () => {
        var _a;
        // When resetting the state, the default state may be a function - unwrap it to invoke it.
        // otherwise, the state won't be properly reset
        states = new Map(Object.entries((_a = unwrap(defaultState)) !== null && _a !== void 0 ? _a : {}));
        handlers.reset.forEach((cb) => cb());
    };
    const dispose = () => {
        // Call first dispose as resetting the state would
        // cause less updates ;)
        handlers.dispose.forEach((cb) => cb());
        reset();
    };
    const get = (propName) => {
        handlers.get.forEach((cb) => cb(propName));
        return states.get(propName);
    };
    const set = (propName, value) => {
        const oldValue = states.get(propName);
        if (shouldUpdate(value, oldValue, propName)) {
            states.set(propName, value);
            handlers.set.forEach((cb) => cb(propName, value, oldValue));
        }
    };
    const state = (typeof Proxy === 'undefined'
        ? {}
        : new Proxy(unwrappedState, {
            get(_, propName) {
                return get(propName);
            },
            ownKeys(_) {
                return Array.from(states.keys());
            },
            getOwnPropertyDescriptor() {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            has(_, propName) {
                return states.has(propName);
            },
            set(_, propName, value) {
                set(propName, value);
                return true;
            },
        }));
    const on = (eventName, callback) => {
        handlers[eventName].push(callback);
        return () => {
            removeFromArray(handlers[eventName], callback);
        };
    };
    const onChange = (propName, cb) => {
        const unSet = on('set', (key, newValue) => {
            if (key === propName) {
                cb(newValue);
            }
        });
        // We need to unwrap the defaultState because it might be a function.
        // Otherwise we might not be sending the right reset value.
        const unReset = on('reset', () => cb(unwrap(defaultState)[propName]));
        return () => {
            unSet();
            unReset();
        };
    };
    const use = (...subscriptions) => {
        const unsubs = subscriptions.reduce((unsubs, subscription) => {
            if (subscription.set) {
                unsubs.push(on('set', subscription.set));
            }
            if (subscription.get) {
                unsubs.push(on('get', subscription.get));
            }
            if (subscription.reset) {
                unsubs.push(on('reset', subscription.reset));
            }
            if (subscription.dispose) {
                unsubs.push(on('dispose', subscription.dispose));
            }
            return unsubs;
        }, []);
        return () => unsubs.forEach((unsub) => unsub());
    };
    const forceUpdate = (key) => {
        const oldValue = states.get(key);
        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));
    };
    return {
        state,
        get,
        set,
        on,
        onChange,
        use,
        dispose,
        reset,
        forceUpdate,
    };
};
const removeFromArray = (array, item) => {
    const index = array.indexOf(item);
    if (index >= 0) {
        array[index] = array[array.length - 1];
        array.length--;
    }
};

const createStore = (defaultState, shouldUpdate) => {
    const map = createObservableMap(defaultState, shouldUpdate);
    map.use(stencilSubscription());
    return map;
};



//# sourceMappingURL=index-05956cab.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
    var _a, _b, _c;
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        // "ru-RU" maps to "ru" use case
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
        }
        else {
            return "en";
        }
    }
}
function getComponentClosestLanguageIntl(element) {
    var _a, _b, _c;
    // it's OK if we don't have the 4 letter language file for it
    // 4 letter language code needed for formatting numbers
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            // we support the 2 letter coded language
            // e.g. it-CH vs it
            return lang;
        }
        else {
            return "en";
        }
    }
}
function fetchLocaleStringsForComponent(componentName, locale) {
    return new Promise((resolve, reject) => {
        fetch((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
            if (result.ok)
                resolve(result.json());
            else
                reject();
        }, () => reject());
    });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
    const id = `${componentName}${locale}`;
    if (!stringCache[id]) {
        stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
    }
    return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
    const componentName = tagName || element.tagName.toLowerCase();
    const componentLanguage = getComponentClosestLanguage(element);
    const componentLanguageIntl = getComponentClosestLanguageIntl(element);
    let strings;
    try {
        strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
    }
    catch (e) {
        console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
        strings = await fetchLocaleStringsFromCache(componentName, "en");
    }
    return [strings, componentLanguage, componentLanguageIntl];
}



//# sourceMappingURL=locale-050b6db9.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js":
/*!*************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ getPrimaryTypeScheme),
/* harmony export */   A: () => (/* binding */ isPointType),
/* harmony export */   B: () => (/* binding */ isPolylineType),
/* harmony export */   C: () => (/* binding */ getFieldTypeCount),
/* harmony export */   D: () => (/* binding */ getGeometryType),
/* harmony export */   E: () => (/* binding */ closePopovers),
/* harmony export */   F: () => (/* binding */ findParentNode),
/* harmony export */   G: () => (/* binding */ getSingleObjectLocalStorage),
/* harmony export */   H: () => (/* binding */ setSingleObjectLocalStorage),
/* harmony export */   I: () => (/* binding */ getLayerFieldTypeCount),
/* harmony export */   J: () => (/* binding */ getRendererTheme),
/* harmony export */   K: () => (/* binding */ addFieldsToLayerCache),
/* harmony export */   L: () => (/* binding */ disablePanel),
/* harmony export */   M: () => (/* binding */ arcgisComponentNotificationsKeys),
/* harmony export */   N: () => (/* binding */ localStorageKeys),
/* harmony export */   O: () => (/* binding */ addFieldsToOutFields),
/* harmony export */   P: () => (/* binding */ findColorScheme),
/* harmony export */   Q: () => (/* binding */ fixNormalizationField),
/* harmony export */   R: () => (/* binding */ isEmpty),
/* harmony export */   S: () => (/* binding */ getDefaultSymbol),
/* harmony export */   T: () => (/* binding */ getSymbolSize),
/* harmony export */   U: () => (/* binding */ applySymbolSize),
/* harmony export */   V: () => (/* binding */ findHeatmapScheme),
/* harmony export */   W: () => (/* binding */ findPredominanceScheme),
/* harmony export */   X: () => (/* binding */ switchMarkersToPolygons),
/* harmony export */   Y: () => (/* binding */ switchPolygonsToMarkers),
/* harmony export */   Z: () => (/* binding */ findPieChartScheme),
/* harmony export */   _: () => (/* binding */ findTypeScheme),
/* harmony export */   a: () => (/* binding */ getVisVar),
/* harmony export */   a0: () => (/* binding */ findRelationshipScheme),
/* harmony export */   a1: () => (/* binding */ createUniqueValueRenderer),
/* harmony export */   a2: () => (/* binding */ createRGBRenderer),
/* harmony export */   a3: () => (/* binding */ createStretchRenderer),
/* harmony export */   a4: () => (/* binding */ isSameColor),
/* harmony export */   a5: () => (/* binding */ hasSymbolOutline),
/* harmony export */   a6: () => (/* binding */ isPictureMarker),
/* harmony export */   a7: () => (/* binding */ getFillColors),
/* harmony export */   a8: () => (/* binding */ layerSupportsCIM),
/* harmony export */   a9: () => (/* binding */ getColorRampsWithSchemes),
/* harmony export */   aA: () => (/* binding */ getRasterUniqueValueFields),
/* harmony export */   aB: () => (/* binding */ createUniqueValueRendererFromExisting),
/* harmony export */   aC: () => (/* binding */ getZoomOptions),
/* harmony export */   aD: () => (/* binding */ getHandleInfo),
/* harmony export */   aE: () => (/* binding */ isSymbolTransparent),
/* harmony export */   aF: () => (/* binding */ addSmartMappingTooltipWithId),
/* harmony export */   aG: () => (/* binding */ removeSmartMappingTooltipById),
/* harmony export */   aH: () => (/* binding */ isDate),
/* harmony export */   aI: () => (/* binding */ scrollIntoView),
/* harmony export */   aJ: () => (/* binding */ removeVisVar),
/* harmony export */   aK: () => (/* binding */ getFirstNumberField),
/* harmony export */   aL: () => (/* binding */ getDefaultDataRange),
/* harmony export */   aa: () => (/* binding */ isTopFlowItem),
/* harmony export */   ab: () => (/* binding */ updateRenderer),
/* harmony export */   ac: () => (/* binding */ isDefined),
/* harmony export */   ad: () => (/* binding */ validateMinMax),
/* harmony export */   ae: () => (/* binding */ removeSmartMappingTooltip),
/* harmony export */   af: () => (/* binding */ addSmartMappingTooltip),
/* harmony export */   ag: () => (/* binding */ hasNumberField),
/* harmony export */   ah: () => (/* binding */ getGeoRSSDefaultSymbol),
/* harmony export */   ai: () => (/* binding */ isLineMarker),
/* harmony export */   aj: () => (/* binding */ getRasterDefaultSymbol),
/* harmony export */   ak: () => (/* binding */ isCimLineSymbol),
/* harmony export */   al: () => (/* binding */ getCimLine),
/* harmony export */   am: () => (/* binding */ getSymbolChanges),
/* harmony export */   an: () => (/* binding */ updateSymbol),
/* harmony export */   ao: () => (/* binding */ applyAlpha),
/* harmony export */   ap: () => (/* binding */ getCIMOutlineWidth),
/* harmony export */   aq: () => (/* binding */ isSymbolAlmostWhite),
/* harmony export */   ar: () => (/* binding */ getRenderPreviewSize),
/* harmony export */   as: () => (/* binding */ setDefaultRGBBands),
/* harmony export */   at: () => (/* binding */ getPercentLabelFlip),
/* harmony export */   au: () => (/* binding */ createRgbRendererFromExisting),
/* harmony export */   av: () => (/* binding */ rgbTypeMap),
/* harmony export */   aw: () => (/* binding */ rgbDefaults),
/* harmony export */   ax: () => (/* binding */ stretchDefaults),
/* harmony export */   ay: () => (/* binding */ createStretchRendererFromExisting),
/* harmony export */   az: () => (/* binding */ stretchTypeMap),
/* harmony export */   b: () => (/* binding */ status),
/* harmony export */   c: () => (/* binding */ clearSmartMappingState),
/* harmony export */   d: () => (/* binding */ buildFieldsList),
/* harmony export */   e: () => (/* binding */ applyRenderer),
/* harmony export */   f: () => (/* binding */ getRendererFieldInfos),
/* harmony export */   g: () => (/* binding */ getRendererType),
/* harmony export */   h: () => (/* binding */ getRenderer),
/* harmony export */   i: () => (/* binding */ isRasterLayer),
/* harmony export */   j: () => (/* binding */ applyRendererToAll),
/* harmony export */   k: () => (/* binding */ isRasterRGBRenderer),
/* harmony export */   l: () => (/* binding */ applyExtraVisVars),
/* harmony export */   m: () => (/* binding */ saveExtraVisVars),
/* harmony export */   n: () => (/* binding */ getVisVarsExcept),
/* harmony export */   o: () => (/* binding */ getAuthVisVarsExcept),
/* harmony export */   p: () => (/* binding */ getAuthVisVar),
/* harmony export */   q: () => (/* binding */ isPolygonType),
/* harmony export */   r: () => (/* binding */ applySymbolColor),
/* harmony export */   s: () => (/* binding */ smartMappingState),
/* harmony export */   t: () => (/* binding */ getSymbolColor),
/* harmony export */   u: () => (/* binding */ getField),
/* harmony export */   v: () => (/* binding */ isSameFieldInfos),
/* harmony export */   w: () => (/* binding */ simpleFieldTypes),
/* harmony export */   x: () => (/* binding */ isSameFieldInfo),
/* harmony export */   y: () => (/* binding */ getFieldTypeFromValueType),
/* harmony export */   z: () => (/* binding */ getFieldType)
/* harmony export */ });
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale-050b6db9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/* harmony import */ var _index_05956cab_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index-05956cab.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */







var status;
(function (status) {
    status["MISSING"] = "missing";
    status["IN_PROGRESS"] = "inProgress";
    status["SUCCESS"] = "success";
    status["FAILED"] = "failed";
})(status || (status = {}));
/**
 * Returns true if the object in question is empty
 * @param input - object to determine if empty
 */
function isEmpty(input) {
    return Object.keys(input).length === 0 && input.constructor === Object;
}
function closePopovers() {
    document.querySelectorAll("calcite-popover").forEach((node) => {
        let remove = false;
        node.classList.forEach((className) => {
            if (className.startsWith("smart-mapping-") && className.endsWith("-popover")) {
                remove = true;
            }
        });
        if (remove) {
            node.setAttribute("open", "false");
            const parentNode = node.parentNode;
            parentNode === null || parentNode === void 0 ? void 0 : parentNode.removeChild(node);
        }
    });
    document
        .querySelectorAll("arcgis-smart-mapping-styler-popover, arcgis-smart-mapping-info-popover")
        .forEach((node) => {
        var _a;
        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(node);
    });
}
/**
 * Returns a parent element with that tag name or class name
 * @param node - starting node
 * @param tagName - tag name to find up the tree
 * @param className - class name to find up the tree
 */
function findParentNode(node, tagName, className) {
    if ((tagName && (node === null || node === void 0 ? void 0 : node.tagName) === tagName.toUpperCase()) || (className && (node === null || node === void 0 ? void 0 : node.classList.contains(className)))) {
        return node;
    }
    else {
        let parentNode = node === null || node === void 0 ? void 0 : node.parentElement;
        while (parentNode) {
            if ((tagName && parentNode.tagName === tagName.toUpperCase()) ||
                (className && parentNode.classList.contains(className))) {
                return parentNode;
            }
            else if (parentNode.tagName === "BODY") {
                break;
            }
            else {
                parentNode = parentNode.parentElement;
            }
        }
    }
    return;
}
/* old */
function findParentPanel(node) {
    if ((node === null || node === void 0 ? void 0 : node.tagName) === "CALCITE-PANEL") {
        return node;
    }
    else if ((node === null || node === void 0 ? void 0 : node.tagName) === "CALCITE-FLOW-ITEM") {
        return node;
    }
    else {
        let parentNode = node === null || node === void 0 ? void 0 : node.parentElement;
        while (parentNode) {
            if (parentNode.tagName === "CALCITE-PANEL") {
                return parentNode;
            }
            else if (parentNode.tagName === "CALCITE-FLOW-ITEM") {
                return parentNode;
            }
            else {
                parentNode = parentNode.parentElement;
            }
        }
    }
    return;
}
/* old */
function disablePanel(node, disable) {
    const parentPanel = findParentPanel(node);
    if (parentPanel) {
        parentPanel.disabled = disable;
    }
}
function isTopFlowItem(node) {
    let parentNode = node === null || node === void 0 ? void 0 : node.parentElement;
    if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.tagName) === "CALCITE-FLOW") {
        let index = 0;
        parentNode.childNodes.forEach((childNode, idx) => {
            if (childNode === node) {
                index = idx;
            }
        });
        return index === 0;
    }
    return false;
}
function addSmartMappingTooltipWithId(tooltipParentNode, label, id, open = true) {
    let node = document.getElementById(id);
    if (node === null || node === void 0 ? void 0 : node.parentNode) {
        node.parentNode.removeChild(node);
    }
    const tooltip = document.createElement("calcite-tooltip");
    tooltip.className = "smart-mapping-tooltip";
    tooltip.id = id;
    tooltip.referenceElement = tooltipParentNode;
    tooltip.open = open;
    tooltip.innerHTML = label;
    document.body.append(tooltip);
}
function addSmartMappingTooltip(tooltipParentNode, label, open = true) {
    const tooltip = document.createElement("calcite-tooltip");
    tooltip.className = "smart-mapping-tooltip";
    tooltip.referenceElement = tooltipParentNode;
    tooltip.open = open;
    tooltip.innerHTML = label;
    document.body.append(tooltip);
}
function removeSmartMappingTooltip() {
    document.querySelectorAll(".smart-mapping-tooltip").forEach((tooltip) => {
        var _a;
        (_a = tooltip.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(tooltip);
    });
}
function removeSmartMappingTooltipById(id) {
    const node = document.getElementById(id);
    if ((node === null || node === void 0 ? void 0 : node.className) === "smart-mapping-tooltip" && (node === null || node === void 0 ? void 0 : node.parentNode)) {
        node.parentNode.removeChild(node);
    }
}
function validateMinMax(obj) {
    if (obj.min === obj.max && isDefined(obj.min)) {
        if (obj.min > 0) {
            obj.min = 0;
            obj.max = obj.max * 2;
        }
        else if (obj.min < 0) {
            obj.min = obj.min * 2;
            obj.max = 0;
        }
        else {
            obj.min = -10;
            obj.max = 10;
        }
    }
    return obj;
}
function getGeometryType(layer) {
    var _a;
    if ("featureReduction" in layer && ((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) === "binning") {
        return "polygon";
    }
    return layer.type === "imagery" || layer.type === "imagery-tile"
        ? "polygon"
        : layer.type === "geo-rss"
            ? "point"
            : layer.geometryType;
}
function isPointType(layer) {
    const isStreamLayer = layer.type === "stream";
    return isStreamLayer || getGeometryType(layer) === "point" || getGeometryType(layer) === "multipoint";
}
function isPolygonType(layer) {
    const isStreamLayer = layer.type === "stream";
    return !isStreamLayer && getGeometryType(layer) === "polygon";
}
function isPolylineType(layer) {
    const isStreamLayer = layer.type === "stream";
    return !isStreamLayer && getGeometryType(layer) === "polyline";
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
function getDefaultDataRange(fieldInfo) {
    if (fieldInfo.simpleFieldType === simpleFieldTypes.DATE) {
        const year = new Date().getFullYear();
        return [new Date(`1/1/${year}`).getTime(), new Date(`12/31/${year}`).getTime()];
    }
    else {
        return [0, 100];
    }
}
function scrollIntoView(node) {
    setTimeout(() => {
        if (node) {
            node.scrollIntoView({
                behavior: "smooth",
                block: "nearest",
                inline: "start"
            });
        }
        // Firefox/Safari bug
        setTimeout(() => {
            var _a;
            const shellNode = (_a = document.getElementsByTagName("calcite-shell")) === null || _a === void 0 ? void 0 : _a[0];
            if (shellNode) {
                shellNode.scrollTop = 0;
            }
        }, 100);
    }, 100);
}
function getPercentLabelFlip(element) {
    const currentLanguage = (0,_locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_1__.a)(element);
    const dir = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_0__.g)(element);
    const percentFormatter = new Intl.NumberFormat(currentLanguage, { style: "percent" });
    const percentFormatSample = percentFormatter.format(0);
    const percentLabelFlip = dir === "rtl" ? percentFormatSample.endsWith("%") : percentFormatSample.startsWith("%");
    return percentLabelFlip;
}

var simpleFieldTypes;
(function (simpleFieldTypes) {
    simpleFieldTypes["NUMBER"] = "number";
    simpleFieldTypes["STRING"] = "string";
    simpleFieldTypes["DATE"] = "date";
    simpleFieldTypes["OID"] = "oid";
    simpleFieldTypes["GUID"] = "guid";
    simpleFieldTypes["UNKNOWN"] = "unknown";
})(simpleFieldTypes || (simpleFieldTypes = {}));
let excludedFields = [
    "id",
    "fips",
    "fid",
    "objectid",
    "_objectid",
    "__objectid",
    "x",
    "y",
    "lat",
    "long",
    "latitude",
    "longitude",
    "shape",
    "shape_length",
    "shape_leng",
    "shape_area",
    "perimeter",
    "stretched_value",
    "fnode_",
    "tnode_",
    "lpoly_",
    "rpoly_",
    "poly_",
    "subclass",
    "rings_ok",
    "rings_nok",
    "st_length(shape)",
    "st_area(shape)"
];
function buildFieldsList() {
    const { layer, mapImageSublayer } = smartMappingState;
    let { layerFields } = smartMappingState;
    if (!layer || layerFields) {
        return Promise.resolve();
    }
    smartMappingState.layerFields = getLayerFields(layer);
    // https://demographics9dev.arcgis.com/arcgis/rest/services/USA_Demographics_and_Boundaries_2019/MapServer
    if (mapImageSublayer &&
        mapImageSublayer.layer.portalItem &&
        mapImageSublayer.layer.url.indexOf("https://demographics") > -1 &&
        mapImageSublayer.layer.url.indexOf(".arcgis.com") > -1) {
        const portalItem = mapImageSublayer.layer.portalItem;
        return portalItem
            .fetchData()
            .then((response) => {
            if (response === null || response === void 0 ? void 0 : response.thematicGroup) {
                const fieldNames = response.thematicGroup.fieldNames;
                if (fieldNames) {
                    layerFields = layerFields.filter((layerField) => fieldNames.indexOf(layerField.name) > -1);
                }
            }
            buildFieldsListAfterThematicGroupCheck();
            return Promise.resolve();
        })
            .catch(() => {
            // assume there is none
            buildFieldsListAfterThematicGroupCheck();
            return Promise.resolve();
        });
    }
    else {
        buildFieldsListAfterThematicGroupCheck();
        return Promise.resolve();
    }
}
function getLayerFields(layer) {
    var _a;
    const { modules } = smartMappingState;
    if (layer.type === "feature" && ((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) === "binning") {
        // convert AggregateFields into Fields
        const aggregateFields = layer.featureReduction.fields;
        const fields = [];
        aggregateFields.forEach((aggregateField) => {
            const layerField = layer.fields.find((field) => field.name === aggregateField.onStatisticField);
            if (!aggregateField.onStatisticField || layerField) {
                fields.push(new modules.Field({
                    name: aggregateField.name,
                    alias: aggregateField.alias || aggregateField.name,
                    type: getFieldType(aggregateField)
                }));
            } // field doesn't exist on layer anymore; don't use it here
        });
        return fields;
    }
    return "fields" in layer && layer.fields;
}
function buildFieldsListAfterThematicGroupCheck() {
    var _a, _b;
    const { layer, mapImageSublayer, layerFields, supportsArcade } = smartMappingState;
    //const supportsStandardizedQuery = layer.version >= 10.2 && layer.capabilities?.query?.supportsStandardizedQueriesOnly;
    // JS-API #27120
    const supportsSqlExpression = layer.hasOwnProperty("capabilities") && ((_b = (_a = layer.capabilities) === null || _a === void 0 ? void 0 : _a.query) === null || _b === void 0 ? void 0 : _b.supportsSqlExpression);
    smartMappingState.fields = [];
    smartMappingState.stringFieldsCount = 0;
    smartMappingState.dateFieldsCount = 0;
    smartMappingState.numberFieldsCount = 0;
    const fieldInfos = "popupTemplate" in layer && layer.popupTemplate ? layer.popupTemplate.fieldInfos : [];
    // make sure no fields used in the renderer are excluded
    // not checking Arcade expressions...
    const rendererFields = getRendererFieldInfos(layer);
    const renNames = rendererFields
        .filter((renField) => !!renField.field)
        .map((renField) => renField.field.toLowerCase());
    if (renNames === null || renNames === void 0 ? void 0 : renNames.length) {
        excludedFields = excludedFields.filter((name) => renNames.indexOf(name) === -1);
    }
    layerFields.forEach((layerField) => {
        if (excludedFields.indexOf(layerField.name.toLowerCase()) > -1) {
            return;
        }
        if (["date", "date-only"].indexOf(layerField.type) > -1 &&
            ((mapImageSublayer && !supportsArcade) || (layer.type !== "stream" && !supportsSqlExpression))) {
            // no date field support
            return;
        }
        const list = fieldInfos
            ? fieldInfos.filter((fieldInfo) => fieldInfo.fieldName === layerField.name)
            : null;
        const label = list && list.length ? list[0].label : null;
        const featureFilterField = {
            layerField: layerField,
            label: label || layerField.alias || layerField.name
        };
        getSimpleFieldType(featureFilterField, renNames);
        if (featureFilterField.simpleFieldType) {
            smartMappingState.fields.push(featureFilterField);
        } // else can't use field
    });
}
function getField(fieldName) {
    const { layer } = smartMappingState;
    if (isRasterLayer(layer)) {
        const fields = getRasterUniqueValueFields();
        const list = fields.filter((field) => field.name === fieldName);
        if (list.length) {
            const field = list[0];
            return {
                label: field.alias,
                layerField: field,
                // raster layer displays are not dependent on field type, so we use "string" as a placeholder
                simpleFieldType: simpleFieldTypes.STRING
            };
        }
    }
    else {
        const list = smartMappingState.fields.filter((field) => field.layerField.name === fieldName);
        if (list.length) {
            return list[0];
        }
    }
    return undefined;
}
function getFirstNumberField() {
    const list = smartMappingState.fields.filter((field) => field.simpleFieldType === simpleFieldTypes.NUMBER);
    if (list.length) {
        return list[0];
    }
    return undefined;
}
function hasNumberField() {
    return smartMappingState.numberFieldsCount > 0;
}
function getFieldTypeCount() {
    const { selectedFields } = smartMappingState;
    const counts = { string: 0, number: 0, date: 0, unknown: 0, expression: 0 };
    selectedFields.forEach((fieldInfo) => {
        counts.expression += fieldInfo.expression ? 1 : 0;
        let fieldType;
        if (fieldInfo.field) {
            const field = getField(fieldInfo.field);
            fieldType = field ? field.simpleFieldType : simpleFieldTypes.UNKNOWN;
        }
        else {
            fieldType = fieldInfo.simpleFieldType;
        }
        switch (fieldType) {
            case simpleFieldTypes.NUMBER:
            case simpleFieldTypes.OID:
            case simpleFieldTypes.GUID:
                counts.number++;
                break;
            case simpleFieldTypes.STRING:
                counts.string++;
                break;
            case simpleFieldTypes.DATE:
                counts.date++;
                break;
            case simpleFieldTypes.UNKNOWN:
                counts.unknown++;
        }
    });
    return counts;
}
function getLayerFieldTypeCount(fields) {
    const { fields: stateFields } = smartMappingState;
    fields = fields || stateFields;
    const counts = { string: 0, number: 0, date: 0, expression: 0 };
    fields.forEach((field) => {
        switch (field.simpleFieldType) {
            case simpleFieldTypes.NUMBER:
            case simpleFieldTypes.OID:
            case simpleFieldTypes.GUID:
                counts.number++;
                break;
            case simpleFieldTypes.STRING:
                counts.string++;
                break;
            case simpleFieldTypes.DATE:
                counts.date++;
                break;
        }
    });
    return counts;
}
function addFieldsToLayerCache(fieldNames) {
    const { layer } = smartMappingState;
    if (!("featureReduction" in layer) || !layer.featureReduction || layer.featureReduction.type !== "binning") {
        addFieldsToOutFields(fieldNames);
    }
}
function addFieldsToOutFields(fieldNames) {
    /*
      feature, geoJSON and wfs need to have outFields updated
      stream layers have read-only outFields and all fields included in outFields
      csv by default has all the fields included in outFields
      for ogc-feature, outFields is not available.. but it would work as if its layerView.availableFields has all the fields..
    */
    const { layer } = smartMappingState;
    if (layer.type === "geojson" || layer.type === "wfs" || layer.type === "feature") {
        layer.outFields = fieldNames;
    }
}
function isSameFieldInfos(fieldInfos1, fieldInfos2) {
    let isSame = true;
    if (fieldInfos1.length !== fieldInfos2.length) {
        return false;
    }
    fieldInfos1.forEach((fieldInfo, idx) => {
        if (isSame && !isSameFieldInfo(fieldInfo, fieldInfos2[idx])) {
            isSame = false;
        }
    });
    return isSame;
}
function isSameFieldInfo(fieldInfo1, fieldInfo2) {
    // no exact comparison so `undefined == null` equals true
    if (fieldInfo1 &&
        fieldInfo2 &&
        fieldInfo1.field == fieldInfo2.field &&
        fieldInfo1.expression == fieldInfo2.expression &&
        fieldInfo1.expressionTitle == fieldInfo2.expressionTitle) {
        return true;
    }
    return false;
}
function isDate(fieldInfo) {
    return fieldInfo.simpleFieldType === simpleFieldTypes.DATE;
}
function getSimpleFieldType(featureFilterField, rendererFieldNames) {
    const layerFieldType = getFieldType(featureFilterField.layerField);
    switch (layerFieldType) {
        case "string":
        case "date-only":
            featureFilterField.simpleFieldType = simpleFieldTypes.STRING;
            smartMappingState.stringFieldsCount++;
            break;
        case "date":
            featureFilterField.simpleFieldType = simpleFieldTypes.DATE;
            smartMappingState.dateFieldsCount++;
            break;
        case "oid":
            // only if field is used in current renderer; field stays for the session
            if (rendererFieldNames.indexOf(featureFilterField.layerField.name.toLowerCase()) > -1) {
                featureFilterField.simpleFieldType = simpleFieldTypes.OID;
            }
            break;
        case "guid":
            // only if field is used in current renderer; field stays for the session
            if (rendererFieldNames.indexOf(featureFilterField.layerField.name.toLowerCase()) > -1) {
                featureFilterField.simpleFieldType = simpleFieldTypes.GUID;
            }
            break;
        case "small-integer":
        case "big-integer":
        case "integer":
        case "single":
        case "double":
        case "long":
            featureFilterField.simpleFieldType = simpleFieldTypes.NUMBER;
            smartMappingState.numberFieldsCount++;
            break;
    }
}
function getFieldTypeFromValueType(field) {
    // "count-or-amount","percentage-or-ratio","measurement","unique-identifier","coordinate","binary"
    // "name-or-title","type-or-category","description","location-or-place-name","ordered-or-ranked","date-and-time"
    const layerField = field.layerField;
    const layerFieldType = getFieldType(layerField);
    switch (layerFieldType) {
        case "small-integer":
        case "big-integer":
        case "integer":
        case "single":
        case "double": {
            if ("domain" in layerField && layerField.domain) {
                return "string";
            }
            switch ("valueType" in layerField && layerField.valueType) {
                case "name-or-title":
                case "type-or-category":
                case "description":
                case "location-or-place-name":
                case "ordered-or-ranked":
                case "binary":
                case "unique-identifier":
                case "date-and-time":
                    return "string";
                case "count-or-amount":
                    return "integer";
                case "percentage-or-ratio":
                case "measurement":
                case "coordinate":
                    return "double";
                default:
                    return "double";
            }
        }
        case "string":
        case "date-only":
            return "string";
        case "date":
            return "date";
        default:
            return "string";
    }
}
function getFieldType(field) {
    const { layer } = smartMappingState;
    if (!field || !("fields" in layer)) {
        return;
    }
    if ("type" in field) {
        // __esri.Field
        return field.type;
    }
    else if ("statisticType" in field) {
        // __esri.AggregateField
        const layerField = layer.fields.find((layerField) => layerField.name === field.onStatisticField);
        if (!field.onStatisticField || layerField) {
            if (field.statisticType === "count") {
                return "integer";
            }
            else if (field.statisticType === "avg") {
                return "double";
            }
            else if (["min", "max", "sum", "mode"].indexOf(field.statisticType) - 1) {
                return (layerField === null || layerField === void 0 ? void 0 : layerField.type) || "integer";
            }
        } // field doesn't exist on layer anymore
        return;
    }
    return;
}

function isRasterLayer(layer) {
    return ["imagery", "imagery-tile"].indexOf(layer.type) > -1;
}

var localStorageKeys;
(function (localStorageKeys) {
    localStorageKeys["ARCGIS_COMPONENT_NOTIFICATIONS"] = "arcgisComponent_notifications";
})(localStorageKeys || (localStorageKeys = {}));
var arcgisComponentNotificationsKeys;
(function (arcgisComponentNotificationsKeys) {
    arcgisComponentNotificationsKeys["SMART_MAPPING_TIP1_DISMISSED"] = "arcgis_smart_mapping_tip1_dismissed";
    arcgisComponentNotificationsKeys["SMART_MAPPING_TIP2_DISMISSED"] = "arcgis_smart_mapping_tip2_dismissed";
})(arcgisComponentNotificationsKeys || (arcgisComponentNotificationsKeys = {}));
const getLocalStorage = (localStorageKey) => {
    return localStorage.getItem(localStorageKey);
};
const setLocalStorage = (localStorageKey, value) => {
    localStorage.setItem(localStorageKey, value);
};
const getObjectLocalStorage = (localStorageKey) => {
    const info = getLocalStorage(localStorageKey);
    return info ? JSON.parse(info) : {};
};
const setSingleObjectLocalStorage = (localStorageKey, keyValueObject) => {
    const setLocalStorageVal = getObjectLocalStorage(localStorageKey);
    setLocalStorageVal[keyValueObject.key] = keyValueObject.value;
    setLocalStorage(localStorageKey, JSON.stringify(setLocalStorageVal));
};
const getSingleObjectLocalStorage = (localStorageKey, objectKey) => {
    const getLocalStorageVal = getObjectLocalStorage(localStorageKey);
    if (getLocalStorageVal === null || getLocalStorageVal === void 0 ? void 0 : getLocalStorageVal.hasOwnProperty(objectKey)) {
        return getLocalStorageVal[objectKey];
    }
    else {
        return null;
    }
};

const SmartMappingStore = (0,_index_05956cab_js__WEBPACK_IMPORTED_MODULE_4__.c)({
    selectedFields: [],
    hideLayerTitle: false,
    supportsArcade: false,
    stringFieldsCount: -1,
    dateFieldsCount: -1,
    numberFieldsCount: -1,
    isRTL: false,
    oneFeatureResponseStatus: status.MISSING
});
const smartMappingState = SmartMappingStore.state;
// createStore gets called just once in a app session
function clearSmartMappingState(smartMappingState) {
    smartMappingState.selectedFields = [];
    smartMappingState.layerFields = undefined;
    smartMappingState.fields = undefined;
    smartMappingState.hideLayerTitle = false;
    smartMappingState.supportsArcade = false;
    smartMappingState.stringFieldsCount = -1;
    smartMappingState.dateFieldsCount = -1;
    smartMappingState.numberFieldsCount = -1;
    smartMappingState.oneFeatureResponseStatus = status.MISSING;
    smartMappingState.selectedAttribute = undefined;
    smartMappingState.selectedAttributeText = undefined;
    smartMappingState.selectedTypeValue = undefined;
    smartMappingState.selectedValue = undefined;
    smartMappingState.lastDefault = undefined;
    smartMappingState.lastDefaults = undefined;
    smartMappingState.dotColorSelected = undefined;
    smartMappingState.backgroundStyleSelected = undefined;
    smartMappingState.lastSettings = undefined;
    smartMappingState.classedSymbolSelectedIdx = undefined;
    smartMappingState.allUniqueValues = undefined;
}

const defaultGeometry = "polygon";
function getRendererType() {
    const { layer } = smartMappingState;
    const renderer = getRenderer(layer);
    return getRendererTypeFromRenderer(renderer);
}
function getRendererTypeFromRenderer(renderer) {
    var _a;
    const { layer } = smartMappingState;
    const hasSizeVisVar = hasVisVar(renderer, "size");
    const hasColorVisVar = hasVisVar(renderer, "color");
    const colorVisVar = getVisVar(renderer, "color");
    const authColorVisVar = getAuthVisVar(renderer, "color");
    const authSizeVisVar = getAuthVisVar(renderer, "size");
    let rendererType = "unknown";
    if (renderer.normalizationType &&
        renderer.normalizationType !== "field") {
        // "percent-of-total" and "log" not supported
        return "unknown";
    }
    else if (renderer.type === "simple") {
        rendererType = "simple";
    }
    else if (renderer.type === "dot-density") {
        rendererType = "dot-density";
    }
    else if (renderer.type === "heatmap") {
        rendererType = "heatmap";
    }
    else if (renderer.type === "class-breaks") {
        const cbRenderer = renderer;
        if (hasColorVisVar) {
            if (cbRenderer.valueExpression && !authColorVisVar) {
                rendererType = "color";
            }
            else if (hasSizeVisVar) {
                if (authSizeVisVar && authSizeVisVar.units) {
                    rendererType = "color-size-age";
                }
                else if (authColorVisVar && authColorVisVar.units) {
                    rendererType = "color-age-size";
                }
                else {
                    rendererType = "color-size";
                }
            }
            else if (authColorVisVar && authColorVisVar.style && colorVisVar.normalizationField) {
                rendererType = "compare";
            }
            else if (authColorVisVar && authColorVisVar.units) {
                if (hasSizeVisVar) {
                    rendererType = "color-age-size";
                }
                else {
                    rendererType = "color-age";
                }
            }
            else {
                rendererType = "color";
            }
        }
        else if (hasSizeVisVar) {
            if (((_a = cbRenderer.authoringInfo) === null || _a === void 0 ? void 0 : _a.type) === "univariate-color-size") {
                rendererType = "color-size";
            }
            else if (cbRenderer.valueExpression && !authSizeVisVar) {
                rendererType = "size";
            }
            else if (authSizeVisVar && authSizeVisVar.units) {
                rendererType = "size-age";
            }
            else {
                rendererType = "size";
            }
        }
        else {
            // classed
            const rend = renderer;
            const authoringInfo = rend.authoringInfo;
            if (authoringInfo) {
                if (authoringInfo.type === "class-breaks-color") {
                    rendererType = "color"; //"classed-color";
                }
                else if (authoringInfo.type === "class-breaks-size") {
                    rendererType = "size"; //"classed-size";
                }
                else {
                    // guess the type
                    if (isSizeChanging(rend.classBreakInfos)) {
                        rendererType = "size"; //"classed-size";
                    }
                    else {
                        rendererType = "color"; //"classed-color";
                    }
                }
            }
            else if (isPolygonType(layer)) {
                if (rend.valueExpression) {
                    if (isSizeChanging(rend.classBreakInfos)) {
                        rendererType = "size"; //"classed-size";
                    }
                    else {
                        rendererType = "color"; //"classed-color";
                    }
                }
                else if (rend.backgroundFillSymbol) {
                    rendererType = "size"; //"classed-size";
                }
                else {
                    rendererType = "color"; //"classed-color";
                }
            }
            else {
                if (isSizeChanging(rend.classBreakInfos)) {
                    rendererType = "size"; //"classed-size";
                }
                else {
                    rendererType = "color"; //"classed-color";
                }
            }
        }
    }
    else if (renderer.type === "unique-value") {
        if (renderer.valueExpression) {
            // TODO API bug; fixed in 4master
            if ((renderer.authoringInfo && renderer.authoringInfo.type === "predominance") ||
                renderer.valueExpressionTitle === "Predominant category") {
                if (hasVisVar(renderer, "size")) {
                    rendererType = "predominance-size";
                }
                else {
                    rendererType = "predominance";
                }
            }
            else if (renderer.authoringInfo && renderer.authoringInfo.type === "relationship") {
                if (hasVisVar(renderer, "size")) {
                    rendererType = "relationship-size";
                }
                else {
                    rendererType = "relationship";
                }
            }
            else if (hasVisVar(renderer, "size")) {
                rendererType = "type-size";
            }
            else {
                rendererType = "type";
            }
        }
        else if (hasSizeVisVar) {
            if (authSizeVisVar && authSizeVisVar.units) {
                rendererType = "type-size-age";
            }
            else {
                rendererType = "type-size";
            }
        }
        else {
            rendererType = "type";
        }
    }
    else if (renderer.type === "pie-chart") {
        if (hasVisVar(renderer, "size")) {
            rendererType = "chart-size";
        }
        else {
            rendererType = "chart";
        }
    }
    return rendererType;
}
function fixNormalizationField(renderer) {
    // otherwise legend will show labels for the only info
    const colorVisVar = getVisVar(renderer, "color");
    const sizeVisVar = getVisVar(renderer, "size");
    const rendererType = getRendererTypeFromRenderer(renderer);
    if (colorVisVar === null || colorVisVar === void 0 ? void 0 : colorVisVar.normalizationField) {
        renderer.normalizationField = colorVisVar.normalizationField;
        renderer.normalizationType = "field";
    }
    else if (["color-size", "color-age-size", "color-size-age"].indexOf(rendererType) > -1 && colorVisVar) {
        renderer.normalizationField = undefined;
        renderer.normalizationType = undefined;
    }
    else if (rendererType === "size" && (sizeVisVar === null || sizeVisVar === void 0 ? void 0 : sizeVisVar.normalizationField)) {
        renderer.normalizationField = sizeVisVar.normalizationField;
        renderer.normalizationType = "field";
    }
}
function getRendererFieldInfos(layer) {
    var _a;
    let renderer = getRenderer(layer);
    let fieldInfos = [];
    const rendererType = getRendererType();
    switch (rendererType) {
        case "relationship":
        case "relationship-size": {
            fieldInfos = [
                {
                    field: renderer.authoringInfo.field1.field,
                    simpleFieldType: simpleFieldTypes.NUMBER
                },
                {
                    field: renderer.authoringInfo.field2.field,
                    simpleFieldType: simpleFieldTypes.NUMBER
                }
            ];
            const sizeVisVar = getVisVar(renderer, "size");
            if (sizeVisVar) {
                // relationship + size
                const field = getField(sizeVisVar.field);
                fieldInfos.push({
                    field: sizeVisVar.field,
                    expression: sizeVisVar.valueExpression,
                    expressionTitle: sizeVisVar.valueExpressionTitle,
                    simpleFieldType: sizeVisVar.field && field ? field.simpleFieldType : simpleFieldTypes.NUMBER
                });
            }
            break;
        }
        case "predominance":
        case "predominance-size": {
            fieldInfos = renderer.uniqueValueInfos.map((info) => {
                var _a;
                return {
                    field: "" + info.value,
                    simpleFieldType: ((_a = getField("" + info.value)) === null || _a === void 0 ? void 0 : _a.simpleFieldType) || simpleFieldTypes.NUMBER
                };
            });
            break;
        }
        case "chart":
        case "chart-size": {
            fieldInfos = renderer.attributes.map((attr) => {
                const field = getField(attr.field);
                return {
                    field: attr.field,
                    expression: attr.valueExpression,
                    expressionTitle: attr.valueExpressionTitle,
                    simpleFieldType: attr.field && field ? field.simpleFieldType : simpleFieldTypes.NUMBER
                };
            });
            break;
        }
    }
    if (fieldInfos.length) {
        // found it
        return fieldInfos;
    }
    switch (renderer.type) {
        case "dot-density": {
            fieldInfos = renderer.attributes.map((attribute) => {
                var _a;
                return {
                    field: attribute.field,
                    simpleFieldType: ((_a = getField(attribute.field)) === null || _a === void 0 ? void 0 : _a.simpleFieldType) || simpleFieldTypes.NUMBER
                };
            });
            break;
        }
        case "heatmap": {
            const hmRenderer = renderer;
            if (hmRenderer.field) {
                fieldInfos = [
                    {
                        field: hmRenderer.field,
                        simpleFieldType: ((_a = getField(hmRenderer.field)) === null || _a === void 0 ? void 0 : _a.simpleFieldType) || simpleFieldTypes.NUMBER
                    }
                ];
            }
            else {
                fieldInfos = [];
            }
            break;
        }
        case "class-breaks": {
            const cbRenderer = renderer;
            const field = getField(cbRenderer.field);
            fieldInfos = [
                {
                    field: cbRenderer.field,
                    expression: !field ? cbRenderer.valueExpression : undefined,
                    expressionTitle: !field ? cbRenderer.valueExpressionTitle : undefined,
                    simpleFieldType: cbRenderer.field && field ? field.simpleFieldType : simpleFieldTypes.NUMBER
                }
            ];
            const colorVisVar = getVisVar(renderer, "color");
            const sizeVisVar = getVisVar(renderer, "size");
            const authColorVisVar = getAuthVisVar(renderer, "color");
            const authSizeVisVar = getAuthVisVar(renderer, "size");
            if (colorVisVar && sizeVisVar) {
                // color + size
                if (colorVisVar.field === sizeVisVar.field &&
                    colorVisVar.valueExpression === sizeVisVar.valueExpression &&
                    colorVisVar.valueExpressionTitle === sizeVisVar.valueExpressionTitle) {
                    // same field
                    const field = getField(colorVisVar.field);
                    fieldInfos = [
                        {
                            field: colorVisVar.field,
                            expression: !field ? colorVisVar.valueExpression : undefined,
                            expressionTitle: !field ? colorVisVar.valueExpressionTitle : undefined,
                            simpleFieldType: colorVisVar.field && field ? field.simpleFieldType : simpleFieldTypes.NUMBER
                        }
                    ];
                }
                else {
                    if (authColorVisVar && authColorVisVar.units) {
                        // color-age
                        fieldInfos = [
                            {
                                field: authColorVisVar.field,
                                simpleFieldType: simpleFieldTypes.DATE
                            }
                        ];
                    }
                    else {
                        const field = getField(colorVisVar.field);
                        fieldInfos = [
                            {
                                field: colorVisVar.field,
                                expression: !field ? colorVisVar.valueExpression : undefined,
                                expressionTitle: !field ? colorVisVar.valueExpressionTitle : undefined,
                                simpleFieldType: colorVisVar.field && field ? field.simpleFieldType : simpleFieldTypes.NUMBER
                            }
                        ];
                    }
                    if (authSizeVisVar && authSizeVisVar.units) {
                        // size-age
                        fieldInfos.push({
                            field: authSizeVisVar.field,
                            simpleFieldType: simpleFieldTypes.DATE
                        });
                    }
                    else {
                        const field = getField(sizeVisVar.field);
                        fieldInfos.push({
                            field: sizeVisVar.field,
                            expression: !field ? sizeVisVar.valueExpression : undefined,
                            expressionTitle: !field ? sizeVisVar.valueExpressionTitle : undefined,
                            simpleFieldType: sizeVisVar.field && field ? field.simpleFieldType : simpleFieldTypes.NUMBER
                        });
                    }
                }
            }
            else if (colorVisVar) {
                // color
                if (authColorVisVar && authColorVisVar.units) {
                    fieldInfos = [
                        {
                            field: authColorVisVar.field,
                            simpleFieldType: simpleFieldTypes.DATE
                        }
                    ];
                }
                else {
                    const field = getField(colorVisVar.field);
                    fieldInfos = [
                        {
                            field: colorVisVar.field,
                            expression: !field ? colorVisVar.valueExpression : undefined,
                            expressionTitle: !field ? colorVisVar.valueExpressionTitle : undefined,
                            simpleFieldType: colorVisVar.field && field ? field.simpleFieldType : simpleFieldTypes.NUMBER
                        }
                    ];
                }
            }
            else if (sizeVisVar) {
                // size
                if (authSizeVisVar && authSizeVisVar.units) {
                    fieldInfos = [
                        {
                            field: authSizeVisVar.field,
                            simpleFieldType: simpleFieldTypes.DATE
                        }
                    ];
                }
                else {
                    const field = getField(sizeVisVar.field);
                    fieldInfos = [
                        {
                            field: sizeVisVar.field,
                            expression: !field ? sizeVisVar.valueExpression : undefined,
                            expressionTitle: !field ? sizeVisVar.valueExpressionTitle : undefined,
                            simpleFieldType: sizeVisVar.field && field ? field.simpleFieldType : simpleFieldTypes.NUMBER
                        }
                    ];
                }
            }
            if (authColorVisVar && authColorVisVar.style && colorVisVar.normalizationField) {
                // compare
                const field = getField(colorVisVar.field);
                const normField = getField(colorVisVar.normalizationField);
                fieldInfos = [
                    {
                        field: colorVisVar.field,
                        simpleFieldType: field ? field.simpleFieldType : simpleFieldTypes.NUMBER
                    },
                    {
                        field: colorVisVar.normalizationField,
                        simpleFieldType: normField ? normField.simpleFieldType : simpleFieldTypes.NUMBER
                    }
                ];
            }
            break;
        }
        case "unique-value": {
            if (renderer.authoringInfo && renderer.authoringInfo.type === "predominance") {
                // predominance
                const uvRenderer = renderer;
                fieldInfos = uvRenderer.uniqueValueInfos.map((info) => {
                    const field = getField("" + info.value);
                    return {
                        field: "" + info.value,
                        simpleFieldType: field ? field.simpleFieldType : simpleFieldTypes.NUMBER
                    };
                });
            }
            else if (renderer.authoringInfo && renderer.authoringInfo.type === "chart") {
                // chart
                const uvRenderer = renderer;
                fieldInfos = uvRenderer.uniqueValueInfos.map((info) => {
                    const field = getField("" + info.value);
                    return {
                        field: "" + info.value,
                        simpleFieldType: field ? field.simpleFieldType : simpleFieldTypes.NUMBER
                    };
                });
            }
            else if (renderer.authoringInfo && renderer.authoringInfo.type === "relationship") {
                // relationship
                const field1 = getField(renderer.authoringInfo.field1.field);
                const field2 = getField(renderer.authoringInfo.field2.field);
                fieldInfos = [
                    {
                        field: renderer.authoringInfo.field1.field,
                        simpleFieldType: field1 ? field1.simpleFieldType : simpleFieldTypes.NUMBER
                    },
                    {
                        field: renderer.authoringInfo.field2.field,
                        simpleFieldType: field2 ? field2.simpleFieldType : simpleFieldTypes.NUMBER
                    }
                ];
            }
            else {
                // types
                const uvRenderer = renderer;
                const field = getField(uvRenderer.field);
                let returnType = simpleFieldTypes.NUMBER;
                if (uvRenderer.field && field) {
                    returnType = field.simpleFieldType;
                }
                else if (uvRenderer.valueExpression &&
                    uvRenderer.uniqueValueInfos &&
                    uvRenderer.uniqueValueInfos[0] &&
                    typeof uvRenderer.uniqueValueInfos[0].value === "string") {
                    returnType = simpleFieldTypes.STRING;
                }
                fieldInfos = [
                    {
                        field: uvRenderer.field,
                        expression: !field ? uvRenderer.valueExpression : undefined,
                        expressionTitle: !field ? uvRenderer.valueExpressionTitle : undefined,
                        simpleFieldType: returnType
                    }
                ];
                const sizeVisVar = getVisVar(renderer, "size");
                if (sizeVisVar) {
                    // type + size
                    let fieldName = sizeVisVar.field;
                    if (!fieldName) {
                        // age renderer
                        const authSizeVisVar = getAuthVisVar(renderer, "size") || {};
                        fieldName = authSizeVisVar.field;
                    }
                    const field = getField(fieldName);
                    fieldInfos.push({
                        field: fieldName,
                        expression: !field ? sizeVisVar.valueExpression : undefined,
                        expressionTitle: !field ? sizeVisVar.valueExpressionTitle : undefined,
                        simpleFieldType: fieldName && field ? field.simpleFieldType : simpleFieldTypes.NUMBER
                    });
                }
            }
        }
    }
    return fieldInfos;
}
function getHandleInfo(theme, stops, noSegment = false) {
    if (!stops || stops.length === 5) {
        switch (theme) {
            case "high-to-low":
            case "above":
            case "below":
                return {
                    handlesSyncedToPrimary: false,
                    primaryHandleEnabled: false,
                    visibleElements: {
                        interactiveTrack: true
                    }
                };
            case "above-and-below":
                return {
                    handlesSyncedToPrimary: false,
                    primaryHandleEnabled: true,
                    syncedSegmentsEnabled: !noSegment,
                    visibleElements: {
                        interactiveTrack: !noSegment
                    }
                };
            case "centered-on":
                return {
                    handlesSyncedToPrimary: false,
                    primaryHandleEnabled: true,
                    syncedSegmentsEnabled: true,
                    visibleElements: {
                        interactiveTrack: true
                    }
                };
            case "extremes":
                return {
                    handlesSyncedToPrimary: false,
                    primaryHandleEnabled: true,
                    syncedSegmentsEnabled: true,
                    visibleElements: {
                        interactiveTrack: true
                    }
                };
        }
    }
    else {
        return {
            handlesSyncedToPrimary: false,
            primaryHandleEnabled: false,
            visibleElements: {
                interactiveTrack: true
            }
        };
    }
}
function getBasemapType(mapView) {
    const baseLayer = mapView.map.basemap.baseLayers.getItemAt(0);
    if (!baseLayer.url) {
        if (baseLayer.declaredClass === "esri.layers.OpenStreetMapLayer") {
            return "osm";
        }
        else {
            return "topo";
        }
    }
    const url = baseLayer.url.toLowerCase();
    if (url.indexOf("arcgis/rest/services/World_Street_Map".toLowerCase()) > -1) {
        return "streets";
    }
    else if (url.indexOf("ArcGIS/rest/services/Canvas/World_Light_Gray_Base".toLowerCase()) > -1) {
        return "gray";
    }
    else if (url.indexOf("arcgis/rest/services/World_Topo_Map".toLowerCase()) > -1 ||
        url.indexOf("arcgis/rest/services/USGSTopo".toLowerCase()) > -1) {
        return "topo";
    }
    else if (url.indexOf("ArcGIS/rest/services/World_Terrain_Base".toLowerCase()) > -1) {
        return "terrain";
    }
    else if (url.indexOf("arcgis/rest/services/NatGeo_World_Map".toLowerCase()) > -1) {
        return "national-geographic";
    }
    else if (url.indexOf("arcgis/rest/services/Ocean/World_Ocean_Base".toLowerCase()) > -1) {
        return "oceans";
    }
    else if (url.indexOf("arcgis/rest/services/World_Imagery".toLowerCase()) > -1) {
        return "satellite";
    }
    else if (url.indexOf("ArcGIS/rest/services/Reference/World_Boundaries_and_Places".toLowerCase()) > -1) {
        return "hybrid";
    }
    else if (url.indexOf("arcgis/rest/services/Canvas/World_Dark_Gray_Base".toLowerCase()) > -1) {
        return "dark-gray";
    }
    return "topo";
}
function getZoomOptions(stops, totalMin, totalMax) {
    if (!(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_5__.i)(totalMin) || !(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_5__.i)(totalMax)) {
        return null;
    }
    const lowerThumb = stops[0].value;
    const upperThumb = stops[stops.length - 1].value;
    const range = upperThumb - lowerThumb;
    const padding = range * 0.3;
    const zoomMin = lowerThumb - padding > totalMin ? lowerThumb - padding : null;
    const zoomMax = upperThumb + padding < totalMax ? upperThumb + padding : null;
    return { min: zoomMin, max: zoomMax, minMaxSame: lowerThumb === upperThumb };
}
function updateRenderer() {
    const { layer, mapImageSublayer } = smartMappingState;
    const isGeoRSS = layer.declaredClass === "esri.layers.GeoRSSLayer";
    if (isGeoRSS) {
        const geoRSSLayer = layer;
        geoRSSLayer.pointSymbol = geoRSSLayer.pointSymbol.clone();
        geoRSSLayer.lineSymbol = geoRSSLayer.lineSymbol.clone();
        geoRSSLayer.polygonSymbol = geoRSSLayer.polygonSymbol.clone();
    }
    else {
        applyRenderer(getRenderer(layer).clone(), layer);
        if (mapImageSublayer) {
            mapImageSublayer.renderer = getRenderer(layer).clone();
        }
    }
}
function applyRenderer(renderer, layer) {
    var _a;
    if ("featureReduction" in layer && ((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) === "binning") {
        layer.featureReduction.renderer = renderer;
    }
    else if ("renderer" in layer) {
        layer.renderer = renderer;
    }
}
/*
 * Apply renderer to layer and mapImageSublayer and make sure it works with featureReduction.
 */
function applyRendererToAll(originalRendererJSON, originalFeatureReduction) {
    const { layer, mapImageSublayer, modules } = smartMappingState;
    if (originalFeatureReduction && "featureReduction" in layer) {
        // to avoid errors while new featureReduction doesn't fit to orig renderer
        layer.featureReduction = null;
    }
    applyRenderer(modules.rendererJsonUtils.fromJSON(originalRendererJSON), layer);
    if (originalFeatureReduction && "featureReduction" in layer) {
        layer.featureReduction = originalFeatureReduction;
    }
    if (mapImageSublayer) {
        mapImageSublayer.renderer = modules.rendererJsonUtils.fromJSON(originalRendererJSON);
    }
}
function getRenderer(layer) {
    var _a;
    if ("featureReduction" in layer && ((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) === "binning") {
        return layer.featureReduction.renderer;
    }
    return "renderer" in layer && layer.renderer;
}
function getRendererTheme(subType) {
    const { layer } = smartMappingState;
    const renderer = "renderer" in layer && layer.renderer;
    const authInfo = "authoringInfo" in renderer && renderer.authoringInfo;
    const authColorVisVar = getAuthVisVar(getRenderer(layer), "color");
    const authSizeVisVar = getAuthVisVar(getRenderer(layer), "size");
    return ((subType === "color"
        ? authColorVisVar === null || authColorVisVar === void 0 ? void 0 : authColorVisVar.theme
        : subType === "size"
            ? authSizeVisVar === null || authSizeVisVar === void 0 ? void 0 : authSizeVisVar.theme
            : (authInfo === null || authInfo === void 0 ? void 0 : authInfo.univariateTheme) || (authColorVisVar === null || authColorVisVar === void 0 ? void 0 : authColorVisVar.theme) || (authSizeVisVar === null || authSizeVisVar === void 0 ? void 0 : authSizeVisVar.theme)) || "");
}
function isSizeChanging(classBreakInfos) {
    // this gets tricky, because the user can change each symbol to anything
    // so if at least 2 symbols have the same color we assume size
    let i, k;
    for (i = 0; i < classBreakInfos.length; i++) {
        const sym1 = classBreakInfos[i].symbol;
        for (k = 0; k < classBreakInfos.length; k++) {
            const sym2 = classBreakInfos[k].symbol;
            if (i !== k && hasSameColor(sym1, sym2)) {
                return true;
            }
        }
    }
    return false;
}
function hasSameColor(sym1, sym2) {
    if (sym1.type == "picture-marker") {
        return false;
    }
    if (sym1.style === "cross" || sym1.style === "x") {
        if (sym2.style === "cross" || sym2.style === "x") {
            return ((!sym1.outline.color && !sym2.outline.color) ||
                (sym1.outline.color && sym2.outline.color && sym1.outline.color.toString() === sym2.outline.color.toString()));
        }
        else {
            return ((!sym1.outline.color && !sym2.color) ||
                (sym1.outline.color && sym2.color && sym1.outline.color.toString() === sym2.color.toString()));
        }
    }
    else {
        if (sym2.style === "cross" || sym2.style === "x") {
            return ((!sym1.color && !sym2.outline.color) ||
                (sym1.color && sym2.outline.color && sym1.color.toString() === sym2.outline.color.toString()));
        }
        else {
            return ((!sym1.color && !sym2.color) || (sym1.color && sym2.color && sym1.color.toString() === sym2.color.toString()));
        }
    }
}
function findColorScheme(theme) {
    // theme is optional
    const { layer, modules } = smartMappingState;
    const renderer = getRenderer(layer);
    const rendererType = getRendererType();
    if (["unique-size", "unique-size-age"].indexOf(rendererType) > -1) {
        return null;
    }
    // try to figure this out
    let matchingSchemes;
    const colorVisVar = getVisVar(renderer, "color");
    const infos = renderer.classBreakInfos ? renderer.classBreakInfos : renderer.uniqueValueInfos;
    let colors;
    if (colorVisVar) {
        colors = colorVisVar.stops.map((stop) => {
            return stop.color;
        });
        matchingSchemes = modules.colorSchemes.getMatchingSchemes({
            theme: theme || "high-to-low",
            colors: colors,
            geometryType: getGeometryType(layer) || defaultGeometry
        });
    }
    else if (infos && infos.length >= 1) {
        colors = infos
            ? infos
                .map((info) => {
                return getSymbolColor(info.symbol);
            })
                .filter((color) => {
                return color;
            })
            : null;
        if (colors && colors.length) {
            if (colors.length > 10) {
                colors = colors.slice(0, 9);
            }
            matchingSchemes = getMatchingSchemes(colors, theme);
        } // else might have point-cloud tag
    }
    if (matchingSchemes && matchingSchemes.length) {
        return matchingSchemes[0];
    }
    return null;
}
function getMatchingSchemes(colors, theme) {
    const { layer, modules } = smartMappingState;
    let matchingSchemes = modules.colorSchemes.getMatchingSchemes({
        theme: theme || "high-to-low",
        colors: colors,
        geometryType: getGeometryType(layer) || defaultGeometry
    });
    if (theme && (!matchingSchemes || !matchingSchemes.length)) {
        matchingSchemes = modules.colorSchemes.getMatchingSchemes({
            theme: "high-to-low",
            colors: colors,
            geometryType: getGeometryType(layer) || defaultGeometry
        });
    }
    if (!matchingSchemes || !matchingSchemes.length) {
        matchingSchemes = modules.colorSchemes.getMatchingSchemes({
            theme: "above-and-below",
            colors: colors,
            geometryType: getGeometryType(layer) || defaultGeometry
        });
    }
    return matchingSchemes;
}
function findRelationshipScheme() {
    const { layer, mapView, modules } = smartMappingState;
    const renderer = getRenderer(layer);
    const infos = renderer.uniqueValueInfos;
    if (!infos || infos.length < 2) {
        return null;
    }
    const currentNumClasses = Math.sqrt(infos.length);
    const schemes = modules.relationshipSchemes.getSchemes({
        basemap: mapView.map.basemap || "topo",
        geometryType: getGeometryType(layer)
    });
    const allSchemes = [schemes.primaryScheme].concat(schemes.secondarySchemes);
    const matchingSchemes = [];
    allSchemes.forEach((scheme) => {
        let allColors = [];
        scheme.colorsForClassBreaks[currentNumClasses - 2].colors.forEach((arr) => {
            allColors = allColors.concat(modules.esriLang.clone(arr));
        });
        const hasNoMatch = infos.some((info) => {
            const color = getSymbolColor(info.symbol);
            // order doesn't matter
            return !color ? false : !allColors.find((allColor) => isSameColor(allColor, color));
        });
        if (!hasNoMatch) {
            matchingSchemes.push(scheme);
        }
    });
    return matchingSchemes.length ? matchingSchemes[0] : null;
}
function findTypeScheme() {
    const { layer, mapView, modules } = smartMappingState;
    const renderer = getRenderer(layer);
    if (!renderer.uniqueValueInfos || renderer.uniqueValueInfos.length < 2) {
        return null;
    }
    const schemes = modules.typeSchemes.getSchemes({
        basemap: mapView.map.basemap,
        geometryType: getGeometryType(layer) || defaultGeometry
    });
    return findScheme(schemes);
}
function findPredominanceScheme() {
    const { layer, mapView, modules } = smartMappingState;
    const renderer = getRenderer(layer);
    if (!renderer.uniqueValueInfos || renderer.uniqueValueInfos.length < 2) {
        return null;
    }
    const schemes = modules.predominanceSchemes.getSchemes({
        basemap: mapView.map.basemap,
        geometryType: getGeometryType(layer),
        numColors: 10 //renderer.uniqueValueInfos.length
    });
    return findScheme(schemes);
}
function findPieChartScheme() {
    const { layer, mapView, modules } = smartMappingState;
    const renderer = getRenderer(layer);
    if (!renderer.attributes || renderer.attributes.length < 2) {
        return null;
    }
    const schemes = modules.pieChartSchemes.getSchemes({
        basemap: mapView.map.basemap,
        geometryType: getGeometryType(layer),
        numColors: 10 //renderer.uniqueValueInfos.length
    });
    return findScheme(schemes);
}
function findHeatmapScheme() {
    // theme is optional
    const { layer, mapView, modules } = smartMappingState;
    const renderer = getRenderer(layer);
    // try to figure this out
    let colors;
    colors = renderer.colorStops
        .filter((__, idx) => idx >= 3)
        .map((stop) => {
        return stop.color;
    });
    const schemes = modules.heatmapSchemes.getSchemes({
        basemap: mapView.map.basemap || "topo" // TODO
    });
    const allSchemes = [schemes.primaryScheme].concat(schemes.secondarySchemes);
    const matchingSchemes = [];
    allSchemes.forEach((scheme) => {
        const hasNoMatch = colors.some((color, idx) => {
            return !isSameColor(scheme.colors[idx], color);
        });
        if (!hasNoMatch) {
            matchingSchemes.push(scheme);
        }
    });
    return matchingSchemes.length ? matchingSchemes[0] : null;
}
function findScheme(schemes) {
    const { layer } = smartMappingState;
    const renderer = getRenderer(layer);
    const infos = renderer.uniqueValueInfos;
    if (!infos || infos.length < 2) {
        return null;
    }
    const colorRampsAndSchemes = getColorRampsWithSchemes(schemes, Math.min(infos.length, 10));
    const matchingSchemes = [];
    colorRampsAndSchemes.forEach((ramp) => {
        const hasNoMatch = infos
            .filter((__, idx) => idx < 10)
            .some((info, idx) => {
            const color = getSymbolColor(info.symbol);
            return !color ? false : !isSameColor(ramp.colors[idx], color);
        });
        if (!hasNoMatch) {
            matchingSchemes.push(ramp.scheme);
        }
    });
    return matchingSchemes.length ? matchingSchemes[0] : null;
}
function getPrimaryTypeScheme() {
    const { layer, mapView, modules } = smartMappingState;
    const schemes = modules.typeSchemes.getSchemes({
        basemap: mapView.map.basemap,
        geometryType: getGeometryType(layer) || defaultGeometry
    });
    return schemes.primaryScheme;
}
function isSameColor(a, b) {
    if (a.r === b.r && a.g === b.g && a.b === b.b) {
        return true;
    }
    return false;
}

function getColorRampsWithSchemes(schemes, numClasses) {
    const allSchemes = _unify(schemes), colorRampsAndSchemes = [];
    allSchemes.forEach((scheme) => {
        const isClassed = numClasses > 0, hasColorsForClassBreaks = !!scheme.colorsForClassBreaks;
        let colors;
        if (isClassed) {
            colors = hasColorsForClassBreaks
                ? _maxSupportedClassBreakColors(scheme.colorsForClassBreaks, numClasses)
                : scheme.colors;
        }
        else {
            colors = scheme.colors;
        }
        colorRampsAndSchemes.push({
            colors,
            scheme
        });
    });
    return colorRampsAndSchemes;
}
function getFillColors(schemes) {
    const allSchemes = _unify(schemes);
    let fillColors = [];
    allSchemes.forEach(function (scheme) {
        if (scheme.colors) {
            fillColors = fillColors.concat(scheme.colors);
        }
    });
    return _removeDuplicates(fillColors);
}
function _unify(schemes) {
    return [schemes.primaryScheme].concat(schemes.secondarySchemes);
}
function _maxSupportedClassBreakColors(colorsForClassBreaks, numClasses) {
    const totalColorsForClassBreaks = colorsForClassBreaks.length;
    let colors = [];
    for (let i = 0; i < totalColorsForClassBreaks; i++) {
        const colorForClassBreaks = colorsForClassBreaks[i];
        if (numClasses < colorForClassBreaks.numClasses) {
            break;
        }
        colors = colorForClassBreaks.colors;
    }
    return colors;
}
function _removeDuplicates(colors) {
    const usedHexColors = {};
    return colors.filter(function (color) {
        const unusedColor = !usedHexColors[color.toHex()];
        if (unusedColor) {
            usedHexColors[color.toHex()] = 1;
        }
        return unusedColor;
    });
}

function getDefaultSymbol(layer, mapView, rendererType) {
    const { modules } = smartMappingState;
    const symbolInfo = modules.typeSchemes.getSchemes({
        theme: "default",
        basemap: getBasemapType(mapView),
        geometryType: getGeometryType(layer)
    }).primaryScheme;
    let defaultSymbol;
    if (isPointType(layer) ||
        (rendererType &&
            [
                "size",
                "color-size",
                "color-age-size",
                "color-size-age",
                "color-age-size-age",
                "type-size",
                "predominance-size",
                "chart-size",
                "relationship-size"
            ].indexOf(rendererType) > -1)) {
        const outlineSym = new modules.SimpleLineSymbol({
            style: "solid",
            color: new modules.esriColor(symbolInfo.outline.color),
            width: symbolInfo.outline.width
        });
        defaultSymbol = new modules.SimpleMarkerSymbol({
            style: "circle",
            size: symbolInfo.size,
            outline: outlineSym,
            color: symbolInfo.noDataColor
        });
    }
    else if (isPolygonType(layer)) {
        const outlineSym = new modules.SimpleLineSymbol({
            style: "solid",
            color: new modules.esriColor(symbolInfo.outline.color),
            width: symbolInfo.outline.width
        });
        defaultSymbol = new modules.SimpleFillSymbol({
            style: "solid",
            outline: outlineSym,
            color: symbolInfo.noDataColor
        });
    }
    else if (isPolylineType(layer)) {
        defaultSymbol = new modules.SimpleLineSymbol({
            style: "solid",
            color: new modules.esriColor(symbolInfo.noDataColor),
            width: symbolInfo.width
        });
    }
    return defaultSymbol;
}
function getGeoRSSDefaultSymbol(mapView, type) {
    const { modules } = smartMappingState;
    const symbolInfo = modules.typeSchemes.getSchemes({
        theme: "default",
        basemap: getBasemapType(mapView),
        geometryType: type === "line" ? "polyline" : type
    }).primaryScheme;
    let defaultSymbol;
    if (type === "point") {
        const outlineSym = new modules.SimpleLineSymbol({
            style: "solid",
            color: new modules.esriColor(symbolInfo.outline.color),
            width: symbolInfo.outline.width
        });
        defaultSymbol = new modules.SimpleMarkerSymbol({
            style: "circle",
            size: symbolInfo.size,
            outline: outlineSym,
            color: symbolInfo.noDataColor
        });
    }
    else if (type === "polygon") {
        const outlineSym = new modules.SimpleLineSymbol({
            style: "solid",
            color: new modules.esriColor(symbolInfo.outline.color),
            width: symbolInfo.outline.width
        });
        defaultSymbol = new modules.SimpleFillSymbol({
            style: "solid",
            outline: outlineSym,
            color: symbolInfo.noDataColor
        });
    }
    else if (type === "line") {
        defaultSymbol = new modules.SimpleLineSymbol({
            style: "solid",
            color: new modules.esriColor(symbolInfo.noDataColor),
            width: symbolInfo.width
        });
    }
    return defaultSymbol;
}
/**
 * to get the default symbol for Raster layers
 */
function getRasterDefaultSymbol() {
    const { modules } = smartMappingState;
    return new modules.SimpleFillSymbol({
        color: [184, 184, 184, 1],
        style: "solid",
        outline: {
            // autocasts as new SimpleLineSymbol()
            color: "white",
            width: 1
        }
    });
}
function isSymbolTransparent(symbol) {
    if (!symbol) {
        return false;
    }
    let isTransparent = false;
    const color = getSymbolColor(symbol);
    if (symbol && symbol.declaredClass === "esri.symbols.SimpleFillSymbol") {
        const outline = symbol.outline;
        if ((!color || color.a === 0) && (!outline || !outline.color || outline.color.a === 0)) {
            isTransparent = true;
        }
    }
    else if (symbol && symbol.declaredClass === "esri.symbols.SimpleLineSymbol") {
        if (!color || color.a === 0) {
            isTransparent = true;
        }
    }
    else if (symbol && symbol.declaredClass === "esri.symbols.SimpleMarkerSymbol") {
        const outline = symbol.outline;
        if ((!color || color.a === 0) && (!outline || !outline.color || outline.color.a === 0)) {
            isTransparent = true;
        }
    }
    return isTransparent;
}
function isSymbolAlmostWhite(symbol) {
    const { modules } = smartMappingState;
    if (symbol) {
        const contrast = modules.previewSymbol2D.getContrastingBackgroundTheme(symbol, 245);
        return contrast === "dark";
    }
    return false;
}
function getSymbolColor(symbol) {
    var _a, _b;
    const { modules } = smartMappingState;
    return (symbol === null || symbol === void 0 ? void 0 : symbol.type) === "cim"
        ? modules.esriColor.fromJSON((_a = modules.cimSymbolUtils.getCIMSymbolColor(symbol)) === null || _a === void 0 ? void 0 : _a.toJSON())
        : (symbol === null || symbol === void 0 ? void 0 : symbol.type) === "simple-marker" && ["x", "cross"].indexOf(symbol === null || symbol === void 0 ? void 0 : symbol.style) > -1
            ? (_b = symbol === null || symbol === void 0 ? void 0 : symbol.outline) === null || _b === void 0 ? void 0 : _b.color
            : symbol === null || symbol === void 0 ? void 0 : symbol.color;
}
function applySymbolColor(sym, color) {
    const { modules } = smartMappingState;
    if (sym.type === "picture-marker") {
        return;
    }
    if (sym.type === "cim") {
        modules.cimSymbolUtils.applyCIMSymbolColor(sym, color);
    }
    else if (sym.type === "simple-marker" && sym.style && ["cross", "x"].indexOf(sym.style) > -1) {
        if (!sym.outline) {
            sym.outline = new __esri.SimpleLineSymbol();
        }
        sym.outline.color = color;
    }
    else {
        sym.color = color;
    }
}
function applyAlpha(color, alpha) {
    if (color) {
        color.a = alpha;
    }
    return color;
}
function getSymbolSize(sym) {
    const { modules } = smartMappingState;
    if (sym.type === "cim") {
        return modules.cimSymbolUtils.getCIMSymbolSize(sym);
    }
    else if (sym.size) {
        return sym.size;
    }
    return sym.width;
}
function applySymbolSize(sym, size) {
    const { modules } = smartMappingState;
    if (sym.type === "cim") {
        // we don't want to change the outline here...
        //const outline = getCimLine(sym);
        //const width = outline?.width;
        // symbol styler doesn't use preserveOutlineWidth, so comparing CIMs is not going to work
        modules.cimSymbolUtils.scaleCIMSymbolTo(sym, size /* , { preserveOutlineWidth: true } */);
        //if (outline && ["CIMPointSymbol", "CIMPolygonSymbol"].indexOf(sym.data.symbol.type) > -1) {
        // set outline width back
        //  outline.width = width;
        //}
    }
    else if ((0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_5__.i)(sym.size)) {
        sym.size = size;
    }
    else {
        const ratio = sym.height / sym.width;
        sym.width = size;
        sym.height = sym.width * ratio;
    }
}
function getCIMOutlineWidth(symbol) {
    var _a, _b;
    // just take first stroke
    const stroke = (_a = symbol.data.symbol.symbolLayers) === null || _a === void 0 ? void 0 : _a.find((symbolLayer) => ["CIMSolidStroke", "CIMPictureStroke"].indexOf(symbolLayer.type) > -1);
    return (_b = stroke === null || stroke === void 0 ? void 0 : stroke.width) !== null && _b !== void 0 ? _b : 0;
}
function getSymbolRotation(sym) {
    const { modules } = smartMappingState;
    if (sym.type === "cim") {
        return modules.cimSymbolUtils.getCIMSymbolRotation(sym, true);
    }
    else if (["simple-marker", "picture-marker"].indexOf(sym.type) > -1) {
        return sym.angle;
    }
    return;
}
function applySymbolRotation(sym, angle) {
    const { modules } = smartMappingState;
    if (angle === null || angle === undefined) {
        return;
    }
    if (sym.type === "cim") {
        modules.cimSymbolUtils.applyCIMSymbolRotation(sym, angle, true);
    }
    else if (["simple-marker", "picture-marker"].indexOf(sym.type) > -1) {
        sym.angle = angle;
    }
}
function hasSymbolOutline(sym) {
    var _a;
    return sym.type === "picture-marker"
        ? false
        : sym.type === "cim"
            ? [/* "CIMPointSymbol", */ "CIMPolygonSymbol"].indexOf(sym.data.symbol.type) > -1 && !!getCimLine(sym)
            : !!((_a = sym.outline) === null || _a === void 0 ? void 0 : _a.color);
}
function switchMarkersToPolygons(renderer, polygonSymbol) {
    var _a, _b;
    if ((_a = renderer.uniqueValueInfos) === null || _a === void 0 ? void 0 : _a.length) {
        const infos = renderer.uniqueValueInfos.slice();
        infos.map((info) => {
            const symbol = polygonSymbol.clone();
            applySymbolColor(symbol, getSymbolColor(info.symbol));
            info.symbol = symbol;
        });
        renderer.uniqueValueInfos = infos;
    }
    else if ((_b = renderer.classBreakInfos) === null || _b === void 0 ? void 0 : _b.length) {
        const infos = renderer.classBreakInfos.slice();
        infos.map((info) => {
            const symbol = polygonSymbol.clone();
            applySymbolColor(symbol, getSymbolColor(info.symbol));
            info.symbol = symbol;
        });
        renderer.classBreakInfos = infos;
    }
    else if (renderer.symbol) {
        const symbol = polygonSymbol.clone();
        applySymbolColor(symbol, getSymbolColor(renderer.symbol));
        renderer.symbol = symbol;
    }
}
function switchPolygonsToMarkers(renderer, markerSymbol) {
    var _a, _b;
    if ((_a = renderer.uniqueValueInfos) === null || _a === void 0 ? void 0 : _a.length) {
        const infos = renderer.uniqueValueInfos.slice();
        infos.map((info) => {
            const symbol = markerSymbol.clone();
            applySymbolColor(symbol, getSymbolColor(info.symbol));
            info.symbol = symbol;
        });
        renderer.uniqueValueInfos = infos;
    }
    else if ((_b = renderer.classBreakInfos) === null || _b === void 0 ? void 0 : _b.length) {
        const infos = renderer.classBreakInfos.slice();
        infos.map((info) => {
            const symbol = markerSymbol.clone();
            applySymbolColor(symbol, getSymbolColor(info.symbol));
            info.symbol = symbol;
        });
        renderer.classBreakInfos = infos;
    }
    else if (renderer.symbol) {
        const symbol = markerSymbol.clone();
        applySymbolColor(symbol, getSymbolColor(renderer.symbol));
        renderer.symbol = symbol;
    }
}
function isCimLineSymbol(sym) {
    var _a;
    return sym.type === "cim" && ((_a = sym.data.symbol) === null || _a === void 0 ? void 0 : _a.type) === "CIMLineSymbol";
}
function getCimLine(sym) {
    var _a, _b, _c;
    if (((_a = sym.data.symbol) === null || _a === void 0 ? void 0 : _a.type) === "CIMPointSymbol") {
        return undefined; //getCimPointOutline(sym);
    }
    else if (((_b = sym.data.symbol) === null || _b === void 0 ? void 0 : _b.type) === "CIMLineSymbol") {
        return getCimLineLine(sym);
    }
    else if (((_c = sym.data.symbol) === null || _c === void 0 ? void 0 : _c.type) === "CIMPolygonSymbol") {
        return getCimPolygonOutline(sym);
    }
}
function getCimLineLine(sym) {
    const symbolLayers = sym.data.symbol.symbolLayers;
    return symbolLayers[0];
}
function getCimPolygonOutline(sym) {
    // we can assume the top stroke layer on polygons is an outline
    const symbolLayers = sym.data.symbol.symbolLayers;
    return symbolLayers.find((sl) => sl.type === "CIMSolidStroke");
}
function isFillOnlyCIM(sym) {
    const { modules } = smartMappingState;
    return !!modules.cimSymbolUtils.getCIMSymbolColor(sym);
}
function layerSupportsCIM() {
    var _a;
    const { mapImageSublayer, layer } = smartMappingState;
    if (mapImageSublayer) {
        return !!((_a = layer.sourceJSON) === null || _a === void 0 ? void 0 : _a.cimVersion);
    }
    return true;
}
/*function hasFill(symbolLayers: any[]): boolean {
  return symbolLayers?.find((sl: any) => sl.type === "CIMSolidFill");
}

function hasUnlockedFill(symbolLayers: any[]): boolean {
  return symbolLayers?.find((sl: any) => sl.type === "CIMSolidFill" && !sl.colorLocked);
}

function hasStroke(symbolLayers: any[]): boolean {
  return symbolLayers?.find((sl: any) => sl.type === "CIMSolidStroke");
}

function hasFillAndStroke(symbolLayers: any[]): boolean {
  return hasFill(symbolLayers) && hasStroke(symbolLayers);
}

function hasUnlockedFillAndStroke(symbolLayers: any[]): boolean {
  return hasUnlockedFill(symbolLayers) && hasStroke(symbolLayers);
} */
function isLineMarker(sym) {
    if (sym.style && ["cross", "x"].indexOf(sym.style) > -1) {
        return true;
    }
    return false;
}
function isPictureMarker(sym) {
    if (sym.type === "picture-marker") {
        return true;
    }
    else if (sym.type === "cim" && !isFillOnlyCIM(sym)) {
        return true;
    }
    return false;
}
function getRenderPreviewSize(symbol) {
    return symbol.type === "simple-line"
        ? {
            width: 12,
            height: 3
        }
        : symbol.type === "cim" && symbol.data.symbol.type === "CIMLineSymbol"
            ? undefined
            : symbol.type === "simple-fill"
                ? 14 /* {
                    width: 12,
                    height: 12
                  } because CIMs still have the non-square shape */
                : symbol.type === "cim" && symbol.data.symbol.type === "CIMPolygonSymbol"
                    ? undefined
                    : symbol.type === "cim"
                        ? 20
                        : 14;
}
function getSymbolChanges(newSym, lastSym) {
    // props only return true if those are the only changes in the symbol
    // { rotation: boolean, size: boolean, color: boolean }
    //console.log("newSym - size", getSymbolSize(newSym), JSON.stringify(newSym.toJSON()));
    //console.log("lastSym - size", getSymbolSize(lastSym), JSON.stringify(lastSym.toJSON()));
    var _a, _b, _c, _d;
    if (newSym.type !== lastSym.type) {
        /* console.log(
          "* getSymbolChanges *",
          "hasRotationChanges:",
          false,
          "hasSizeChanges:",
          false,
          "hasOutlineChanges:",
          false,
          "hasColorChanges:",
          false,
          "hasOtherChanges:",
          true
        ); */
        return {
            hasOtherChanges: true,
            any: true
        };
    }
    const hasRotationChanges = getSymbolRotation(newSym) !== getSymbolRotation(lastSym);
    // consider rounding issues between pt and px conversions
    const hasSizeChanges = Math.abs(getSymbolSize(newSym) - getSymbolSize(lastSym)) > 0.01;
    const hasColorChanges = JSON.stringify((_a = getSymbolColor(newSym)) === null || _a === void 0 ? void 0 : _a.toJSON()) !== JSON.stringify((_b = getSymbolColor(lastSym)) === null || _b === void 0 ? void 0 : _b.toJSON());
    const hasOutlineChanges = ["simple-marker", "simple-fill"].indexOf(newSym.type) > -1
        ? JSON.stringify((_c = newSym.outline) === null || _c === void 0 ? void 0 : _c.toJSON()) !== JSON.stringify((_d = lastSym.outline) === null || _d === void 0 ? void 0 : _d.toJSON())
        : false;
    const tempSym = newSym.clone();
    applySymbolSize(tempSym, getSymbolSize(lastSym));
    applySymbolColor(tempSym, getSymbolColor(lastSym));
    if (["simple-marker", "simple-fill"].indexOf(newSym.type) > -1) {
        tempSym.outline = lastSym.outline.clone();
    }
    applySymbolRotation(tempSym, getSymbolRotation(lastSym));
    //console.log("tempSym - size", getSymbolSize(tempSym), JSON.stringify(tempSym.toJSON()));
    const hasOtherChanges = !isSameSymbol(tempSym, lastSym);
    /* console.log(
      "* getSymbolChanges *",
      "hasRotationChanges:",
      hasRotationChanges,
      "hasSizeChanges:",
      hasSizeChanges,
      "hasOutlineChanges:",
      hasOutlineChanges,
      "hasColorChanges:",
      hasColorChanges,
      "hasOtherChanges:",
      hasOtherChanges
    ); */
    return {
        rotation: hasRotationChanges && !hasSizeChanges && !hasColorChanges && !hasOutlineChanges && !hasOtherChanges,
        size: hasSizeChanges && !hasRotationChanges && !hasColorChanges && !hasOutlineChanges && !hasOtherChanges,
        outline: hasOutlineChanges && !hasRotationChanges && !hasSizeChanges && !hasColorChanges && !hasOtherChanges,
        color: hasColorChanges && !hasRotationChanges && !hasSizeChanges && !hasOutlineChanges && !hasOtherChanges,
        other: hasOtherChanges,
        any: hasRotationChanges || hasSizeChanges || hasOutlineChanges || hasColorChanges || hasOtherChanges
    };
}
function updateSymbol(symbol, fromSymbol, color, symbolChangeInfo) {
    var _a;
    if (symbolChangeInfo.rotation) {
        applySymbolRotation(symbol, getSymbolRotation(fromSymbol));
    }
    else if (symbolChangeInfo.size) {
        applySymbolSize(symbol, getSymbolSize(fromSymbol));
    }
    else if (symbolChangeInfo.color) {
        if (symbol.type === "picture-marker") {
            symbol = fromSymbol.clone();
        }
        applySymbolColor(symbol, color);
    }
    else if (symbolChangeInfo.outline) {
        if (symbol.type === "picture-marker") {
            symbol = fromSymbol.clone();
        }
        else {
            symbol.outline = (_a = fromSymbol.outline) === null || _a === void 0 ? void 0 : _a.clone();
        }
    }
    else {
        // we're changing the entire symbol
        symbol = fromSymbol.clone();
        applySymbolColor(symbol, color);
    }
    return symbol;
}
function isSameSymbol(sym1, sym2) {
    if (JSON.stringify(sym1.toJSON()) === JSON.stringify(sym2.toJSON())) {
        return true;
    }
    else if (sym1.type === "cim" && sym2.type === "cim") {
        // it could just be rounding issues for size and width
        return deepCIMEqual(sym1.toJSON().symbol, sym2.toJSON().symbol);
    }
    return false;
}
function deepCIMEqual(x, y) {
    const ok = Object.keys, tx = typeof x, ty = typeof y;
    if (x && y && tx === "object" && tx === ty) {
        return (ok(x).length === ok(y).length &&
            ok(x).every((key) => {
                if (key === "size" || key === "width") {
                    return Math.abs(x[key] - y[key]) < 0.01;
                }
                else {
                    return deepCIMEqual(x[key], y[key]);
                }
            }));
    }
    else {
        return x === y;
    }
}

function hasVisVar(object, type, target) {
    // target="auto" - means the visual variable for automatic sizing
    const visVars = object && object.visualVariables;
    if (visVars) {
        return visVars.some((visVar) => {
            // SizeVariable has property target
            const visVarTarget = visVar.target;
            const isAutomatic = visVar.valueExpression === "$view.scale";
            return (visVar.type === type &&
                ((!(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_5__.i)(visVarTarget) && !(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_5__.i)(target) && !isAutomatic) ||
                    visVarTarget === target ||
                    (target === "auto" && isAutomatic)));
        });
    }
    return false;
}
function getVisVar(object, type, target) {
    // target="auto" - means the visual variable for automatic sizing
    const visVars = object && object.visualVariables;
    if (visVars) {
        const foundVisVars = visVars.filter((visVar) => {
            const visVarTarget = visVar.target;
            const isAutomatic = visVar.valueExpression === "$view.scale";
            return (visVar.type === type &&
                ((!(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_5__.i)(visVarTarget) && !(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_5__.i)(target) && !isAutomatic) ||
                    visVarTarget === target ||
                    (target === "auto" && isAutomatic && !visVarTarget)));
        });
        if (foundVisVars.length) {
            return foundVisVars[0];
        }
    }
    return undefined;
}
function getAuthVisVar(object, type, target) {
    if (!object.authoringInfo) {
        return undefined;
    }
    const visVars = object && object.authoringInfo && object.authoringInfo.visualVariables;
    if (visVars) {
        const foundVisVars = visVars.filter((visVar) => {
            const visVarTarget = visVar.target;
            return visVar.type === type && ((!(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_5__.i)(visVarTarget) && !(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_5__.i)(target)) || visVarTarget === target);
        });
        if (foundVisVars.length) {
            return foundVisVars[0];
        }
    }
    return undefined;
}
function getVisVarsExcept(object, type, target) {
    // target="auto" - means the visual variable for automatic sizing
    const visVars = object && object.visualVariables;
    if (visVars) {
        const foundVisVars = visVars.filter((visVar) => {
            const visVarTarget = visVar.target;
            const isAutomatic = visVar.valueExpression === "$view.scale";
            return !(visVar.type === type &&
                ((!(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_5__.i)(visVarTarget) && !(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_5__.i)(target) && !isAutomatic) ||
                    visVarTarget === target ||
                    (target === "auto" && isAutomatic)));
        });
        if (foundVisVars.length) {
            return foundVisVars;
        }
    }
    return undefined;
}
function getAuthVisVarsExcept(object, type, target) {
    if (!("authoringInfo" in object) || !object.authoringInfo) {
        return undefined;
    }
    const visVars = object && object.authoringInfo.visualVariables && object.authoringInfo.visualVariables;
    if (visVars) {
        const foundVisVars = visVars.filter((visVar) => {
            const visVarTarget = visVar.target;
            return !(visVar.type === type && ((!(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_5__.i)(visVarTarget) && !(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_5__.i)(target)) || visVarTarget === target));
        });
        if (foundVisVars.length) {
            return foundVisVars;
        }
    }
    return undefined;
}
function removeVisVar(type, layer) {
    if (!("renderer" in layer) || !("visualVariables" in layer.renderer)) {
        return;
    }
    const { renderer } = layer;
    renderer.visualVariables = getVisVarsExcept(renderer, type);
    if ("authoringInfo" in renderer && renderer.authoringInfo) {
        renderer.authoringInfo.visualVariables = getAuthVisVarsExcept(renderer, type);
    }
}
function saveExtraVisVars(renderer) {
    const rendererType = getRendererTypeFromRenderer(renderer);
    const sizeOutlineVisVar = getVisVar(renderer, "size", "outline");
    const sizeAutoVisVar = getVisVar(renderer, "size", "auto");
    const rotationVisVar = getVisVar(renderer, "rotation");
    let opacityVisVar, authOpacityVisVar;
    if (["predominance", "predominance-size"].indexOf(rendererType) === -1) {
        opacityVisVar = getVisVar(renderer, "opacity");
        authOpacityVisVar = getAuthVisVar(renderer, "opacity");
    }
    return {
        sizeOutlineVisVar,
        sizeAutoVisVar,
        opacityVisVar,
        authOpacityVisVar,
        rotationVisVar
    };
}
function applyExtraVisVars(extras, renderer, options) {
    const { sizeOutlineVisVar, opacityVisVar, authOpacityVisVar, rotationVisVar } = extras;
    if (sizeOutlineVisVar) {
        renderer.visualVariables = getVisVarsExcept(renderer, "size", "outline") || [];
        renderer.visualVariables.push(sizeOutlineVisVar);
    }
    if (opacityVisVar && authOpacityVisVar && !(options && options.notOpacity)) {
        renderer.visualVariables = getVisVarsExcept(renderer, "opacity") || [];
        renderer.visualVariables.push(opacityVisVar);
        renderer.authoringInfo = renderer.authoringInfo || {};
        renderer.authoringInfo.visualVariables = getAuthVisVarsExcept(renderer, "opacity") || [];
        renderer.authoringInfo.visualVariables.push(authOpacityVisVar);
    }
    if (rotationVisVar) {
        renderer.visualVariables = renderer.visualVariables || [];
        renderer.visualVariables.push(rotationVisVar);
    }
}

var rgbTypeMap;
(function (rgbTypeMap) {
    rgbTypeMap["NONE"] = "none";
    rgbTypeMap["MINIMUM_MAXIMUM"] = "min-max";
    rgbTypeMap["PERCENT_CLIP"] = "percent-clip";
    rgbTypeMap["STANDARD_DEVIATION"] = "standard-deviation";
    // NOTE: not yet supported
    // HISTOGRAM_EQUALIZE = "histogram-equalization",
    // SIGMOID = "sigmoid",
    // CUSTOM = "custom"
})(rgbTypeMap || (rgbTypeMap = {}));
const rgbDefaults = {
    STD_DEV: 2.0,
    MIN_PERCENT: 2.0,
    MAX_PERCENT: 2.0,
    GAMMA: 1.0,
    STRETCH_TYPE: rgbTypeMap.NONE
};
/**
 * creates an Rgb renderer with default settings
 */
async function createRGBRenderer() {
    const { layer: smLayer, modules } = smartMappingState;
    const layer = smLayer;
    const rasterFunction = layer.type === "imagery" ? layer.rasterFunction : undefined;
    layer.bandIds = await setDefaultRGBBands(layer);
    return modules.RasterRGBCreator.createRenderer({
        layer,
        rasterFunction,
        rgbBandIds: layer.bandIds
    }).then((result) => {
        layer.effect = undefined;
        layer.renderer = result.renderer;
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}
/**
 * Creates an Rgb renderer with some settings from the current renderer
 * @param options: options
 */
function createRgbRendererFromExisting(options) {
    const { layer: smLayer, modules } = smartMappingState;
    const layer = smLayer;
    const renderer = layer.renderer;
    const rasterFunction = layer.type === "imagery" ? layer.rasterFunction : undefined;
    options = options || {};
    return modules.RasterRGBCreator.createRenderer({
        layer,
        rasterFunction,
        rgbBandIds: layer.bandIds,
        stretchType: options.stretchType || renderer.stretchType
    }).then((result) => {
        // save dynamic range adjustment settings
        result.renderer.dynamicRangeAdjustment = renderer.dynamicRangeAdjustment;
        // save old color ramp
        result.renderer.colorRamp = renderer.colorRamp;
        // save old statistics
        result.renderer.statistics = renderer.statistics;
        // handle standard deviation
        if (!isDefined(result.renderer.numberOfStandardDeviations) || result.renderer.numberOfStandardDeviations === 0) {
            result.renderer.numberOfStandardDeviations = rgbDefaults.STD_DEV;
        }
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}
function isRasterRGBRenderer(layer) {
    var _a, _b, _c, _d;
    const isRasterStretchRenderer = ((_a = layer.renderer) === null || _a === void 0 ? void 0 : _a.type) === "raster-stretch";
    if (!isRasterStretchRenderer) {
        return false;
    }
    // checking "> 1" and not "=== 3" for datasets which
    // have just 2 bands but are supported by rgb
    const hasValidBandIds = ((_b = layer.bandIds) === null || _b === void 0 ? void 0 : _b.length) > 1;
    const isMultiband = ((_c = layer.rasterInfo) === null || _c === void 0 ? void 0 : _c.bandCount) > 1;
    const hasValidGammaValue = ((_d = layer.renderer.gamma) === null || _d === void 0 ? void 0 : _d.length) > 1;
    // return true if renderer type is stretch and has bandIds > 1, or
    // return true if renderer type is stretch and isMultiband and has multiple gamma values
    return isRasterStretchRenderer && (hasValidBandIds || (isMultiband && hasValidGammaValue));
}
async function setDefaultRGBBands(layer) {
    var _a;
    const { modules } = smartMappingState;
    const { rasterInfo } = layer;
    const { bandCount } = rasterInfo;
    let defaultBandCombination = await modules.RasterRendererUtils.getDefaultBandCombination({ layer });
    const bandCombinationLength = defaultBandCombination.length;
    if (bandCombinationLength !== bandCount) {
        defaultBandCombination.push(...new Array(3 - bandCombinationLength).fill(bandCount - 1));
    }
    if (((_a = layer.bandIds) === null || _a === void 0 ? void 0 : _a.length) !== 3) {
        layer.bandIds = defaultBandCombination;
    }
    return layer.bandIds;
}

var stretchTypeMap;
(function (stretchTypeMap) {
    stretchTypeMap["NONE"] = "none";
    stretchTypeMap["MINIMUM_MAXIMUM"] = "min-max";
    stretchTypeMap["PERCENT_CLIP"] = "percent-clip";
    stretchTypeMap["STANDARD_DEVIATION"] = "standard-deviation";
    // NOTE: not yet supported
    // HISTOGRAM_EQUALIZE = "histogram-equalization",
    // SIGMOID = "sigmoid",
    // CUSTOM = "custom"
})(stretchTypeMap || (stretchTypeMap = {}));
const stretchDefaults = {
    STD_DEV: 2.0,
    MIN_PERCENT: 2.0,
    MAX_PERCENT: 2.0,
    GAMMA: 1.0,
    BAND_INDEX: 0,
    STRETCH_TYPE: stretchTypeMap.NONE
};
/**
 * creates a Stretch renderer with default settings
 */
function createStretchRenderer() {
    const { layer: smLayer, modules } = smartMappingState;
    const layer = smLayer;
    const rasterFunction = layer.type === "imagery" ? layer.rasterFunction : undefined;
    layer.bandIds = [0];
    return modules.RasterStretchCreator.createRenderer({ layer, rasterFunction }).then((result) => {
        layer.effect = undefined;
        // handles when renderer statistics are stored as an array, not in an object
        const newStatistics = result.renderer.statistics;
        if (Array.isArray(newStatistics) && newStatistics.length > 1) {
            result.renderer.statistics = [
                {
                    min: newStatistics[0],
                    max: newStatistics[1],
                    avg: newStatistics[2],
                    stddev: newStatistics[3]
                }
            ];
        }
        layer.renderer = result.renderer;
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}
/**
 * Creates a Stretch renderer with some settings from the current renderer
 * @param options: options
 */
function createStretchRendererFromExisting(options) {
    const { layer: smLayer, modules } = smartMappingState;
    const layer = smLayer;
    const renderer = layer.renderer;
    const rasterFunction = layer.type === "imagery" ? layer.rasterFunction : undefined;
    options = options || {};
    return modules.RasterStretchCreator.createRenderer({
        layer,
        rasterFunction,
        stretchType: options.stretchType || renderer.stretchType
    }).then((result) => {
        // save dynamic range adjustment settings
        result.renderer.dynamicRangeAdjustment = renderer.dynamicRangeAdjustment;
        // save old color ramp
        result.renderer.colorRamp = renderer.colorRamp;
        // save old statistics
        result.renderer.statistics = renderer.statistics;
        // handle standard deviation
        if (!isDefined(result.renderer.numberOfStandardDeviations) || result.renderer.numberOfStandardDeviations === 0) {
            result.renderer.numberOfStandardDeviations = stretchDefaults.STD_DEV;
        }
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}

/**
 * creates a Unique Value renderer with default settings
 */
async function createUniqueValueRenderer() {
    const { layer: smLayer, modules } = smartMappingState;
    const layer = smLayer;
    const rasterFunction = layer.type === "imagery" ? layer.rasterFunction : undefined;
    return modules.RasterUniqueValueCreator.createRenderer({ layer, rasterFunction });
}
/**
 * Creates a Unique Value renderer with some settings from the current renderer
 * @param options: options
 */
function createUniqueValueRendererFromExisting(options) {
    const { layer: smLayer, modules } = smartMappingState;
    const layer = smLayer;
    const renderer = layer.renderer;
    const rasterFunction = layer.type === "imagery" ? layer.rasterFunction : undefined;
    options = options || {};
    return modules.RasterUniqueValueCreator.createRenderer({
        layer,
        rasterFunction,
        classFieldName: options.field || renderer.field
    }).then((result) => {
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}
function getRasterUniqueValueFields() {
    var _a;
    const { layer: smLayer, modules, strings } = smartMappingState;
    const layer = smLayer;
    let fields;
    const { rasterInfo } = layer;
    const rasterAttributeTableFields = (_a = rasterInfo === null || rasterInfo === void 0 ? void 0 : rasterInfo.attributeTable) === null || _a === void 0 ? void 0 : _a.fields;
    if (rasterAttributeTableFields) {
        fields = rasterAttributeTableFields.filter((field) => field.type !== "oid");
    }
    else {
        fields = [new modules.Field({ name: "value", alias: strings.panels.uniqueValue.value })];
    }
    return fields;
}



//# sourceMappingURL=raster-unique-value-0976ec7f.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fcmFzdGVyLTEwNjI1My5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQzZFOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZUFBZSxpREFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaURBQVc7QUFDdEU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdEQUF3RCxpREFBVztBQUNuRTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSDtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0Qjs7QUFFNUI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUMyRTtBQUNiO0FBQ047O0FBRXhEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtREFBaUM7QUFDbEU7QUFDQTtBQUNBLFFBQVEsd0RBQVc7QUFDbkIsZUFBZSx3REFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFXO0FBQ3ZCLG1CQUFtQix3REFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtREFBaUM7QUFDbEU7QUFDQTtBQUNBLFFBQVEsd0RBQVc7QUFDbkIsZUFBZSx3REFBVztBQUMxQjtBQUNBO0FBQ0EsWUFBWSx3REFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxREFBWSw4QkFBOEIsY0FBYyxRQUFRLE9BQU87QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjLEVBQUUsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZSxHQUFHLGtCQUFrQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEU7O0FBRTVFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dFO0FBQ1E7QUFDckM7QUFDQTtBQUNvQjtBQUNVOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSyxnQ0FBZ0MsS0FBSztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0QixzREFBMkI7QUFDdkQsZ0JBQWdCLDREQUFhO0FBQzdCLHNFQUFzRSxrQkFBa0I7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEMsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYyx5Q0FBeUM7QUFDdkQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQXVEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEVBQTRFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIscURBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtEQUFXLGVBQWUsK0RBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsNkJBQTZCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtEQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBVyxtQkFBbUIsK0RBQVc7QUFDNUQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtEQUFXLG1CQUFtQiwrREFBVztBQUM1RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsK0RBQVcsbUJBQW1CLCtEQUFXO0FBQ3ZGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtEQUFXLG1CQUFtQiwrREFBVztBQUM1RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsK0RBQVcsbUJBQW1CLCtEQUFXO0FBQ3pGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUFzRTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksYUFBYTtBQUN6QixZQUFZLFlBQVk7QUFDeEIsK0ZBQStGLE9BQU87QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EseURBQXlELHVCQUF1QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBLDZEQUE2RCx1QkFBdUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1DQUFtQztBQUMvQztBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0RBQXdEO0FBQzlGO0FBQ0E7QUFDQTs7QUFFeTlFOztBQUV6OUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9pbmRleC0wNTk1NmNhYi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9sb2NhbGUtMDUwYjZkYjkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vcmFzdGVyLXVuaXF1ZS12YWx1ZS0wOTc2ZWM3Zi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGcgYXMgZ2V0UmVuZGVyaW5nUmVmLCBmIGFzIGZvcmNlVXBkYXRlIH0gZnJvbSAnLi9pbmRleC1lM2JmN2RhNy5qcyc7XG5cbmNvbnN0IGFwcGVuZFRvTWFwID0gKG1hcCwgcHJvcE5hbWUsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgaXRlbXMgPSBtYXAuZ2V0KHByb3BOYW1lKTtcbiAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICAgIG1hcC5zZXQocHJvcE5hbWUsIFt2YWx1ZV0pO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXRlbXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIGl0ZW1zLnB1c2godmFsdWUpO1xuICAgIH1cbn07XG5jb25zdCBkZWJvdW5jZSA9IChmbiwgbXMpID0+IHtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IDA7XG4gICAgICAgICAgICBmbiguLi5hcmdzKTtcbiAgICAgICAgfSwgbXMpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgcG9zc2libGUgZWxlbWVudCBpc0Nvbm5lY3RlZC5cbiAqIFRoZSBwcm9wZXJ0eSBtaWdodCBub3QgYmUgdGhlcmUsIHNvIHdlIGNoZWNrIGZvciBpdC5cbiAqXG4gKiBXZSB3YW50IGl0IHRvIHJldHVybiB0cnVlIGlmIGlzQ29ubmVjdGVkIGlzIG5vdCBhIHByb3BlcnR5LFxuICogb3RoZXJ3aXNlIHdlIHdvdWxkIHJlbW92ZSB0aGVzZSBlbGVtZW50cyBhbmQgd291bGQgbm90IHVwZGF0ZS5cbiAqXG4gKiBCZXR0ZXIgbGVhayBpbiBFZGdlIHRoYW4gdG8gYmUgdXNlbGVzcy5cbiAqL1xuY29uc3QgaXNDb25uZWN0ZWQgPSAobWF5YmVFbGVtZW50KSA9PiAhKCdpc0Nvbm5lY3RlZCcgaW4gbWF5YmVFbGVtZW50KSB8fCBtYXliZUVsZW1lbnQuaXNDb25uZWN0ZWQ7XG5jb25zdCBjbGVhbnVwRWxlbWVudHMgPSBkZWJvdW5jZSgobWFwKSA9PiB7XG4gICAgZm9yIChsZXQga2V5IG9mIG1hcC5rZXlzKCkpIHtcbiAgICAgICAgbWFwLnNldChrZXksIG1hcC5nZXQoa2V5KS5maWx0ZXIoaXNDb25uZWN0ZWQpKTtcbiAgICB9XG59LCAyMDAwKTtcbmNvbnN0IHN0ZW5jaWxTdWJzY3JpcHRpb24gPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnZXRSZW5kZXJpbmdSZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBpbiBhIHN0ZW5jaWwgcHJvamVjdCwgd2UgZG8gbm90aGluZy5cbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVhbGx5IGV4cG9ydGVkIGJ5IEBzdGVuY2lsL2NvcmUuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgZWxtc1RvVXBkYXRlID0gbmV3IE1hcCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3Bvc2U6ICgpID0+IGVsbXNUb1VwZGF0ZS5jbGVhcigpLFxuICAgICAgICBnZXQ6IChwcm9wTmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxtID0gZ2V0UmVuZGVyaW5nUmVmKCk7XG4gICAgICAgICAgICBpZiAoZWxtKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kVG9NYXAoZWxtc1RvVXBkYXRlLCBwcm9wTmFtZSwgZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiAocHJvcE5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZWxtc1RvVXBkYXRlLmdldChwcm9wTmFtZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBlbG1zVG9VcGRhdGUuc2V0KHByb3BOYW1lLCBlbGVtZW50cy5maWx0ZXIoZm9yY2VVcGRhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFudXBFbGVtZW50cyhlbG1zVG9VcGRhdGUpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICAgICAgZWxtc1RvVXBkYXRlLmZvckVhY2goKGVsbXMpID0+IGVsbXMuZm9yRWFjaChmb3JjZVVwZGF0ZSkpO1xuICAgICAgICAgICAgY2xlYW51cEVsZW1lbnRzKGVsbXNUb1VwZGF0ZSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbmNvbnN0IHVud3JhcCA9ICh2YWwpID0+ICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nID8gdmFsKCkgOiB2YWwpO1xuY29uc3QgY3JlYXRlT2JzZXJ2YWJsZU1hcCA9IChkZWZhdWx0U3RhdGUsIHNob3VsZFVwZGF0ZSA9IChhLCBiKSA9PiBhICE9PSBiKSA9PiB7XG4gICAgY29uc3QgdW53cmFwcGVkU3RhdGUgPSB1bndyYXAoZGVmYXVsdFN0YXRlKTtcbiAgICBsZXQgc3RhdGVzID0gbmV3IE1hcChPYmplY3QuZW50cmllcyh1bndyYXBwZWRTdGF0ZSAhPT0gbnVsbCAmJiB1bndyYXBwZWRTdGF0ZSAhPT0gdm9pZCAwID8gdW53cmFwcGVkU3RhdGUgOiB7fSkpO1xuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgICBkaXNwb3NlOiBbXSxcbiAgICAgICAgZ2V0OiBbXSxcbiAgICAgICAgc2V0OiBbXSxcbiAgICAgICAgcmVzZXQ6IFtdLFxuICAgIH07XG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gV2hlbiByZXNldHRpbmcgdGhlIHN0YXRlLCB0aGUgZGVmYXVsdCBzdGF0ZSBtYXkgYmUgYSBmdW5jdGlvbiAtIHVud3JhcCBpdCB0byBpbnZva2UgaXQuXG4gICAgICAgIC8vIG90aGVyd2lzZSwgdGhlIHN0YXRlIHdvbid0IGJlIHByb3Blcmx5IHJlc2V0XG4gICAgICAgIHN0YXRlcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoKF9hID0gdW53cmFwKGRlZmF1bHRTdGF0ZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KSk7XG4gICAgICAgIGhhbmRsZXJzLnJlc2V0LmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICB9O1xuICAgIGNvbnN0IGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICAgIC8vIENhbGwgZmlyc3QgZGlzcG9zZSBhcyByZXNldHRpbmcgdGhlIHN0YXRlIHdvdWxkXG4gICAgICAgIC8vIGNhdXNlIGxlc3MgdXBkYXRlcyA7KVxuICAgICAgICBoYW5kbGVycy5kaXNwb3NlLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldCA9IChwcm9wTmFtZSkgPT4ge1xuICAgICAgICBoYW5kbGVycy5nZXQuZm9yRWFjaCgoY2IpID0+IGNiKHByb3BOYW1lKSk7XG4gICAgICAgIHJldHVybiBzdGF0ZXMuZ2V0KHByb3BOYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldCA9IChwcm9wTmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBzdGF0ZXMuZ2V0KHByb3BOYW1lKTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSh2YWx1ZSwgb2xkVmFsdWUsIHByb3BOYW1lKSkge1xuICAgICAgICAgICAgc3RhdGVzLnNldChwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgaGFuZGxlcnMuc2V0LmZvckVhY2goKGNiKSA9PiBjYihwcm9wTmFtZSwgdmFsdWUsIG9sZFZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHN0YXRlID0gKHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyB7fVxuICAgICAgICA6IG5ldyBQcm94eSh1bndyYXBwZWRTdGF0ZSwge1xuICAgICAgICAgICAgZ2V0KF8sIHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldChwcm9wTmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3duS2V5cyhfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oc3RhdGVzLmtleXMoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhcyhfLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZXMuaGFzKHByb3BOYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQoXywgcHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2V0KHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgY29uc3Qgb24gPSAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBoYW5kbGVyc1tldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KGhhbmRsZXJzW2V2ZW50TmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IG9uQ2hhbmdlID0gKHByb3BOYW1lLCBjYikgPT4ge1xuICAgICAgICBjb25zdCB1blNldCA9IG9uKCdzZXQnLCAoa2V5LCBuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYihuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHVud3JhcCB0aGUgZGVmYXVsdFN0YXRlIGJlY2F1c2UgaXQgbWlnaHQgYmUgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG1pZ2h0IG5vdCBiZSBzZW5kaW5nIHRoZSByaWdodCByZXNldCB2YWx1ZS5cbiAgICAgICAgY29uc3QgdW5SZXNldCA9IG9uKCdyZXNldCcsICgpID0+IGNiKHVud3JhcChkZWZhdWx0U3RhdGUpW3Byb3BOYW1lXSkpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdW5TZXQoKTtcbiAgICAgICAgICAgIHVuUmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHVzZSA9ICguLi5zdWJzY3JpcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuc3VicyA9IHN1YnNjcmlwdGlvbnMucmVkdWNlKCh1bnN1YnMsIHN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5zZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbignc2V0Jywgc3Vic2NyaXB0aW9uLnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5nZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbignZ2V0Jywgc3Vic2NyaXB0aW9uLmdldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5yZXNldCkge1xuICAgICAgICAgICAgICAgIHVuc3Vicy5wdXNoKG9uKCdyZXNldCcsIHN1YnNjcmlwdGlvbi5yZXNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5kaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzLnB1c2gob24oJ2Rpc3Bvc2UnLCBzdWJzY3JpcHRpb24uZGlzcG9zZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuc3VicztcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gKCkgPT4gdW5zdWJzLmZvckVhY2goKHVuc3ViKSA9PiB1bnN1YigpKTtcbiAgICB9O1xuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHN0YXRlcy5nZXQoa2V5KTtcbiAgICAgICAgaGFuZGxlcnMuc2V0LmZvckVhY2goKGNiKSA9PiBjYihrZXksIG9sZFZhbHVlLCBvbGRWYWx1ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGdldCxcbiAgICAgICAgc2V0LFxuICAgICAgICBvbixcbiAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgIHVzZSxcbiAgICAgICAgZGlzcG9zZSxcbiAgICAgICAgcmVzZXQsXG4gICAgICAgIGZvcmNlVXBkYXRlLFxuICAgIH07XG59O1xuY29uc3QgcmVtb3ZlRnJvbUFycmF5ID0gKGFycmF5LCBpdGVtKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBhcnJheS5sZW5ndGgtLTtcbiAgICB9XG59O1xuXG5jb25zdCBjcmVhdGVTdG9yZSA9IChkZWZhdWx0U3RhdGUsIHNob3VsZFVwZGF0ZSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGNyZWF0ZU9ic2VydmFibGVNYXAoZGVmYXVsdFN0YXRlLCBzaG91bGRVcGRhdGUpO1xuICAgIG1hcC51c2Uoc3RlbmNpbFN1YnNjcmlwdGlvbigpKTtcbiAgICByZXR1cm4gbWFwO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlU3RvcmUgYXMgYyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC0wNTk1NmNhYi5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGMgYXMgY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5IH0gZnJvbSAnLi9kb20tNGQzNjc2NzcuanMnO1xuaW1wb3J0IHsgbCBhcyBsYW5ndWFnZU1hcCB9IGZyb20gJy4vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzJztcbmltcG9ydCB7IGEgYXMgZ2V0QXNzZXRQYXRoIH0gZnJvbSAnLi9pbmRleC1lM2JmN2RhNy5qcyc7XG5cbi8vIGh0dHBzOi8vbWVkaXVtLmNvbS9zdGVuY2lsLXRyaWNrcy9pbXBsZW1lbnRpbmctaW50ZXJuYXRpb25hbGlzYXRpb24taTE4bi13aXRoLXN0ZW5jaWwtNWU2NTU5NTU0MTE3XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICAgIGNvbnN0IGxhbmcgPSAoKGNsb3Nlc3RFbGVtZW50ID09PSBudWxsIHx8IGNsb3Nlc3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXN0RWxlbWVudC5sYW5nKSB8fCAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gXCJydS1SVVwiIG1hcHMgdG8gXCJydVwiIHVzZSBjYXNlXG4gICAgICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZy5zbGljZSgwLCAyKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZy5zbGljZSgwLCAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJlblwiO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgLy8gaXQncyBPSyBpZiB3ZSBkb24ndCBoYXZlIHRoZSA0IGxldHRlciBsYW5ndWFnZSBmaWxlIGZvciBpdFxuICAgIC8vIDQgbGV0dGVyIGxhbmd1YWdlIGNvZGUgbmVlZGVkIGZvciBmb3JtYXR0aW5nIG51bWJlcnNcbiAgICBjb25zdCBjbG9zZXN0RWxlbWVudCA9IChfYSA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbGVtZW50LCBcIltsYW5nXVwiKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9jID0gKF9iID0gZWxlbWVudC5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAvLyBsYW5ndWFnZSBzZXQgYnkgdGhlIGNhbGxpbmcgYXBwbGljYXRpb24gb3IgYnJvd3Nlci4gZGVmYXVsdHMgdG8gZW5nbGlzaC5cbiAgICBjb25zdCBsYW5nID0gKChjbG9zZXN0RWxlbWVudCA9PT0gbnVsbCB8fCBjbG9zZXN0RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VzdEVsZW1lbnQubGFuZykgfHwgKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlblwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZykpIHtcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZy5zbGljZSgwLCAyKSkpIHtcbiAgICAgICAgICAgIC8vIHdlIHN1cHBvcnQgdGhlIDIgbGV0dGVyIGNvZGVkIGxhbmd1YWdlXG4gICAgICAgICAgICAvLyBlLmcuIGl0LUNIIHZzIGl0XG4gICAgICAgICAgICByZXR1cm4gbGFuZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcImVuXCI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmZXRjaExvY2FsZVN0cmluZ3NGb3JDb21wb25lbnQoY29tcG9uZW50TmFtZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZmV0Y2goZ2V0QXNzZXRQYXRoKGAuLi9hcmNnaXMtYXBwLWFzc2V0cy9pMThuLyR7Y29tcG9uZW50TmFtZX0uaTE4bi4ke2xvY2FsZX0uanNvbmApKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQub2spXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQuanNvbigpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfSwgKCkgPT4gcmVqZWN0KCkpO1xuICAgIH0pO1xufVxuY29uc3Qgc3RyaW5nQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgICBjb25zdCBpZCA9IGAke2NvbXBvbmVudE5hbWV9JHtsb2NhbGV9YDtcbiAgICBpZiAoIXN0cmluZ0NhY2hlW2lkXSkge1xuICAgICAgICBzdHJpbmdDYWNoZVtpZF0gPSBmZXRjaExvY2FsZVN0cmluZ3NGb3JDb21wb25lbnQoY29tcG9uZW50TmFtZSwgbG9jYWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ0NhY2hlW2lkXTtcbn1cbi8qKlxuICogR2V0IHN0cmluZ3MgYW5kIGxhbmd1YWdlIGNvZGVzLlxuICogVGhpcyBtZXRob2QgcmV0dXJucyAyIGxhbmd1YWdlIGNvZGVzLlxuICogVGhlIGZpcnN0IG9uZSByZXR1cm5zIGEgY29kZSB0aGF0J3MgYWxzbyBzdXBwb3J0ZWQgYXMgYSBsYW5ndWFnZSBmaWxlLlxuICogVGhlIHNlY29uZCBvbmUgcmV0dXJucyBhIGNvZGUgd2hlcmUgdGhlcmUgaXMgc3VwcG9ydCBmb3IgdGhlIGZpcnN0IDIgbGV0dGVycyBvZiB0aGUgY29kZSBhcyBwYXJ0IG9mIGEgbGFuZ3VhZ2UgZmlsZSxcbiAqIGJ1dCB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgNCBsZXR0ZXIgY29kZSBmcm9tIHRoZSBwYWdlLlxuICogRS5nLiBGb3IgXCJpdC1jaFwiIGl0IHdpbGwgcmV0dXJuIFwiaXRcIiBhcyB0aGUgZmlyc3QgbGFuZ3VhZ2UgY29kZSBhbmQgXCJpdC1jaFwiIGFzIHRoZSBzZWNvbmQuXG4gKiBUaGUgc2Vjb25kIG9uZSBpcyByZXF1aXJlZCBmb3IgZXNyaS5pbnRsLnNldExvY2FsZSgpIHRvIGdldCB0aGUgY29ycmVjdCBmb3JtYXR0aW5nLlxuICpcbiAqIElmIGEgdGFnTmFtZSBpcyBwcm92aWRlZCBpdCB3aWxsIG92ZXJ3aXRlIHRoZSBlbGVtZW50J3MgdGFnTmFtZVxuICpcbiAqICBAcmV0dXJuIFsgc3RyaW5ncywgZmlyc3QgbGFuZ3VhZ2UgY29kZSwgc2Vjb25kIGxhbmd1YWdlIGNvZGVdXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MoZWxlbWVudCwgdGFnTmFtZSkge1xuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSB0YWdOYW1lIHx8IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGNvbXBvbmVudExhbmd1YWdlID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlKGVsZW1lbnQpO1xuICAgIGNvbnN0IGNvbXBvbmVudExhbmd1YWdlSW50bCA9IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZUludGwoZWxlbWVudCk7XG4gICAgbGV0IHN0cmluZ3M7XG4gICAgdHJ5IHtcbiAgICAgICAgc3RyaW5ncyA9IGF3YWl0IGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBjb21wb25lbnRMYW5ndWFnZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihgbm8gbG9jYWxlIGZvciAke2NvbXBvbmVudE5hbWV9ICgke2NvbXBvbmVudExhbmd1YWdlfSkgbG9hZGluZyBkZWZhdWx0IGxvY2FsZSBlbi5gKTtcbiAgICAgICAgc3RyaW5ncyA9IGF3YWl0IGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBcImVuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gW3N0cmluZ3MsIGNvbXBvbmVudExhbmd1YWdlLCBjb21wb25lbnRMYW5ndWFnZUludGxdO1xufVxuXG5leHBvcnQgeyBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UgYXMgYSwgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyBhcyBnIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsZS0wNTBiNmRiOS5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGcgYXMgZ2V0RWxlbWVudERpciB9IGZyb20gJy4vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzJztcbmltcG9ydCB7IGEgYXMgZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlIH0gZnJvbSAnLi9sb2NhbGUtMDUwYjZkYjkuanMnO1xuaW1wb3J0ICcuL2xvYWRNb2R1bGVzLWI0YWMxMjQ3LmpzJztcbmltcG9ydCAnLi9jb21tb25FbnVtcy1mY2YxMzY2MS5qcyc7XG5pbXBvcnQgeyBjIGFzIGNyZWF0ZVN0b3JlIH0gZnJvbSAnLi9pbmRleC0wNTk1NmNhYi5qcyc7XG5pbXBvcnQgeyBpIGFzIGlzRGVmaW5lZCQxIH0gZnJvbSAnLi9jb21tb25GdW5jdGlvbnMtYjA4MzBlOWUuanMnO1xuXG52YXIgc3RhdHVzO1xuKGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICBzdGF0dXNbXCJNSVNTSU5HXCJdID0gXCJtaXNzaW5nXCI7XG4gICAgc3RhdHVzW1wiSU5fUFJPR1JFU1NcIl0gPSBcImluUHJvZ3Jlc3NcIjtcbiAgICBzdGF0dXNbXCJTVUNDRVNTXCJdID0gXCJzdWNjZXNzXCI7XG4gICAgc3RhdHVzW1wiRkFJTEVEXCJdID0gXCJmYWlsZWRcIjtcbn0pKHN0YXR1cyB8fCAoc3RhdHVzID0ge30pKTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaW4gcXVlc3Rpb24gaXMgZW1wdHlcbiAqIEBwYXJhbSBpbnB1dCAtIG9iamVjdCB0byBkZXRlcm1pbmUgaWYgZW1wdHlcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eShpbnB1dCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhpbnB1dCkubGVuZ3RoID09PSAwICYmIGlucHV0LmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5mdW5jdGlvbiBjbG9zZVBvcG92ZXJzKCkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYWxjaXRlLXBvcG92ZXJcIikuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBsZXQgcmVtb3ZlID0gZmFsc2U7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LmZvckVhY2goKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZS5zdGFydHNXaXRoKFwic21hcnQtbWFwcGluZy1cIikgJiYgY2xhc3NOYW1lLmVuZHNXaXRoKFwiLXBvcG92ZXJcIikpIHtcbiAgICAgICAgICAgICAgICByZW1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJvcGVuXCIsIFwiZmFsc2VcIik7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgcGFyZW50Tm9kZSA9PT0gbnVsbCB8fCBwYXJlbnROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZG9jdW1lbnRcbiAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhcmNnaXMtc21hcnQtbWFwcGluZy1zdHlsZXItcG9wb3ZlciwgYXJjZ2lzLXNtYXJ0LW1hcHBpbmctaW5mby1wb3BvdmVyXCIpXG4gICAgICAgIC5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gbm9kZS5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBwYXJlbnQgZWxlbWVudCB3aXRoIHRoYXQgdGFnIG5hbWUgb3IgY2xhc3MgbmFtZVxuICogQHBhcmFtIG5vZGUgLSBzdGFydGluZyBub2RlXG4gKiBAcGFyYW0gdGFnTmFtZSAtIHRhZyBuYW1lIHRvIGZpbmQgdXAgdGhlIHRyZWVcbiAqIEBwYXJhbSBjbGFzc05hbWUgLSBjbGFzcyBuYW1lIHRvIGZpbmQgdXAgdGhlIHRyZWVcbiAqL1xuZnVuY3Rpb24gZmluZFBhcmVudE5vZGUobm9kZSwgdGFnTmFtZSwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKCh0YWdOYW1lICYmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUudGFnTmFtZSkgPT09IHRhZ05hbWUudG9VcHBlckNhc2UoKSkgfHwgKGNsYXNzTmFtZSAmJiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgcGFyZW50Tm9kZSA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICB3aGlsZSAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgaWYgKCh0YWdOYW1lICYmIHBhcmVudE5vZGUudGFnTmFtZSA9PT0gdGFnTmFtZS50b1VwcGVyQ2FzZSgpKSB8fFxuICAgICAgICAgICAgICAgIChjbGFzc05hbWUgJiYgcGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudE5vZGUudGFnTmFtZSA9PT0gXCJCT0RZXCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufVxuLyogb2xkICovXG5mdW5jdGlvbiBmaW5kUGFyZW50UGFuZWwobm9kZSkge1xuICAgIGlmICgobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnRhZ05hbWUpID09PSBcIkNBTENJVEUtUEFORUxcIikge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS50YWdOYW1lKSA9PT0gXCJDQUxDSVRFLUZMT1ctSVRFTVwiKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgd2hpbGUgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlLnRhZ05hbWUgPT09IFwiQ0FMQ0lURS1QQU5FTFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnROb2RlLnRhZ05hbWUgPT09IFwiQ0FMQ0lURS1GTE9XLUlURU1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG59XG4vKiBvbGQgKi9cbmZ1bmN0aW9uIGRpc2FibGVQYW5lbChub2RlLCBkaXNhYmxlKSB7XG4gICAgY29uc3QgcGFyZW50UGFuZWwgPSBmaW5kUGFyZW50UGFuZWwobm9kZSk7XG4gICAgaWYgKHBhcmVudFBhbmVsKSB7XG4gICAgICAgIHBhcmVudFBhbmVsLmRpc2FibGVkID0gZGlzYWJsZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1RvcEZsb3dJdGVtKG5vZGUpIHtcbiAgICBsZXQgcGFyZW50Tm9kZSA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIGlmICgocGFyZW50Tm9kZSA9PT0gbnVsbCB8fCBwYXJlbnROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnROb2RlLnRhZ05hbWUpID09PSBcIkNBTENJVEUtRkxPV1wiKSB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHBhcmVudE5vZGUuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE5vZGUsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSAwO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhZGRTbWFydE1hcHBpbmdUb29sdGlwV2l0aElkKHRvb2x0aXBQYXJlbnROb2RlLCBsYWJlbCwgaWQsIG9wZW4gPSB0cnVlKSB7XG4gICAgbGV0IG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9XG4gICAgY29uc3QgdG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYWxjaXRlLXRvb2x0aXBcIik7XG4gICAgdG9vbHRpcC5jbGFzc05hbWUgPSBcInNtYXJ0LW1hcHBpbmctdG9vbHRpcFwiO1xuICAgIHRvb2x0aXAuaWQgPSBpZDtcbiAgICB0b29sdGlwLnJlZmVyZW5jZUVsZW1lbnQgPSB0b29sdGlwUGFyZW50Tm9kZTtcbiAgICB0b29sdGlwLm9wZW4gPSBvcGVuO1xuICAgIHRvb2x0aXAuaW5uZXJIVE1MID0gbGFiZWw7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmQodG9vbHRpcCk7XG59XG5mdW5jdGlvbiBhZGRTbWFydE1hcHBpbmdUb29sdGlwKHRvb2x0aXBQYXJlbnROb2RlLCBsYWJlbCwgb3BlbiA9IHRydWUpIHtcbiAgICBjb25zdCB0b29sdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbGNpdGUtdG9vbHRpcFwiKTtcbiAgICB0b29sdGlwLmNsYXNzTmFtZSA9IFwic21hcnQtbWFwcGluZy10b29sdGlwXCI7XG4gICAgdG9vbHRpcC5yZWZlcmVuY2VFbGVtZW50ID0gdG9vbHRpcFBhcmVudE5vZGU7XG4gICAgdG9vbHRpcC5vcGVuID0gb3BlbjtcbiAgICB0b29sdGlwLmlubmVySFRNTCA9IGxhYmVsO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKHRvb2x0aXApO1xufVxuZnVuY3Rpb24gcmVtb3ZlU21hcnRNYXBwaW5nVG9vbHRpcCgpIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnNtYXJ0LW1hcHBpbmctdG9vbHRpcFwiKS5mb3JFYWNoKCh0b29sdGlwKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdG9vbHRpcC5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQ2hpbGQodG9vbHRpcCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZW1vdmVTbWFydE1hcHBpbmdUb29sdGlwQnlJZChpZCkge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgaWYgKChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUuY2xhc3NOYW1lKSA9PT0gXCJzbWFydC1tYXBwaW5nLXRvb2x0aXBcIiAmJiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnBhcmVudE5vZGUpKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1pbk1heChvYmopIHtcbiAgICBpZiAob2JqLm1pbiA9PT0gb2JqLm1heCAmJiBpc0RlZmluZWQob2JqLm1pbikpIHtcbiAgICAgICAgaWYgKG9iai5taW4gPiAwKSB7XG4gICAgICAgICAgICBvYmoubWluID0gMDtcbiAgICAgICAgICAgIG9iai5tYXggPSBvYmoubWF4ICogMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmoubWluIDwgMCkge1xuICAgICAgICAgICAgb2JqLm1pbiA9IG9iai5taW4gKiAyO1xuICAgICAgICAgICAgb2JqLm1heCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoubWluID0gLTEwO1xuICAgICAgICAgICAgb2JqLm1heCA9IDEwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBnZXRHZW9tZXRyeVR5cGUobGF5ZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKFwiZmVhdHVyZVJlZHVjdGlvblwiIGluIGxheWVyICYmICgoX2EgPSBsYXllci5mZWF0dXJlUmVkdWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IFwiYmlubmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBcInBvbHlnb25cIjtcbiAgICB9XG4gICAgcmV0dXJuIGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeVwiIHx8IGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeS10aWxlXCJcbiAgICAgICAgPyBcInBvbHlnb25cIlxuICAgICAgICA6IGxheWVyLnR5cGUgPT09IFwiZ2VvLXJzc1wiXG4gICAgICAgICAgICA/IFwicG9pbnRcIlxuICAgICAgICAgICAgOiBsYXllci5nZW9tZXRyeVR5cGU7XG59XG5mdW5jdGlvbiBpc1BvaW50VHlwZShsYXllcikge1xuICAgIGNvbnN0IGlzU3RyZWFtTGF5ZXIgPSBsYXllci50eXBlID09PSBcInN0cmVhbVwiO1xuICAgIHJldHVybiBpc1N0cmVhbUxheWVyIHx8IGdldEdlb21ldHJ5VHlwZShsYXllcikgPT09IFwicG9pbnRcIiB8fCBnZXRHZW9tZXRyeVR5cGUobGF5ZXIpID09PSBcIm11bHRpcG9pbnRcIjtcbn1cbmZ1bmN0aW9uIGlzUG9seWdvblR5cGUobGF5ZXIpIHtcbiAgICBjb25zdCBpc1N0cmVhbUxheWVyID0gbGF5ZXIudHlwZSA9PT0gXCJzdHJlYW1cIjtcbiAgICByZXR1cm4gIWlzU3RyZWFtTGF5ZXIgJiYgZ2V0R2VvbWV0cnlUeXBlKGxheWVyKSA9PT0gXCJwb2x5Z29uXCI7XG59XG5mdW5jdGlvbiBpc1BvbHlsaW5lVHlwZShsYXllcikge1xuICAgIGNvbnN0IGlzU3RyZWFtTGF5ZXIgPSBsYXllci50eXBlID09PSBcInN0cmVhbVwiO1xuICAgIHJldHVybiAhaXNTdHJlYW1MYXllciAmJiBnZXRHZW9tZXRyeVR5cGUobGF5ZXIpID09PSBcInBvbHlsaW5lXCI7XG59XG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHREYXRhUmFuZ2UoZmllbGRJbmZvKSB7XG4gICAgaWYgKGZpZWxkSW5mby5zaW1wbGVGaWVsZFR5cGUgPT09IHNpbXBsZUZpZWxkVHlwZXMuREFURSkge1xuICAgICAgICBjb25zdCB5ZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuICAgICAgICByZXR1cm4gW25ldyBEYXRlKGAxLzEvJHt5ZWFyfWApLmdldFRpbWUoKSwgbmV3IERhdGUoYDEyLzMxLyR7eWVhcn1gKS5nZXRUaW1lKCldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFswLCAxMDBdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KG5vZGUpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiBcInNtb290aFwiLFxuICAgICAgICAgICAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIixcbiAgICAgICAgICAgICAgICBpbmxpbmU6IFwic3RhcnRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyZWZveC9TYWZhcmkgYnVnXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3Qgc2hlbGxOb2RlID0gKF9hID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjYWxjaXRlLXNoZWxsXCIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF07XG4gICAgICAgICAgICBpZiAoc2hlbGxOb2RlKSB7XG4gICAgICAgICAgICAgICAgc2hlbGxOb2RlLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfSwgMTAwKTtcbn1cbmZ1bmN0aW9uIGdldFBlcmNlbnRMYWJlbEZsaXAoZWxlbWVudCkge1xuICAgIGNvbnN0IGN1cnJlbnRMYW5ndWFnZSA9IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZShlbGVtZW50KTtcbiAgICBjb25zdCBkaXIgPSBnZXRFbGVtZW50RGlyKGVsZW1lbnQpO1xuICAgIGNvbnN0IHBlcmNlbnRGb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQoY3VycmVudExhbmd1YWdlLCB7IHN0eWxlOiBcInBlcmNlbnRcIiB9KTtcbiAgICBjb25zdCBwZXJjZW50Rm9ybWF0U2FtcGxlID0gcGVyY2VudEZvcm1hdHRlci5mb3JtYXQoMCk7XG4gICAgY29uc3QgcGVyY2VudExhYmVsRmxpcCA9IGRpciA9PT0gXCJydGxcIiA/IHBlcmNlbnRGb3JtYXRTYW1wbGUuZW5kc1dpdGgoXCIlXCIpIDogcGVyY2VudEZvcm1hdFNhbXBsZS5zdGFydHNXaXRoKFwiJVwiKTtcbiAgICByZXR1cm4gcGVyY2VudExhYmVsRmxpcDtcbn1cblxudmFyIHNpbXBsZUZpZWxkVHlwZXM7XG4oZnVuY3Rpb24gKHNpbXBsZUZpZWxkVHlwZXMpIHtcbiAgICBzaW1wbGVGaWVsZFR5cGVzW1wiTlVNQkVSXCJdID0gXCJudW1iZXJcIjtcbiAgICBzaW1wbGVGaWVsZFR5cGVzW1wiU1RSSU5HXCJdID0gXCJzdHJpbmdcIjtcbiAgICBzaW1wbGVGaWVsZFR5cGVzW1wiREFURVwiXSA9IFwiZGF0ZVwiO1xuICAgIHNpbXBsZUZpZWxkVHlwZXNbXCJPSURcIl0gPSBcIm9pZFwiO1xuICAgIHNpbXBsZUZpZWxkVHlwZXNbXCJHVUlEXCJdID0gXCJndWlkXCI7XG4gICAgc2ltcGxlRmllbGRUeXBlc1tcIlVOS05PV05cIl0gPSBcInVua25vd25cIjtcbn0pKHNpbXBsZUZpZWxkVHlwZXMgfHwgKHNpbXBsZUZpZWxkVHlwZXMgPSB7fSkpO1xubGV0IGV4Y2x1ZGVkRmllbGRzID0gW1xuICAgIFwiaWRcIixcbiAgICBcImZpcHNcIixcbiAgICBcImZpZFwiLFxuICAgIFwib2JqZWN0aWRcIixcbiAgICBcIl9vYmplY3RpZFwiLFxuICAgIFwiX19vYmplY3RpZFwiLFxuICAgIFwieFwiLFxuICAgIFwieVwiLFxuICAgIFwibGF0XCIsXG4gICAgXCJsb25nXCIsXG4gICAgXCJsYXRpdHVkZVwiLFxuICAgIFwibG9uZ2l0dWRlXCIsXG4gICAgXCJzaGFwZVwiLFxuICAgIFwic2hhcGVfbGVuZ3RoXCIsXG4gICAgXCJzaGFwZV9sZW5nXCIsXG4gICAgXCJzaGFwZV9hcmVhXCIsXG4gICAgXCJwZXJpbWV0ZXJcIixcbiAgICBcInN0cmV0Y2hlZF92YWx1ZVwiLFxuICAgIFwiZm5vZGVfXCIsXG4gICAgXCJ0bm9kZV9cIixcbiAgICBcImxwb2x5X1wiLFxuICAgIFwicnBvbHlfXCIsXG4gICAgXCJwb2x5X1wiLFxuICAgIFwic3ViY2xhc3NcIixcbiAgICBcInJpbmdzX29rXCIsXG4gICAgXCJyaW5nc19ub2tcIixcbiAgICBcInN0X2xlbmd0aChzaGFwZSlcIixcbiAgICBcInN0X2FyZWEoc2hhcGUpXCJcbl07XG5mdW5jdGlvbiBidWlsZEZpZWxkc0xpc3QoKSB7XG4gICAgY29uc3QgeyBsYXllciwgbWFwSW1hZ2VTdWJsYXllciB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgbGV0IHsgbGF5ZXJGaWVsZHMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGlmICghbGF5ZXIgfHwgbGF5ZXJGaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBzbWFydE1hcHBpbmdTdGF0ZS5sYXllckZpZWxkcyA9IGdldExheWVyRmllbGRzKGxheWVyKTtcbiAgICAvLyBodHRwczovL2RlbW9ncmFwaGljczlkZXYuYXJjZ2lzLmNvbS9hcmNnaXMvcmVzdC9zZXJ2aWNlcy9VU0FfRGVtb2dyYXBoaWNzX2FuZF9Cb3VuZGFyaWVzXzIwMTkvTWFwU2VydmVyXG4gICAgaWYgKG1hcEltYWdlU3VibGF5ZXIgJiZcbiAgICAgICAgbWFwSW1hZ2VTdWJsYXllci5sYXllci5wb3J0YWxJdGVtICYmXG4gICAgICAgIG1hcEltYWdlU3VibGF5ZXIubGF5ZXIudXJsLmluZGV4T2YoXCJodHRwczovL2RlbW9ncmFwaGljc1wiKSA+IC0xICYmXG4gICAgICAgIG1hcEltYWdlU3VibGF5ZXIubGF5ZXIudXJsLmluZGV4T2YoXCIuYXJjZ2lzLmNvbVwiKSA+IC0xKSB7XG4gICAgICAgIGNvbnN0IHBvcnRhbEl0ZW0gPSBtYXBJbWFnZVN1YmxheWVyLmxheWVyLnBvcnRhbEl0ZW07XG4gICAgICAgIHJldHVybiBwb3J0YWxJdGVtXG4gICAgICAgICAgICAuZmV0Y2hEYXRhKClcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS50aGVtYXRpY0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IHJlc3BvbnNlLnRoZW1hdGljR3JvdXAuZmllbGROYW1lcztcbiAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBsYXllckZpZWxkcyA9IGxheWVyRmllbGRzLmZpbHRlcigobGF5ZXJGaWVsZCkgPT4gZmllbGROYW1lcy5pbmRleE9mKGxheWVyRmllbGQubmFtZSkgPiAtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVpbGRGaWVsZHNMaXN0QWZ0ZXJUaGVtYXRpY0dyb3VwQ2hlY2soKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBhc3N1bWUgdGhlcmUgaXMgbm9uZVxuICAgICAgICAgICAgYnVpbGRGaWVsZHNMaXN0QWZ0ZXJUaGVtYXRpY0dyb3VwQ2hlY2soKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWlsZEZpZWxkc0xpc3RBZnRlclRoZW1hdGljR3JvdXBDaGVjaygpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TGF5ZXJGaWVsZHMobGF5ZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBpZiAobGF5ZXIudHlwZSA9PT0gXCJmZWF0dXJlXCIgJiYgKChfYSA9IGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gXCJiaW5uaW5nXCIpIHtcbiAgICAgICAgLy8gY29udmVydCBBZ2dyZWdhdGVGaWVsZHMgaW50byBGaWVsZHNcbiAgICAgICAgY29uc3QgYWdncmVnYXRlRmllbGRzID0gbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbi5maWVsZHM7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgICAgICBhZ2dyZWdhdGVGaWVsZHMuZm9yRWFjaCgoYWdncmVnYXRlRmllbGQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxheWVyRmllbGQgPSBsYXllci5maWVsZHMuZmluZCgoZmllbGQpID0+IGZpZWxkLm5hbWUgPT09IGFnZ3JlZ2F0ZUZpZWxkLm9uU3RhdGlzdGljRmllbGQpO1xuICAgICAgICAgICAgaWYgKCFhZ2dyZWdhdGVGaWVsZC5vblN0YXRpc3RpY0ZpZWxkIHx8IGxheWVyRmllbGQpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChuZXcgbW9kdWxlcy5GaWVsZCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGFnZ3JlZ2F0ZUZpZWxkLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzOiBhZ2dyZWdhdGVGaWVsZC5hbGlhcyB8fCBhZ2dyZWdhdGVGaWVsZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBnZXRGaWVsZFR5cGUoYWdncmVnYXRlRmllbGQpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSAvLyBmaWVsZCBkb2Vzbid0IGV4aXN0IG9uIGxheWVyIGFueW1vcmU7IGRvbid0IHVzZSBpdCBoZXJlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmllbGRzO1xuICAgIH1cbiAgICByZXR1cm4gXCJmaWVsZHNcIiBpbiBsYXllciAmJiBsYXllci5maWVsZHM7XG59XG5mdW5jdGlvbiBidWlsZEZpZWxkc0xpc3RBZnRlclRoZW1hdGljR3JvdXBDaGVjaygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1hcEltYWdlU3VibGF5ZXIsIGxheWVyRmllbGRzLCBzdXBwb3J0c0FyY2FkZSB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgLy9jb25zdCBzdXBwb3J0c1N0YW5kYXJkaXplZFF1ZXJ5ID0gbGF5ZXIudmVyc2lvbiA+PSAxMC4yICYmIGxheWVyLmNhcGFiaWxpdGllcz8ucXVlcnk/LnN1cHBvcnRzU3RhbmRhcmRpemVkUXVlcmllc09ubHk7XG4gICAgLy8gSlMtQVBJICMyNzEyMFxuICAgIGNvbnN0IHN1cHBvcnRzU3FsRXhwcmVzc2lvbiA9IGxheWVyLmhhc093blByb3BlcnR5KFwiY2FwYWJpbGl0aWVzXCIpICYmICgoX2IgPSAoX2EgPSBsYXllci5jYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5xdWVyeSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN1cHBvcnRzU3FsRXhwcmVzc2lvbik7XG4gICAgc21hcnRNYXBwaW5nU3RhdGUuZmllbGRzID0gW107XG4gICAgc21hcnRNYXBwaW5nU3RhdGUuc3RyaW5nRmllbGRzQ291bnQgPSAwO1xuICAgIHNtYXJ0TWFwcGluZ1N0YXRlLmRhdGVGaWVsZHNDb3VudCA9IDA7XG4gICAgc21hcnRNYXBwaW5nU3RhdGUubnVtYmVyRmllbGRzQ291bnQgPSAwO1xuICAgIGNvbnN0IGZpZWxkSW5mb3MgPSBcInBvcHVwVGVtcGxhdGVcIiBpbiBsYXllciAmJiBsYXllci5wb3B1cFRlbXBsYXRlID8gbGF5ZXIucG9wdXBUZW1wbGF0ZS5maWVsZEluZm9zIDogW107XG4gICAgLy8gbWFrZSBzdXJlIG5vIGZpZWxkcyB1c2VkIGluIHRoZSByZW5kZXJlciBhcmUgZXhjbHVkZWRcbiAgICAvLyBub3QgY2hlY2tpbmcgQXJjYWRlIGV4cHJlc3Npb25zLi4uXG4gICAgY29uc3QgcmVuZGVyZXJGaWVsZHMgPSBnZXRSZW5kZXJlckZpZWxkSW5mb3MobGF5ZXIpO1xuICAgIGNvbnN0IHJlbk5hbWVzID0gcmVuZGVyZXJGaWVsZHNcbiAgICAgICAgLmZpbHRlcigocmVuRmllbGQpID0+ICEhcmVuRmllbGQuZmllbGQpXG4gICAgICAgIC5tYXAoKHJlbkZpZWxkKSA9PiByZW5GaWVsZC5maWVsZC50b0xvd2VyQ2FzZSgpKTtcbiAgICBpZiAocmVuTmFtZXMgPT09IG51bGwgfHwgcmVuTmFtZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbk5hbWVzLmxlbmd0aCkge1xuICAgICAgICBleGNsdWRlZEZpZWxkcyA9IGV4Y2x1ZGVkRmllbGRzLmZpbHRlcigobmFtZSkgPT4gcmVuTmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpO1xuICAgIH1cbiAgICBsYXllckZpZWxkcy5mb3JFYWNoKChsYXllckZpZWxkKSA9PiB7XG4gICAgICAgIGlmIChleGNsdWRlZEZpZWxkcy5pbmRleE9mKGxheWVyRmllbGQubmFtZS50b0xvd2VyQ2FzZSgpKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFtcImRhdGVcIiwgXCJkYXRlLW9ubHlcIl0uaW5kZXhPZihsYXllckZpZWxkLnR5cGUpID4gLTEgJiZcbiAgICAgICAgICAgICgobWFwSW1hZ2VTdWJsYXllciAmJiAhc3VwcG9ydHNBcmNhZGUpIHx8IChsYXllci50eXBlICE9PSBcInN0cmVhbVwiICYmICFzdXBwb3J0c1NxbEV4cHJlc3Npb24pKSkge1xuICAgICAgICAgICAgLy8gbm8gZGF0ZSBmaWVsZCBzdXBwb3J0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGlzdCA9IGZpZWxkSW5mb3NcbiAgICAgICAgICAgID8gZmllbGRJbmZvcy5maWx0ZXIoKGZpZWxkSW5mbykgPT4gZmllbGRJbmZvLmZpZWxkTmFtZSA9PT0gbGF5ZXJGaWVsZC5uYW1lKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjb25zdCBsYWJlbCA9IGxpc3QgJiYgbGlzdC5sZW5ndGggPyBsaXN0WzBdLmxhYmVsIDogbnVsbDtcbiAgICAgICAgY29uc3QgZmVhdHVyZUZpbHRlckZpZWxkID0ge1xuICAgICAgICAgICAgbGF5ZXJGaWVsZDogbGF5ZXJGaWVsZCxcbiAgICAgICAgICAgIGxhYmVsOiBsYWJlbCB8fCBsYXllckZpZWxkLmFsaWFzIHx8IGxheWVyRmllbGQubmFtZVxuICAgICAgICB9O1xuICAgICAgICBnZXRTaW1wbGVGaWVsZFR5cGUoZmVhdHVyZUZpbHRlckZpZWxkLCByZW5OYW1lcyk7XG4gICAgICAgIGlmIChmZWF0dXJlRmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlKSB7XG4gICAgICAgICAgICBzbWFydE1hcHBpbmdTdGF0ZS5maWVsZHMucHVzaChmZWF0dXJlRmlsdGVyRmllbGQpO1xuICAgICAgICB9IC8vIGVsc2UgY2FuJ3QgdXNlIGZpZWxkXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRGaWVsZChmaWVsZE5hbWUpIHtcbiAgICBjb25zdCB7IGxheWVyIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBpZiAoaXNSYXN0ZXJMYXllcihsYXllcikpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gZ2V0UmFzdGVyVW5pcXVlVmFsdWVGaWVsZHMoKTtcbiAgICAgICAgY29uc3QgbGlzdCA9IGZpZWxkcy5maWx0ZXIoKGZpZWxkKSA9PiBmaWVsZC5uYW1lID09PSBmaWVsZE5hbWUpO1xuICAgICAgICBpZiAobGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gbGlzdFswXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGFiZWw6IGZpZWxkLmFsaWFzLFxuICAgICAgICAgICAgICAgIGxheWVyRmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgICAgIC8vIHJhc3RlciBsYXllciBkaXNwbGF5cyBhcmUgbm90IGRlcGVuZGVudCBvbiBmaWVsZCB0eXBlLCBzbyB3ZSB1c2UgXCJzdHJpbmdcIiBhcyBhIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgc2ltcGxlRmllbGRUeXBlOiBzaW1wbGVGaWVsZFR5cGVzLlNUUklOR1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IHNtYXJ0TWFwcGluZ1N0YXRlLmZpZWxkcy5maWx0ZXIoKGZpZWxkKSA9PiBmaWVsZC5sYXllckZpZWxkLm5hbWUgPT09IGZpZWxkTmFtZSk7XG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0TnVtYmVyRmllbGQoKSB7XG4gICAgY29uc3QgbGlzdCA9IHNtYXJ0TWFwcGluZ1N0YXRlLmZpZWxkcy5maWx0ZXIoKGZpZWxkKSA9PiBmaWVsZC5zaW1wbGVGaWVsZFR5cGUgPT09IHNpbXBsZUZpZWxkVHlwZXMuTlVNQkVSKTtcbiAgICBpZiAobGlzdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RbMF07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBoYXNOdW1iZXJGaWVsZCgpIHtcbiAgICByZXR1cm4gc21hcnRNYXBwaW5nU3RhdGUubnVtYmVyRmllbGRzQ291bnQgPiAwO1xufVxuZnVuY3Rpb24gZ2V0RmllbGRUeXBlQ291bnQoKSB7XG4gICAgY29uc3QgeyBzZWxlY3RlZEZpZWxkcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgY291bnRzID0geyBzdHJpbmc6IDAsIG51bWJlcjogMCwgZGF0ZTogMCwgdW5rbm93bjogMCwgZXhwcmVzc2lvbjogMCB9O1xuICAgIHNlbGVjdGVkRmllbGRzLmZvckVhY2goKGZpZWxkSW5mbykgPT4ge1xuICAgICAgICBjb3VudHMuZXhwcmVzc2lvbiArPSBmaWVsZEluZm8uZXhwcmVzc2lvbiA/IDEgOiAwO1xuICAgICAgICBsZXQgZmllbGRUeXBlO1xuICAgICAgICBpZiAoZmllbGRJbmZvLmZpZWxkKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldEZpZWxkKGZpZWxkSW5mby5maWVsZCk7XG4gICAgICAgICAgICBmaWVsZFR5cGUgPSBmaWVsZCA/IGZpZWxkLnNpbXBsZUZpZWxkVHlwZSA6IHNpbXBsZUZpZWxkVHlwZXMuVU5LTk9XTjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpZWxkVHlwZSA9IGZpZWxkSW5mby5zaW1wbGVGaWVsZFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmaWVsZFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2Ugc2ltcGxlRmllbGRUeXBlcy5OVU1CRVI6XG4gICAgICAgICAgICBjYXNlIHNpbXBsZUZpZWxkVHlwZXMuT0lEOlxuICAgICAgICAgICAgY2FzZSBzaW1wbGVGaWVsZFR5cGVzLkdVSUQ6XG4gICAgICAgICAgICAgICAgY291bnRzLm51bWJlcisrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzaW1wbGVGaWVsZFR5cGVzLlNUUklORzpcbiAgICAgICAgICAgICAgICBjb3VudHMuc3RyaW5nKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNpbXBsZUZpZWxkVHlwZXMuREFURTpcbiAgICAgICAgICAgICAgICBjb3VudHMuZGF0ZSsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzaW1wbGVGaWVsZFR5cGVzLlVOS05PV046XG4gICAgICAgICAgICAgICAgY291bnRzLnVua25vd24rKztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb3VudHM7XG59XG5mdW5jdGlvbiBnZXRMYXllckZpZWxkVHlwZUNvdW50KGZpZWxkcykge1xuICAgIGNvbnN0IHsgZmllbGRzOiBzdGF0ZUZpZWxkcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgZmllbGRzID0gZmllbGRzIHx8IHN0YXRlRmllbGRzO1xuICAgIGNvbnN0IGNvdW50cyA9IHsgc3RyaW5nOiAwLCBudW1iZXI6IDAsIGRhdGU6IDAsIGV4cHJlc3Npb246IDAgfTtcbiAgICBmaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgc3dpdGNoIChmaWVsZC5zaW1wbGVGaWVsZFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2Ugc2ltcGxlRmllbGRUeXBlcy5OVU1CRVI6XG4gICAgICAgICAgICBjYXNlIHNpbXBsZUZpZWxkVHlwZXMuT0lEOlxuICAgICAgICAgICAgY2FzZSBzaW1wbGVGaWVsZFR5cGVzLkdVSUQ6XG4gICAgICAgICAgICAgICAgY291bnRzLm51bWJlcisrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzaW1wbGVGaWVsZFR5cGVzLlNUUklORzpcbiAgICAgICAgICAgICAgICBjb3VudHMuc3RyaW5nKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNpbXBsZUZpZWxkVHlwZXMuREFURTpcbiAgICAgICAgICAgICAgICBjb3VudHMuZGF0ZSsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvdW50cztcbn1cbmZ1bmN0aW9uIGFkZEZpZWxkc1RvTGF5ZXJDYWNoZShmaWVsZE5hbWVzKSB7XG4gICAgY29uc3QgeyBsYXllciB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgaWYgKCEoXCJmZWF0dXJlUmVkdWN0aW9uXCIgaW4gbGF5ZXIpIHx8ICFsYXllci5mZWF0dXJlUmVkdWN0aW9uIHx8IGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24udHlwZSAhPT0gXCJiaW5uaW5nXCIpIHtcbiAgICAgICAgYWRkRmllbGRzVG9PdXRGaWVsZHMoZmllbGROYW1lcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkRmllbGRzVG9PdXRGaWVsZHMoZmllbGROYW1lcykge1xuICAgIC8qXG4gICAgICBmZWF0dXJlLCBnZW9KU09OIGFuZCB3ZnMgbmVlZCB0byBoYXZlIG91dEZpZWxkcyB1cGRhdGVkXG4gICAgICBzdHJlYW0gbGF5ZXJzIGhhdmUgcmVhZC1vbmx5IG91dEZpZWxkcyBhbmQgYWxsIGZpZWxkcyBpbmNsdWRlZCBpbiBvdXRGaWVsZHNcbiAgICAgIGNzdiBieSBkZWZhdWx0IGhhcyBhbGwgdGhlIGZpZWxkcyBpbmNsdWRlZCBpbiBvdXRGaWVsZHNcbiAgICAgIGZvciBvZ2MtZmVhdHVyZSwgb3V0RmllbGRzIGlzIG5vdCBhdmFpbGFibGUuLiBidXQgaXQgd291bGQgd29yayBhcyBpZiBpdHMgbGF5ZXJWaWV3LmF2YWlsYWJsZUZpZWxkcyBoYXMgYWxsIHRoZSBmaWVsZHMuLlxuICAgICovXG4gICAgY29uc3QgeyBsYXllciB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgaWYgKGxheWVyLnR5cGUgPT09IFwiZ2VvanNvblwiIHx8IGxheWVyLnR5cGUgPT09IFwid2ZzXCIgfHwgbGF5ZXIudHlwZSA9PT0gXCJmZWF0dXJlXCIpIHtcbiAgICAgICAgbGF5ZXIub3V0RmllbGRzID0gZmllbGROYW1lcztcbiAgICB9XG59XG5mdW5jdGlvbiBpc1NhbWVGaWVsZEluZm9zKGZpZWxkSW5mb3MxLCBmaWVsZEluZm9zMikge1xuICAgIGxldCBpc1NhbWUgPSB0cnVlO1xuICAgIGlmIChmaWVsZEluZm9zMS5sZW5ndGggIT09IGZpZWxkSW5mb3MyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZpZWxkSW5mb3MxLmZvckVhY2goKGZpZWxkSW5mbywgaWR4KSA9PiB7XG4gICAgICAgIGlmIChpc1NhbWUgJiYgIWlzU2FtZUZpZWxkSW5mbyhmaWVsZEluZm8sIGZpZWxkSW5mb3MyW2lkeF0pKSB7XG4gICAgICAgICAgICBpc1NhbWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpc1NhbWU7XG59XG5mdW5jdGlvbiBpc1NhbWVGaWVsZEluZm8oZmllbGRJbmZvMSwgZmllbGRJbmZvMikge1xuICAgIC8vIG5vIGV4YWN0IGNvbXBhcmlzb24gc28gYHVuZGVmaW5lZCA9PSBudWxsYCBlcXVhbHMgdHJ1ZVxuICAgIGlmIChmaWVsZEluZm8xICYmXG4gICAgICAgIGZpZWxkSW5mbzIgJiZcbiAgICAgICAgZmllbGRJbmZvMS5maWVsZCA9PSBmaWVsZEluZm8yLmZpZWxkICYmXG4gICAgICAgIGZpZWxkSW5mbzEuZXhwcmVzc2lvbiA9PSBmaWVsZEluZm8yLmV4cHJlc3Npb24gJiZcbiAgICAgICAgZmllbGRJbmZvMS5leHByZXNzaW9uVGl0bGUgPT0gZmllbGRJbmZvMi5leHByZXNzaW9uVGl0bGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzRGF0ZShmaWVsZEluZm8pIHtcbiAgICByZXR1cm4gZmllbGRJbmZvLnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5EQVRFO1xufVxuZnVuY3Rpb24gZ2V0U2ltcGxlRmllbGRUeXBlKGZlYXR1cmVGaWx0ZXJGaWVsZCwgcmVuZGVyZXJGaWVsZE5hbWVzKSB7XG4gICAgY29uc3QgbGF5ZXJGaWVsZFR5cGUgPSBnZXRGaWVsZFR5cGUoZmVhdHVyZUZpbHRlckZpZWxkLmxheWVyRmllbGQpO1xuICAgIHN3aXRjaCAobGF5ZXJGaWVsZFR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBjYXNlIFwiZGF0ZS1vbmx5XCI6XG4gICAgICAgICAgICBmZWF0dXJlRmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID0gc2ltcGxlRmllbGRUeXBlcy5TVFJJTkc7XG4gICAgICAgICAgICBzbWFydE1hcHBpbmdTdGF0ZS5zdHJpbmdGaWVsZHNDb3VudCsrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgICBmZWF0dXJlRmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID0gc2ltcGxlRmllbGRUeXBlcy5EQVRFO1xuICAgICAgICAgICAgc21hcnRNYXBwaW5nU3RhdGUuZGF0ZUZpZWxkc0NvdW50Kys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9pZFwiOlxuICAgICAgICAgICAgLy8gb25seSBpZiBmaWVsZCBpcyB1c2VkIGluIGN1cnJlbnQgcmVuZGVyZXI7IGZpZWxkIHN0YXlzIGZvciB0aGUgc2Vzc2lvblxuICAgICAgICAgICAgaWYgKHJlbmRlcmVyRmllbGROYW1lcy5pbmRleE9mKGZlYXR1cmVGaWx0ZXJGaWVsZC5sYXllckZpZWxkLm5hbWUudG9Mb3dlckNhc2UoKSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVGaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgPSBzaW1wbGVGaWVsZFR5cGVzLk9JRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZ3VpZFwiOlxuICAgICAgICAgICAgLy8gb25seSBpZiBmaWVsZCBpcyB1c2VkIGluIGN1cnJlbnQgcmVuZGVyZXI7IGZpZWxkIHN0YXlzIGZvciB0aGUgc2Vzc2lvblxuICAgICAgICAgICAgaWYgKHJlbmRlcmVyRmllbGROYW1lcy5pbmRleE9mKGZlYXR1cmVGaWx0ZXJGaWVsZC5sYXllckZpZWxkLm5hbWUudG9Mb3dlckNhc2UoKSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVGaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgPSBzaW1wbGVGaWVsZFR5cGVzLkdVSUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNtYWxsLWludGVnZXJcIjpcbiAgICAgICAgY2FzZSBcImJpZy1pbnRlZ2VyXCI6XG4gICAgICAgIGNhc2UgXCJpbnRlZ2VyXCI6XG4gICAgICAgIGNhc2UgXCJzaW5nbGVcIjpcbiAgICAgICAgY2FzZSBcImRvdWJsZVwiOlxuICAgICAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgICAgICAgZmVhdHVyZUZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9IHNpbXBsZUZpZWxkVHlwZXMuTlVNQkVSO1xuICAgICAgICAgICAgc21hcnRNYXBwaW5nU3RhdGUubnVtYmVyRmllbGRzQ291bnQrKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEZpZWxkVHlwZUZyb21WYWx1ZVR5cGUoZmllbGQpIHtcbiAgICAvLyBcImNvdW50LW9yLWFtb3VudFwiLFwicGVyY2VudGFnZS1vci1yYXRpb1wiLFwibWVhc3VyZW1lbnRcIixcInVuaXF1ZS1pZGVudGlmaWVyXCIsXCJjb29yZGluYXRlXCIsXCJiaW5hcnlcIlxuICAgIC8vIFwibmFtZS1vci10aXRsZVwiLFwidHlwZS1vci1jYXRlZ29yeVwiLFwiZGVzY3JpcHRpb25cIixcImxvY2F0aW9uLW9yLXBsYWNlLW5hbWVcIixcIm9yZGVyZWQtb3ItcmFua2VkXCIsXCJkYXRlLWFuZC10aW1lXCJcbiAgICBjb25zdCBsYXllckZpZWxkID0gZmllbGQubGF5ZXJGaWVsZDtcbiAgICBjb25zdCBsYXllckZpZWxkVHlwZSA9IGdldEZpZWxkVHlwZShsYXllckZpZWxkKTtcbiAgICBzd2l0Y2ggKGxheWVyRmllbGRUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJzbWFsbC1pbnRlZ2VyXCI6XG4gICAgICAgIGNhc2UgXCJiaWctaW50ZWdlclwiOlxuICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICBjYXNlIFwic2luZ2xlXCI6XG4gICAgICAgIGNhc2UgXCJkb3VibGVcIjoge1xuICAgICAgICAgICAgaWYgKFwiZG9tYWluXCIgaW4gbGF5ZXJGaWVsZCAmJiBsYXllckZpZWxkLmRvbWFpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChcInZhbHVlVHlwZVwiIGluIGxheWVyRmllbGQgJiYgbGF5ZXJGaWVsZC52YWx1ZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwibmFtZS1vci10aXRsZVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0eXBlLW9yLWNhdGVnb3J5XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImRlc2NyaXB0aW9uXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImxvY2F0aW9uLW9yLXBsYWNlLW5hbWVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwib3JkZXJlZC1vci1yYW5rZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInVuaXF1ZS1pZGVudGlmaWVyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImRhdGUtYW5kLXRpbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvdW50LW9yLWFtb3VudFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnRlZ2VyXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcInBlcmNlbnRhZ2Utb3ItcmF0aW9cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVhc3VyZW1lbnRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29vcmRpbmF0ZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkb3VibGVcIjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkb3VibGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJkYXRlLW9ubHlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZGF0ZVwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RmllbGRUeXBlKGZpZWxkKSB7XG4gICAgY29uc3QgeyBsYXllciB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgaWYgKCFmaWVsZCB8fCAhKFwiZmllbGRzXCIgaW4gbGF5ZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFwidHlwZVwiIGluIGZpZWxkKSB7XG4gICAgICAgIC8vIF9fZXNyaS5GaWVsZFxuICAgICAgICByZXR1cm4gZmllbGQudHlwZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJzdGF0aXN0aWNUeXBlXCIgaW4gZmllbGQpIHtcbiAgICAgICAgLy8gX19lc3JpLkFnZ3JlZ2F0ZUZpZWxkXG4gICAgICAgIGNvbnN0IGxheWVyRmllbGQgPSBsYXllci5maWVsZHMuZmluZCgobGF5ZXJGaWVsZCkgPT4gbGF5ZXJGaWVsZC5uYW1lID09PSBmaWVsZC5vblN0YXRpc3RpY0ZpZWxkKTtcbiAgICAgICAgaWYgKCFmaWVsZC5vblN0YXRpc3RpY0ZpZWxkIHx8IGxheWVyRmllbGQpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5zdGF0aXN0aWNUeXBlID09PSBcImNvdW50XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnRlZ2VyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5zdGF0aXN0aWNUeXBlID09PSBcImF2Z1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZG91YmxlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChbXCJtaW5cIiwgXCJtYXhcIiwgXCJzdW1cIiwgXCJtb2RlXCJdLmluZGV4T2YoZmllbGQuc3RhdGlzdGljVHlwZSkgLSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChsYXllckZpZWxkID09PSBudWxsIHx8IGxheWVyRmllbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyRmllbGQudHlwZSkgfHwgXCJpbnRlZ2VyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZmllbGQgZG9lc24ndCBleGlzdCBvbiBsYXllciBhbnltb3JlXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuO1xufVxuXG5mdW5jdGlvbiBpc1Jhc3RlckxheWVyKGxheWVyKSB7XG4gICAgcmV0dXJuIFtcImltYWdlcnlcIiwgXCJpbWFnZXJ5LXRpbGVcIl0uaW5kZXhPZihsYXllci50eXBlKSA+IC0xO1xufVxuXG52YXIgbG9jYWxTdG9yYWdlS2V5cztcbihmdW5jdGlvbiAobG9jYWxTdG9yYWdlS2V5cykge1xuICAgIGxvY2FsU3RvcmFnZUtleXNbXCJBUkNHSVNfQ09NUE9ORU5UX05PVElGSUNBVElPTlNcIl0gPSBcImFyY2dpc0NvbXBvbmVudF9ub3RpZmljYXRpb25zXCI7XG59KShsb2NhbFN0b3JhZ2VLZXlzIHx8IChsb2NhbFN0b3JhZ2VLZXlzID0ge30pKTtcbnZhciBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5cztcbihmdW5jdGlvbiAoYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXMpIHtcbiAgICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIlNNQVJUX01BUFBJTkdfVElQMV9ESVNNSVNTRURcIl0gPSBcImFyY2dpc19zbWFydF9tYXBwaW5nX3RpcDFfZGlzbWlzc2VkXCI7XG4gICAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJTTUFSVF9NQVBQSU5HX1RJUDJfRElTTUlTU0VEXCJdID0gXCJhcmNnaXNfc21hcnRfbWFwcGluZ190aXAyX2Rpc21pc3NlZFwiO1xufSkoYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXMgfHwgKGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzID0ge30pKTtcbmNvbnN0IGdldExvY2FsU3RvcmFnZSA9IChsb2NhbFN0b3JhZ2VLZXkpID0+IHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0obG9jYWxTdG9yYWdlS2V5KTtcbn07XG5jb25zdCBzZXRMb2NhbFN0b3JhZ2UgPSAobG9jYWxTdG9yYWdlS2V5LCB2YWx1ZSkgPT4ge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGxvY2FsU3RvcmFnZUtleSwgdmFsdWUpO1xufTtcbmNvbnN0IGdldE9iamVjdExvY2FsU3RvcmFnZSA9IChsb2NhbFN0b3JhZ2VLZXkpID0+IHtcbiAgICBjb25zdCBpbmZvID0gZ2V0TG9jYWxTdG9yYWdlKGxvY2FsU3RvcmFnZUtleSk7XG4gICAgcmV0dXJuIGluZm8gPyBKU09OLnBhcnNlKGluZm8pIDoge307XG59O1xuY29uc3Qgc2V0U2luZ2xlT2JqZWN0TG9jYWxTdG9yYWdlID0gKGxvY2FsU3RvcmFnZUtleSwga2V5VmFsdWVPYmplY3QpID0+IHtcbiAgICBjb25zdCBzZXRMb2NhbFN0b3JhZ2VWYWwgPSBnZXRPYmplY3RMb2NhbFN0b3JhZ2UobG9jYWxTdG9yYWdlS2V5KTtcbiAgICBzZXRMb2NhbFN0b3JhZ2VWYWxba2V5VmFsdWVPYmplY3Qua2V5XSA9IGtleVZhbHVlT2JqZWN0LnZhbHVlO1xuICAgIHNldExvY2FsU3RvcmFnZShsb2NhbFN0b3JhZ2VLZXksIEpTT04uc3RyaW5naWZ5KHNldExvY2FsU3RvcmFnZVZhbCkpO1xufTtcbmNvbnN0IGdldFNpbmdsZU9iamVjdExvY2FsU3RvcmFnZSA9IChsb2NhbFN0b3JhZ2VLZXksIG9iamVjdEtleSkgPT4ge1xuICAgIGNvbnN0IGdldExvY2FsU3RvcmFnZVZhbCA9IGdldE9iamVjdExvY2FsU3RvcmFnZShsb2NhbFN0b3JhZ2VLZXkpO1xuICAgIGlmIChnZXRMb2NhbFN0b3JhZ2VWYWwgPT09IG51bGwgfHwgZ2V0TG9jYWxTdG9yYWdlVmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXRMb2NhbFN0b3JhZ2VWYWwuaGFzT3duUHJvcGVydHkob2JqZWN0S2V5KSkge1xuICAgICAgICByZXR1cm4gZ2V0TG9jYWxTdG9yYWdlVmFsW29iamVjdEtleV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5jb25zdCBTbWFydE1hcHBpbmdTdG9yZSA9IGNyZWF0ZVN0b3JlKHtcbiAgICBzZWxlY3RlZEZpZWxkczogW10sXG4gICAgaGlkZUxheWVyVGl0bGU6IGZhbHNlLFxuICAgIHN1cHBvcnRzQXJjYWRlOiBmYWxzZSxcbiAgICBzdHJpbmdGaWVsZHNDb3VudDogLTEsXG4gICAgZGF0ZUZpZWxkc0NvdW50OiAtMSxcbiAgICBudW1iZXJGaWVsZHNDb3VudDogLTEsXG4gICAgaXNSVEw6IGZhbHNlLFxuICAgIG9uZUZlYXR1cmVSZXNwb25zZVN0YXR1czogc3RhdHVzLk1JU1NJTkdcbn0pO1xuY29uc3Qgc21hcnRNYXBwaW5nU3RhdGUgPSBTbWFydE1hcHBpbmdTdG9yZS5zdGF0ZTtcbi8vIGNyZWF0ZVN0b3JlIGdldHMgY2FsbGVkIGp1c3Qgb25jZSBpbiBhIGFwcCBzZXNzaW9uXG5mdW5jdGlvbiBjbGVhclNtYXJ0TWFwcGluZ1N0YXRlKHNtYXJ0TWFwcGluZ1N0YXRlKSB7XG4gICAgc21hcnRNYXBwaW5nU3RhdGUuc2VsZWN0ZWRGaWVsZHMgPSBbXTtcbiAgICBzbWFydE1hcHBpbmdTdGF0ZS5sYXllckZpZWxkcyA9IHVuZGVmaW5lZDtcbiAgICBzbWFydE1hcHBpbmdTdGF0ZS5maWVsZHMgPSB1bmRlZmluZWQ7XG4gICAgc21hcnRNYXBwaW5nU3RhdGUuaGlkZUxheWVyVGl0bGUgPSBmYWxzZTtcbiAgICBzbWFydE1hcHBpbmdTdGF0ZS5zdXBwb3J0c0FyY2FkZSA9IGZhbHNlO1xuICAgIHNtYXJ0TWFwcGluZ1N0YXRlLnN0cmluZ0ZpZWxkc0NvdW50ID0gLTE7XG4gICAgc21hcnRNYXBwaW5nU3RhdGUuZGF0ZUZpZWxkc0NvdW50ID0gLTE7XG4gICAgc21hcnRNYXBwaW5nU3RhdGUubnVtYmVyRmllbGRzQ291bnQgPSAtMTtcbiAgICBzbWFydE1hcHBpbmdTdGF0ZS5vbmVGZWF0dXJlUmVzcG9uc2VTdGF0dXMgPSBzdGF0dXMuTUlTU0lORztcbiAgICBzbWFydE1hcHBpbmdTdGF0ZS5zZWxlY3RlZEF0dHJpYnV0ZSA9IHVuZGVmaW5lZDtcbiAgICBzbWFydE1hcHBpbmdTdGF0ZS5zZWxlY3RlZEF0dHJpYnV0ZVRleHQgPSB1bmRlZmluZWQ7XG4gICAgc21hcnRNYXBwaW5nU3RhdGUuc2VsZWN0ZWRUeXBlVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgc21hcnRNYXBwaW5nU3RhdGUuc2VsZWN0ZWRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICBzbWFydE1hcHBpbmdTdGF0ZS5sYXN0RGVmYXVsdCA9IHVuZGVmaW5lZDtcbiAgICBzbWFydE1hcHBpbmdTdGF0ZS5sYXN0RGVmYXVsdHMgPSB1bmRlZmluZWQ7XG4gICAgc21hcnRNYXBwaW5nU3RhdGUuZG90Q29sb3JTZWxlY3RlZCA9IHVuZGVmaW5lZDtcbiAgICBzbWFydE1hcHBpbmdTdGF0ZS5iYWNrZ3JvdW5kU3R5bGVTZWxlY3RlZCA9IHVuZGVmaW5lZDtcbiAgICBzbWFydE1hcHBpbmdTdGF0ZS5sYXN0U2V0dGluZ3MgPSB1bmRlZmluZWQ7XG4gICAgc21hcnRNYXBwaW5nU3RhdGUuY2xhc3NlZFN5bWJvbFNlbGVjdGVkSWR4ID0gdW5kZWZpbmVkO1xuICAgIHNtYXJ0TWFwcGluZ1N0YXRlLmFsbFVuaXF1ZVZhbHVlcyA9IHVuZGVmaW5lZDtcbn1cblxuY29uc3QgZGVmYXVsdEdlb21ldHJ5ID0gXCJwb2x5Z29uXCI7XG5mdW5jdGlvbiBnZXRSZW5kZXJlclR5cGUoKSB7XG4gICAgY29uc3QgeyBsYXllciB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgcmV0dXJuIGdldFJlbmRlcmVyVHlwZUZyb21SZW5kZXJlcihyZW5kZXJlcik7XG59XG5mdW5jdGlvbiBnZXRSZW5kZXJlclR5cGVGcm9tUmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBsYXllciB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgaGFzU2l6ZVZpc1ZhciA9IGhhc1Zpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIpO1xuICAgIGNvbnN0IGhhc0NvbG9yVmlzVmFyID0gaGFzVmlzVmFyKHJlbmRlcmVyLCBcImNvbG9yXCIpO1xuICAgIGNvbnN0IGNvbG9yVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcImNvbG9yXCIpO1xuICAgIGNvbnN0IGF1dGhDb2xvclZpc1ZhciA9IGdldEF1dGhWaXNWYXIocmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgY29uc3QgYXV0aFNpemVWaXNWYXIgPSBnZXRBdXRoVmlzVmFyKHJlbmRlcmVyLCBcInNpemVcIik7XG4gICAgbGV0IHJlbmRlcmVyVHlwZSA9IFwidW5rbm93blwiO1xuICAgIGlmIChyZW5kZXJlci5ub3JtYWxpemF0aW9uVHlwZSAmJlxuICAgICAgICByZW5kZXJlci5ub3JtYWxpemF0aW9uVHlwZSAhPT0gXCJmaWVsZFwiKSB7XG4gICAgICAgIC8vIFwicGVyY2VudC1vZi10b3RhbFwiIGFuZCBcImxvZ1wiIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgcmV0dXJuIFwidW5rbm93blwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZW5kZXJlci50eXBlID09PSBcInNpbXBsZVwiKSB7XG4gICAgICAgIHJlbmRlcmVyVHlwZSA9IFwic2ltcGxlXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlbmRlcmVyLnR5cGUgPT09IFwiZG90LWRlbnNpdHlcIikge1xuICAgICAgICByZW5kZXJlclR5cGUgPSBcImRvdC1kZW5zaXR5XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlbmRlcmVyLnR5cGUgPT09IFwiaGVhdG1hcFwiKSB7XG4gICAgICAgIHJlbmRlcmVyVHlwZSA9IFwiaGVhdG1hcFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZW5kZXJlci50eXBlID09PSBcImNsYXNzLWJyZWFrc1wiKSB7XG4gICAgICAgIGNvbnN0IGNiUmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgaWYgKGhhc0NvbG9yVmlzVmFyKSB7XG4gICAgICAgICAgICBpZiAoY2JSZW5kZXJlci52YWx1ZUV4cHJlc3Npb24gJiYgIWF1dGhDb2xvclZpc1Zhcikge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9IFwiY29sb3JcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc1NpemVWaXNWYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXV0aFNpemVWaXNWYXIgJiYgYXV0aFNpemVWaXNWYXIudW5pdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gXCJjb2xvci1zaXplLWFnZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdXRoQ29sb3JWaXNWYXIgJiYgYXV0aENvbG9yVmlzVmFyLnVuaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9IFwiY29sb3ItYWdlLXNpemVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9IFwiY29sb3Itc2l6ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGF1dGhDb2xvclZpc1ZhciAmJiBhdXRoQ29sb3JWaXNWYXIuc3R5bGUgJiYgY29sb3JWaXNWYXIubm9ybWFsaXphdGlvbkZpZWxkKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gXCJjb21wYXJlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhdXRoQ29sb3JWaXNWYXIgJiYgYXV0aENvbG9yVmlzVmFyLnVuaXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1NpemVWaXNWYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gXCJjb2xvci1hZ2Utc2l6ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gXCJjb2xvci1hZ2VcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlclR5cGUgPSBcImNvbG9yXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzU2l6ZVZpc1Zhcikge1xuICAgICAgICAgICAgaWYgKCgoX2EgPSBjYlJlbmRlcmVyLmF1dGhvcmluZ0luZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gXCJ1bml2YXJpYXRlLWNvbG9yLXNpemVcIikge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9IFwiY29sb3Itc2l6ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2JSZW5kZXJlci52YWx1ZUV4cHJlc3Npb24gJiYgIWF1dGhTaXplVmlzVmFyKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gXCJzaXplXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhdXRoU2l6ZVZpc1ZhciAmJiBhdXRoU2l6ZVZpc1Zhci51bml0cykge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9IFwic2l6ZS1hZ2VcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9IFwic2l6ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gY2xhc3NlZFxuICAgICAgICAgICAgY29uc3QgcmVuZCA9IHJlbmRlcmVyO1xuICAgICAgICAgICAgY29uc3QgYXV0aG9yaW5nSW5mbyA9IHJlbmQuYXV0aG9yaW5nSW5mbztcbiAgICAgICAgICAgIGlmIChhdXRob3JpbmdJbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dGhvcmluZ0luZm8udHlwZSA9PT0gXCJjbGFzcy1icmVha3MtY29sb3JcIikge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlclR5cGUgPSBcImNvbG9yXCI7IC8vXCJjbGFzc2VkLWNvbG9yXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF1dGhvcmluZ0luZm8udHlwZSA9PT0gXCJjbGFzcy1icmVha3Mtc2l6ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9IFwic2l6ZVwiOyAvL1wiY2xhc3NlZC1zaXplXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBndWVzcyB0aGUgdHlwZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTaXplQ2hhbmdpbmcocmVuZC5jbGFzc0JyZWFrSW5mb3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlclR5cGUgPSBcInNpemVcIjsgLy9cImNsYXNzZWQtc2l6ZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gXCJjb2xvclwiOyAvL1wiY2xhc3NlZC1jb2xvclwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNQb2x5Z29uVHlwZShsYXllcikpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVuZC52YWx1ZUV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2l6ZUNoYW5naW5nKHJlbmQuY2xhc3NCcmVha0luZm9zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gXCJzaXplXCI7IC8vXCJjbGFzc2VkLXNpemVcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9IFwiY29sb3JcIjsgLy9cImNsYXNzZWQtY29sb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZW5kLmJhY2tncm91bmRGaWxsU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9IFwic2l6ZVwiOyAvL1wiY2xhc3NlZC1zaXplXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlclR5cGUgPSBcImNvbG9yXCI7IC8vXCJjbGFzc2VkLWNvbG9yXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2l6ZUNoYW5naW5nKHJlbmQuY2xhc3NCcmVha0luZm9zKSkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlclR5cGUgPSBcInNpemVcIjsgLy9cImNsYXNzZWQtc2l6ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gXCJjb2xvclwiOyAvL1wiY2xhc3NlZC1jb2xvclwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyZW5kZXJlci50eXBlID09PSBcInVuaXF1ZS12YWx1ZVwiKSB7XG4gICAgICAgIGlmIChyZW5kZXJlci52YWx1ZUV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIC8vIFRPRE8gQVBJIGJ1ZzsgZml4ZWQgaW4gNG1hc3RlclxuICAgICAgICAgICAgaWYgKChyZW5kZXJlci5hdXRob3JpbmdJbmZvICYmIHJlbmRlcmVyLmF1dGhvcmluZ0luZm8udHlwZSA9PT0gXCJwcmVkb21pbmFuY2VcIikgfHxcbiAgICAgICAgICAgICAgICByZW5kZXJlci52YWx1ZUV4cHJlc3Npb25UaXRsZSA9PT0gXCJQcmVkb21pbmFudCBjYXRlZ29yeVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1Zpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9IFwicHJlZG9taW5hbmNlLXNpemVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9IFwicHJlZG9taW5hbmNlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVuZGVyZXIuYXV0aG9yaW5nSW5mbyAmJiByZW5kZXJlci5hdXRob3JpbmdJbmZvLnR5cGUgPT09IFwicmVsYXRpb25zaGlwXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVmlzVmFyKHJlbmRlcmVyLCBcInNpemVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gXCJyZWxhdGlvbnNoaXAtc2l6ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gXCJyZWxhdGlvbnNoaXBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiKSkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9IFwidHlwZS1zaXplXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlclR5cGUgPSBcInR5cGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNTaXplVmlzVmFyKSB7XG4gICAgICAgICAgICBpZiAoYXV0aFNpemVWaXNWYXIgJiYgYXV0aFNpemVWaXNWYXIudW5pdHMpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlclR5cGUgPSBcInR5cGUtc2l6ZS1hZ2VcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9IFwidHlwZS1zaXplXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlclR5cGUgPSBcInR5cGVcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyZW5kZXJlci50eXBlID09PSBcInBpZS1jaGFydFwiKSB7XG4gICAgICAgIGlmIChoYXNWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiKSkge1xuICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gXCJjaGFydC1zaXplXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlclR5cGUgPSBcImNoYXJ0XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlcmVyVHlwZTtcbn1cbmZ1bmN0aW9uIGZpeE5vcm1hbGl6YXRpb25GaWVsZChyZW5kZXJlcikge1xuICAgIC8vIG90aGVyd2lzZSBsZWdlbmQgd2lsbCBzaG93IGxhYmVscyBmb3IgdGhlIG9ubHkgaW5mb1xuICAgIGNvbnN0IGNvbG9yVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcImNvbG9yXCIpO1xuICAgIGNvbnN0IHNpemVWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiKTtcbiAgICBjb25zdCByZW5kZXJlclR5cGUgPSBnZXRSZW5kZXJlclR5cGVGcm9tUmVuZGVyZXIocmVuZGVyZXIpO1xuICAgIGlmIChjb2xvclZpc1ZhciA9PT0gbnVsbCB8fCBjb2xvclZpc1ZhciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sb3JWaXNWYXIubm9ybWFsaXphdGlvbkZpZWxkKSB7XG4gICAgICAgIHJlbmRlcmVyLm5vcm1hbGl6YXRpb25GaWVsZCA9IGNvbG9yVmlzVmFyLm5vcm1hbGl6YXRpb25GaWVsZDtcbiAgICAgICAgcmVuZGVyZXIubm9ybWFsaXphdGlvblR5cGUgPSBcImZpZWxkXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKFtcImNvbG9yLXNpemVcIiwgXCJjb2xvci1hZ2Utc2l6ZVwiLCBcImNvbG9yLXNpemUtYWdlXCJdLmluZGV4T2YocmVuZGVyZXJUeXBlKSA+IC0xICYmIGNvbG9yVmlzVmFyKSB7XG4gICAgICAgIHJlbmRlcmVyLm5vcm1hbGl6YXRpb25GaWVsZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmVuZGVyZXIubm9ybWFsaXphdGlvblR5cGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlbmRlcmVyVHlwZSA9PT0gXCJzaXplXCIgJiYgKHNpemVWaXNWYXIgPT09IG51bGwgfHwgc2l6ZVZpc1ZhciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2l6ZVZpc1Zhci5ub3JtYWxpemF0aW9uRmllbGQpKSB7XG4gICAgICAgIHJlbmRlcmVyLm5vcm1hbGl6YXRpb25GaWVsZCA9IHNpemVWaXNWYXIubm9ybWFsaXphdGlvbkZpZWxkO1xuICAgICAgICByZW5kZXJlci5ub3JtYWxpemF0aW9uVHlwZSA9IFwiZmllbGRcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSZW5kZXJlckZpZWxkSW5mb3MobGF5ZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgIGxldCBmaWVsZEluZm9zID0gW107XG4gICAgY29uc3QgcmVuZGVyZXJUeXBlID0gZ2V0UmVuZGVyZXJUeXBlKCk7XG4gICAgc3dpdGNoIChyZW5kZXJlclR5cGUpIHtcbiAgICAgICAgY2FzZSBcInJlbGF0aW9uc2hpcFwiOlxuICAgICAgICBjYXNlIFwicmVsYXRpb25zaGlwLXNpemVcIjoge1xuICAgICAgICAgICAgZmllbGRJbmZvcyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiByZW5kZXJlci5hdXRob3JpbmdJbmZvLmZpZWxkMS5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgc2ltcGxlRmllbGRUeXBlOiBzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogcmVuZGVyZXIuYXV0aG9yaW5nSW5mby5maWVsZDIuZmllbGQsXG4gICAgICAgICAgICAgICAgICAgIHNpbXBsZUZpZWxkVHlwZTogc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZVZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIpO1xuICAgICAgICAgICAgaWYgKHNpemVWaXNWYXIpIHtcbiAgICAgICAgICAgICAgICAvLyByZWxhdGlvbnNoaXAgKyBzaXplXG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXRGaWVsZChzaXplVmlzVmFyLmZpZWxkKTtcbiAgICAgICAgICAgICAgICBmaWVsZEluZm9zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogc2l6ZVZpc1Zhci5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogc2l6ZVZpc1Zhci52YWx1ZUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25UaXRsZTogc2l6ZVZpc1Zhci52YWx1ZUV4cHJlc3Npb25UaXRsZSxcbiAgICAgICAgICAgICAgICAgICAgc2ltcGxlRmllbGRUeXBlOiBzaXplVmlzVmFyLmZpZWxkICYmIGZpZWxkID8gZmllbGQuc2ltcGxlRmllbGRUeXBlIDogc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJwcmVkb21pbmFuY2VcIjpcbiAgICAgICAgY2FzZSBcInByZWRvbWluYW5jZS1zaXplXCI6IHtcbiAgICAgICAgICAgIGZpZWxkSW5mb3MgPSByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zLm1hcCgoaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogXCJcIiArIGluZm8udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHNpbXBsZUZpZWxkVHlwZTogKChfYSA9IGdldEZpZWxkKFwiXCIgKyBpbmZvLnZhbHVlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpbXBsZUZpZWxkVHlwZSkgfHwgc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiY2hhcnRcIjpcbiAgICAgICAgY2FzZSBcImNoYXJ0LXNpemVcIjoge1xuICAgICAgICAgICAgZmllbGRJbmZvcyA9IHJlbmRlcmVyLmF0dHJpYnV0ZXMubWFwKChhdHRyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXRGaWVsZChhdHRyLmZpZWxkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogYXR0ci5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogYXR0ci52YWx1ZUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25UaXRsZTogYXR0ci52YWx1ZUV4cHJlc3Npb25UaXRsZSxcbiAgICAgICAgICAgICAgICAgICAgc2ltcGxlRmllbGRUeXBlOiBhdHRyLmZpZWxkICYmIGZpZWxkID8gZmllbGQuc2ltcGxlRmllbGRUeXBlIDogc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmllbGRJbmZvcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gZm91bmQgaXRcbiAgICAgICAgcmV0dXJuIGZpZWxkSW5mb3M7XG4gICAgfVxuICAgIHN3aXRjaCAocmVuZGVyZXIudHlwZSkge1xuICAgICAgICBjYXNlIFwiZG90LWRlbnNpdHlcIjoge1xuICAgICAgICAgICAgZmllbGRJbmZvcyA9IHJlbmRlcmVyLmF0dHJpYnV0ZXMubWFwKChhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGF0dHJpYnV0ZS5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgc2ltcGxlRmllbGRUeXBlOiAoKF9hID0gZ2V0RmllbGQoYXR0cmlidXRlLmZpZWxkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpbXBsZUZpZWxkVHlwZSkgfHwgc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiaGVhdG1hcFwiOiB7XG4gICAgICAgICAgICBjb25zdCBobVJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgICAgICBpZiAoaG1SZW5kZXJlci5maWVsZCkge1xuICAgICAgICAgICAgICAgIGZpZWxkSW5mb3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBobVJlbmRlcmVyLmZpZWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2ltcGxlRmllbGRUeXBlOiAoKF9hID0gZ2V0RmllbGQoaG1SZW5kZXJlci5maWVsZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaW1wbGVGaWVsZFR5cGUpIHx8IHNpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmllbGRJbmZvcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImNsYXNzLWJyZWFrc1wiOiB7XG4gICAgICAgICAgICBjb25zdCBjYlJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldEZpZWxkKGNiUmVuZGVyZXIuZmllbGQpO1xuICAgICAgICAgICAgZmllbGRJbmZvcyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBjYlJlbmRlcmVyLmZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiAhZmllbGQgPyBjYlJlbmRlcmVyLnZhbHVlRXhwcmVzc2lvbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblRpdGxlOiAhZmllbGQgPyBjYlJlbmRlcmVyLnZhbHVlRXhwcmVzc2lvblRpdGxlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBzaW1wbGVGaWVsZFR5cGU6IGNiUmVuZGVyZXIuZmllbGQgJiYgZmllbGQgPyBmaWVsZC5zaW1wbGVGaWVsZFR5cGUgOiBzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCBjb2xvclZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJjb2xvclwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNpemVWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGF1dGhDb2xvclZpc1ZhciA9IGdldEF1dGhWaXNWYXIocmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgICAgICAgICBjb25zdCBhdXRoU2l6ZVZpc1ZhciA9IGdldEF1dGhWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiKTtcbiAgICAgICAgICAgIGlmIChjb2xvclZpc1ZhciAmJiBzaXplVmlzVmFyKSB7XG4gICAgICAgICAgICAgICAgLy8gY29sb3IgKyBzaXplXG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yVmlzVmFyLmZpZWxkID09PSBzaXplVmlzVmFyLmZpZWxkICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yVmlzVmFyLnZhbHVlRXhwcmVzc2lvbiA9PT0gc2l6ZVZpc1Zhci52YWx1ZUV4cHJlc3Npb24gJiZcbiAgICAgICAgICAgICAgICAgICAgY29sb3JWaXNWYXIudmFsdWVFeHByZXNzaW9uVGl0bGUgPT09IHNpemVWaXNWYXIudmFsdWVFeHByZXNzaW9uVGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2FtZSBmaWVsZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldEZpZWxkKGNvbG9yVmlzVmFyLmZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbmZvcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogY29sb3JWaXNWYXIuZmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogIWZpZWxkID8gY29sb3JWaXNWYXIudmFsdWVFeHByZXNzaW9uIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25UaXRsZTogIWZpZWxkID8gY29sb3JWaXNWYXIudmFsdWVFeHByZXNzaW9uVGl0bGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2ltcGxlRmllbGRUeXBlOiBjb2xvclZpc1Zhci5maWVsZCAmJiBmaWVsZCA/IGZpZWxkLnNpbXBsZUZpZWxkVHlwZSA6IHNpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXV0aENvbG9yVmlzVmFyICYmIGF1dGhDb2xvclZpc1Zhci51bml0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29sb3ItYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZEluZm9zID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGF1dGhDb2xvclZpc1Zhci5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2ltcGxlRmllbGRUeXBlOiBzaW1wbGVGaWVsZFR5cGVzLkRBVEVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXRGaWVsZChjb2xvclZpc1Zhci5maWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZEluZm9zID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGNvbG9yVmlzVmFyLmZpZWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiAhZmllbGQgPyBjb2xvclZpc1Zhci52YWx1ZUV4cHJlc3Npb24gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25UaXRsZTogIWZpZWxkID8gY29sb3JWaXNWYXIudmFsdWVFeHByZXNzaW9uVGl0bGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsZUZpZWxkVHlwZTogY29sb3JWaXNWYXIuZmllbGQgJiYgZmllbGQgPyBmaWVsZC5zaW1wbGVGaWVsZFR5cGUgOiBzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1dGhTaXplVmlzVmFyICYmIGF1dGhTaXplVmlzVmFyLnVuaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaXplLWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRJbmZvcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogYXV0aFNpemVWaXNWYXIuZmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2ltcGxlRmllbGRUeXBlOiBzaW1wbGVGaWVsZFR5cGVzLkRBVEVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXRGaWVsZChzaXplVmlzVmFyLmZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkSW5mb3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHNpemVWaXNWYXIuZmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogIWZpZWxkID8gc2l6ZVZpc1Zhci52YWx1ZUV4cHJlc3Npb24gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblRpdGxlOiAhZmllbGQgPyBzaXplVmlzVmFyLnZhbHVlRXhwcmVzc2lvblRpdGxlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsZUZpZWxkVHlwZTogc2l6ZVZpc1Zhci5maWVsZCAmJiBmaWVsZCA/IGZpZWxkLnNpbXBsZUZpZWxkVHlwZSA6IHNpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbG9yVmlzVmFyKSB7XG4gICAgICAgICAgICAgICAgLy8gY29sb3JcbiAgICAgICAgICAgICAgICBpZiAoYXV0aENvbG9yVmlzVmFyICYmIGF1dGhDb2xvclZpc1Zhci51bml0cykge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEluZm9zID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBhdXRoQ29sb3JWaXNWYXIuZmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2ltcGxlRmllbGRUeXBlOiBzaW1wbGVGaWVsZFR5cGVzLkRBVEVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0RmllbGQoY29sb3JWaXNWYXIuZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEluZm9zID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBjb2xvclZpc1Zhci5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiAhZmllbGQgPyBjb2xvclZpc1Zhci52YWx1ZUV4cHJlc3Npb24gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblRpdGxlOiAhZmllbGQgPyBjb2xvclZpc1Zhci52YWx1ZUV4cHJlc3Npb25UaXRsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGVGaWVsZFR5cGU6IGNvbG9yVmlzVmFyLmZpZWxkICYmIGZpZWxkID8gZmllbGQuc2ltcGxlRmllbGRUeXBlIDogc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplVmlzVmFyKSB7XG4gICAgICAgICAgICAgICAgLy8gc2l6ZVxuICAgICAgICAgICAgICAgIGlmIChhdXRoU2l6ZVZpc1ZhciAmJiBhdXRoU2l6ZVZpc1Zhci51bml0cykge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEluZm9zID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBhdXRoU2l6ZVZpc1Zhci5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGVGaWVsZFR5cGU6IHNpbXBsZUZpZWxkVHlwZXMuREFURVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXRGaWVsZChzaXplVmlzVmFyLmZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbmZvcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogc2l6ZVZpc1Zhci5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiAhZmllbGQgPyBzaXplVmlzVmFyLnZhbHVlRXhwcmVzc2lvbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uVGl0bGU6ICFmaWVsZCA/IHNpemVWaXNWYXIudmFsdWVFeHByZXNzaW9uVGl0bGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2ltcGxlRmllbGRUeXBlOiBzaXplVmlzVmFyLmZpZWxkICYmIGZpZWxkID8gZmllbGQuc2ltcGxlRmllbGRUeXBlIDogc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXV0aENvbG9yVmlzVmFyICYmIGF1dGhDb2xvclZpc1Zhci5zdHlsZSAmJiBjb2xvclZpc1Zhci5ub3JtYWxpemF0aW9uRmllbGQpIHtcbiAgICAgICAgICAgICAgICAvLyBjb21wYXJlXG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXRGaWVsZChjb2xvclZpc1Zhci5maWVsZCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9ybUZpZWxkID0gZ2V0RmllbGQoY29sb3JWaXNWYXIubm9ybWFsaXphdGlvbkZpZWxkKTtcbiAgICAgICAgICAgICAgICBmaWVsZEluZm9zID0gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogY29sb3JWaXNWYXIuZmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGVGaWVsZFR5cGU6IGZpZWxkID8gZmllbGQuc2ltcGxlRmllbGRUeXBlIDogc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGNvbG9yVmlzVmFyLm5vcm1hbGl6YXRpb25GaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsZUZpZWxkVHlwZTogbm9ybUZpZWxkID8gbm9ybUZpZWxkLnNpbXBsZUZpZWxkVHlwZSA6IHNpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInVuaXF1ZS12YWx1ZVwiOiB7XG4gICAgICAgICAgICBpZiAocmVuZGVyZXIuYXV0aG9yaW5nSW5mbyAmJiByZW5kZXJlci5hdXRob3JpbmdJbmZvLnR5cGUgPT09IFwicHJlZG9taW5hbmNlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmVkb21pbmFuY2VcbiAgICAgICAgICAgICAgICBjb25zdCB1dlJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgICAgICAgICAgZmllbGRJbmZvcyA9IHV2UmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcy5tYXAoKGluZm8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXRGaWVsZChcIlwiICsgaW5mby52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogXCJcIiArIGluZm8udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGVGaWVsZFR5cGU6IGZpZWxkID8gZmllbGQuc2ltcGxlRmllbGRUeXBlIDogc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlbmRlcmVyLmF1dGhvcmluZ0luZm8gJiYgcmVuZGVyZXIuYXV0aG9yaW5nSW5mby50eXBlID09PSBcImNoYXJ0XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGFydFxuICAgICAgICAgICAgICAgIGNvbnN0IHV2UmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgICAgICAgICBmaWVsZEluZm9zID0gdXZSZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zLm1hcCgoaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldEZpZWxkKFwiXCIgKyBpbmZvLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBcIlwiICsgaW5mby52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsZUZpZWxkVHlwZTogZmllbGQgPyBmaWVsZC5zaW1wbGVGaWVsZFR5cGUgOiBzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVuZGVyZXIuYXV0aG9yaW5nSW5mbyAmJiByZW5kZXJlci5hdXRob3JpbmdJbmZvLnR5cGUgPT09IFwicmVsYXRpb25zaGlwXCIpIHtcbiAgICAgICAgICAgICAgICAvLyByZWxhdGlvbnNoaXBcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZDEgPSBnZXRGaWVsZChyZW5kZXJlci5hdXRob3JpbmdJbmZvLmZpZWxkMS5maWVsZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQyID0gZ2V0RmllbGQocmVuZGVyZXIuYXV0aG9yaW5nSW5mby5maWVsZDIuZmllbGQpO1xuICAgICAgICAgICAgICAgIGZpZWxkSW5mb3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiByZW5kZXJlci5hdXRob3JpbmdJbmZvLmZpZWxkMS5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsZUZpZWxkVHlwZTogZmllbGQxID8gZmllbGQxLnNpbXBsZUZpZWxkVHlwZSA6IHNpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiByZW5kZXJlci5hdXRob3JpbmdJbmZvLmZpZWxkMi5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsZUZpZWxkVHlwZTogZmllbGQyID8gZmllbGQyLnNpbXBsZUZpZWxkVHlwZSA6IHNpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdHlwZXNcbiAgICAgICAgICAgICAgICBjb25zdCB1dlJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXRGaWVsZCh1dlJlbmRlcmVyLmZpZWxkKTtcbiAgICAgICAgICAgICAgICBsZXQgcmV0dXJuVHlwZSA9IHNpbXBsZUZpZWxkVHlwZXMuTlVNQkVSO1xuICAgICAgICAgICAgICAgIGlmICh1dlJlbmRlcmVyLmZpZWxkICYmIGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBmaWVsZC5zaW1wbGVGaWVsZFR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHV2UmVuZGVyZXIudmFsdWVFeHByZXNzaW9uICYmXG4gICAgICAgICAgICAgICAgICAgIHV2UmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcyAmJlxuICAgICAgICAgICAgICAgICAgICB1dlJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3NbMF0gJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHV2UmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvc1swXS52YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gc2ltcGxlRmllbGRUeXBlcy5TVFJJTkc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpZWxkSW5mb3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiB1dlJlbmRlcmVyLmZpZWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogIWZpZWxkID8gdXZSZW5kZXJlci52YWx1ZUV4cHJlc3Npb24gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uVGl0bGU6ICFmaWVsZCA/IHV2UmVuZGVyZXIudmFsdWVFeHByZXNzaW9uVGl0bGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGVGaWVsZFR5cGU6IHJldHVyblR5cGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZVZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplVmlzVmFyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHR5cGUgKyBzaXplXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZE5hbWUgPSBzaXplVmlzVmFyLmZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWdlIHJlbmRlcmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdXRoU2l6ZVZpc1ZhciA9IGdldEF1dGhWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiKSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IGF1dGhTaXplVmlzVmFyLmZpZWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0RmllbGQoZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbmZvcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiAhZmllbGQgPyBzaXplVmlzVmFyLnZhbHVlRXhwcmVzc2lvbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25UaXRsZTogIWZpZWxkID8gc2l6ZVZpc1Zhci52YWx1ZUV4cHJlc3Npb25UaXRsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsZUZpZWxkVHlwZTogZmllbGROYW1lICYmIGZpZWxkID8gZmllbGQuc2ltcGxlRmllbGRUeXBlIDogc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWVsZEluZm9zO1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlSW5mbyh0aGVtZSwgc3RvcHMsIG5vU2VnbWVudCA9IGZhbHNlKSB7XG4gICAgaWYgKCFzdG9wcyB8fCBzdG9wcy5sZW5ndGggPT09IDUpIHtcbiAgICAgICAgc3dpdGNoICh0aGVtZSkge1xuICAgICAgICAgICAgY2FzZSBcImhpZ2gtdG8tbG93XCI6XG4gICAgICAgICAgICBjYXNlIFwiYWJvdmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJiZWxvd1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXNTeW5jZWRUb1ByaW1hcnk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5SGFuZGxlRW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHZpc2libGVFbGVtZW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVUcmFjazogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJhYm92ZS1hbmQtYmVsb3dcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVzU3luY2VkVG9QcmltYXJ5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUhhbmRsZUVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN5bmNlZFNlZ21lbnRzRW5hYmxlZDogIW5vU2VnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUVsZW1lbnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZVRyYWNrOiAhbm9TZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImNlbnRlcmVkLW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlc1N5bmNlZFRvUHJpbWFyeTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHByaW1hcnlIYW5kbGVFbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzeW5jZWRTZWdtZW50c0VuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZpc2libGVFbGVtZW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVUcmFjazogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJleHRyZW1lc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXNTeW5jZWRUb1ByaW1hcnk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5SGFuZGxlRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3luY2VkU2VnbWVudHNFbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlRWxlbWVudHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aXZlVHJhY2s6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoYW5kbGVzU3luY2VkVG9QcmltYXJ5OiBmYWxzZSxcbiAgICAgICAgICAgIHByaW1hcnlIYW5kbGVFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHZpc2libGVFbGVtZW50czoge1xuICAgICAgICAgICAgICAgIGludGVyYWN0aXZlVHJhY2s6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRCYXNlbWFwVHlwZShtYXBWaWV3KSB7XG4gICAgY29uc3QgYmFzZUxheWVyID0gbWFwVmlldy5tYXAuYmFzZW1hcC5iYXNlTGF5ZXJzLmdldEl0ZW1BdCgwKTtcbiAgICBpZiAoIWJhc2VMYXllci51cmwpIHtcbiAgICAgICAgaWYgKGJhc2VMYXllci5kZWNsYXJlZENsYXNzID09PSBcImVzcmkubGF5ZXJzLk9wZW5TdHJlZXRNYXBMYXllclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJvc21cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcInRvcG9cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1cmwgPSBiYXNlTGF5ZXIudXJsLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHVybC5pbmRleE9mKFwiYXJjZ2lzL3Jlc3Qvc2VydmljZXMvV29ybGRfU3RyZWV0X01hcFwiLnRvTG93ZXJDYXNlKCkpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIFwic3RyZWV0c1wiO1xuICAgIH1cbiAgICBlbHNlIGlmICh1cmwuaW5kZXhPZihcIkFyY0dJUy9yZXN0L3NlcnZpY2VzL0NhbnZhcy9Xb3JsZF9MaWdodF9HcmF5X0Jhc2VcIi50b0xvd2VyQ2FzZSgpKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBcImdyYXlcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAodXJsLmluZGV4T2YoXCJhcmNnaXMvcmVzdC9zZXJ2aWNlcy9Xb3JsZF9Ub3BvX01hcFwiLnRvTG93ZXJDYXNlKCkpID4gLTEgfHxcbiAgICAgICAgdXJsLmluZGV4T2YoXCJhcmNnaXMvcmVzdC9zZXJ2aWNlcy9VU0dTVG9wb1wiLnRvTG93ZXJDYXNlKCkpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIFwidG9wb1wiO1xuICAgIH1cbiAgICBlbHNlIGlmICh1cmwuaW5kZXhPZihcIkFyY0dJUy9yZXN0L3NlcnZpY2VzL1dvcmxkX1RlcnJhaW5fQmFzZVwiLnRvTG93ZXJDYXNlKCkpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIFwidGVycmFpblwiO1xuICAgIH1cbiAgICBlbHNlIGlmICh1cmwuaW5kZXhPZihcImFyY2dpcy9yZXN0L3NlcnZpY2VzL05hdEdlb19Xb3JsZF9NYXBcIi50b0xvd2VyQ2FzZSgpKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBcIm5hdGlvbmFsLWdlb2dyYXBoaWNcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAodXJsLmluZGV4T2YoXCJhcmNnaXMvcmVzdC9zZXJ2aWNlcy9PY2Vhbi9Xb3JsZF9PY2Vhbl9CYXNlXCIudG9Mb3dlckNhc2UoKSkgPiAtMSkge1xuICAgICAgICByZXR1cm4gXCJvY2VhbnNcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAodXJsLmluZGV4T2YoXCJhcmNnaXMvcmVzdC9zZXJ2aWNlcy9Xb3JsZF9JbWFnZXJ5XCIudG9Mb3dlckNhc2UoKSkgPiAtMSkge1xuICAgICAgICByZXR1cm4gXCJzYXRlbGxpdGVcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAodXJsLmluZGV4T2YoXCJBcmNHSVMvcmVzdC9zZXJ2aWNlcy9SZWZlcmVuY2UvV29ybGRfQm91bmRhcmllc19hbmRfUGxhY2VzXCIudG9Mb3dlckNhc2UoKSkgPiAtMSkge1xuICAgICAgICByZXR1cm4gXCJoeWJyaWRcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAodXJsLmluZGV4T2YoXCJhcmNnaXMvcmVzdC9zZXJ2aWNlcy9DYW52YXMvV29ybGRfRGFya19HcmF5X0Jhc2VcIi50b0xvd2VyQ2FzZSgpKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBcImRhcmstZ3JheVwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJ0b3BvXCI7XG59XG5mdW5jdGlvbiBnZXRab29tT3B0aW9ucyhzdG9wcywgdG90YWxNaW4sIHRvdGFsTWF4KSB7XG4gICAgaWYgKCFpc0RlZmluZWQkMSh0b3RhbE1pbikgfHwgIWlzRGVmaW5lZCQxKHRvdGFsTWF4KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbG93ZXJUaHVtYiA9IHN0b3BzWzBdLnZhbHVlO1xuICAgIGNvbnN0IHVwcGVyVGh1bWIgPSBzdG9wc1tzdG9wcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgICBjb25zdCByYW5nZSA9IHVwcGVyVGh1bWIgLSBsb3dlclRodW1iO1xuICAgIGNvbnN0IHBhZGRpbmcgPSByYW5nZSAqIDAuMztcbiAgICBjb25zdCB6b29tTWluID0gbG93ZXJUaHVtYiAtIHBhZGRpbmcgPiB0b3RhbE1pbiA/IGxvd2VyVGh1bWIgLSBwYWRkaW5nIDogbnVsbDtcbiAgICBjb25zdCB6b29tTWF4ID0gdXBwZXJUaHVtYiArIHBhZGRpbmcgPCB0b3RhbE1heCA/IHVwcGVyVGh1bWIgKyBwYWRkaW5nIDogbnVsbDtcbiAgICByZXR1cm4geyBtaW46IHpvb21NaW4sIG1heDogem9vbU1heCwgbWluTWF4U2FtZTogbG93ZXJUaHVtYiA9PT0gdXBwZXJUaHVtYiB9O1xufVxuZnVuY3Rpb24gdXBkYXRlUmVuZGVyZXIoKSB7XG4gICAgY29uc3QgeyBsYXllciwgbWFwSW1hZ2VTdWJsYXllciB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgaXNHZW9SU1MgPSBsYXllci5kZWNsYXJlZENsYXNzID09PSBcImVzcmkubGF5ZXJzLkdlb1JTU0xheWVyXCI7XG4gICAgaWYgKGlzR2VvUlNTKSB7XG4gICAgICAgIGNvbnN0IGdlb1JTU0xheWVyID0gbGF5ZXI7XG4gICAgICAgIGdlb1JTU0xheWVyLnBvaW50U3ltYm9sID0gZ2VvUlNTTGF5ZXIucG9pbnRTeW1ib2wuY2xvbmUoKTtcbiAgICAgICAgZ2VvUlNTTGF5ZXIubGluZVN5bWJvbCA9IGdlb1JTU0xheWVyLmxpbmVTeW1ib2wuY2xvbmUoKTtcbiAgICAgICAgZ2VvUlNTTGF5ZXIucG9seWdvblN5bWJvbCA9IGdlb1JTU0xheWVyLnBvbHlnb25TeW1ib2wuY2xvbmUoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFwcGx5UmVuZGVyZXIoZ2V0UmVuZGVyZXIobGF5ZXIpLmNsb25lKCksIGxheWVyKTtcbiAgICAgICAgaWYgKG1hcEltYWdlU3VibGF5ZXIpIHtcbiAgICAgICAgICAgIG1hcEltYWdlU3VibGF5ZXIucmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcikuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5UmVuZGVyZXIocmVuZGVyZXIsIGxheWVyKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChcImZlYXR1cmVSZWR1Y3Rpb25cIiBpbiBsYXllciAmJiAoKF9hID0gbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSBcImJpbm5pbmdcIikge1xuICAgICAgICBsYXllci5mZWF0dXJlUmVkdWN0aW9uLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKFwicmVuZGVyZXJcIiBpbiBsYXllcikge1xuICAgICAgICBsYXllci5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIH1cbn1cbi8qXG4gKiBBcHBseSByZW5kZXJlciB0byBsYXllciBhbmQgbWFwSW1hZ2VTdWJsYXllciBhbmQgbWFrZSBzdXJlIGl0IHdvcmtzIHdpdGggZmVhdHVyZVJlZHVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gYXBwbHlSZW5kZXJlclRvQWxsKG9yaWdpbmFsUmVuZGVyZXJKU09OLCBvcmlnaW5hbEZlYXR1cmVSZWR1Y3Rpb24pIHtcbiAgICBjb25zdCB7IGxheWVyLCBtYXBJbWFnZVN1YmxheWVyLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBpZiAob3JpZ2luYWxGZWF0dXJlUmVkdWN0aW9uICYmIFwiZmVhdHVyZVJlZHVjdGlvblwiIGluIGxheWVyKSB7XG4gICAgICAgIC8vIHRvIGF2b2lkIGVycm9ycyB3aGlsZSBuZXcgZmVhdHVyZVJlZHVjdGlvbiBkb2Vzbid0IGZpdCB0byBvcmlnIHJlbmRlcmVyXG4gICAgICAgIGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24gPSBudWxsO1xuICAgIH1cbiAgICBhcHBseVJlbmRlcmVyKG1vZHVsZXMucmVuZGVyZXJKc29uVXRpbHMuZnJvbUpTT04ob3JpZ2luYWxSZW5kZXJlckpTT04pLCBsYXllcik7XG4gICAgaWYgKG9yaWdpbmFsRmVhdHVyZVJlZHVjdGlvbiAmJiBcImZlYXR1cmVSZWR1Y3Rpb25cIiBpbiBsYXllcikge1xuICAgICAgICBsYXllci5mZWF0dXJlUmVkdWN0aW9uID0gb3JpZ2luYWxGZWF0dXJlUmVkdWN0aW9uO1xuICAgIH1cbiAgICBpZiAobWFwSW1hZ2VTdWJsYXllcikge1xuICAgICAgICBtYXBJbWFnZVN1YmxheWVyLnJlbmRlcmVyID0gbW9kdWxlcy5yZW5kZXJlckpzb25VdGlscy5mcm9tSlNPTihvcmlnaW5hbFJlbmRlcmVySlNPTik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UmVuZGVyZXIobGF5ZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKFwiZmVhdHVyZVJlZHVjdGlvblwiIGluIGxheWVyICYmICgoX2EgPSBsYXllci5mZWF0dXJlUmVkdWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IFwiYmlubmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBsYXllci5mZWF0dXJlUmVkdWN0aW9uLnJlbmRlcmVyO1xuICAgIH1cbiAgICByZXR1cm4gXCJyZW5kZXJlclwiIGluIGxheWVyICYmIGxheWVyLnJlbmRlcmVyO1xufVxuZnVuY3Rpb24gZ2V0UmVuZGVyZXJUaGVtZShzdWJUeXBlKSB7XG4gICAgY29uc3QgeyBsYXllciB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBcInJlbmRlcmVyXCIgaW4gbGF5ZXIgJiYgbGF5ZXIucmVuZGVyZXI7XG4gICAgY29uc3QgYXV0aEluZm8gPSBcImF1dGhvcmluZ0luZm9cIiBpbiByZW5kZXJlciAmJiByZW5kZXJlci5hdXRob3JpbmdJbmZvO1xuICAgIGNvbnN0IGF1dGhDb2xvclZpc1ZhciA9IGdldEF1dGhWaXNWYXIoZ2V0UmVuZGVyZXIobGF5ZXIpLCBcImNvbG9yXCIpO1xuICAgIGNvbnN0IGF1dGhTaXplVmlzVmFyID0gZ2V0QXV0aFZpc1ZhcihnZXRSZW5kZXJlcihsYXllciksIFwic2l6ZVwiKTtcbiAgICByZXR1cm4gKChzdWJUeXBlID09PSBcImNvbG9yXCJcbiAgICAgICAgPyBhdXRoQ29sb3JWaXNWYXIgPT09IG51bGwgfHwgYXV0aENvbG9yVmlzVmFyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdXRoQ29sb3JWaXNWYXIudGhlbWVcbiAgICAgICAgOiBzdWJUeXBlID09PSBcInNpemVcIlxuICAgICAgICAgICAgPyBhdXRoU2l6ZVZpc1ZhciA9PT0gbnVsbCB8fCBhdXRoU2l6ZVZpc1ZhciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXV0aFNpemVWaXNWYXIudGhlbWVcbiAgICAgICAgICAgIDogKGF1dGhJbmZvID09PSBudWxsIHx8IGF1dGhJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdXRoSW5mby51bml2YXJpYXRlVGhlbWUpIHx8IChhdXRoQ29sb3JWaXNWYXIgPT09IG51bGwgfHwgYXV0aENvbG9yVmlzVmFyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdXRoQ29sb3JWaXNWYXIudGhlbWUpIHx8IChhdXRoU2l6ZVZpc1ZhciA9PT0gbnVsbCB8fCBhdXRoU2l6ZVZpc1ZhciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXV0aFNpemVWaXNWYXIudGhlbWUpKSB8fCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzU2l6ZUNoYW5naW5nKGNsYXNzQnJlYWtJbmZvcykge1xuICAgIC8vIHRoaXMgZ2V0cyB0cmlja3ksIGJlY2F1c2UgdGhlIHVzZXIgY2FuIGNoYW5nZSBlYWNoIHN5bWJvbCB0byBhbnl0aGluZ1xuICAgIC8vIHNvIGlmIGF0IGxlYXN0IDIgc3ltYm9scyBoYXZlIHRoZSBzYW1lIGNvbG9yIHdlIGFzc3VtZSBzaXplXG4gICAgbGV0IGksIGs7XG4gICAgZm9yIChpID0gMDsgaSA8IGNsYXNzQnJlYWtJbmZvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzeW0xID0gY2xhc3NCcmVha0luZm9zW2ldLnN5bWJvbDtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGNsYXNzQnJlYWtJbmZvcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgY29uc3Qgc3ltMiA9IGNsYXNzQnJlYWtJbmZvc1trXS5zeW1ib2w7XG4gICAgICAgICAgICBpZiAoaSAhPT0gayAmJiBoYXNTYW1lQ29sb3Ioc3ltMSwgc3ltMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYXNTYW1lQ29sb3Ioc3ltMSwgc3ltMikge1xuICAgIGlmIChzeW0xLnR5cGUgPT0gXCJwaWN0dXJlLW1hcmtlclwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN5bTEuc3R5bGUgPT09IFwiY3Jvc3NcIiB8fCBzeW0xLnN0eWxlID09PSBcInhcIikge1xuICAgICAgICBpZiAoc3ltMi5zdHlsZSA9PT0gXCJjcm9zc1wiIHx8IHN5bTIuc3R5bGUgPT09IFwieFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gKCghc3ltMS5vdXRsaW5lLmNvbG9yICYmICFzeW0yLm91dGxpbmUuY29sb3IpIHx8XG4gICAgICAgICAgICAgICAgKHN5bTEub3V0bGluZS5jb2xvciAmJiBzeW0yLm91dGxpbmUuY29sb3IgJiYgc3ltMS5vdXRsaW5lLmNvbG9yLnRvU3RyaW5nKCkgPT09IHN5bTIub3V0bGluZS5jb2xvci50b1N0cmluZygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKCghc3ltMS5vdXRsaW5lLmNvbG9yICYmICFzeW0yLmNvbG9yKSB8fFxuICAgICAgICAgICAgICAgIChzeW0xLm91dGxpbmUuY29sb3IgJiYgc3ltMi5jb2xvciAmJiBzeW0xLm91dGxpbmUuY29sb3IudG9TdHJpbmcoKSA9PT0gc3ltMi5jb2xvci50b1N0cmluZygpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChzeW0yLnN0eWxlID09PSBcImNyb3NzXCIgfHwgc3ltMi5zdHlsZSA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiAoKCFzeW0xLmNvbG9yICYmICFzeW0yLm91dGxpbmUuY29sb3IpIHx8XG4gICAgICAgICAgICAgICAgKHN5bTEuY29sb3IgJiYgc3ltMi5vdXRsaW5lLmNvbG9yICYmIHN5bTEuY29sb3IudG9TdHJpbmcoKSA9PT0gc3ltMi5vdXRsaW5lLmNvbG9yLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoKCFzeW0xLmNvbG9yICYmICFzeW0yLmNvbG9yKSB8fCAoc3ltMS5jb2xvciAmJiBzeW0yLmNvbG9yICYmIHN5bTEuY29sb3IudG9TdHJpbmcoKSA9PT0gc3ltMi5jb2xvci50b1N0cmluZygpKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kQ29sb3JTY2hlbWUodGhlbWUpIHtcbiAgICAvLyB0aGVtZSBpcyBvcHRpb25hbFxuICAgIGNvbnN0IHsgbGF5ZXIsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgIGNvbnN0IHJlbmRlcmVyVHlwZSA9IGdldFJlbmRlcmVyVHlwZSgpO1xuICAgIGlmIChbXCJ1bmlxdWUtc2l6ZVwiLCBcInVuaXF1ZS1zaXplLWFnZVwiXS5pbmRleE9mKHJlbmRlcmVyVHlwZSkgPiAtMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gdHJ5IHRvIGZpZ3VyZSB0aGlzIG91dFxuICAgIGxldCBtYXRjaGluZ1NjaGVtZXM7XG4gICAgY29uc3QgY29sb3JWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgY29uc3QgaW5mb3MgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MgPyByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MgOiByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zO1xuICAgIGxldCBjb2xvcnM7XG4gICAgaWYgKGNvbG9yVmlzVmFyKSB7XG4gICAgICAgIGNvbG9ycyA9IGNvbG9yVmlzVmFyLnN0b3BzLm1hcCgoc3RvcCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3AuY29sb3I7XG4gICAgICAgIH0pO1xuICAgICAgICBtYXRjaGluZ1NjaGVtZXMgPSBtb2R1bGVzLmNvbG9yU2NoZW1lcy5nZXRNYXRjaGluZ1NjaGVtZXMoe1xuICAgICAgICAgICAgdGhlbWU6IHRoZW1lIHx8IFwiaGlnaC10by1sb3dcIixcbiAgICAgICAgICAgIGNvbG9yczogY29sb3JzLFxuICAgICAgICAgICAgZ2VvbWV0cnlUeXBlOiBnZXRHZW9tZXRyeVR5cGUobGF5ZXIpIHx8IGRlZmF1bHRHZW9tZXRyeVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5mb3MgJiYgaW5mb3MubGVuZ3RoID49IDEpIHtcbiAgICAgICAgY29sb3JzID0gaW5mb3NcbiAgICAgICAgICAgID8gaW5mb3NcbiAgICAgICAgICAgICAgICAubWFwKChpbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFN5bWJvbENvbG9yKGluZm8uc3ltYm9sKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoY29sb3IpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAoY29sb3JzICYmIGNvbG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChjb2xvcnMubGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgICAgICBjb2xvcnMgPSBjb2xvcnMuc2xpY2UoMCwgOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaGluZ1NjaGVtZXMgPSBnZXRNYXRjaGluZ1NjaGVtZXMoY29sb3JzLCB0aGVtZSk7XG4gICAgICAgIH0gLy8gZWxzZSBtaWdodCBoYXZlIHBvaW50LWNsb3VkIHRhZ1xuICAgIH1cbiAgICBpZiAobWF0Y2hpbmdTY2hlbWVzICYmIG1hdGNoaW5nU2NoZW1lcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nU2NoZW1lc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRNYXRjaGluZ1NjaGVtZXMoY29sb3JzLCB0aGVtZSkge1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGxldCBtYXRjaGluZ1NjaGVtZXMgPSBtb2R1bGVzLmNvbG9yU2NoZW1lcy5nZXRNYXRjaGluZ1NjaGVtZXMoe1xuICAgICAgICB0aGVtZTogdGhlbWUgfHwgXCJoaWdoLXRvLWxvd1wiLFxuICAgICAgICBjb2xvcnM6IGNvbG9ycyxcbiAgICAgICAgZ2VvbWV0cnlUeXBlOiBnZXRHZW9tZXRyeVR5cGUobGF5ZXIpIHx8IGRlZmF1bHRHZW9tZXRyeVxuICAgIH0pO1xuICAgIGlmICh0aGVtZSAmJiAoIW1hdGNoaW5nU2NoZW1lcyB8fCAhbWF0Y2hpbmdTY2hlbWVzLmxlbmd0aCkpIHtcbiAgICAgICAgbWF0Y2hpbmdTY2hlbWVzID0gbW9kdWxlcy5jb2xvclNjaGVtZXMuZ2V0TWF0Y2hpbmdTY2hlbWVzKHtcbiAgICAgICAgICAgIHRoZW1lOiBcImhpZ2gtdG8tbG93XCIsXG4gICAgICAgICAgICBjb2xvcnM6IGNvbG9ycyxcbiAgICAgICAgICAgIGdlb21ldHJ5VHlwZTogZ2V0R2VvbWV0cnlUeXBlKGxheWVyKSB8fCBkZWZhdWx0R2VvbWV0cnlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghbWF0Y2hpbmdTY2hlbWVzIHx8ICFtYXRjaGluZ1NjaGVtZXMubGVuZ3RoKSB7XG4gICAgICAgIG1hdGNoaW5nU2NoZW1lcyA9IG1vZHVsZXMuY29sb3JTY2hlbWVzLmdldE1hdGNoaW5nU2NoZW1lcyh7XG4gICAgICAgICAgICB0aGVtZTogXCJhYm92ZS1hbmQtYmVsb3dcIixcbiAgICAgICAgICAgIGNvbG9yczogY29sb3JzLFxuICAgICAgICAgICAgZ2VvbWV0cnlUeXBlOiBnZXRHZW9tZXRyeVR5cGUobGF5ZXIpIHx8IGRlZmF1bHRHZW9tZXRyeVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoaW5nU2NoZW1lcztcbn1cbmZ1bmN0aW9uIGZpbmRSZWxhdGlvbnNoaXBTY2hlbWUoKSB7XG4gICAgY29uc3QgeyBsYXllciwgbWFwVmlldywgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgY29uc3QgaW5mb3MgPSByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zO1xuICAgIGlmICghaW5mb3MgfHwgaW5mb3MubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudE51bUNsYXNzZXMgPSBNYXRoLnNxcnQoaW5mb3MubGVuZ3RoKTtcbiAgICBjb25zdCBzY2hlbWVzID0gbW9kdWxlcy5yZWxhdGlvbnNoaXBTY2hlbWVzLmdldFNjaGVtZXMoe1xuICAgICAgICBiYXNlbWFwOiBtYXBWaWV3Lm1hcC5iYXNlbWFwIHx8IFwidG9wb1wiLFxuICAgICAgICBnZW9tZXRyeVR5cGU6IGdldEdlb21ldHJ5VHlwZShsYXllcilcbiAgICB9KTtcbiAgICBjb25zdCBhbGxTY2hlbWVzID0gW3NjaGVtZXMucHJpbWFyeVNjaGVtZV0uY29uY2F0KHNjaGVtZXMuc2Vjb25kYXJ5U2NoZW1lcyk7XG4gICAgY29uc3QgbWF0Y2hpbmdTY2hlbWVzID0gW107XG4gICAgYWxsU2NoZW1lcy5mb3JFYWNoKChzY2hlbWUpID0+IHtcbiAgICAgICAgbGV0IGFsbENvbG9ycyA9IFtdO1xuICAgICAgICBzY2hlbWUuY29sb3JzRm9yQ2xhc3NCcmVha3NbY3VycmVudE51bUNsYXNzZXMgLSAyXS5jb2xvcnMuZm9yRWFjaCgoYXJyKSA9PiB7XG4gICAgICAgICAgICBhbGxDb2xvcnMgPSBhbGxDb2xvcnMuY29uY2F0KG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoYXJyKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYXNOb01hdGNoID0gaW5mb3Muc29tZSgoaW5mbykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBnZXRTeW1ib2xDb2xvcihpbmZvLnN5bWJvbCk7XG4gICAgICAgICAgICAvLyBvcmRlciBkb2Vzbid0IG1hdHRlclxuICAgICAgICAgICAgcmV0dXJuICFjb2xvciA/IGZhbHNlIDogIWFsbENvbG9ycy5maW5kKChhbGxDb2xvcikgPT4gaXNTYW1lQ29sb3IoYWxsQ29sb3IsIGNvbG9yKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWhhc05vTWF0Y2gpIHtcbiAgICAgICAgICAgIG1hdGNoaW5nU2NoZW1lcy5wdXNoKHNjaGVtZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWF0Y2hpbmdTY2hlbWVzLmxlbmd0aCA/IG1hdGNoaW5nU2NoZW1lc1swXSA6IG51bGw7XG59XG5mdW5jdGlvbiBmaW5kVHlwZVNjaGVtZSgpIHtcbiAgICBjb25zdCB7IGxheWVyLCBtYXBWaWV3LCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICBpZiAoIXJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3MgfHwgcmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzY2hlbWVzID0gbW9kdWxlcy50eXBlU2NoZW1lcy5nZXRTY2hlbWVzKHtcbiAgICAgICAgYmFzZW1hcDogbWFwVmlldy5tYXAuYmFzZW1hcCxcbiAgICAgICAgZ2VvbWV0cnlUeXBlOiBnZXRHZW9tZXRyeVR5cGUobGF5ZXIpIHx8IGRlZmF1bHRHZW9tZXRyeVxuICAgIH0pO1xuICAgIHJldHVybiBmaW5kU2NoZW1lKHNjaGVtZXMpO1xufVxuZnVuY3Rpb24gZmluZFByZWRvbWluYW5jZVNjaGVtZSgpIHtcbiAgICBjb25zdCB7IGxheWVyLCBtYXBWaWV3LCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICBpZiAoIXJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3MgfHwgcmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzY2hlbWVzID0gbW9kdWxlcy5wcmVkb21pbmFuY2VTY2hlbWVzLmdldFNjaGVtZXMoe1xuICAgICAgICBiYXNlbWFwOiBtYXBWaWV3Lm1hcC5iYXNlbWFwLFxuICAgICAgICBnZW9tZXRyeVR5cGU6IGdldEdlb21ldHJ5VHlwZShsYXllciksXG4gICAgICAgIG51bUNvbG9yczogMTAgLy9yZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zLmxlbmd0aFxuICAgIH0pO1xuICAgIHJldHVybiBmaW5kU2NoZW1lKHNjaGVtZXMpO1xufVxuZnVuY3Rpb24gZmluZFBpZUNoYXJ0U2NoZW1lKCkge1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1hcFZpZXcsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgIGlmICghcmVuZGVyZXIuYXR0cmlidXRlcyB8fCByZW5kZXJlci5hdHRyaWJ1dGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNjaGVtZXMgPSBtb2R1bGVzLnBpZUNoYXJ0U2NoZW1lcy5nZXRTY2hlbWVzKHtcbiAgICAgICAgYmFzZW1hcDogbWFwVmlldy5tYXAuYmFzZW1hcCxcbiAgICAgICAgZ2VvbWV0cnlUeXBlOiBnZXRHZW9tZXRyeVR5cGUobGF5ZXIpLFxuICAgICAgICBudW1Db2xvcnM6IDEwIC8vcmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcy5sZW5ndGhcbiAgICB9KTtcbiAgICByZXR1cm4gZmluZFNjaGVtZShzY2hlbWVzKTtcbn1cbmZ1bmN0aW9uIGZpbmRIZWF0bWFwU2NoZW1lKCkge1xuICAgIC8vIHRoZW1lIGlzIG9wdGlvbmFsXG4gICAgY29uc3QgeyBsYXllciwgbWFwVmlldywgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgLy8gdHJ5IHRvIGZpZ3VyZSB0aGlzIG91dFxuICAgIGxldCBjb2xvcnM7XG4gICAgY29sb3JzID0gcmVuZGVyZXIuY29sb3JTdG9wc1xuICAgICAgICAuZmlsdGVyKChfXywgaWR4KSA9PiBpZHggPj0gMylcbiAgICAgICAgLm1hcCgoc3RvcCkgPT4ge1xuICAgICAgICByZXR1cm4gc3RvcC5jb2xvcjtcbiAgICB9KTtcbiAgICBjb25zdCBzY2hlbWVzID0gbW9kdWxlcy5oZWF0bWFwU2NoZW1lcy5nZXRTY2hlbWVzKHtcbiAgICAgICAgYmFzZW1hcDogbWFwVmlldy5tYXAuYmFzZW1hcCB8fCBcInRvcG9cIiAvLyBUT0RPXG4gICAgfSk7XG4gICAgY29uc3QgYWxsU2NoZW1lcyA9IFtzY2hlbWVzLnByaW1hcnlTY2hlbWVdLmNvbmNhdChzY2hlbWVzLnNlY29uZGFyeVNjaGVtZXMpO1xuICAgIGNvbnN0IG1hdGNoaW5nU2NoZW1lcyA9IFtdO1xuICAgIGFsbFNjaGVtZXMuZm9yRWFjaCgoc2NoZW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc05vTWF0Y2ggPSBjb2xvcnMuc29tZSgoY29sb3IsIGlkeCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICFpc1NhbWVDb2xvcihzY2hlbWUuY29sb3JzW2lkeF0sIGNvbG9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaGFzTm9NYXRjaCkge1xuICAgICAgICAgICAgbWF0Y2hpbmdTY2hlbWVzLnB1c2goc2NoZW1lKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtYXRjaGluZ1NjaGVtZXMubGVuZ3RoID8gbWF0Y2hpbmdTY2hlbWVzWzBdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRTY2hlbWUoc2NoZW1lcykge1xuICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgIGNvbnN0IGluZm9zID0gcmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcztcbiAgICBpZiAoIWluZm9zIHx8IGluZm9zLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yUmFtcHNBbmRTY2hlbWVzID0gZ2V0Q29sb3JSYW1wc1dpdGhTY2hlbWVzKHNjaGVtZXMsIE1hdGgubWluKGluZm9zLmxlbmd0aCwgMTApKTtcbiAgICBjb25zdCBtYXRjaGluZ1NjaGVtZXMgPSBbXTtcbiAgICBjb2xvclJhbXBzQW5kU2NoZW1lcy5mb3JFYWNoKChyYW1wKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc05vTWF0Y2ggPSBpbmZvc1xuICAgICAgICAgICAgLmZpbHRlcigoX18sIGlkeCkgPT4gaWR4IDwgMTApXG4gICAgICAgICAgICAuc29tZSgoaW5mbywgaWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IGdldFN5bWJvbENvbG9yKGluZm8uc3ltYm9sKTtcbiAgICAgICAgICAgIHJldHVybiAhY29sb3IgPyBmYWxzZSA6ICFpc1NhbWVDb2xvcihyYW1wLmNvbG9yc1tpZHhdLCBjb2xvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWhhc05vTWF0Y2gpIHtcbiAgICAgICAgICAgIG1hdGNoaW5nU2NoZW1lcy5wdXNoKHJhbXAuc2NoZW1lKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtYXRjaGluZ1NjaGVtZXMubGVuZ3RoID8gbWF0Y2hpbmdTY2hlbWVzWzBdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFByaW1hcnlUeXBlU2NoZW1lKCkge1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1hcFZpZXcsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IHNjaGVtZXMgPSBtb2R1bGVzLnR5cGVTY2hlbWVzLmdldFNjaGVtZXMoe1xuICAgICAgICBiYXNlbWFwOiBtYXBWaWV3Lm1hcC5iYXNlbWFwLFxuICAgICAgICBnZW9tZXRyeVR5cGU6IGdldEdlb21ldHJ5VHlwZShsYXllcikgfHwgZGVmYXVsdEdlb21ldHJ5XG4gICAgfSk7XG4gICAgcmV0dXJuIHNjaGVtZXMucHJpbWFyeVNjaGVtZTtcbn1cbmZ1bmN0aW9uIGlzU2FtZUNvbG9yKGEsIGIpIHtcbiAgICBpZiAoYS5yID09PSBiLnIgJiYgYS5nID09PSBiLmcgJiYgYS5iID09PSBiLmIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29sb3JSYW1wc1dpdGhTY2hlbWVzKHNjaGVtZXMsIG51bUNsYXNzZXMpIHtcbiAgICBjb25zdCBhbGxTY2hlbWVzID0gX3VuaWZ5KHNjaGVtZXMpLCBjb2xvclJhbXBzQW5kU2NoZW1lcyA9IFtdO1xuICAgIGFsbFNjaGVtZXMuZm9yRWFjaCgoc2NoZW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzQ2xhc3NlZCA9IG51bUNsYXNzZXMgPiAwLCBoYXNDb2xvcnNGb3JDbGFzc0JyZWFrcyA9ICEhc2NoZW1lLmNvbG9yc0ZvckNsYXNzQnJlYWtzO1xuICAgICAgICBsZXQgY29sb3JzO1xuICAgICAgICBpZiAoaXNDbGFzc2VkKSB7XG4gICAgICAgICAgICBjb2xvcnMgPSBoYXNDb2xvcnNGb3JDbGFzc0JyZWFrc1xuICAgICAgICAgICAgICAgID8gX21heFN1cHBvcnRlZENsYXNzQnJlYWtDb2xvcnMoc2NoZW1lLmNvbG9yc0ZvckNsYXNzQnJlYWtzLCBudW1DbGFzc2VzKVxuICAgICAgICAgICAgICAgIDogc2NoZW1lLmNvbG9ycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbG9ycyA9IHNjaGVtZS5jb2xvcnM7XG4gICAgICAgIH1cbiAgICAgICAgY29sb3JSYW1wc0FuZFNjaGVtZXMucHVzaCh7XG4gICAgICAgICAgICBjb2xvcnMsXG4gICAgICAgICAgICBzY2hlbWVcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbG9yUmFtcHNBbmRTY2hlbWVzO1xufVxuZnVuY3Rpb24gZ2V0RmlsbENvbG9ycyhzY2hlbWVzKSB7XG4gICAgY29uc3QgYWxsU2NoZW1lcyA9IF91bmlmeShzY2hlbWVzKTtcbiAgICBsZXQgZmlsbENvbG9ycyA9IFtdO1xuICAgIGFsbFNjaGVtZXMuZm9yRWFjaChmdW5jdGlvbiAoc2NoZW1lKSB7XG4gICAgICAgIGlmIChzY2hlbWUuY29sb3JzKSB7XG4gICAgICAgICAgICBmaWxsQ29sb3JzID0gZmlsbENvbG9ycy5jb25jYXQoc2NoZW1lLmNvbG9ycyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3JlbW92ZUR1cGxpY2F0ZXMoZmlsbENvbG9ycyk7XG59XG5mdW5jdGlvbiBfdW5pZnkoc2NoZW1lcykge1xuICAgIHJldHVybiBbc2NoZW1lcy5wcmltYXJ5U2NoZW1lXS5jb25jYXQoc2NoZW1lcy5zZWNvbmRhcnlTY2hlbWVzKTtcbn1cbmZ1bmN0aW9uIF9tYXhTdXBwb3J0ZWRDbGFzc0JyZWFrQ29sb3JzKGNvbG9yc0ZvckNsYXNzQnJlYWtzLCBudW1DbGFzc2VzKSB7XG4gICAgY29uc3QgdG90YWxDb2xvcnNGb3JDbGFzc0JyZWFrcyA9IGNvbG9yc0ZvckNsYXNzQnJlYWtzLmxlbmd0aDtcbiAgICBsZXQgY29sb3JzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbENvbG9yc0ZvckNsYXNzQnJlYWtzOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29sb3JGb3JDbGFzc0JyZWFrcyA9IGNvbG9yc0ZvckNsYXNzQnJlYWtzW2ldO1xuICAgICAgICBpZiAobnVtQ2xhc3NlcyA8IGNvbG9yRm9yQ2xhc3NCcmVha3MubnVtQ2xhc3Nlcykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29sb3JzID0gY29sb3JGb3JDbGFzc0JyZWFrcy5jb2xvcnM7XG4gICAgfVxuICAgIHJldHVybiBjb2xvcnM7XG59XG5mdW5jdGlvbiBfcmVtb3ZlRHVwbGljYXRlcyhjb2xvcnMpIHtcbiAgICBjb25zdCB1c2VkSGV4Q29sb3JzID0ge307XG4gICAgcmV0dXJuIGNvbG9ycy5maWx0ZXIoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IHVudXNlZENvbG9yID0gIXVzZWRIZXhDb2xvcnNbY29sb3IudG9IZXgoKV07XG4gICAgICAgIGlmICh1bnVzZWRDb2xvcikge1xuICAgICAgICAgICAgdXNlZEhleENvbG9yc1tjb2xvci50b0hleCgpXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVudXNlZENvbG9yO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0U3ltYm9sKGxheWVyLCBtYXBWaWV3LCByZW5kZXJlclR5cGUpIHtcbiAgICBjb25zdCB7IG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IHN5bWJvbEluZm8gPSBtb2R1bGVzLnR5cGVTY2hlbWVzLmdldFNjaGVtZXMoe1xuICAgICAgICB0aGVtZTogXCJkZWZhdWx0XCIsXG4gICAgICAgIGJhc2VtYXA6IGdldEJhc2VtYXBUeXBlKG1hcFZpZXcpLFxuICAgICAgICBnZW9tZXRyeVR5cGU6IGdldEdlb21ldHJ5VHlwZShsYXllcilcbiAgICB9KS5wcmltYXJ5U2NoZW1lO1xuICAgIGxldCBkZWZhdWx0U3ltYm9sO1xuICAgIGlmIChpc1BvaW50VHlwZShsYXllcikgfHxcbiAgICAgICAgKHJlbmRlcmVyVHlwZSAmJlxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwic2l6ZVwiLFxuICAgICAgICAgICAgICAgIFwiY29sb3Itc2l6ZVwiLFxuICAgICAgICAgICAgICAgIFwiY29sb3ItYWdlLXNpemVcIixcbiAgICAgICAgICAgICAgICBcImNvbG9yLXNpemUtYWdlXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvci1hZ2Utc2l6ZS1hZ2VcIixcbiAgICAgICAgICAgICAgICBcInR5cGUtc2l6ZVwiLFxuICAgICAgICAgICAgICAgIFwicHJlZG9taW5hbmNlLXNpemVcIixcbiAgICAgICAgICAgICAgICBcImNoYXJ0LXNpemVcIixcbiAgICAgICAgICAgICAgICBcInJlbGF0aW9uc2hpcC1zaXplXCJcbiAgICAgICAgICAgIF0uaW5kZXhPZihyZW5kZXJlclR5cGUpID4gLTEpKSB7XG4gICAgICAgIGNvbnN0IG91dGxpbmVTeW0gPSBuZXcgbW9kdWxlcy5TaW1wbGVMaW5lU3ltYm9sKHtcbiAgICAgICAgICAgIHN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgICAgICBjb2xvcjogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKHN5bWJvbEluZm8ub3V0bGluZS5jb2xvciksXG4gICAgICAgICAgICB3aWR0aDogc3ltYm9sSW5mby5vdXRsaW5lLndpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICBkZWZhdWx0U3ltYm9sID0gbmV3IG1vZHVsZXMuU2ltcGxlTWFya2VyU3ltYm9sKHtcbiAgICAgICAgICAgIHN0eWxlOiBcImNpcmNsZVwiLFxuICAgICAgICAgICAgc2l6ZTogc3ltYm9sSW5mby5zaXplLFxuICAgICAgICAgICAgb3V0bGluZTogb3V0bGluZVN5bSxcbiAgICAgICAgICAgIGNvbG9yOiBzeW1ib2xJbmZvLm5vRGF0YUNvbG9yXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1BvbHlnb25UeXBlKGxheWVyKSkge1xuICAgICAgICBjb25zdCBvdXRsaW5lU3ltID0gbmV3IG1vZHVsZXMuU2ltcGxlTGluZVN5bWJvbCh7XG4gICAgICAgICAgICBzdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihzeW1ib2xJbmZvLm91dGxpbmUuY29sb3IpLFxuICAgICAgICAgICAgd2lkdGg6IHN5bWJvbEluZm8ub3V0bGluZS53aWR0aFxuICAgICAgICB9KTtcbiAgICAgICAgZGVmYXVsdFN5bWJvbCA9IG5ldyBtb2R1bGVzLlNpbXBsZUZpbGxTeW1ib2woe1xuICAgICAgICAgICAgc3R5bGU6IFwic29saWRcIixcbiAgICAgICAgICAgIG91dGxpbmU6IG91dGxpbmVTeW0sXG4gICAgICAgICAgICBjb2xvcjogc3ltYm9sSW5mby5ub0RhdGFDb2xvclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQb2x5bGluZVR5cGUobGF5ZXIpKSB7XG4gICAgICAgIGRlZmF1bHRTeW1ib2wgPSBuZXcgbW9kdWxlcy5TaW1wbGVMaW5lU3ltYm9sKHtcbiAgICAgICAgICAgIHN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgICAgICBjb2xvcjogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKHN5bWJvbEluZm8ubm9EYXRhQ29sb3IpLFxuICAgICAgICAgICAgd2lkdGg6IHN5bWJvbEluZm8ud2lkdGhcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3ltYm9sO1xufVxuZnVuY3Rpb24gZ2V0R2VvUlNTRGVmYXVsdFN5bWJvbChtYXBWaWV3LCB0eXBlKSB7XG4gICAgY29uc3QgeyBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCBzeW1ib2xJbmZvID0gbW9kdWxlcy50eXBlU2NoZW1lcy5nZXRTY2hlbWVzKHtcbiAgICAgICAgdGhlbWU6IFwiZGVmYXVsdFwiLFxuICAgICAgICBiYXNlbWFwOiBnZXRCYXNlbWFwVHlwZShtYXBWaWV3KSxcbiAgICAgICAgZ2VvbWV0cnlUeXBlOiB0eXBlID09PSBcImxpbmVcIiA/IFwicG9seWxpbmVcIiA6IHR5cGVcbiAgICB9KS5wcmltYXJ5U2NoZW1lO1xuICAgIGxldCBkZWZhdWx0U3ltYm9sO1xuICAgIGlmICh0eXBlID09PSBcInBvaW50XCIpIHtcbiAgICAgICAgY29uc3Qgb3V0bGluZVN5bSA9IG5ldyBtb2R1bGVzLlNpbXBsZUxpbmVTeW1ib2woe1xuICAgICAgICAgICAgc3R5bGU6IFwic29saWRcIixcbiAgICAgICAgICAgIGNvbG9yOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3Ioc3ltYm9sSW5mby5vdXRsaW5lLmNvbG9yKSxcbiAgICAgICAgICAgIHdpZHRoOiBzeW1ib2xJbmZvLm91dGxpbmUud2lkdGhcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZmF1bHRTeW1ib2wgPSBuZXcgbW9kdWxlcy5TaW1wbGVNYXJrZXJTeW1ib2woe1xuICAgICAgICAgICAgc3R5bGU6IFwiY2lyY2xlXCIsXG4gICAgICAgICAgICBzaXplOiBzeW1ib2xJbmZvLnNpemUsXG4gICAgICAgICAgICBvdXRsaW5lOiBvdXRsaW5lU3ltLFxuICAgICAgICAgICAgY29sb3I6IHN5bWJvbEluZm8ubm9EYXRhQ29sb3JcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwicG9seWdvblwiKSB7XG4gICAgICAgIGNvbnN0IG91dGxpbmVTeW0gPSBuZXcgbW9kdWxlcy5TaW1wbGVMaW5lU3ltYm9sKHtcbiAgICAgICAgICAgIHN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgICAgICBjb2xvcjogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKHN5bWJvbEluZm8ub3V0bGluZS5jb2xvciksXG4gICAgICAgICAgICB3aWR0aDogc3ltYm9sSW5mby5vdXRsaW5lLndpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICBkZWZhdWx0U3ltYm9sID0gbmV3IG1vZHVsZXMuU2ltcGxlRmlsbFN5bWJvbCh7XG4gICAgICAgICAgICBzdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICAgICAgb3V0bGluZTogb3V0bGluZVN5bSxcbiAgICAgICAgICAgIGNvbG9yOiBzeW1ib2xJbmZvLm5vRGF0YUNvbG9yXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcImxpbmVcIikge1xuICAgICAgICBkZWZhdWx0U3ltYm9sID0gbmV3IG1vZHVsZXMuU2ltcGxlTGluZVN5bWJvbCh7XG4gICAgICAgICAgICBzdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihzeW1ib2xJbmZvLm5vRGF0YUNvbG9yKSxcbiAgICAgICAgICAgIHdpZHRoOiBzeW1ib2xJbmZvLndpZHRoXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN5bWJvbDtcbn1cbi8qKlxuICogdG8gZ2V0IHRoZSBkZWZhdWx0IHN5bWJvbCBmb3IgUmFzdGVyIGxheWVyc1xuICovXG5mdW5jdGlvbiBnZXRSYXN0ZXJEZWZhdWx0U3ltYm9sKCkge1xuICAgIGNvbnN0IHsgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgcmV0dXJuIG5ldyBtb2R1bGVzLlNpbXBsZUZpbGxTeW1ib2woe1xuICAgICAgICBjb2xvcjogWzE4NCwgMTg0LCAxODQsIDFdLFxuICAgICAgICBzdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICBvdXRsaW5lOiB7XG4gICAgICAgICAgICAvLyBhdXRvY2FzdHMgYXMgbmV3IFNpbXBsZUxpbmVTeW1ib2woKVxuICAgICAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgICAgIHdpZHRoOiAxXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzU3ltYm9sVHJhbnNwYXJlbnQoc3ltYm9sKSB7XG4gICAgaWYgKCFzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaXNUcmFuc3BhcmVudCA9IGZhbHNlO1xuICAgIGNvbnN0IGNvbG9yID0gZ2V0U3ltYm9sQ29sb3Ioc3ltYm9sKTtcbiAgICBpZiAoc3ltYm9sICYmIHN5bWJvbC5kZWNsYXJlZENsYXNzID09PSBcImVzcmkuc3ltYm9scy5TaW1wbGVGaWxsU3ltYm9sXCIpIHtcbiAgICAgICAgY29uc3Qgb3V0bGluZSA9IHN5bWJvbC5vdXRsaW5lO1xuICAgICAgICBpZiAoKCFjb2xvciB8fCBjb2xvci5hID09PSAwKSAmJiAoIW91dGxpbmUgfHwgIW91dGxpbmUuY29sb3IgfHwgb3V0bGluZS5jb2xvci5hID09PSAwKSkge1xuICAgICAgICAgICAgaXNUcmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc3ltYm9sICYmIHN5bWJvbC5kZWNsYXJlZENsYXNzID09PSBcImVzcmkuc3ltYm9scy5TaW1wbGVMaW5lU3ltYm9sXCIpIHtcbiAgICAgICAgaWYgKCFjb2xvciB8fCBjb2xvci5hID09PSAwKSB7XG4gICAgICAgICAgICBpc1RyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wgJiYgc3ltYm9sLmRlY2xhcmVkQ2xhc3MgPT09IFwiZXNyaS5zeW1ib2xzLlNpbXBsZU1hcmtlclN5bWJvbFwiKSB7XG4gICAgICAgIGNvbnN0IG91dGxpbmUgPSBzeW1ib2wub3V0bGluZTtcbiAgICAgICAgaWYgKCghY29sb3IgfHwgY29sb3IuYSA9PT0gMCkgJiYgKCFvdXRsaW5lIHx8ICFvdXRsaW5lLmNvbG9yIHx8IG91dGxpbmUuY29sb3IuYSA9PT0gMCkpIHtcbiAgICAgICAgICAgIGlzVHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc1RyYW5zcGFyZW50O1xufVxuZnVuY3Rpb24gaXNTeW1ib2xBbG1vc3RXaGl0ZShzeW1ib2wpIHtcbiAgICBjb25zdCB7IG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgY29uc3QgY29udHJhc3QgPSBtb2R1bGVzLnByZXZpZXdTeW1ib2wyRC5nZXRDb250cmFzdGluZ0JhY2tncm91bmRUaGVtZShzeW1ib2wsIDI0NSk7XG4gICAgICAgIHJldHVybiBjb250cmFzdCA9PT0gXCJkYXJrXCI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFN5bWJvbENvbG9yKHN5bWJvbCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICByZXR1cm4gKHN5bWJvbCA9PT0gbnVsbCB8fCBzeW1ib2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN5bWJvbC50eXBlKSA9PT0gXCJjaW1cIlxuICAgICAgICA/IG1vZHVsZXMuZXNyaUNvbG9yLmZyb21KU09OKChfYSA9IG1vZHVsZXMuY2ltU3ltYm9sVXRpbHMuZ2V0Q0lNU3ltYm9sQ29sb3Ioc3ltYm9sKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvSlNPTigpKVxuICAgICAgICA6IChzeW1ib2wgPT09IG51bGwgfHwgc3ltYm9sID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzeW1ib2wudHlwZSkgPT09IFwic2ltcGxlLW1hcmtlclwiICYmIFtcInhcIiwgXCJjcm9zc1wiXS5pbmRleE9mKHN5bWJvbCA9PT0gbnVsbCB8fCBzeW1ib2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN5bWJvbC5zdHlsZSkgPiAtMVxuICAgICAgICAgICAgPyAoX2IgPSBzeW1ib2wgPT09IG51bGwgfHwgc3ltYm9sID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzeW1ib2wub3V0bGluZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbG9yXG4gICAgICAgICAgICA6IHN5bWJvbCA9PT0gbnVsbCB8fCBzeW1ib2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN5bWJvbC5jb2xvcjtcbn1cbmZ1bmN0aW9uIGFwcGx5U3ltYm9sQ29sb3Ioc3ltLCBjb2xvcikge1xuICAgIGNvbnN0IHsgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgaWYgKHN5bS50eXBlID09PSBcInBpY3R1cmUtbWFya2VyXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3ltLnR5cGUgPT09IFwiY2ltXCIpIHtcbiAgICAgICAgbW9kdWxlcy5jaW1TeW1ib2xVdGlscy5hcHBseUNJTVN5bWJvbENvbG9yKHN5bSwgY29sb3IpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzeW0udHlwZSA9PT0gXCJzaW1wbGUtbWFya2VyXCIgJiYgc3ltLnN0eWxlICYmIFtcImNyb3NzXCIsIFwieFwiXS5pbmRleE9mKHN5bS5zdHlsZSkgPiAtMSkge1xuICAgICAgICBpZiAoIXN5bS5vdXRsaW5lKSB7XG4gICAgICAgICAgICBzeW0ub3V0bGluZSA9IG5ldyBfX2VzcmkuU2ltcGxlTGluZVN5bWJvbCgpO1xuICAgICAgICB9XG4gICAgICAgIHN5bS5vdXRsaW5lLmNvbG9yID0gY29sb3I7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzeW0uY29sb3IgPSBjb2xvcjtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseUFscGhhKGNvbG9yLCBhbHBoYSkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgICBjb2xvci5hID0gYWxwaGE7XG4gICAgfVxuICAgIHJldHVybiBjb2xvcjtcbn1cbmZ1bmN0aW9uIGdldFN5bWJvbFNpemUoc3ltKSB7XG4gICAgY29uc3QgeyBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBpZiAoc3ltLnR5cGUgPT09IFwiY2ltXCIpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZXMuY2ltU3ltYm9sVXRpbHMuZ2V0Q0lNU3ltYm9sU2l6ZShzeW0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzeW0uc2l6ZSkge1xuICAgICAgICByZXR1cm4gc3ltLnNpemU7XG4gICAgfVxuICAgIHJldHVybiBzeW0ud2lkdGg7XG59XG5mdW5jdGlvbiBhcHBseVN5bWJvbFNpemUoc3ltLCBzaXplKSB7XG4gICAgY29uc3QgeyBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBpZiAoc3ltLnR5cGUgPT09IFwiY2ltXCIpIHtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBjaGFuZ2UgdGhlIG91dGxpbmUgaGVyZS4uLlxuICAgICAgICAvL2NvbnN0IG91dGxpbmUgPSBnZXRDaW1MaW5lKHN5bSk7XG4gICAgICAgIC8vY29uc3Qgd2lkdGggPSBvdXRsaW5lPy53aWR0aDtcbiAgICAgICAgLy8gc3ltYm9sIHN0eWxlciBkb2Vzbid0IHVzZSBwcmVzZXJ2ZU91dGxpbmVXaWR0aCwgc28gY29tcGFyaW5nIENJTXMgaXMgbm90IGdvaW5nIHRvIHdvcmtcbiAgICAgICAgbW9kdWxlcy5jaW1TeW1ib2xVdGlscy5zY2FsZUNJTVN5bWJvbFRvKHN5bSwgc2l6ZSAvKiAsIHsgcHJlc2VydmVPdXRsaW5lV2lkdGg6IHRydWUgfSAqLyk7XG4gICAgICAgIC8vaWYgKG91dGxpbmUgJiYgW1wiQ0lNUG9pbnRTeW1ib2xcIiwgXCJDSU1Qb2x5Z29uU3ltYm9sXCJdLmluZGV4T2Yoc3ltLmRhdGEuc3ltYm9sLnR5cGUpID4gLTEpIHtcbiAgICAgICAgLy8gc2V0IG91dGxpbmUgd2lkdGggYmFja1xuICAgICAgICAvLyAgb3V0bGluZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICAvL31cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZWZpbmVkJDEoc3ltLnNpemUpKSB7XG4gICAgICAgIHN5bS5zaXplID0gc2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gc3ltLmhlaWdodCAvIHN5bS53aWR0aDtcbiAgICAgICAgc3ltLndpZHRoID0gc2l6ZTtcbiAgICAgICAgc3ltLmhlaWdodCA9IHN5bS53aWR0aCAqIHJhdGlvO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENJTU91dGxpbmVXaWR0aChzeW1ib2wpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIC8vIGp1c3QgdGFrZSBmaXJzdCBzdHJva2VcbiAgICBjb25zdCBzdHJva2UgPSAoX2EgPSBzeW1ib2wuZGF0YS5zeW1ib2wuc3ltYm9sTGF5ZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZCgoc3ltYm9sTGF5ZXIpID0+IFtcIkNJTVNvbGlkU3Ryb2tlXCIsIFwiQ0lNUGljdHVyZVN0cm9rZVwiXS5pbmRleE9mKHN5bWJvbExheWVyLnR5cGUpID4gLTEpO1xuICAgIHJldHVybiAoX2IgPSBzdHJva2UgPT09IG51bGwgfHwgc3Ryb2tlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJva2Uud2lkdGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG59XG5mdW5jdGlvbiBnZXRTeW1ib2xSb3RhdGlvbihzeW0pIHtcbiAgICBjb25zdCB7IG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGlmIChzeW0udHlwZSA9PT0gXCJjaW1cIikge1xuICAgICAgICByZXR1cm4gbW9kdWxlcy5jaW1TeW1ib2xVdGlscy5nZXRDSU1TeW1ib2xSb3RhdGlvbihzeW0sIHRydWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChbXCJzaW1wbGUtbWFya2VyXCIsIFwicGljdHVyZS1tYXJrZXJcIl0uaW5kZXhPZihzeW0udHlwZSkgPiAtMSkge1xuICAgICAgICByZXR1cm4gc3ltLmFuZ2xlO1xuICAgIH1cbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiBhcHBseVN5bWJvbFJvdGF0aW9uKHN5bSwgYW5nbGUpIHtcbiAgICBjb25zdCB7IG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGlmIChhbmdsZSA9PT0gbnVsbCB8fCBhbmdsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN5bS50eXBlID09PSBcImNpbVwiKSB7XG4gICAgICAgIG1vZHVsZXMuY2ltU3ltYm9sVXRpbHMuYXBwbHlDSU1TeW1ib2xSb3RhdGlvbihzeW0sIGFuZ2xlLCB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoW1wic2ltcGxlLW1hcmtlclwiLCBcInBpY3R1cmUtbWFya2VyXCJdLmluZGV4T2Yoc3ltLnR5cGUpID4gLTEpIHtcbiAgICAgICAgc3ltLmFuZ2xlID0gYW5nbGU7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzU3ltYm9sT3V0bGluZShzeW0pIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIHN5bS50eXBlID09PSBcInBpY3R1cmUtbWFya2VyXCJcbiAgICAgICAgPyBmYWxzZVxuICAgICAgICA6IHN5bS50eXBlID09PSBcImNpbVwiXG4gICAgICAgICAgICA/IFsvKiBcIkNJTVBvaW50U3ltYm9sXCIsICovIFwiQ0lNUG9seWdvblN5bWJvbFwiXS5pbmRleE9mKHN5bS5kYXRhLnN5bWJvbC50eXBlKSA+IC0xICYmICEhZ2V0Q2ltTGluZShzeW0pXG4gICAgICAgICAgICA6ICEhKChfYSA9IHN5bS5vdXRsaW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29sb3IpO1xufVxuZnVuY3Rpb24gc3dpdGNoTWFya2Vyc1RvUG9seWdvbnMocmVuZGVyZXIsIHBvbHlnb25TeW1ib2wpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICgoX2EgPSByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGluZm9zID0gcmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcy5zbGljZSgpO1xuICAgICAgICBpbmZvcy5tYXAoKGluZm8pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IHBvbHlnb25TeW1ib2wuY2xvbmUoKTtcbiAgICAgICAgICAgIGFwcGx5U3ltYm9sQ29sb3Ioc3ltYm9sLCBnZXRTeW1ib2xDb2xvcihpbmZvLnN5bWJvbCkpO1xuICAgICAgICAgICAgaW5mby5zeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zID0gaW5mb3M7XG4gICAgfVxuICAgIGVsc2UgaWYgKChfYiA9IHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBpbmZvcyA9IHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcy5zbGljZSgpO1xuICAgICAgICBpbmZvcy5tYXAoKGluZm8pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IHBvbHlnb25TeW1ib2wuY2xvbmUoKTtcbiAgICAgICAgICAgIGFwcGx5U3ltYm9sQ29sb3Ioc3ltYm9sLCBnZXRTeW1ib2xDb2xvcihpbmZvLnN5bWJvbCkpO1xuICAgICAgICAgICAgaW5mby5zeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MgPSBpbmZvcztcbiAgICB9XG4gICAgZWxzZSBpZiAocmVuZGVyZXIuc3ltYm9sKSB7XG4gICAgICAgIGNvbnN0IHN5bWJvbCA9IHBvbHlnb25TeW1ib2wuY2xvbmUoKTtcbiAgICAgICAgYXBwbHlTeW1ib2xDb2xvcihzeW1ib2wsIGdldFN5bWJvbENvbG9yKHJlbmRlcmVyLnN5bWJvbCkpO1xuICAgICAgICByZW5kZXJlci5zeW1ib2wgPSBzeW1ib2w7XG4gICAgfVxufVxuZnVuY3Rpb24gc3dpdGNoUG9seWdvbnNUb01hcmtlcnMocmVuZGVyZXIsIG1hcmtlclN5bWJvbCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKChfYSA9IHJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaW5mb3MgPSByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zLnNsaWNlKCk7XG4gICAgICAgIGluZm9zLm1hcCgoaW5mbykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3ltYm9sID0gbWFya2VyU3ltYm9sLmNsb25lKCk7XG4gICAgICAgICAgICBhcHBseVN5bWJvbENvbG9yKHN5bWJvbCwgZ2V0U3ltYm9sQ29sb3IoaW5mby5zeW1ib2wpKTtcbiAgICAgICAgICAgIGluZm8uc3ltYm9sID0gc3ltYm9sO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcyA9IGluZm9zO1xuICAgIH1cbiAgICBlbHNlIGlmICgoX2IgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaW5mb3MgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3Muc2xpY2UoKTtcbiAgICAgICAgaW5mb3MubWFwKChpbmZvKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzeW1ib2wgPSBtYXJrZXJTeW1ib2wuY2xvbmUoKTtcbiAgICAgICAgICAgIGFwcGx5U3ltYm9sQ29sb3Ioc3ltYm9sLCBnZXRTeW1ib2xDb2xvcihpbmZvLnN5bWJvbCkpO1xuICAgICAgICAgICAgaW5mby5zeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MgPSBpbmZvcztcbiAgICB9XG4gICAgZWxzZSBpZiAocmVuZGVyZXIuc3ltYm9sKSB7XG4gICAgICAgIGNvbnN0IHN5bWJvbCA9IG1hcmtlclN5bWJvbC5jbG9uZSgpO1xuICAgICAgICBhcHBseVN5bWJvbENvbG9yKHN5bWJvbCwgZ2V0U3ltYm9sQ29sb3IocmVuZGVyZXIuc3ltYm9sKSk7XG4gICAgICAgIHJlbmRlcmVyLnN5bWJvbCA9IHN5bWJvbDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0NpbUxpbmVTeW1ib2woc3ltKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBzeW0udHlwZSA9PT0gXCJjaW1cIiAmJiAoKF9hID0gc3ltLmRhdGEuc3ltYm9sKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IFwiQ0lNTGluZVN5bWJvbFwiO1xufVxuZnVuY3Rpb24gZ2V0Q2ltTGluZShzeW0pIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBpZiAoKChfYSA9IHN5bS5kYXRhLnN5bWJvbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSBcIkNJTVBvaW50U3ltYm9sXCIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy9nZXRDaW1Qb2ludE91dGxpbmUoc3ltKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKChfYiA9IHN5bS5kYXRhLnN5bWJvbCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnR5cGUpID09PSBcIkNJTUxpbmVTeW1ib2xcIikge1xuICAgICAgICByZXR1cm4gZ2V0Q2ltTGluZUxpbmUoc3ltKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKChfYyA9IHN5bS5kYXRhLnN5bWJvbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnR5cGUpID09PSBcIkNJTVBvbHlnb25TeW1ib2xcIikge1xuICAgICAgICByZXR1cm4gZ2V0Q2ltUG9seWdvbk91dGxpbmUoc3ltKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDaW1MaW5lTGluZShzeW0pIHtcbiAgICBjb25zdCBzeW1ib2xMYXllcnMgPSBzeW0uZGF0YS5zeW1ib2wuc3ltYm9sTGF5ZXJzO1xuICAgIHJldHVybiBzeW1ib2xMYXllcnNbMF07XG59XG5mdW5jdGlvbiBnZXRDaW1Qb2x5Z29uT3V0bGluZShzeW0pIHtcbiAgICAvLyB3ZSBjYW4gYXNzdW1lIHRoZSB0b3Agc3Ryb2tlIGxheWVyIG9uIHBvbHlnb25zIGlzIGFuIG91dGxpbmVcbiAgICBjb25zdCBzeW1ib2xMYXllcnMgPSBzeW0uZGF0YS5zeW1ib2wuc3ltYm9sTGF5ZXJzO1xuICAgIHJldHVybiBzeW1ib2xMYXllcnMuZmluZCgoc2wpID0+IHNsLnR5cGUgPT09IFwiQ0lNU29saWRTdHJva2VcIik7XG59XG5mdW5jdGlvbiBpc0ZpbGxPbmx5Q0lNKHN5bSkge1xuICAgIGNvbnN0IHsgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgcmV0dXJuICEhbW9kdWxlcy5jaW1TeW1ib2xVdGlscy5nZXRDSU1TeW1ib2xDb2xvcihzeW0pO1xufVxuZnVuY3Rpb24gbGF5ZXJTdXBwb3J0c0NJTSgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBtYXBJbWFnZVN1YmxheWVyLCBsYXllciB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgaWYgKG1hcEltYWdlU3VibGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuICEhKChfYSA9IGxheWVyLnNvdXJjZUpTT04pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jaW1WZXJzaW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKmZ1bmN0aW9uIGhhc0ZpbGwoc3ltYm9sTGF5ZXJzOiBhbnlbXSk6IGJvb2xlYW4ge1xuICByZXR1cm4gc3ltYm9sTGF5ZXJzPy5maW5kKChzbDogYW55KSA9PiBzbC50eXBlID09PSBcIkNJTVNvbGlkRmlsbFwiKTtcbn1cblxuZnVuY3Rpb24gaGFzVW5sb2NrZWRGaWxsKHN5bWJvbExheWVyczogYW55W10pOiBib29sZWFuIHtcbiAgcmV0dXJuIHN5bWJvbExheWVycz8uZmluZCgoc2w6IGFueSkgPT4gc2wudHlwZSA9PT0gXCJDSU1Tb2xpZEZpbGxcIiAmJiAhc2wuY29sb3JMb2NrZWQpO1xufVxuXG5mdW5jdGlvbiBoYXNTdHJva2Uoc3ltYm9sTGF5ZXJzOiBhbnlbXSk6IGJvb2xlYW4ge1xuICByZXR1cm4gc3ltYm9sTGF5ZXJzPy5maW5kKChzbDogYW55KSA9PiBzbC50eXBlID09PSBcIkNJTVNvbGlkU3Ryb2tlXCIpO1xufVxuXG5mdW5jdGlvbiBoYXNGaWxsQW5kU3Ryb2tlKHN5bWJvbExheWVyczogYW55W10pOiBib29sZWFuIHtcbiAgcmV0dXJuIGhhc0ZpbGwoc3ltYm9sTGF5ZXJzKSAmJiBoYXNTdHJva2Uoc3ltYm9sTGF5ZXJzKTtcbn1cblxuZnVuY3Rpb24gaGFzVW5sb2NrZWRGaWxsQW5kU3Ryb2tlKHN5bWJvbExheWVyczogYW55W10pOiBib29sZWFuIHtcbiAgcmV0dXJuIGhhc1VubG9ja2VkRmlsbChzeW1ib2xMYXllcnMpICYmIGhhc1N0cm9rZShzeW1ib2xMYXllcnMpO1xufSAqL1xuZnVuY3Rpb24gaXNMaW5lTWFya2VyKHN5bSkge1xuICAgIGlmIChzeW0uc3R5bGUgJiYgW1wiY3Jvc3NcIiwgXCJ4XCJdLmluZGV4T2Yoc3ltLnN0eWxlKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1BpY3R1cmVNYXJrZXIoc3ltKSB7XG4gICAgaWYgKHN5bS50eXBlID09PSBcInBpY3R1cmUtbWFya2VyXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN5bS50eXBlID09PSBcImNpbVwiICYmICFpc0ZpbGxPbmx5Q0lNKHN5bSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFJlbmRlclByZXZpZXdTaXplKHN5bWJvbCkge1xuICAgIHJldHVybiBzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbGluZVwiXG4gICAgICAgID8ge1xuICAgICAgICAgICAgd2lkdGg6IDEyLFxuICAgICAgICAgICAgaGVpZ2h0OiAzXG4gICAgICAgIH1cbiAgICAgICAgOiBzeW1ib2wudHlwZSA9PT0gXCJjaW1cIiAmJiBzeW1ib2wuZGF0YS5zeW1ib2wudHlwZSA9PT0gXCJDSU1MaW5lU3ltYm9sXCJcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IHN5bWJvbC50eXBlID09PSBcInNpbXBsZS1maWxsXCJcbiAgICAgICAgICAgICAgICA/IDE0IC8qIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEyLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyXG4gICAgICAgICAgICAgICAgICB9IGJlY2F1c2UgQ0lNcyBzdGlsbCBoYXZlIHRoZSBub24tc3F1YXJlIHNoYXBlICovXG4gICAgICAgICAgICAgICAgOiBzeW1ib2wudHlwZSA9PT0gXCJjaW1cIiAmJiBzeW1ib2wuZGF0YS5zeW1ib2wudHlwZSA9PT0gXCJDSU1Qb2x5Z29uU3ltYm9sXCJcbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiBzeW1ib2wudHlwZSA9PT0gXCJjaW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyAyMFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAxNDtcbn1cbmZ1bmN0aW9uIGdldFN5bWJvbENoYW5nZXMobmV3U3ltLCBsYXN0U3ltKSB7XG4gICAgLy8gcHJvcHMgb25seSByZXR1cm4gdHJ1ZSBpZiB0aG9zZSBhcmUgdGhlIG9ubHkgY2hhbmdlcyBpbiB0aGUgc3ltYm9sXG4gICAgLy8geyByb3RhdGlvbjogYm9vbGVhbiwgc2l6ZTogYm9vbGVhbiwgY29sb3I6IGJvb2xlYW4gfVxuICAgIC8vY29uc29sZS5sb2coXCJuZXdTeW0gLSBzaXplXCIsIGdldFN5bWJvbFNpemUobmV3U3ltKSwgSlNPTi5zdHJpbmdpZnkobmV3U3ltLnRvSlNPTigpKSk7XG4gICAgLy9jb25zb2xlLmxvZyhcImxhc3RTeW0gLSBzaXplXCIsIGdldFN5bWJvbFNpemUobGFzdFN5bSksIEpTT04uc3RyaW5naWZ5KGxhc3RTeW0udG9KU09OKCkpKTtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgaWYgKG5ld1N5bS50eXBlICE9PSBsYXN0U3ltLnR5cGUpIHtcbiAgICAgICAgLyogY29uc29sZS5sb2coXG4gICAgICAgICAgXCIqIGdldFN5bWJvbENoYW5nZXMgKlwiLFxuICAgICAgICAgIFwiaGFzUm90YXRpb25DaGFuZ2VzOlwiLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiaGFzU2l6ZUNoYW5nZXM6XCIsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJoYXNPdXRsaW5lQ2hhbmdlczpcIixcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcImhhc0NvbG9yQ2hhbmdlczpcIixcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcImhhc090aGVyQ2hhbmdlczpcIixcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7ICovXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoYXNPdGhlckNoYW5nZXM6IHRydWUsXG4gICAgICAgICAgICBhbnk6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaGFzUm90YXRpb25DaGFuZ2VzID0gZ2V0U3ltYm9sUm90YXRpb24obmV3U3ltKSAhPT0gZ2V0U3ltYm9sUm90YXRpb24obGFzdFN5bSk7XG4gICAgLy8gY29uc2lkZXIgcm91bmRpbmcgaXNzdWVzIGJldHdlZW4gcHQgYW5kIHB4IGNvbnZlcnNpb25zXG4gICAgY29uc3QgaGFzU2l6ZUNoYW5nZXMgPSBNYXRoLmFicyhnZXRTeW1ib2xTaXplKG5ld1N5bSkgLSBnZXRTeW1ib2xTaXplKGxhc3RTeW0pKSA+IDAuMDE7XG4gICAgY29uc3QgaGFzQ29sb3JDaGFuZ2VzID0gSlNPTi5zdHJpbmdpZnkoKF9hID0gZ2V0U3ltYm9sQ29sb3IobmV3U3ltKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvSlNPTigpKSAhPT0gSlNPTi5zdHJpbmdpZnkoKF9iID0gZ2V0U3ltYm9sQ29sb3IobGFzdFN5bSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b0pTT04oKSk7XG4gICAgY29uc3QgaGFzT3V0bGluZUNoYW5nZXMgPSBbXCJzaW1wbGUtbWFya2VyXCIsIFwic2ltcGxlLWZpbGxcIl0uaW5kZXhPZihuZXdTeW0udHlwZSkgPiAtMVxuICAgICAgICA/IEpTT04uc3RyaW5naWZ5KChfYyA9IG5ld1N5bS5vdXRsaW5lKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9KU09OKCkpICE9PSBKU09OLnN0cmluZ2lmeSgoX2QgPSBsYXN0U3ltLm91dGxpbmUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50b0pTT04oKSlcbiAgICAgICAgOiBmYWxzZTtcbiAgICBjb25zdCB0ZW1wU3ltID0gbmV3U3ltLmNsb25lKCk7XG4gICAgYXBwbHlTeW1ib2xTaXplKHRlbXBTeW0sIGdldFN5bWJvbFNpemUobGFzdFN5bSkpO1xuICAgIGFwcGx5U3ltYm9sQ29sb3IodGVtcFN5bSwgZ2V0U3ltYm9sQ29sb3IobGFzdFN5bSkpO1xuICAgIGlmIChbXCJzaW1wbGUtbWFya2VyXCIsIFwic2ltcGxlLWZpbGxcIl0uaW5kZXhPZihuZXdTeW0udHlwZSkgPiAtMSkge1xuICAgICAgICB0ZW1wU3ltLm91dGxpbmUgPSBsYXN0U3ltLm91dGxpbmUuY2xvbmUoKTtcbiAgICB9XG4gICAgYXBwbHlTeW1ib2xSb3RhdGlvbih0ZW1wU3ltLCBnZXRTeW1ib2xSb3RhdGlvbihsYXN0U3ltKSk7XG4gICAgLy9jb25zb2xlLmxvZyhcInRlbXBTeW0gLSBzaXplXCIsIGdldFN5bWJvbFNpemUodGVtcFN5bSksIEpTT04uc3RyaW5naWZ5KHRlbXBTeW0udG9KU09OKCkpKTtcbiAgICBjb25zdCBoYXNPdGhlckNoYW5nZXMgPSAhaXNTYW1lU3ltYm9sKHRlbXBTeW0sIGxhc3RTeW0pO1xuICAgIC8qIGNvbnNvbGUubG9nKFxuICAgICAgXCIqIGdldFN5bWJvbENoYW5nZXMgKlwiLFxuICAgICAgXCJoYXNSb3RhdGlvbkNoYW5nZXM6XCIsXG4gICAgICBoYXNSb3RhdGlvbkNoYW5nZXMsXG4gICAgICBcImhhc1NpemVDaGFuZ2VzOlwiLFxuICAgICAgaGFzU2l6ZUNoYW5nZXMsXG4gICAgICBcImhhc091dGxpbmVDaGFuZ2VzOlwiLFxuICAgICAgaGFzT3V0bGluZUNoYW5nZXMsXG4gICAgICBcImhhc0NvbG9yQ2hhbmdlczpcIixcbiAgICAgIGhhc0NvbG9yQ2hhbmdlcyxcbiAgICAgIFwiaGFzT3RoZXJDaGFuZ2VzOlwiLFxuICAgICAgaGFzT3RoZXJDaGFuZ2VzXG4gICAgKTsgKi9cbiAgICByZXR1cm4ge1xuICAgICAgICByb3RhdGlvbjogaGFzUm90YXRpb25DaGFuZ2VzICYmICFoYXNTaXplQ2hhbmdlcyAmJiAhaGFzQ29sb3JDaGFuZ2VzICYmICFoYXNPdXRsaW5lQ2hhbmdlcyAmJiAhaGFzT3RoZXJDaGFuZ2VzLFxuICAgICAgICBzaXplOiBoYXNTaXplQ2hhbmdlcyAmJiAhaGFzUm90YXRpb25DaGFuZ2VzICYmICFoYXNDb2xvckNoYW5nZXMgJiYgIWhhc091dGxpbmVDaGFuZ2VzICYmICFoYXNPdGhlckNoYW5nZXMsXG4gICAgICAgIG91dGxpbmU6IGhhc091dGxpbmVDaGFuZ2VzICYmICFoYXNSb3RhdGlvbkNoYW5nZXMgJiYgIWhhc1NpemVDaGFuZ2VzICYmICFoYXNDb2xvckNoYW5nZXMgJiYgIWhhc090aGVyQ2hhbmdlcyxcbiAgICAgICAgY29sb3I6IGhhc0NvbG9yQ2hhbmdlcyAmJiAhaGFzUm90YXRpb25DaGFuZ2VzICYmICFoYXNTaXplQ2hhbmdlcyAmJiAhaGFzT3V0bGluZUNoYW5nZXMgJiYgIWhhc090aGVyQ2hhbmdlcyxcbiAgICAgICAgb3RoZXI6IGhhc090aGVyQ2hhbmdlcyxcbiAgICAgICAgYW55OiBoYXNSb3RhdGlvbkNoYW5nZXMgfHwgaGFzU2l6ZUNoYW5nZXMgfHwgaGFzT3V0bGluZUNoYW5nZXMgfHwgaGFzQ29sb3JDaGFuZ2VzIHx8IGhhc090aGVyQ2hhbmdlc1xuICAgIH07XG59XG5mdW5jdGlvbiB1cGRhdGVTeW1ib2woc3ltYm9sLCBmcm9tU3ltYm9sLCBjb2xvciwgc3ltYm9sQ2hhbmdlSW5mbykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoc3ltYm9sQ2hhbmdlSW5mby5yb3RhdGlvbikge1xuICAgICAgICBhcHBseVN5bWJvbFJvdGF0aW9uKHN5bWJvbCwgZ2V0U3ltYm9sUm90YXRpb24oZnJvbVN5bWJvbCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2xDaGFuZ2VJbmZvLnNpemUpIHtcbiAgICAgICAgYXBwbHlTeW1ib2xTaXplKHN5bWJvbCwgZ2V0U3ltYm9sU2l6ZShmcm9tU3ltYm9sKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN5bWJvbENoYW5nZUluZm8uY29sb3IpIHtcbiAgICAgICAgaWYgKHN5bWJvbC50eXBlID09PSBcInBpY3R1cmUtbWFya2VyXCIpIHtcbiAgICAgICAgICAgIHN5bWJvbCA9IGZyb21TeW1ib2wuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBhcHBseVN5bWJvbENvbG9yKHN5bWJvbCwgY29sb3IpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2xDaGFuZ2VJbmZvLm91dGxpbmUpIHtcbiAgICAgICAgaWYgKHN5bWJvbC50eXBlID09PSBcInBpY3R1cmUtbWFya2VyXCIpIHtcbiAgICAgICAgICAgIHN5bWJvbCA9IGZyb21TeW1ib2wuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN5bWJvbC5vdXRsaW5lID0gKF9hID0gZnJvbVN5bWJvbC5vdXRsaW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gd2UncmUgY2hhbmdpbmcgdGhlIGVudGlyZSBzeW1ib2xcbiAgICAgICAgc3ltYm9sID0gZnJvbVN5bWJvbC5jbG9uZSgpO1xuICAgICAgICBhcHBseVN5bWJvbENvbG9yKHN5bWJvbCwgY29sb3IpO1xuICAgIH1cbiAgICByZXR1cm4gc3ltYm9sO1xufVxuZnVuY3Rpb24gaXNTYW1lU3ltYm9sKHN5bTEsIHN5bTIpIHtcbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkoc3ltMS50b0pTT04oKSkgPT09IEpTT04uc3RyaW5naWZ5KHN5bTIudG9KU09OKCkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChzeW0xLnR5cGUgPT09IFwiY2ltXCIgJiYgc3ltMi50eXBlID09PSBcImNpbVwiKSB7XG4gICAgICAgIC8vIGl0IGNvdWxkIGp1c3QgYmUgcm91bmRpbmcgaXNzdWVzIGZvciBzaXplIGFuZCB3aWR0aFxuICAgICAgICByZXR1cm4gZGVlcENJTUVxdWFsKHN5bTEudG9KU09OKCkuc3ltYm9sLCBzeW0yLnRvSlNPTigpLnN5bWJvbCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRlZXBDSU1FcXVhbCh4LCB5KSB7XG4gICAgY29uc3Qgb2sgPSBPYmplY3Qua2V5cywgdHggPSB0eXBlb2YgeCwgdHkgPSB0eXBlb2YgeTtcbiAgICBpZiAoeCAmJiB5ICYmIHR4ID09PSBcIm9iamVjdFwiICYmIHR4ID09PSB0eSkge1xuICAgICAgICByZXR1cm4gKG9rKHgpLmxlbmd0aCA9PT0gb2soeSkubGVuZ3RoICYmXG4gICAgICAgICAgICBvayh4KS5ldmVyeSgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJzaXplXCIgfHwga2V5ID09PSBcIndpZHRoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHhba2V5XSAtIHlba2V5XSkgPCAwLjAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZXBDSU1FcXVhbCh4W2tleV0sIHlba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHggPT09IHk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNWaXNWYXIob2JqZWN0LCB0eXBlLCB0YXJnZXQpIHtcbiAgICAvLyB0YXJnZXQ9XCJhdXRvXCIgLSBtZWFucyB0aGUgdmlzdWFsIHZhcmlhYmxlIGZvciBhdXRvbWF0aWMgc2l6aW5nXG4gICAgY29uc3QgdmlzVmFycyA9IG9iamVjdCAmJiBvYmplY3QudmlzdWFsVmFyaWFibGVzO1xuICAgIGlmICh2aXNWYXJzKSB7XG4gICAgICAgIHJldHVybiB2aXNWYXJzLnNvbWUoKHZpc1ZhcikgPT4ge1xuICAgICAgICAgICAgLy8gU2l6ZVZhcmlhYmxlIGhhcyBwcm9wZXJ0eSB0YXJnZXRcbiAgICAgICAgICAgIGNvbnN0IHZpc1ZhclRhcmdldCA9IHZpc1Zhci50YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBpc0F1dG9tYXRpYyA9IHZpc1Zhci52YWx1ZUV4cHJlc3Npb24gPT09IFwiJHZpZXcuc2NhbGVcIjtcbiAgICAgICAgICAgIHJldHVybiAodmlzVmFyLnR5cGUgPT09IHR5cGUgJiZcbiAgICAgICAgICAgICAgICAoKCFpc0RlZmluZWQkMSh2aXNWYXJUYXJnZXQpICYmICFpc0RlZmluZWQkMSh0YXJnZXQpICYmICFpc0F1dG9tYXRpYykgfHxcbiAgICAgICAgICAgICAgICAgICAgdmlzVmFyVGFyZ2V0ID09PSB0YXJnZXQgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRhcmdldCA9PT0gXCJhdXRvXCIgJiYgaXNBdXRvbWF0aWMpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRWaXNWYXIob2JqZWN0LCB0eXBlLCB0YXJnZXQpIHtcbiAgICAvLyB0YXJnZXQ9XCJhdXRvXCIgLSBtZWFucyB0aGUgdmlzdWFsIHZhcmlhYmxlIGZvciBhdXRvbWF0aWMgc2l6aW5nXG4gICAgY29uc3QgdmlzVmFycyA9IG9iamVjdCAmJiBvYmplY3QudmlzdWFsVmFyaWFibGVzO1xuICAgIGlmICh2aXNWYXJzKSB7XG4gICAgICAgIGNvbnN0IGZvdW5kVmlzVmFycyA9IHZpc1ZhcnMuZmlsdGVyKCh2aXNWYXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZpc1ZhclRhcmdldCA9IHZpc1Zhci50YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBpc0F1dG9tYXRpYyA9IHZpc1Zhci52YWx1ZUV4cHJlc3Npb24gPT09IFwiJHZpZXcuc2NhbGVcIjtcbiAgICAgICAgICAgIHJldHVybiAodmlzVmFyLnR5cGUgPT09IHR5cGUgJiZcbiAgICAgICAgICAgICAgICAoKCFpc0RlZmluZWQkMSh2aXNWYXJUYXJnZXQpICYmICFpc0RlZmluZWQkMSh0YXJnZXQpICYmICFpc0F1dG9tYXRpYykgfHxcbiAgICAgICAgICAgICAgICAgICAgdmlzVmFyVGFyZ2V0ID09PSB0YXJnZXQgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRhcmdldCA9PT0gXCJhdXRvXCIgJiYgaXNBdXRvbWF0aWMgJiYgIXZpc1ZhclRhcmdldCkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmb3VuZFZpc1ZhcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm91bmRWaXNWYXJzWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXRBdXRoVmlzVmFyKG9iamVjdCwgdHlwZSwgdGFyZ2V0KSB7XG4gICAgaWYgKCFvYmplY3QuYXV0aG9yaW5nSW5mbykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCB2aXNWYXJzID0gb2JqZWN0ICYmIG9iamVjdC5hdXRob3JpbmdJbmZvICYmIG9iamVjdC5hdXRob3JpbmdJbmZvLnZpc3VhbFZhcmlhYmxlcztcbiAgICBpZiAodmlzVmFycykge1xuICAgICAgICBjb25zdCBmb3VuZFZpc1ZhcnMgPSB2aXNWYXJzLmZpbHRlcigodmlzVmFyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2aXNWYXJUYXJnZXQgPSB2aXNWYXIudGFyZ2V0O1xuICAgICAgICAgICAgcmV0dXJuIHZpc1Zhci50eXBlID09PSB0eXBlICYmICgoIWlzRGVmaW5lZCQxKHZpc1ZhclRhcmdldCkgJiYgIWlzRGVmaW5lZCQxKHRhcmdldCkpIHx8IHZpc1ZhclRhcmdldCA9PT0gdGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmb3VuZFZpc1ZhcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm91bmRWaXNWYXJzWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXRWaXNWYXJzRXhjZXB0KG9iamVjdCwgdHlwZSwgdGFyZ2V0KSB7XG4gICAgLy8gdGFyZ2V0PVwiYXV0b1wiIC0gbWVhbnMgdGhlIHZpc3VhbCB2YXJpYWJsZSBmb3IgYXV0b21hdGljIHNpemluZ1xuICAgIGNvbnN0IHZpc1ZhcnMgPSBvYmplY3QgJiYgb2JqZWN0LnZpc3VhbFZhcmlhYmxlcztcbiAgICBpZiAodmlzVmFycykge1xuICAgICAgICBjb25zdCBmb3VuZFZpc1ZhcnMgPSB2aXNWYXJzLmZpbHRlcigodmlzVmFyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2aXNWYXJUYXJnZXQgPSB2aXNWYXIudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgaXNBdXRvbWF0aWMgPSB2aXNWYXIudmFsdWVFeHByZXNzaW9uID09PSBcIiR2aWV3LnNjYWxlXCI7XG4gICAgICAgICAgICByZXR1cm4gISh2aXNWYXIudHlwZSA9PT0gdHlwZSAmJlxuICAgICAgICAgICAgICAgICgoIWlzRGVmaW5lZCQxKHZpc1ZhclRhcmdldCkgJiYgIWlzRGVmaW5lZCQxKHRhcmdldCkgJiYgIWlzQXV0b21hdGljKSB8fFxuICAgICAgICAgICAgICAgICAgICB2aXNWYXJUYXJnZXQgPT09IHRhcmdldCB8fFxuICAgICAgICAgICAgICAgICAgICAodGFyZ2V0ID09PSBcImF1dG9cIiAmJiBpc0F1dG9tYXRpYykpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmb3VuZFZpc1ZhcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm91bmRWaXNWYXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXRBdXRoVmlzVmFyc0V4Y2VwdChvYmplY3QsIHR5cGUsIHRhcmdldCkge1xuICAgIGlmICghKFwiYXV0aG9yaW5nSW5mb1wiIGluIG9iamVjdCkgfHwgIW9iamVjdC5hdXRob3JpbmdJbmZvKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHZpc1ZhcnMgPSBvYmplY3QgJiYgb2JqZWN0LmF1dGhvcmluZ0luZm8udmlzdWFsVmFyaWFibGVzICYmIG9iamVjdC5hdXRob3JpbmdJbmZvLnZpc3VhbFZhcmlhYmxlcztcbiAgICBpZiAodmlzVmFycykge1xuICAgICAgICBjb25zdCBmb3VuZFZpc1ZhcnMgPSB2aXNWYXJzLmZpbHRlcigodmlzVmFyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2aXNWYXJUYXJnZXQgPSB2aXNWYXIudGFyZ2V0O1xuICAgICAgICAgICAgcmV0dXJuICEodmlzVmFyLnR5cGUgPT09IHR5cGUgJiYgKCghaXNEZWZpbmVkJDEodmlzVmFyVGFyZ2V0KSAmJiAhaXNEZWZpbmVkJDEodGFyZ2V0KSkgfHwgdmlzVmFyVGFyZ2V0ID09PSB0YXJnZXQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmb3VuZFZpc1ZhcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm91bmRWaXNWYXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiByZW1vdmVWaXNWYXIodHlwZSwgbGF5ZXIpIHtcbiAgICBpZiAoIShcInJlbmRlcmVyXCIgaW4gbGF5ZXIpIHx8ICEoXCJ2aXN1YWxWYXJpYWJsZXNcIiBpbiBsYXllci5yZW5kZXJlcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHJlbmRlcmVyIH0gPSBsYXllcjtcbiAgICByZW5kZXJlci52aXN1YWxWYXJpYWJsZXMgPSBnZXRWaXNWYXJzRXhjZXB0KHJlbmRlcmVyLCB0eXBlKTtcbiAgICBpZiAoXCJhdXRob3JpbmdJbmZvXCIgaW4gcmVuZGVyZXIgJiYgcmVuZGVyZXIuYXV0aG9yaW5nSW5mbykge1xuICAgICAgICByZW5kZXJlci5hdXRob3JpbmdJbmZvLnZpc3VhbFZhcmlhYmxlcyA9IGdldEF1dGhWaXNWYXJzRXhjZXB0KHJlbmRlcmVyLCB0eXBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzYXZlRXh0cmFWaXNWYXJzKHJlbmRlcmVyKSB7XG4gICAgY29uc3QgcmVuZGVyZXJUeXBlID0gZ2V0UmVuZGVyZXJUeXBlRnJvbVJlbmRlcmVyKHJlbmRlcmVyKTtcbiAgICBjb25zdCBzaXplT3V0bGluZVZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwib3V0bGluZVwiKTtcbiAgICBjb25zdCBzaXplQXV0b1Zpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwiYXV0b1wiKTtcbiAgICBjb25zdCByb3RhdGlvblZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJyb3RhdGlvblwiKTtcbiAgICBsZXQgb3BhY2l0eVZpc1ZhciwgYXV0aE9wYWNpdHlWaXNWYXI7XG4gICAgaWYgKFtcInByZWRvbWluYW5jZVwiLCBcInByZWRvbWluYW5jZS1zaXplXCJdLmluZGV4T2YocmVuZGVyZXJUeXBlKSA9PT0gLTEpIHtcbiAgICAgICAgb3BhY2l0eVZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJvcGFjaXR5XCIpO1xuICAgICAgICBhdXRoT3BhY2l0eVZpc1ZhciA9IGdldEF1dGhWaXNWYXIocmVuZGVyZXIsIFwib3BhY2l0eVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2l6ZU91dGxpbmVWaXNWYXIsXG4gICAgICAgIHNpemVBdXRvVmlzVmFyLFxuICAgICAgICBvcGFjaXR5VmlzVmFyLFxuICAgICAgICBhdXRoT3BhY2l0eVZpc1ZhcixcbiAgICAgICAgcm90YXRpb25WaXNWYXJcbiAgICB9O1xufVxuZnVuY3Rpb24gYXBwbHlFeHRyYVZpc1ZhcnMoZXh0cmFzLCByZW5kZXJlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgc2l6ZU91dGxpbmVWaXNWYXIsIG9wYWNpdHlWaXNWYXIsIGF1dGhPcGFjaXR5VmlzVmFyLCByb3RhdGlvblZpc1ZhciB9ID0gZXh0cmFzO1xuICAgIGlmIChzaXplT3V0bGluZVZpc1Zhcikge1xuICAgICAgICByZW5kZXJlci52aXN1YWxWYXJpYWJsZXMgPSBnZXRWaXNWYXJzRXhjZXB0KHJlbmRlcmVyLCBcInNpemVcIiwgXCJvdXRsaW5lXCIpIHx8IFtdO1xuICAgICAgICByZW5kZXJlci52aXN1YWxWYXJpYWJsZXMucHVzaChzaXplT3V0bGluZVZpc1Zhcik7XG4gICAgfVxuICAgIGlmIChvcGFjaXR5VmlzVmFyICYmIGF1dGhPcGFjaXR5VmlzVmFyICYmICEob3B0aW9ucyAmJiBvcHRpb25zLm5vdE9wYWNpdHkpKSB7XG4gICAgICAgIHJlbmRlcmVyLnZpc3VhbFZhcmlhYmxlcyA9IGdldFZpc1ZhcnNFeGNlcHQocmVuZGVyZXIsIFwib3BhY2l0eVwiKSB8fCBbXTtcbiAgICAgICAgcmVuZGVyZXIudmlzdWFsVmFyaWFibGVzLnB1c2gob3BhY2l0eVZpc1Zhcik7XG4gICAgICAgIHJlbmRlcmVyLmF1dGhvcmluZ0luZm8gPSByZW5kZXJlci5hdXRob3JpbmdJbmZvIHx8IHt9O1xuICAgICAgICByZW5kZXJlci5hdXRob3JpbmdJbmZvLnZpc3VhbFZhcmlhYmxlcyA9IGdldEF1dGhWaXNWYXJzRXhjZXB0KHJlbmRlcmVyLCBcIm9wYWNpdHlcIikgfHwgW107XG4gICAgICAgIHJlbmRlcmVyLmF1dGhvcmluZ0luZm8udmlzdWFsVmFyaWFibGVzLnB1c2goYXV0aE9wYWNpdHlWaXNWYXIpO1xuICAgIH1cbiAgICBpZiAocm90YXRpb25WaXNWYXIpIHtcbiAgICAgICAgcmVuZGVyZXIudmlzdWFsVmFyaWFibGVzID0gcmVuZGVyZXIudmlzdWFsVmFyaWFibGVzIHx8IFtdO1xuICAgICAgICByZW5kZXJlci52aXN1YWxWYXJpYWJsZXMucHVzaChyb3RhdGlvblZpc1Zhcik7XG4gICAgfVxufVxuXG52YXIgcmdiVHlwZU1hcDtcbihmdW5jdGlvbiAocmdiVHlwZU1hcCkge1xuICAgIHJnYlR5cGVNYXBbXCJOT05FXCJdID0gXCJub25lXCI7XG4gICAgcmdiVHlwZU1hcFtcIk1JTklNVU1fTUFYSU1VTVwiXSA9IFwibWluLW1heFwiO1xuICAgIHJnYlR5cGVNYXBbXCJQRVJDRU5UX0NMSVBcIl0gPSBcInBlcmNlbnQtY2xpcFwiO1xuICAgIHJnYlR5cGVNYXBbXCJTVEFOREFSRF9ERVZJQVRJT05cIl0gPSBcInN0YW5kYXJkLWRldmlhdGlvblwiO1xuICAgIC8vIE5PVEU6IG5vdCB5ZXQgc3VwcG9ydGVkXG4gICAgLy8gSElTVE9HUkFNX0VRVUFMSVpFID0gXCJoaXN0b2dyYW0tZXF1YWxpemF0aW9uXCIsXG4gICAgLy8gU0lHTU9JRCA9IFwic2lnbW9pZFwiLFxuICAgIC8vIENVU1RPTSA9IFwiY3VzdG9tXCJcbn0pKHJnYlR5cGVNYXAgfHwgKHJnYlR5cGVNYXAgPSB7fSkpO1xuY29uc3QgcmdiRGVmYXVsdHMgPSB7XG4gICAgU1REX0RFVjogMi4wLFxuICAgIE1JTl9QRVJDRU5UOiAyLjAsXG4gICAgTUFYX1BFUkNFTlQ6IDIuMCxcbiAgICBHQU1NQTogMS4wLFxuICAgIFNUUkVUQ0hfVFlQRTogcmdiVHlwZU1hcC5OT05FXG59O1xuLyoqXG4gKiBjcmVhdGVzIGFuIFJnYiByZW5kZXJlciB3aXRoIGRlZmF1bHQgc2V0dGluZ3NcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlUkdCUmVuZGVyZXIoKSB7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIGNvbnN0IHJhc3RlckZ1bmN0aW9uID0gbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5XCIgPyBsYXllci5yYXN0ZXJGdW5jdGlvbiA6IHVuZGVmaW5lZDtcbiAgICBsYXllci5iYW5kSWRzID0gYXdhaXQgc2V0RGVmYXVsdFJHQkJhbmRzKGxheWVyKTtcbiAgICByZXR1cm4gbW9kdWxlcy5SYXN0ZXJSR0JDcmVhdG9yLmNyZWF0ZVJlbmRlcmVyKHtcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIHJhc3RlckZ1bmN0aW9uLFxuICAgICAgICByZ2JCYW5kSWRzOiBsYXllci5iYW5kSWRzXG4gICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGxheWVyLmVmZmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGF5ZXIucmVuZGVyZXIgPSByZXN1bHQucmVuZGVyZXI7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9LCAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gUmdiIHJlbmRlcmVyIHdpdGggc29tZSBzZXR0aW5ncyBmcm9tIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gKiBAcGFyYW0gb3B0aW9uczogb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjcmVhdGVSZ2JSZW5kZXJlckZyb21FeGlzdGluZyhvcHRpb25zKSB7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbGF5ZXIucmVuZGVyZXI7XG4gICAgY29uc3QgcmFzdGVyRnVuY3Rpb24gPSBsYXllci50eXBlID09PSBcImltYWdlcnlcIiA/IGxheWVyLnJhc3RlckZ1bmN0aW9uIDogdW5kZWZpbmVkO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBtb2R1bGVzLlJhc3RlclJHQkNyZWF0b3IuY3JlYXRlUmVuZGVyZXIoe1xuICAgICAgICBsYXllcixcbiAgICAgICAgcmFzdGVyRnVuY3Rpb24sXG4gICAgICAgIHJnYkJhbmRJZHM6IGxheWVyLmJhbmRJZHMsXG4gICAgICAgIHN0cmV0Y2hUeXBlOiBvcHRpb25zLnN0cmV0Y2hUeXBlIHx8IHJlbmRlcmVyLnN0cmV0Y2hUeXBlXG4gICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIC8vIHNhdmUgZHluYW1pYyByYW5nZSBhZGp1c3RtZW50IHNldHRpbmdzXG4gICAgICAgIHJlc3VsdC5yZW5kZXJlci5keW5hbWljUmFuZ2VBZGp1c3RtZW50ID0gcmVuZGVyZXIuZHluYW1pY1JhbmdlQWRqdXN0bWVudDtcbiAgICAgICAgLy8gc2F2ZSBvbGQgY29sb3IgcmFtcFxuICAgICAgICByZXN1bHQucmVuZGVyZXIuY29sb3JSYW1wID0gcmVuZGVyZXIuY29sb3JSYW1wO1xuICAgICAgICAvLyBzYXZlIG9sZCBzdGF0aXN0aWNzXG4gICAgICAgIHJlc3VsdC5yZW5kZXJlci5zdGF0aXN0aWNzID0gcmVuZGVyZXIuc3RhdGlzdGljcztcbiAgICAgICAgLy8gaGFuZGxlIHN0YW5kYXJkIGRldmlhdGlvblxuICAgICAgICBpZiAoIWlzRGVmaW5lZChyZXN1bHQucmVuZGVyZXIubnVtYmVyT2ZTdGFuZGFyZERldmlhdGlvbnMpIHx8IHJlc3VsdC5yZW5kZXJlci5udW1iZXJPZlN0YW5kYXJkRGV2aWF0aW9ucyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLm51bWJlck9mU3RhbmRhcmREZXZpYXRpb25zID0gcmdiRGVmYXVsdHMuU1REX0RFVjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfSwgKGVycm9yKSA9PiBQcm9taXNlLnJlamVjdChlcnJvcikpO1xufVxuZnVuY3Rpb24gaXNSYXN0ZXJSR0JSZW5kZXJlcihsYXllcikge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCBpc1Jhc3RlclN0cmV0Y2hSZW5kZXJlciA9ICgoX2EgPSBsYXllci5yZW5kZXJlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSBcInJhc3Rlci1zdHJldGNoXCI7XG4gICAgaWYgKCFpc1Jhc3RlclN0cmV0Y2hSZW5kZXJlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGNoZWNraW5nIFwiPiAxXCIgYW5kIG5vdCBcIj09PSAzXCIgZm9yIGRhdGFzZXRzIHdoaWNoXG4gICAgLy8gaGF2ZSBqdXN0IDIgYmFuZHMgYnV0IGFyZSBzdXBwb3J0ZWQgYnkgcmdiXG4gICAgY29uc3QgaGFzVmFsaWRCYW5kSWRzID0gKChfYiA9IGxheWVyLmJhbmRJZHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpID4gMTtcbiAgICBjb25zdCBpc011bHRpYmFuZCA9ICgoX2MgPSBsYXllci5yYXN0ZXJJbmZvKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmFuZENvdW50KSA+IDE7XG4gICAgY29uc3QgaGFzVmFsaWRHYW1tYVZhbHVlID0gKChfZCA9IGxheWVyLnJlbmRlcmVyLmdhbW1hKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA+IDE7XG4gICAgLy8gcmV0dXJuIHRydWUgaWYgcmVuZGVyZXIgdHlwZSBpcyBzdHJldGNoIGFuZCBoYXMgYmFuZElkcyA+IDEsIG9yXG4gICAgLy8gcmV0dXJuIHRydWUgaWYgcmVuZGVyZXIgdHlwZSBpcyBzdHJldGNoIGFuZCBpc011bHRpYmFuZCBhbmQgaGFzIG11bHRpcGxlIGdhbW1hIHZhbHVlc1xuICAgIHJldHVybiBpc1Jhc3RlclN0cmV0Y2hSZW5kZXJlciAmJiAoaGFzVmFsaWRCYW5kSWRzIHx8IChpc011bHRpYmFuZCAmJiBoYXNWYWxpZEdhbW1hVmFsdWUpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNldERlZmF1bHRSR0JCYW5kcyhsYXllcikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IHsgcmFzdGVySW5mbyB9ID0gbGF5ZXI7XG4gICAgY29uc3QgeyBiYW5kQ291bnQgfSA9IHJhc3RlckluZm87XG4gICAgbGV0IGRlZmF1bHRCYW5kQ29tYmluYXRpb24gPSBhd2FpdCBtb2R1bGVzLlJhc3RlclJlbmRlcmVyVXRpbHMuZ2V0RGVmYXVsdEJhbmRDb21iaW5hdGlvbih7IGxheWVyIH0pO1xuICAgIGNvbnN0IGJhbmRDb21iaW5hdGlvbkxlbmd0aCA9IGRlZmF1bHRCYW5kQ29tYmluYXRpb24ubGVuZ3RoO1xuICAgIGlmIChiYW5kQ29tYmluYXRpb25MZW5ndGggIT09IGJhbmRDb3VudCkge1xuICAgICAgICBkZWZhdWx0QmFuZENvbWJpbmF0aW9uLnB1c2goLi4ubmV3IEFycmF5KDMgLSBiYW5kQ29tYmluYXRpb25MZW5ndGgpLmZpbGwoYmFuZENvdW50IC0gMSkpO1xuICAgIH1cbiAgICBpZiAoKChfYSA9IGxheWVyLmJhbmRJZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICE9PSAzKSB7XG4gICAgICAgIGxheWVyLmJhbmRJZHMgPSBkZWZhdWx0QmFuZENvbWJpbmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gbGF5ZXIuYmFuZElkcztcbn1cblxudmFyIHN0cmV0Y2hUeXBlTWFwO1xuKGZ1bmN0aW9uIChzdHJldGNoVHlwZU1hcCkge1xuICAgIHN0cmV0Y2hUeXBlTWFwW1wiTk9ORVwiXSA9IFwibm9uZVwiO1xuICAgIHN0cmV0Y2hUeXBlTWFwW1wiTUlOSU1VTV9NQVhJTVVNXCJdID0gXCJtaW4tbWF4XCI7XG4gICAgc3RyZXRjaFR5cGVNYXBbXCJQRVJDRU5UX0NMSVBcIl0gPSBcInBlcmNlbnQtY2xpcFwiO1xuICAgIHN0cmV0Y2hUeXBlTWFwW1wiU1RBTkRBUkRfREVWSUFUSU9OXCJdID0gXCJzdGFuZGFyZC1kZXZpYXRpb25cIjtcbiAgICAvLyBOT1RFOiBub3QgeWV0IHN1cHBvcnRlZFxuICAgIC8vIEhJU1RPR1JBTV9FUVVBTElaRSA9IFwiaGlzdG9ncmFtLWVxdWFsaXphdGlvblwiLFxuICAgIC8vIFNJR01PSUQgPSBcInNpZ21vaWRcIixcbiAgICAvLyBDVVNUT00gPSBcImN1c3RvbVwiXG59KShzdHJldGNoVHlwZU1hcCB8fCAoc3RyZXRjaFR5cGVNYXAgPSB7fSkpO1xuY29uc3Qgc3RyZXRjaERlZmF1bHRzID0ge1xuICAgIFNURF9ERVY6IDIuMCxcbiAgICBNSU5fUEVSQ0VOVDogMi4wLFxuICAgIE1BWF9QRVJDRU5UOiAyLjAsXG4gICAgR0FNTUE6IDEuMCxcbiAgICBCQU5EX0lOREVYOiAwLFxuICAgIFNUUkVUQ0hfVFlQRTogc3RyZXRjaFR5cGVNYXAuTk9ORVxufTtcbi8qKlxuICogY3JlYXRlcyBhIFN0cmV0Y2ggcmVuZGVyZXIgd2l0aCBkZWZhdWx0IHNldHRpbmdzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0cmV0Y2hSZW5kZXJlcigpIHtcbiAgICBjb25zdCB7IGxheWVyOiBzbUxheWVyLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCBsYXllciA9IHNtTGF5ZXI7XG4gICAgY29uc3QgcmFzdGVyRnVuY3Rpb24gPSBsYXllci50eXBlID09PSBcImltYWdlcnlcIiA/IGxheWVyLnJhc3RlckZ1bmN0aW9uIDogdW5kZWZpbmVkO1xuICAgIGxheWVyLmJhbmRJZHMgPSBbMF07XG4gICAgcmV0dXJuIG1vZHVsZXMuUmFzdGVyU3RyZXRjaENyZWF0b3IuY3JlYXRlUmVuZGVyZXIoeyBsYXllciwgcmFzdGVyRnVuY3Rpb24gfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGxheWVyLmVmZmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gaGFuZGxlcyB3aGVuIHJlbmRlcmVyIHN0YXRpc3RpY3MgYXJlIHN0b3JlZCBhcyBhbiBhcnJheSwgbm90IGluIGFuIG9iamVjdFxuICAgICAgICBjb25zdCBuZXdTdGF0aXN0aWNzID0gcmVzdWx0LnJlbmRlcmVyLnN0YXRpc3RpY3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5ld1N0YXRpc3RpY3MpICYmIG5ld1N0YXRpc3RpY3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLnN0YXRpc3RpY3MgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBtaW46IG5ld1N0YXRpc3RpY3NbMF0sXG4gICAgICAgICAgICAgICAgICAgIG1heDogbmV3U3RhdGlzdGljc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgYXZnOiBuZXdTdGF0aXN0aWNzWzJdLFxuICAgICAgICAgICAgICAgICAgICBzdGRkZXY6IG5ld1N0YXRpc3RpY3NbM11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGxheWVyLnJlbmRlcmVyID0gcmVzdWx0LnJlbmRlcmVyO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfSwgKGVycm9yKSA9PiBQcm9taXNlLnJlamVjdChlcnJvcikpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgU3RyZXRjaCByZW5kZXJlciB3aXRoIHNvbWUgc2V0dGluZ3MgZnJvbSB0aGUgY3VycmVudCByZW5kZXJlclxuICogQHBhcmFtIG9wdGlvbnM6IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RyZXRjaFJlbmRlcmVyRnJvbUV4aXN0aW5nKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGxheWVyOiBzbUxheWVyLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCBsYXllciA9IHNtTGF5ZXI7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBsYXllci5yZW5kZXJlcjtcbiAgICBjb25zdCByYXN0ZXJGdW5jdGlvbiA9IGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeVwiID8gbGF5ZXIucmFzdGVyRnVuY3Rpb24gOiB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIG1vZHVsZXMuUmFzdGVyU3RyZXRjaENyZWF0b3IuY3JlYXRlUmVuZGVyZXIoe1xuICAgICAgICBsYXllcixcbiAgICAgICAgcmFzdGVyRnVuY3Rpb24sXG4gICAgICAgIHN0cmV0Y2hUeXBlOiBvcHRpb25zLnN0cmV0Y2hUeXBlIHx8IHJlbmRlcmVyLnN0cmV0Y2hUeXBlXG4gICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIC8vIHNhdmUgZHluYW1pYyByYW5nZSBhZGp1c3RtZW50IHNldHRpbmdzXG4gICAgICAgIHJlc3VsdC5yZW5kZXJlci5keW5hbWljUmFuZ2VBZGp1c3RtZW50ID0gcmVuZGVyZXIuZHluYW1pY1JhbmdlQWRqdXN0bWVudDtcbiAgICAgICAgLy8gc2F2ZSBvbGQgY29sb3IgcmFtcFxuICAgICAgICByZXN1bHQucmVuZGVyZXIuY29sb3JSYW1wID0gcmVuZGVyZXIuY29sb3JSYW1wO1xuICAgICAgICAvLyBzYXZlIG9sZCBzdGF0aXN0aWNzXG4gICAgICAgIHJlc3VsdC5yZW5kZXJlci5zdGF0aXN0aWNzID0gcmVuZGVyZXIuc3RhdGlzdGljcztcbiAgICAgICAgLy8gaGFuZGxlIHN0YW5kYXJkIGRldmlhdGlvblxuICAgICAgICBpZiAoIWlzRGVmaW5lZChyZXN1bHQucmVuZGVyZXIubnVtYmVyT2ZTdGFuZGFyZERldmlhdGlvbnMpIHx8IHJlc3VsdC5yZW5kZXJlci5udW1iZXJPZlN0YW5kYXJkRGV2aWF0aW9ucyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLm51bWJlck9mU3RhbmRhcmREZXZpYXRpb25zID0gc3RyZXRjaERlZmF1bHRzLlNURF9ERVY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH0sIChlcnJvcikgPT4gUHJvbWlzZS5yZWplY3QoZXJyb3IpKTtcbn1cblxuLyoqXG4gKiBjcmVhdGVzIGEgVW5pcXVlIFZhbHVlIHJlbmRlcmVyIHdpdGggZGVmYXVsdCBzZXR0aW5nc1xuICovXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVVbmlxdWVWYWx1ZVJlbmRlcmVyKCkge1xuICAgIGNvbnN0IHsgbGF5ZXI6IHNtTGF5ZXIsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IGxheWVyID0gc21MYXllcjtcbiAgICBjb25zdCByYXN0ZXJGdW5jdGlvbiA9IGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeVwiID8gbGF5ZXIucmFzdGVyRnVuY3Rpb24gOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG1vZHVsZXMuUmFzdGVyVW5pcXVlVmFsdWVDcmVhdG9yLmNyZWF0ZVJlbmRlcmVyKHsgbGF5ZXIsIHJhc3RlckZ1bmN0aW9uIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgVW5pcXVlIFZhbHVlIHJlbmRlcmVyIHdpdGggc29tZSBzZXR0aW5ncyBmcm9tIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gKiBAcGFyYW0gb3B0aW9uczogb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjcmVhdGVVbmlxdWVWYWx1ZVJlbmRlcmVyRnJvbUV4aXN0aW5nKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGxheWVyOiBzbUxheWVyLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCBsYXllciA9IHNtTGF5ZXI7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBsYXllci5yZW5kZXJlcjtcbiAgICBjb25zdCByYXN0ZXJGdW5jdGlvbiA9IGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeVwiID8gbGF5ZXIucmFzdGVyRnVuY3Rpb24gOiB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIG1vZHVsZXMuUmFzdGVyVW5pcXVlVmFsdWVDcmVhdG9yLmNyZWF0ZVJlbmRlcmVyKHtcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIHJhc3RlckZ1bmN0aW9uLFxuICAgICAgICBjbGFzc0ZpZWxkTmFtZTogb3B0aW9ucy5maWVsZCB8fCByZW5kZXJlci5maWVsZFxuICAgIH0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfSwgKGVycm9yKSA9PiBQcm9taXNlLnJlamVjdChlcnJvcikpO1xufVxuZnVuY3Rpb24gZ2V0UmFzdGVyVW5pcXVlVmFsdWVGaWVsZHMoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgbGF5ZXI6IHNtTGF5ZXIsIG1vZHVsZXMsIHN0cmluZ3MgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IGxheWVyID0gc21MYXllcjtcbiAgICBsZXQgZmllbGRzO1xuICAgIGNvbnN0IHsgcmFzdGVySW5mbyB9ID0gbGF5ZXI7XG4gICAgY29uc3QgcmFzdGVyQXR0cmlidXRlVGFibGVGaWVsZHMgPSAoX2EgPSByYXN0ZXJJbmZvID09PSBudWxsIHx8IHJhc3RlckluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhc3RlckluZm8uYXR0cmlidXRlVGFibGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWVsZHM7XG4gICAgaWYgKHJhc3RlckF0dHJpYnV0ZVRhYmxlRmllbGRzKSB7XG4gICAgICAgIGZpZWxkcyA9IHJhc3RlckF0dHJpYnV0ZVRhYmxlRmllbGRzLmZpbHRlcigoZmllbGQpID0+IGZpZWxkLnR5cGUgIT09IFwib2lkXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmllbGRzID0gW25ldyBtb2R1bGVzLkZpZWxkKHsgbmFtZTogXCJ2YWx1ZVwiLCBhbGlhczogc3RyaW5ncy5wYW5lbHMudW5pcXVlVmFsdWUudmFsdWUgfSldO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xufVxuXG5leHBvcnQgeyBnZXRQcmltYXJ5VHlwZVNjaGVtZSBhcyAkLCBpc1BvaW50VHlwZSBhcyBBLCBpc1BvbHlsaW5lVHlwZSBhcyBCLCBnZXRGaWVsZFR5cGVDb3VudCBhcyBDLCBnZXRHZW9tZXRyeVR5cGUgYXMgRCwgY2xvc2VQb3BvdmVycyBhcyBFLCBmaW5kUGFyZW50Tm9kZSBhcyBGLCBnZXRTaW5nbGVPYmplY3RMb2NhbFN0b3JhZ2UgYXMgRywgc2V0U2luZ2xlT2JqZWN0TG9jYWxTdG9yYWdlIGFzIEgsIGdldExheWVyRmllbGRUeXBlQ291bnQgYXMgSSwgZ2V0UmVuZGVyZXJUaGVtZSBhcyBKLCBhZGRGaWVsZHNUb0xheWVyQ2FjaGUgYXMgSywgZGlzYWJsZVBhbmVsIGFzIEwsIGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzIGFzIE0sIGxvY2FsU3RvcmFnZUtleXMgYXMgTiwgYWRkRmllbGRzVG9PdXRGaWVsZHMgYXMgTywgZmluZENvbG9yU2NoZW1lIGFzIFAsIGZpeE5vcm1hbGl6YXRpb25GaWVsZCBhcyBRLCBpc0VtcHR5IGFzIFIsIGdldERlZmF1bHRTeW1ib2wgYXMgUywgZ2V0U3ltYm9sU2l6ZSBhcyBULCBhcHBseVN5bWJvbFNpemUgYXMgVSwgZmluZEhlYXRtYXBTY2hlbWUgYXMgViwgZmluZFByZWRvbWluYW5jZVNjaGVtZSBhcyBXLCBzd2l0Y2hNYXJrZXJzVG9Qb2x5Z29ucyBhcyBYLCBzd2l0Y2hQb2x5Z29uc1RvTWFya2VycyBhcyBZLCBmaW5kUGllQ2hhcnRTY2hlbWUgYXMgWiwgZmluZFR5cGVTY2hlbWUgYXMgXywgZ2V0VmlzVmFyIGFzIGEsIGZpbmRSZWxhdGlvbnNoaXBTY2hlbWUgYXMgYTAsIGNyZWF0ZVVuaXF1ZVZhbHVlUmVuZGVyZXIgYXMgYTEsIGNyZWF0ZVJHQlJlbmRlcmVyIGFzIGEyLCBjcmVhdGVTdHJldGNoUmVuZGVyZXIgYXMgYTMsIGlzU2FtZUNvbG9yIGFzIGE0LCBoYXNTeW1ib2xPdXRsaW5lIGFzIGE1LCBpc1BpY3R1cmVNYXJrZXIgYXMgYTYsIGdldEZpbGxDb2xvcnMgYXMgYTcsIGxheWVyU3VwcG9ydHNDSU0gYXMgYTgsIGdldENvbG9yUmFtcHNXaXRoU2NoZW1lcyBhcyBhOSwgZ2V0UmFzdGVyVW5pcXVlVmFsdWVGaWVsZHMgYXMgYUEsIGNyZWF0ZVVuaXF1ZVZhbHVlUmVuZGVyZXJGcm9tRXhpc3RpbmcgYXMgYUIsIGdldFpvb21PcHRpb25zIGFzIGFDLCBnZXRIYW5kbGVJbmZvIGFzIGFELCBpc1N5bWJvbFRyYW5zcGFyZW50IGFzIGFFLCBhZGRTbWFydE1hcHBpbmdUb29sdGlwV2l0aElkIGFzIGFGLCByZW1vdmVTbWFydE1hcHBpbmdUb29sdGlwQnlJZCBhcyBhRywgaXNEYXRlIGFzIGFILCBzY3JvbGxJbnRvVmlldyBhcyBhSSwgcmVtb3ZlVmlzVmFyIGFzIGFKLCBnZXRGaXJzdE51bWJlckZpZWxkIGFzIGFLLCBnZXREZWZhdWx0RGF0YVJhbmdlIGFzIGFMLCBpc1RvcEZsb3dJdGVtIGFzIGFhLCB1cGRhdGVSZW5kZXJlciBhcyBhYiwgaXNEZWZpbmVkIGFzIGFjLCB2YWxpZGF0ZU1pbk1heCBhcyBhZCwgcmVtb3ZlU21hcnRNYXBwaW5nVG9vbHRpcCBhcyBhZSwgYWRkU21hcnRNYXBwaW5nVG9vbHRpcCBhcyBhZiwgaGFzTnVtYmVyRmllbGQgYXMgYWcsIGdldEdlb1JTU0RlZmF1bHRTeW1ib2wgYXMgYWgsIGlzTGluZU1hcmtlciBhcyBhaSwgZ2V0UmFzdGVyRGVmYXVsdFN5bWJvbCBhcyBhaiwgaXNDaW1MaW5lU3ltYm9sIGFzIGFrLCBnZXRDaW1MaW5lIGFzIGFsLCBnZXRTeW1ib2xDaGFuZ2VzIGFzIGFtLCB1cGRhdGVTeW1ib2wgYXMgYW4sIGFwcGx5QWxwaGEgYXMgYW8sIGdldENJTU91dGxpbmVXaWR0aCBhcyBhcCwgaXNTeW1ib2xBbG1vc3RXaGl0ZSBhcyBhcSwgZ2V0UmVuZGVyUHJldmlld1NpemUgYXMgYXIsIHNldERlZmF1bHRSR0JCYW5kcyBhcyBhcywgZ2V0UGVyY2VudExhYmVsRmxpcCBhcyBhdCwgY3JlYXRlUmdiUmVuZGVyZXJGcm9tRXhpc3RpbmcgYXMgYXUsIHJnYlR5cGVNYXAgYXMgYXYsIHJnYkRlZmF1bHRzIGFzIGF3LCBzdHJldGNoRGVmYXVsdHMgYXMgYXgsIGNyZWF0ZVN0cmV0Y2hSZW5kZXJlckZyb21FeGlzdGluZyBhcyBheSwgc3RyZXRjaFR5cGVNYXAgYXMgYXosIHN0YXR1cyBhcyBiLCBjbGVhclNtYXJ0TWFwcGluZ1N0YXRlIGFzIGMsIGJ1aWxkRmllbGRzTGlzdCBhcyBkLCBhcHBseVJlbmRlcmVyIGFzIGUsIGdldFJlbmRlcmVyRmllbGRJbmZvcyBhcyBmLCBnZXRSZW5kZXJlclR5cGUgYXMgZywgZ2V0UmVuZGVyZXIgYXMgaCwgaXNSYXN0ZXJMYXllciBhcyBpLCBhcHBseVJlbmRlcmVyVG9BbGwgYXMgaiwgaXNSYXN0ZXJSR0JSZW5kZXJlciBhcyBrLCBhcHBseUV4dHJhVmlzVmFycyBhcyBsLCBzYXZlRXh0cmFWaXNWYXJzIGFzIG0sIGdldFZpc1ZhcnNFeGNlcHQgYXMgbiwgZ2V0QXV0aFZpc1ZhcnNFeGNlcHQgYXMgbywgZ2V0QXV0aFZpc1ZhciBhcyBwLCBpc1BvbHlnb25UeXBlIGFzIHEsIGFwcGx5U3ltYm9sQ29sb3IgYXMgciwgc21hcnRNYXBwaW5nU3RhdGUgYXMgcywgZ2V0U3ltYm9sQ29sb3IgYXMgdCwgZ2V0RmllbGQgYXMgdSwgaXNTYW1lRmllbGRJbmZvcyBhcyB2LCBzaW1wbGVGaWVsZFR5cGVzIGFzIHcsIGlzU2FtZUZpZWxkSW5mbyBhcyB4LCBnZXRGaWVsZFR5cGVGcm9tVmFsdWVUeXBlIGFzIHksIGdldEZpZWxkVHlwZSBhcyB6IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhc3Rlci11bmlxdWUtdmFsdWUtMDk3NmVjN2YuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9